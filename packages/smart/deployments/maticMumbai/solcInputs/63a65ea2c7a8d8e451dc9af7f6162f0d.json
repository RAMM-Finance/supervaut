{
  "language": "Solidity",
  "sources": {
    "contracts/balancer/BColor.sol": {
      "content": "// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity 0.7.6;\r\n\r\ninterface BColor {\r\n    function getColor() external view returns (bytes32);\r\n}\r\n\r\ncontract BBronze is BColor {\r\n    function getColor() external pure override returns (bytes32) {\r\n        return bytes32(\"BRONZE\");\r\n    }\r\n}\r\n"
    },
    "contracts/balancer/BConst.sol": {
      "content": "// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity 0.7.6;\r\n\r\nimport \"./BColor.sol\";\r\n\r\ncontract BConst is BBronze {\r\n    uint256 public constant BONE = 10**18;\r\n\r\n    uint256 public constant MIN_BOUND_TOKENS = 2;\r\n    uint256 public constant MAX_BOUND_TOKENS = 8;\r\n\r\n    uint256 public constant MIN_FEE = BONE / 10**6;\r\n    uint256 public constant MAX_FEE = BONE / 10;\r\n    uint256 public constant EXIT_FEE = 0;\r\n\r\n    uint256 public constant MIN_WEIGHT = BONE;\r\n    uint256 public constant MAX_WEIGHT = BONE * 50;\r\n    uint256 public constant MAX_TOTAL_WEIGHT = BONE * 50;\r\n    uint256 public constant MIN_BALANCE = BONE / 10**12;\r\n\r\n    uint256 public constant INIT_POOL_SUPPLY = BONE * 100;\r\n\r\n    uint256 public constant MIN_BPOW_BASE = 1 wei;\r\n    uint256 public constant MAX_BPOW_BASE = (2 * BONE) - 1 wei;\r\n    uint256 public constant BPOW_PRECISION = BONE / 10**10;\r\n\r\n    uint256 public constant MAX_IN_RATIO = BONE / 2;\r\n    uint256 public constant MAX_OUT_RATIO = (BONE / 3) + 1 wei;\r\n}\r\n"
    },
    "contracts/balancer/BNum.sol": {
      "content": "// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity 0.7.6;\r\n\r\nimport \"./BConst.sol\";\r\n\r\ncontract BNum is BConst {\r\n    function btoi(uint256 a) internal pure returns (uint256) {\r\n        return a / BONE;\r\n    }\r\n\r\n    function bfloor(uint256 a) internal pure returns (uint256) {\r\n        return btoi(a) * BONE;\r\n    }\r\n\r\n    function badd(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"ERR_ADD_OVERFLOW\");\r\n        return c;\r\n    }\r\n\r\n    function bsub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        (uint256 c, bool flag) = bsubSign(a, b);\r\n        require(!flag, \"ERR_SUB_UNDERFLOW\");\r\n        return c;\r\n    }\r\n\r\n    function bsubSign(uint256 a, uint256 b) internal pure returns (uint256, bool) {\r\n        if (a >= b) {\r\n            return (a - b, false);\r\n        } else {\r\n            return (b - a, true);\r\n        }\r\n    }\r\n\r\n    function bmul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c0 = a * b;\r\n        require(a == 0 || c0 / a == b, \"ERR_MUL_OVERFLOW\");\r\n        uint256 c1 = c0 + (BONE / 2);\r\n        require(c1 >= c0, \"ERR_MUL_OVERFLOW\");\r\n        uint256 c2 = c1 / BONE;\r\n        return c2;\r\n    }\r\n\r\n    function bdiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"ERR_DIV_ZERO\");\r\n        uint256 c0 = a * BONE;\r\n        require(a == 0 || c0 / a == BONE, \"ERR_DIV_INTERNAL\"); // bmul overflow\r\n        uint256 c1 = c0 + (b / 2);\r\n        require(c1 >= c0, \"ERR_DIV_INTERNAL\"); //  badd require\r\n        uint256 c2 = c1 / b;\r\n        return c2;\r\n    }\r\n\r\n    // DSMath.wpow\r\n    function bpowi(uint256 a, uint256 n) internal pure returns (uint256) {\r\n        uint256 z = n % 2 != 0 ? a : BONE;\r\n\r\n        for (n /= 2; n != 0; n /= 2) {\r\n            a = bmul(a, a);\r\n\r\n            if (n % 2 != 0) {\r\n                z = bmul(z, a);\r\n            }\r\n        }\r\n        return z;\r\n    }\r\n\r\n    // Compute b^(e.w) by splitting it into (b^e)*(b^0.w).\r\n    // Use `bpowi` for `b^e` and `bpowK` for k iterations\r\n    // of approximation of b^0.w\r\n    function bpow(uint256 base, uint256 exp) internal pure returns (uint256) {\r\n        require(base >= MIN_BPOW_BASE, \"ERR_BPOW_BASE_TOO_LOW\");\r\n        require(base <= MAX_BPOW_BASE, \"ERR_BPOW_BASE_TOO_HIGH\");\r\n\r\n        uint256 whole = bfloor(exp);\r\n        uint256 remain = bsub(exp, whole);\r\n\r\n        uint256 wholePow = bpowi(base, btoi(whole));\r\n\r\n        if (remain == 0) {\r\n            return wholePow;\r\n        }\r\n\r\n        uint256 partialResult = bpowApprox(base, remain, BPOW_PRECISION);\r\n        return bmul(wholePow, partialResult);\r\n    }\r\n\r\n    function bpowApprox(\r\n        uint256 base,\r\n        uint256 exp,\r\n        uint256 precision\r\n    ) internal pure returns (uint256) {\r\n        // term 0:\r\n        uint256 a = exp;\r\n        (uint256 x, bool xneg) = bsubSign(base, BONE);\r\n        uint256 term = BONE;\r\n        uint256 sum = term;\r\n        bool negative = false;\r\n\r\n        // term(k) = numer / denom\r\n        //         = (product(a - i - 1, i=1-->k) * x^k) / (k!)\r\n        // each iteration, multiply previous term by (a-(k-1)) * x / k\r\n        // continue until term is less than precision\r\n        for (uint256 i = 1; term >= precision; i++) {\r\n            uint256 bigK = i * BONE;\r\n            (uint256 c, bool cneg) = bsubSign(a, bsub(bigK, BONE));\r\n            term = bmul(term, bmul(c, x));\r\n            term = bdiv(term, bigK);\r\n            if (term == 0) break;\r\n\r\n            if (xneg) negative = !negative;\r\n            if (cneg) negative = !negative;\r\n            if (negative) {\r\n                sum = bsub(sum, term);\r\n            } else {\r\n                sum = badd(sum, term);\r\n            }\r\n        }\r\n\r\n        return sum;\r\n    }\r\n}\r\n"
    },
    "contracts/turbo/AMMFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.7.6;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"../balancer/BFactory.sol\";\r\nimport \"../libraries/SafeMathUint256.sol\";\r\nimport \"./AbstractMarketFactoryV3.sol\";\r\nimport \"../balancer/BNum.sol\";\r\n\r\ncontract AMMFactory is BNum {\r\n    using SafeMathUint256 for uint256;\r\n\r\n    uint256 private constant MAX_UINT = 2**256 - 1;\r\n    uint256 private constant MIN_INITIAL_LIQUIDITY = BONE * 100;\r\n\r\n    BFactory public bFactory;\r\n    // MarketFactory => Market => BPool\r\n    mapping(address => mapping(uint256 => BPool)) public pools;\r\n    uint256 fee;\r\n\r\n    event PoolCreated(\r\n        address pool,\r\n        address indexed marketFactory,\r\n        uint256 indexed marketId,\r\n        address indexed creator,\r\n        address lpTokenRecipient\r\n    );\r\n    event LiquidityChanged(\r\n        address indexed marketFactory,\r\n        uint256 indexed marketId,\r\n        address indexed user,\r\n        address recipient,\r\n        // from the perspective of the user. e.g. collateral is negative when adding liquidity\r\n        int256 collateral,\r\n        int256 lpTokens,\r\n        uint256[] sharesReturned\r\n    );\r\n    event SharesSwapped(\r\n        address indexed marketFactory,\r\n        uint256 indexed marketId,\r\n        address indexed user,\r\n        uint256 outcome,\r\n        // from the perspective of the user. e.g. collateral is negative when buying\r\n        int256 collateral,\r\n        int256 shares,\r\n        uint256 price\r\n    );\r\n\r\n    constructor(BFactory _bFactory, uint256 _fee) {\r\n        bFactory = _bFactory;\r\n        fee = _fee;\r\n    }\r\n\r\n    function createPool(\r\n        AbstractMarketFactoryV3 _marketFactory,\r\n        uint256 _marketId,\r\n        uint256 _initialLiquidity,\r\n        address _lpTokenRecipient\r\n    ) public returns (uint256) {\r\n        require(pools[address(_marketFactory)][_marketId] == BPool(0), \"Pool already created\");\r\n\r\n        AbstractMarketFactoryV3.Market memory _market = _marketFactory.getMarket(_marketId);\r\n\r\n        uint256 _sets = _marketFactory.calcShares(_initialLiquidity);\r\n\r\n        // Comparing to sets because sets are normalized to 10e18.\r\n        require(_sets >= MIN_INITIAL_LIQUIDITY, \"Initial liquidity must be at least 100 collateral.\");\r\n\r\n        //  Turn collateral into shares\r\n        IERC20Full _collateral = _marketFactory.collateral();\r\n        require(\r\n            _collateral.allowance(msg.sender, address(this)) >= _initialLiquidity,\r\n            \"insufficient collateral allowance for initial liquidity\"\r\n        );\r\n\r\n        _collateral.transferFrom(msg.sender, address(this), _initialLiquidity);\r\n        _collateral.approve(address(_marketFactory), MAX_UINT);\r\n\r\n        _marketFactory.mintShares(_marketId, _sets, address(this));\r\n\r\n        // Create pool\r\n        BPool _pool = bFactory.newBPool();\r\n\r\n        // Add each outcome to the pool. Collateral is NOT added.\r\n        for (uint256 i = 0; i < _market.shareTokens.length; i++) {\r\n            OwnedERC20 _token = _market.shareTokens[i];\r\n            _token.approve(address(_pool), MAX_UINT);\r\n            _pool.bind(address(_token), _sets, _market.initialOdds[i]);\r\n        }\r\n\r\n        // Set the swap fee.\r\n        _pool.setSwapFee(fee);\r\n\r\n        // Finalize pool setup\r\n        _pool.finalize();\r\n\r\n        pools[address(_marketFactory)][_marketId] = _pool;\r\n\r\n        // Pass along LP tokens for initial liquidity\r\n        uint256 _lpTokenBalance = _pool.balanceOf(address(this)) - (BONE / 1000);\r\n\r\n        // Burn (BONE / 1000) lp tokens to prevent the bpool from locking up. When all liquidity is removed.\r\n        _pool.transfer(address(0x0), (BONE / 1000));\r\n        _pool.transfer(_lpTokenRecipient, _lpTokenBalance);\r\n\r\n        uint256[] memory _balances = new uint256[](_market.shareTokens.length);\r\n        for (uint256 i = 0; i < _market.shareTokens.length; i++) {\r\n            _balances[i] = 0;\r\n        }\r\n\r\n        emit PoolCreated(address(_pool), address(_marketFactory), _marketId, msg.sender, _lpTokenRecipient);\r\n        emit LiquidityChanged(\r\n            address(_marketFactory),\r\n            _marketId,\r\n            msg.sender,\r\n            _lpTokenRecipient,\r\n            -int256(_initialLiquidity),\r\n            int256(_lpTokenBalance),\r\n            _balances\r\n        );\r\n\r\n        return _lpTokenBalance;\r\n    }\r\n\r\n    function addLiquidity(\r\n        AbstractMarketFactoryV3 _marketFactory,\r\n        uint256 _marketId,\r\n        uint256 _collateralIn,\r\n        uint256 _minLPTokensOut,\r\n        address _lpTokenRecipient\r\n    ) public returns (uint256 _poolAmountOut, uint256[] memory _balances) {\r\n        BPool _pool = pools[address(_marketFactory)][_marketId];\r\n        require(_pool != BPool(0), \"Pool needs to be created\");\r\n\r\n        AbstractMarketFactoryV3.Market memory _market = _marketFactory.getMarket(_marketId);\r\n\r\n        //  Turn collateral into shares\r\n        IERC20Full _collateral = _marketFactory.collateral();\r\n        _collateral.transferFrom(msg.sender, address(this), _collateralIn);\r\n        _collateral.approve(address(_marketFactory), MAX_UINT);\r\n        uint256 _sets = _marketFactory.calcShares(_collateralIn);\r\n        _marketFactory.mintShares(_marketId, _sets, address(this));\r\n\r\n        // Find poolAmountOut\r\n        _poolAmountOut = MAX_UINT;\r\n\r\n        {\r\n            uint256 _totalSupply = _pool.totalSupply();\r\n            uint256[] memory _maxAmountsIn = new uint256[](_market.shareTokens.length);\r\n            for (uint256 i = 0; i < _market.shareTokens.length; i++) {\r\n                _maxAmountsIn[i] = _sets;\r\n\r\n                OwnedERC20 _token = _market.shareTokens[i];\r\n                uint256 _bPoolTokenBalance = _pool.getBalance(address(_token));\r\n\r\n                // This is the result the following when solving for poolAmountOut:\r\n                // uint256 ratio = bdiv(poolAmountOut, poolTotal);\r\n                // uint256 tokenAmountIn = bmul(ratio, bal);\r\n                uint256 _tokenPoolAmountOut =\r\n                    (((((_sets * BONE) - (BONE / 2)) * _totalSupply) / _bPoolTokenBalance) - (_totalSupply / 2)) / BONE;\r\n\r\n                if (_tokenPoolAmountOut < _poolAmountOut) {\r\n                    _poolAmountOut = _tokenPoolAmountOut;\r\n                }\r\n            }\r\n            _pool.joinPool(_poolAmountOut, _maxAmountsIn);\r\n        }\r\n\r\n        require(_poolAmountOut >= _minLPTokensOut, \"Would not have received enough LP tokens\");\r\n\r\n        _pool.transfer(_lpTokenRecipient, _poolAmountOut);\r\n\r\n        // Transfer the remaining shares back to _lpTokenRecipient.\r\n        _balances = new uint256[](_market.shareTokens.length);\r\n        for (uint256 i = 0; i < _market.shareTokens.length; i++) {\r\n            OwnedERC20 _token = _market.shareTokens[i];\r\n            _balances[i] = _token.balanceOf(address(this));\r\n            if (_balances[i] > 0) {\r\n                _token.transfer(_lpTokenRecipient, _balances[i]);\r\n            }\r\n        }\r\n\r\n        emit LiquidityChanged(\r\n            address(_marketFactory),\r\n            _marketId,\r\n            msg.sender,\r\n            _lpTokenRecipient,\r\n            -int256(_collateralIn),\r\n            int256(_poolAmountOut),\r\n            _balances\r\n        );\r\n    }\r\n\r\n    function removeLiquidity(\r\n        AbstractMarketFactoryV3 _marketFactory,\r\n        uint256 _marketId,\r\n        uint256 _lpTokensIn,\r\n        uint256 _minCollateralOut,\r\n        address _collateralRecipient\r\n    ) public returns (uint256 _collateralOut, uint256[] memory _balances) {\r\n        BPool _pool = pools[address(_marketFactory)][_marketId];\r\n        require(_pool != BPool(0), \"Pool needs to be created\");\r\n\r\n        AbstractMarketFactoryV3.Market memory _market = _marketFactory.getMarket(_marketId);\r\n\r\n        _pool.transferFrom(msg.sender, address(this), _lpTokensIn);\r\n\r\n        uint256[] memory exitPoolEstimate;\r\n        {\r\n            uint256[] memory minAmountsOut = new uint256[](_market.shareTokens.length);\r\n            exitPoolEstimate = _pool.calcExitPool(_lpTokensIn, minAmountsOut);\r\n            _pool.exitPool(_lpTokensIn, minAmountsOut);\r\n        }\r\n\r\n        // Find the number of sets to sell.\r\n        uint256 _setsToSell = MAX_UINT;\r\n        for (uint256 i = 0; i < _market.shareTokens.length; i++) {\r\n            uint256 _acquiredTokenBalance = exitPoolEstimate[i];\r\n            if (_acquiredTokenBalance < _setsToSell) _setsToSell = _acquiredTokenBalance;\r\n        }\r\n\r\n        // Must be a multiple of share factor.\r\n        _setsToSell = (_setsToSell / _marketFactory.shareFactor()) * _marketFactory.shareFactor();\r\n\r\n        bool _resolved = _marketFactory.isMarketResolved(_marketId);\r\n        if (_resolved) {\r\n            _collateralOut = _marketFactory.claimWinnings(_marketId, _collateralRecipient);\r\n        } else {\r\n            _collateralOut = _marketFactory.burnShares(_marketId, _setsToSell, _collateralRecipient);\r\n        }\r\n        require(_collateralOut > _minCollateralOut, \"Amount of collateral returned too low.\");\r\n\r\n        // Transfer the remaining shares back to _collateralRecipient.\r\n        _balances = new uint256[](_market.shareTokens.length);\r\n        for (uint256 i = 0; i < _market.shareTokens.length; i++) {\r\n            OwnedERC20 _token = _market.shareTokens[i];\r\n            if (_resolved && _token == _market.winner) continue; // all winning shares claimed when market is resolved\r\n            _balances[i] = exitPoolEstimate[i] - _setsToSell;\r\n            if (_balances[i] > 0) {\r\n                _token.transfer(_collateralRecipient, _balances[i]);\r\n            }\r\n        }\r\n\r\n        emit LiquidityChanged(\r\n            address(_marketFactory),\r\n            _marketId,\r\n            msg.sender,\r\n            _collateralRecipient,\r\n            int256(_collateralOut),\r\n            -int256(_lpTokensIn),\r\n            _balances\r\n        );\r\n    }\r\n\r\n    function buy(\r\n        AbstractMarketFactoryV3 _marketFactory,\r\n        uint256 _marketId,\r\n        uint256 _outcome,\r\n        uint256 _collateralIn,\r\n        uint256 _minTokensOut\r\n    ) external returns (uint256) {\r\n        BPool _pool = pools[address(_marketFactory)][_marketId];\r\n        require(_pool != BPool(0), \"Pool needs to be created\");\r\n\r\n        AbstractMarketFactoryV3.Market memory _market = _marketFactory.getMarket(_marketId);\r\n\r\n        IERC20Full _collateral = _marketFactory.collateral();\r\n        _collateral.transferFrom(msg.sender, address(this), _collateralIn);\r\n        uint256 _sets = _marketFactory.calcShares(_collateralIn);\r\n        _marketFactory.mintShares(_marketId, _sets, address(this));\r\n\r\n        uint256 _totalDesiredOutcome = _sets;\r\n        {\r\n            OwnedERC20 _desiredToken = _market.shareTokens[_outcome];\r\n\r\n            for (uint256 i = 0; i < _market.shareTokens.length; i++) {\r\n                if (i == _outcome) continue;\r\n                OwnedERC20 _token = _market.shareTokens[i];\r\n                (uint256 _acquiredToken, ) =\r\n                    _pool.swapExactAmountIn(address(_token), _sets, address(_desiredToken), 0, MAX_UINT);\r\n                _totalDesiredOutcome += _acquiredToken;\r\n            }\r\n            require(_totalDesiredOutcome >= _minTokensOut, \"Slippage exceeded\");\r\n\r\n            _desiredToken.transfer(msg.sender, _totalDesiredOutcome);\r\n        }\r\n\r\n        emit SharesSwapped(\r\n            address(_marketFactory),\r\n            _marketId,\r\n            msg.sender,\r\n            _outcome,\r\n            -int256(_collateralIn),\r\n            int256(_totalDesiredOutcome),\r\n            bdiv(_sets, _totalDesiredOutcome)\r\n        );\r\n\r\n        return _totalDesiredOutcome;\r\n    }\r\n\r\n    function sellForCollateral(\r\n        AbstractMarketFactoryV3 _marketFactory,\r\n        uint256 _marketId,\r\n        uint256 _outcome,\r\n        uint256[] memory _shareTokensIn,\r\n        uint256 _minSetsOut\r\n    ) external returns (uint256) {\r\n        BPool _pool = pools[address(_marketFactory)][_marketId];\r\n        require(_pool != BPool(0), \"Pool needs to be created\");\r\n        AbstractMarketFactoryV3.Market memory _market = _marketFactory.getMarket(_marketId);\r\n\r\n        uint256 _setsOut = MAX_UINT;\r\n        uint256 _totalUndesiredTokensIn = 0;\r\n        for (uint256 i = 0; i < _market.shareTokens.length; i++) {\r\n            _totalUndesiredTokensIn += _shareTokensIn[i];\r\n        }\r\n\r\n        {\r\n            _market.shareTokens[_outcome].transferFrom(msg.sender, address(this), _totalUndesiredTokensIn);\r\n            _market.shareTokens[_outcome].approve(address(_pool), MAX_UINT);\r\n\r\n            for (uint256 i = 0; i < _market.shareTokens.length; i++) {\r\n                if (i == _outcome) continue;\r\n                OwnedERC20 _token = _market.shareTokens[i];\r\n                (uint256 tokenAmountOut, ) =\r\n                    _pool.swapExactAmountIn(\r\n                        address(_market.shareTokens[_outcome]),\r\n                        _shareTokensIn[i],\r\n                        address(_token),\r\n                        0,\r\n                        MAX_UINT\r\n                    );\r\n\r\n                //Ensure tokenAmountOut is a multiple of shareFactor.\r\n                tokenAmountOut = (tokenAmountOut / _marketFactory.shareFactor()) * _marketFactory.shareFactor();\r\n                if (tokenAmountOut < _setsOut) _setsOut = tokenAmountOut;\r\n            }\r\n\r\n            require(_setsOut >= _minSetsOut, \"Minimum sets not available.\");\r\n            _marketFactory.burnShares(_marketId, _setsOut, msg.sender);\r\n        }\r\n\r\n        // Transfer undesired token balance back.\r\n        for (uint256 i = 0; i < _market.shareTokens.length; i++) {\r\n            OwnedERC20 _token = _market.shareTokens[i];\r\n            uint256 _balance = _token.balanceOf(address(this));\r\n            if (_balance > 0) {\r\n                _token.transfer(msg.sender, _balance);\r\n            }\r\n        }\r\n\r\n        uint256 _collateralOut = _marketFactory.calcCost(_setsOut);\r\n        emit SharesSwapped(\r\n            address(_marketFactory),\r\n            _marketId,\r\n            msg.sender,\r\n            _outcome,\r\n            int256(_collateralOut),\r\n            -int256(_totalUndesiredTokensIn),\r\n            bdiv(_setsOut, _totalUndesiredTokensIn)\r\n        );\r\n\r\n        return _collateralOut;\r\n    }\r\n\r\n    // Returns an array of token values for the outcomes of the market, relative to the first outcome.\r\n    // So the first outcome is 10**18 and all others are higher or lower.\r\n    // Prices can be derived due to the fact that the total of all outcome shares equals one collateral, possibly with a scaling factor,\r\n    function tokenRatios(AbstractMarketFactoryV3 _marketFactory, uint256 _marketId)\r\n        external\r\n        view\r\n        returns (uint256[] memory)\r\n    {\r\n        BPool _pool = pools[address(_marketFactory)][_marketId];\r\n        // Pool does not exist. Do not want to revert because multicall.\r\n        if (_pool == BPool(0)) {\r\n            return new uint256[](0);\r\n        }\r\n\r\n        AbstractMarketFactoryV3.Market memory _market = _marketFactory.getMarket(_marketId);\r\n        address _basisToken = address(_market.shareTokens[0]);\r\n        uint256[] memory _ratios = new uint256[](_market.shareTokens.length);\r\n        _ratios[0] = 10**18;\r\n        for (uint256 i = 1; i < _market.shareTokens.length; i++) {\r\n            uint256 _price = _pool.getSpotPrice(_basisToken, address(_market.shareTokens[i]));\r\n            _ratios[i] = _price;\r\n        }\r\n        return _ratios;\r\n    }\r\n\r\n    function getPoolBalances(AbstractMarketFactoryV3 _marketFactory, uint256 _marketId)\r\n        external\r\n        view\r\n        returns (uint256[] memory)\r\n    {\r\n        BPool _pool = pools[address(_marketFactory)][_marketId];\r\n        // Pool does not exist. Do not want to revert because multicall.\r\n        if (_pool == BPool(0)) {\r\n            return new uint256[](0);\r\n        }\r\n\r\n        address[] memory _tokens = _pool.getCurrentTokens();\r\n        uint256[] memory _balances = new uint256[](_tokens.length);\r\n        for (uint256 i = 0; i < _tokens.length; i++) {\r\n            _balances[i] = _pool.getBalance(_tokens[i]);\r\n        }\r\n        return _balances;\r\n    }\r\n\r\n    function getPoolWeights(AbstractMarketFactoryV3 _marketFactory, uint256 _marketId)\r\n        external\r\n        view\r\n        returns (uint256[] memory)\r\n    {\r\n        BPool _pool = pools[address(_marketFactory)][_marketId];\r\n        // Pool does not exist. Do not want to revert because multicall.\r\n        if (_pool == BPool(0)) {\r\n            return new uint256[](0);\r\n        }\r\n\r\n        address[] memory _tokens = _pool.getCurrentTokens();\r\n        uint256[] memory _weights = new uint256[](_tokens.length);\r\n        for (uint256 i = 0; i < _tokens.length; i++) {\r\n            _weights[i] = _pool.getDenormalizedWeight(_tokens[i]);\r\n        }\r\n        return _weights;\r\n    }\r\n\r\n    function getSwapFee(AbstractMarketFactoryV3 _marketFactory, uint256 _marketId) external view returns (uint256) {\r\n        BPool _pool = pools[address(_marketFactory)][_marketId];\r\n        return _pool.getSwapFee();\r\n    }\r\n\r\n    function getPoolTokenBalance(\r\n        AbstractMarketFactoryV3 _marketFactory,\r\n        uint256 _marketId,\r\n        address _user\r\n    ) external view returns (uint256) {\r\n        BPool _pool = pools[address(_marketFactory)][_marketId];\r\n        return _pool.balanceOf(_user);\r\n    }\r\n\r\n    function getPool(AbstractMarketFactoryV3 _marketFactory, uint256 _marketId) external view returns (BPool) {\r\n        return pools[address(_marketFactory)][_marketId];\r\n    }\r\n}\r\n"
    },
    "contracts/balancer/BFactory.sol": {
      "content": "// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is disstributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity 0.7.6;\r\n\r\n// Builds new BPools, logging their addresses and providing `isBPool(address) -> (bool)`\r\n\r\nimport \"./BPool.sol\";\r\n\r\ncontract BFactory is BBronze {\r\n    event LOG_NEW_POOL(address indexed caller, address indexed pool);\r\n\r\n    event LOG_BLABS(address indexed caller, address indexed blabs);\r\n\r\n    mapping(address => bool) private _isBPool;\r\n\r\n    function isBPool(address b) external view returns (bool) {\r\n        return _isBPool[b];\r\n    }\r\n\r\n    function newBPool() external returns (BPool) {\r\n        BPool bpool = new BPool();\r\n        _isBPool[address(bpool)] = true;\r\n        emit LOG_NEW_POOL(msg.sender, address(bpool));\r\n        bpool.setController(msg.sender);\r\n        return bpool;\r\n    }\r\n\r\n    address private _blabs;\r\n\r\n    constructor() {\r\n        _blabs = msg.sender;\r\n    }\r\n\r\n    function getBLabs() external view returns (address) {\r\n        return _blabs;\r\n    }\r\n\r\n    function setBLabs(address b) external {\r\n        require(msg.sender == _blabs, \"ERR_NOT_BLABS\");\r\n        emit LOG_BLABS(msg.sender, b);\r\n        _blabs = b;\r\n    }\r\n\r\n    function collect(BPool pool) external {\r\n        require(msg.sender == _blabs, \"ERR_NOT_BLABS\");\r\n        uint256 collected = IERC20Balancer(pool).balanceOf(address(this));\r\n        bool xfer = pool.transfer(_blabs, collected);\r\n        require(xfer, \"ERR_ERC20_FAILED\");\r\n    }\r\n}\r\n"
    },
    "contracts/libraries/SafeMathUint256.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.7.6;\r\n\r\n/**\r\n * @title SafeMathUint256\r\n * @dev Uint256 math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMathUint256 {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function subS(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory message\r\n    ) internal pure returns (uint256) {\r\n        require(b <= a, message);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a <= b) {\r\n            return a;\r\n        } else {\r\n            return b;\r\n        }\r\n    }\r\n\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a >= b) {\r\n            return a;\r\n        } else {\r\n            return b;\r\n        }\r\n    }\r\n\r\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\r\n        if (y > 3) {\r\n            uint256 x = (y + 1) / 2;\r\n            z = y;\r\n            while (x < z) {\r\n                z = x;\r\n                x = (y / x + x) / 2;\r\n            }\r\n        } else if (y != 0) {\r\n            z = 1;\r\n        }\r\n    }\r\n\r\n    function getUint256Min() internal pure returns (uint256) {\r\n        return 0;\r\n    }\r\n\r\n    function getUint256Max() internal pure returns (uint256) {\r\n        // 2 ** 256 - 1\r\n        return 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\r\n    }\r\n\r\n    function isMultipleOf(uint256 a, uint256 b) internal pure returns (bool) {\r\n        return a % b == 0;\r\n    }\r\n\r\n    // Float [fixed point] Operations\r\n    function fxpMul(\r\n        uint256 a,\r\n        uint256 b,\r\n        uint256 base\r\n    ) internal pure returns (uint256) {\r\n        return div(mul(a, b), base);\r\n    }\r\n\r\n    function fxpDiv(\r\n        uint256 a,\r\n        uint256 b,\r\n        uint256 base\r\n    ) internal pure returns (uint256) {\r\n        return div(mul(a, base), b);\r\n    }\r\n}\r\n"
    },
    "contracts/turbo/AbstractMarketFactoryV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.7.6;\r\npragma abicoder v2;\r\n\r\nimport \"../libraries/IERC20Full.sol\";\r\nimport \"../balancer/BPool.sol\";\r\nimport \"./TurboShareTokenFactory.sol\";\r\nimport \"./FeePot.sol\";\r\nimport \"../libraries/Rewardable.sol\";\r\n\r\nabstract contract AbstractMarketFactoryV3 is TurboShareTokenFactory, Ownable, Rewardable {\r\n    using SafeMathUint256 for uint256;\r\n\r\n    event MarketCreated(uint256 id, string[] names, uint256[] initialOdds);\r\n    event MarketResolved(uint256 id, address winner, uint256 winnerIndex, string winnerName);\r\n    event MarketActivated(uint256 id);\r\n\r\n    event SharesMinted(uint256 id, uint256 amount, address receiver);\r\n    event SharesBurned(uint256 id, uint256 amount, address receiver);\r\n    event WinningsClaimed(\r\n        uint256 id,\r\n        address winningOutcome,\r\n        uint256 winningIndex,\r\n        string winningName,\r\n        uint256 amount,\r\n        uint256 settlementFee,\r\n        uint256 payout,\r\n        address indexed receiver\r\n    );\r\n\r\n    IERC20Full public collateral;\r\n    FeePot public feePot;\r\n\r\n    // fees are out of 1e18 and only apply to new markets\r\n    uint256 public stakerFee;\r\n    uint256 public settlementFee;\r\n    uint256 public protocolFee;\r\n\r\n    address public protocol; // collects protocol fees\r\n\r\n    uint256 public accumulatedProtocolFee = 0;\r\n    // settlement address => amount of collateral\r\n    mapping(address => uint256) public accumulatedSettlementFees;\r\n\r\n    // How many shares equals one collateral.\r\n    // Necessary to account for math errors from small numbers in balancer.\r\n    // shares = collateral / shareFactor\r\n    // collateral = shares * shareFactor\r\n    uint256 public shareFactor;\r\n\r\n    struct Market {\r\n        address settlementAddress;\r\n        OwnedERC20[] shareTokens;\r\n        OwnedERC20 winner;\r\n        uint256 winnerIndex;\r\n        uint256 settlementFee;\r\n        uint256 protocolFee;\r\n        uint256 stakerFee;\r\n        uint256 creationTimestamp;\r\n        uint256 resolutionTimestamp; // when winner is declared\r\n        uint256[] initialOdds;\r\n        bool active; // false if not ready to use or if resolved\r\n    }\r\n    Market[] internal markets;\r\n\r\n    uint256 private constant MAX_UINT = 2**256 - 1;\r\n\r\n    constructor(\r\n        address _owner,\r\n        IERC20Full _collateral,\r\n        uint256 _shareFactor,\r\n        FeePot _feePot,\r\n        uint256[3] memory _fees, // staker, settlement, protocol\r\n        address _protocol\r\n    ) {\r\n        owner = _owner; // controls fees for new markets\r\n        collateral = _collateral;\r\n        shareFactor = _shareFactor;\r\n        feePot = _feePot;\r\n        stakerFee = _fees[0];\r\n        settlementFee = _fees[1];\r\n        protocolFee = _fees[2];\r\n        protocol = _protocol;\r\n\r\n        _collateral.approve(address(_feePot), MAX_UINT);\r\n\r\n        // First market is always empty so that marketid zero means \"no market\"\r\n        markets.push(makeEmptyMarket());\r\n    }\r\n\r\n    // Returns an empty struct if the market doesn't exist.\r\n    // Can check market existence before calling this by comparing _id against markets.length.\r\n    // Can check market existence of the return struct by checking that shareTokens[0] isn't the null address\r\n    function getMarket(uint256 _id) public view returns (Market memory) {\r\n        if (_id >= markets.length) {\r\n            return makeEmptyMarket();\r\n        } else {\r\n            return markets[_id];\r\n        }\r\n    }\r\n\r\n    function marketCount() public view returns (uint256) {\r\n        return markets.length;\r\n    }\r\n\r\n    // Returns factory-specific details about a market.\r\n    // function getMarketDetails(uint256 _id) public view returns (MarketDetails memory);\r\n\r\n    function mintShares(\r\n        uint256 _id,\r\n        uint256 _shareToMint,\r\n        address _receiver\r\n    ) public {\r\n        require(markets.length > _id);\r\n        require(markets[_id].active);\r\n\r\n        uint256 _cost = calcCost(_shareToMint);\r\n        collateral.transferFrom(msg.sender, address(this), _cost);\r\n\r\n        Market memory _market = markets[_id];\r\n        for (uint256 _i = 0; _i < _market.shareTokens.length; _i++) {\r\n            _market.shareTokens[_i].trustedMint(_receiver, _shareToMint);\r\n        }\r\n\r\n        emit SharesMinted(_id, _shareToMint, _receiver);\r\n    }\r\n\r\n    function burnShares(\r\n        uint256 _id,\r\n        uint256 _sharesToBurn,\r\n        address _receiver\r\n    ) public returns (uint256) {\r\n        require(markets.length > _id);\r\n        require(markets[_id].active);\r\n\r\n        Market memory _market = markets[_id];\r\n        for (uint256 _i = 0; _i < _market.shareTokens.length; _i++) {\r\n            // errors if sender doesn't have enough shares\r\n            _market.shareTokens[_i].trustedBurn(msg.sender, _sharesToBurn);\r\n        }\r\n\r\n        uint256 _payout = calcCost(_sharesToBurn);\r\n        uint256 _protocolFee = _payout.mul(_market.protocolFee).div(10**18);\r\n        uint256 _stakerFee = _payout.mul(_market.stakerFee).div(10**18);\r\n        _payout = _payout.sub(_protocolFee).sub(_stakerFee);\r\n\r\n        accumulatedProtocolFee += _protocolFee;\r\n        collateral.transfer(_receiver, _payout);\r\n        feePot.depositFees(_stakerFee);\r\n\r\n        emit SharesBurned(_id, _sharesToBurn, msg.sender);\r\n        return _payout;\r\n    }\r\n\r\n    function claimWinnings(uint256 _id, address _receiver) public returns (uint256) {\r\n        require(isMarketResolved(_id), \"market unresolved\");\r\n\r\n        Market memory _market = markets[_id];\r\n        uint256 _winningShares = _market.winner.trustedBurnAll(msg.sender);\r\n        _winningShares = (_winningShares / shareFactor) * shareFactor; // remove unusable dust\r\n\r\n        uint256 _payout = calcCost(_winningShares); // will fail if there are no winnings to claim\r\n        uint256 _settlementFee = _payout.mul(_market.settlementFee).div(10**18);\r\n        _payout = _payout.sub(_settlementFee);\r\n\r\n        accumulatedSettlementFees[_market.settlementAddress] += _settlementFee;\r\n        collateral.transfer(_receiver, _payout);\r\n\r\n        uint256 _winningIndex = _market.winnerIndex;\r\n        string memory _winningName = _market.winner.name();\r\n\r\n        emit WinningsClaimed(\r\n            _id,\r\n            address(_market.winner),\r\n            _winningIndex,\r\n            _winningName,\r\n            _winningShares,\r\n            _settlementFee,\r\n            _payout,\r\n            _receiver\r\n        );\r\n        return _payout;\r\n    }\r\n\r\n    function claimManyWinnings(uint256[] memory _ids, address _receiver) public returns (uint256) {\r\n        uint256 _totalWinnings = 0;\r\n        for (uint256 i = 0; i < _ids.length; i++) {\r\n            _totalWinnings = _totalWinnings.add(claimWinnings(_ids[i], _receiver));\r\n        }\r\n        return _totalWinnings;\r\n    }\r\n\r\n    function claimSettlementFees(address _receiver) public returns (uint256) {\r\n        uint256 _fees = accumulatedSettlementFees[msg.sender];\r\n        if (_fees > 0) {\r\n            accumulatedSettlementFees[msg.sender] = 0;\r\n            collateral.transfer(_receiver, _fees);\r\n        }\r\n        return _fees;\r\n    }\r\n\r\n    function claimProtocolFees() public returns (uint256) {\r\n        require(msg.sender == protocol || msg.sender == address(this));\r\n        uint256 _fees = accumulatedProtocolFee;\r\n        if (_fees > 0) {\r\n            accumulatedProtocolFee = 0;\r\n            collateral.transfer(protocol, _fees);\r\n        }\r\n        return _fees;\r\n    }\r\n\r\n    function setSettlementFee(uint256 _newFee) external onlyOwner {\r\n        settlementFee = _newFee;\r\n    }\r\n\r\n    function setStakerFee(uint256 _newFee) external onlyOwner {\r\n        stakerFee = _newFee;\r\n    }\r\n\r\n    function setProtocolFee(uint256 _newFee) external onlyOwner {\r\n        protocolFee = _newFee;\r\n    }\r\n\r\n    function setProtocol(address _newProtocol, bool _claimFirst) external onlyOwner {\r\n        if (_claimFirst) {\r\n            claimProtocolFees();\r\n        }\r\n        protocol = _newProtocol;\r\n    }\r\n\r\n    function startMarket(\r\n        address _settlementAddress,\r\n        string[] memory _names,\r\n        uint256[] memory _initialOdds,\r\n        bool _active\r\n    ) internal returns (uint256 _marketId) {\r\n        _marketId = markets.length;\r\n        markets.push(\r\n            Market(\r\n                _settlementAddress,\r\n                createShareTokens(_names, address(this)),\r\n                OwnedERC20(0),\r\n                0,\r\n                settlementFee,\r\n                protocolFee,\r\n                stakerFee,\r\n                block.timestamp,\r\n                0,\r\n                _initialOdds,\r\n                _active\r\n            )\r\n        );\r\n        emit MarketCreated(_marketId, _names, _initialOdds);\r\n        if (_active) {\r\n            emit MarketActivated(_marketId);\r\n        }\r\n    }\r\n\r\n    function activateMarket(uint256 _marketId) internal {\r\n        markets[_marketId].active = true;\r\n        emit MarketActivated(_marketId);\r\n    }\r\n\r\n    function makeEmptyMarket() private pure returns (Market memory) {\r\n        OwnedERC20[] memory _tokens = new OwnedERC20[](0);\r\n        uint256[] memory _initialOdds = new uint256[](0);\r\n        return Market(address(0), _tokens, OwnedERC20(0), 0, 0, 0, 0, 0, 0, _initialOdds, false);\r\n    }\r\n\r\n    function endMarket(uint256 _marketId, uint256 _winningOutcome) internal {\r\n        Market storage _market = markets[_marketId];\r\n        OwnedERC20 _winner = _market.shareTokens[_winningOutcome];\r\n\r\n        _market.winner = _winner;\r\n        _market.active = false;\r\n        _market.winnerIndex = _winningOutcome;\r\n        _market.resolutionTimestamp = block.timestamp;\r\n        string memory _outcomeName = _winner.name();\r\n        emit MarketResolved(_marketId, address(_winner), _winningOutcome, _outcomeName);\r\n    }\r\n\r\n    function isMarketResolved(uint256 _id) public view returns (bool) {\r\n        Market memory _market = markets[_id];\r\n        return _market.winner != OwnedERC20(0);\r\n    }\r\n\r\n    // shares => collateral\r\n    // Shares must be both greater than (or equal to) and divisible by shareFactor.\r\n    function calcCost(uint256 _shares) public view returns (uint256) {\r\n        require(_shares >= shareFactor && _shares % shareFactor == 0);\r\n        return _shares / shareFactor;\r\n    }\r\n\r\n    // collateral => shares\r\n    function calcShares(uint256 _collateralIn) public view returns (uint256) {\r\n        return _collateralIn * shareFactor;\r\n    }\r\n\r\n    function onTransferOwnership(address, address) internal override {}\r\n}\r\n"
    },
    "contracts/balancer/BPool.sol": {
      "content": "// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity 0.7.6;\r\n\r\nimport \"./BToken.sol\";\r\nimport \"./BMath.sol\";\r\n\r\ncontract BPool is BBronze, BToken, BMath {\r\n    struct Record {\r\n        bool bound; // is token bound to pool\r\n        uint256 index; // private\r\n        uint256 denorm; // denormalized weight\r\n        uint256 balance;\r\n    }\r\n\r\n    event LOG_SWAP(\r\n        address indexed caller,\r\n        address indexed tokenIn,\r\n        address indexed tokenOut,\r\n        uint256 tokenAmountIn,\r\n        uint256 tokenAmountOut\r\n    );\r\n\r\n    event LOG_JOIN(address indexed caller, address indexed tokenIn, uint256 tokenAmountIn);\r\n\r\n    event LOG_EXIT(address indexed caller, address indexed tokenOut, uint256 tokenAmountOut);\r\n\r\n    event LOG_CALL(bytes4 indexed sig, address indexed caller, bytes data) anonymous;\r\n\r\n    modifier _logs_() {\r\n        emit LOG_CALL(msg.sig, msg.sender, msg.data);\r\n        _;\r\n    }\r\n\r\n    modifier _lock_() {\r\n        require(!_mutex, \"ERR_REENTRY\");\r\n        _mutex = true;\r\n        _;\r\n        _mutex = false;\r\n    }\r\n\r\n    modifier _viewlock_() {\r\n        require(!_mutex, \"ERR_REENTRY\");\r\n        _;\r\n    }\r\n\r\n    bool private _mutex;\r\n\r\n    address private _factory; // BFactory address to push token exitFee to\r\n    address private _controller; // has CONTROL role\r\n    bool private _publicSwap; // true if PUBLIC can call SWAP functions\r\n\r\n    // `setSwapFee` and `finalize` require CONTROL\r\n    // `finalize` sets `PUBLIC can SWAP`, `PUBLIC can JOIN`\r\n    uint256 private _swapFee;\r\n    bool private _finalized;\r\n\r\n    address[] private _tokens;\r\n    mapping(address => Record) private _records;\r\n    uint256 private _totalWeight;\r\n\r\n    constructor() {\r\n        _controller = msg.sender;\r\n        _factory = msg.sender;\r\n        _swapFee = MIN_FEE;\r\n        _publicSwap = false;\r\n        _finalized = false;\r\n    }\r\n\r\n    function isPublicSwap() external view returns (bool) {\r\n        return _publicSwap;\r\n    }\r\n\r\n    function isFinalized() external view returns (bool) {\r\n        return _finalized;\r\n    }\r\n\r\n    function isBound(address t) external view returns (bool) {\r\n        return _records[t].bound;\r\n    }\r\n\r\n    function getNumTokens() external view returns (uint256) {\r\n        return _tokens.length;\r\n    }\r\n\r\n    function getCurrentTokens() external view _viewlock_ returns (address[] memory tokens) {\r\n        return _tokens;\r\n    }\r\n\r\n    function getFinalTokens() external view _viewlock_ returns (address[] memory tokens) {\r\n        require(_finalized, \"ERR_NOT_FINALIZED\");\r\n        return _tokens;\r\n    }\r\n\r\n    function getDenormalizedWeight(address token) external view _viewlock_ returns (uint256) {\r\n        require(_records[token].bound, \"ERR_NOT_BOUND\");\r\n        return _records[token].denorm;\r\n    }\r\n\r\n    function getTotalDenormalizedWeight() external view _viewlock_ returns (uint256) {\r\n        return _totalWeight;\r\n    }\r\n\r\n    function getNormalizedWeight(address token) external view _viewlock_ returns (uint256) {\r\n        require(_records[token].bound, \"ERR_NOT_BOUND\");\r\n        uint256 denorm = _records[token].denorm;\r\n        return bdiv(denorm, _totalWeight);\r\n    }\r\n\r\n    function getBalance(address token) external view _viewlock_ returns (uint256) {\r\n        require(_records[token].bound, \"ERR_NOT_BOUND\");\r\n        return _records[token].balance;\r\n    }\r\n\r\n    function getSwapFee() external view _viewlock_ returns (uint256) {\r\n        return _swapFee;\r\n    }\r\n\r\n    function getController() external view _viewlock_ returns (address) {\r\n        return _controller;\r\n    }\r\n\r\n    function setSwapFee(uint256 swapFee) external _logs_ _lock_ {\r\n        require(!_finalized, \"ERR_IS_FINALIZED\");\r\n        require(msg.sender == _controller, \"ERR_NOT_CONTROLLER\");\r\n        require(swapFee >= MIN_FEE, \"ERR_MIN_FEE\");\r\n        require(swapFee <= MAX_FEE, \"ERR_MAX_FEE\");\r\n        _swapFee = swapFee;\r\n    }\r\n\r\n    function setController(address manager) external _logs_ _lock_ {\r\n        require(msg.sender == _controller, \"ERR_NOT_CONTROLLER\");\r\n        _controller = manager;\r\n    }\r\n\r\n    function setPublicSwap(bool public_) external _logs_ _lock_ {\r\n        require(!_finalized, \"ERR_IS_FINALIZED\");\r\n        require(msg.sender == _controller, \"ERR_NOT_CONTROLLER\");\r\n        _publicSwap = public_;\r\n    }\r\n\r\n    function finalize() external _logs_ _lock_ {\r\n        require(msg.sender == _controller, \"ERR_NOT_CONTROLLER\");\r\n        require(!_finalized, \"ERR_IS_FINALIZED\");\r\n        require(_tokens.length >= MIN_BOUND_TOKENS, \"ERR_MIN_TOKENS\");\r\n\r\n        _finalized = true;\r\n        _publicSwap = true;\r\n\r\n        _mintPoolShare(INIT_POOL_SUPPLY);\r\n        _pushPoolShare(msg.sender, INIT_POOL_SUPPLY);\r\n    }\r\n\r\n    function bind(\r\n        address token,\r\n        uint256 balance,\r\n        uint256 denorm\r\n    )\r\n        external\r\n        _logs_ // _lock_  Bind does not lock because it jumps to `rebind`, which does\r\n    {\r\n        require(msg.sender == _controller, \"ERR_NOT_CONTROLLER\");\r\n        require(!_records[token].bound, \"ERR_IS_BOUND\");\r\n        require(!_finalized, \"ERR_IS_FINALIZED\");\r\n\r\n        require(_tokens.length < MAX_BOUND_TOKENS, \"ERR_MAX_TOKENS\");\r\n\r\n        _records[token] = Record({\r\n            bound: true,\r\n            index: _tokens.length,\r\n            denorm: 0, // balance and denorm will be validated\r\n            balance: 0 // and set by `rebind`\r\n        });\r\n        _tokens.push(token);\r\n        rebind(token, balance, denorm);\r\n    }\r\n\r\n    function rebind(\r\n        address token,\r\n        uint256 balance,\r\n        uint256 denorm\r\n    ) public _logs_ _lock_ {\r\n        require(msg.sender == _controller, \"ERR_NOT_CONTROLLER\");\r\n        require(_records[token].bound, \"ERR_NOT_BOUND\");\r\n        require(!_finalized, \"ERR_IS_FINALIZED\");\r\n\r\n        require(denorm >= MIN_WEIGHT, \"ERR_MIN_WEIGHT\");\r\n        require(denorm <= MAX_WEIGHT, \"ERR_MAX_WEIGHT\");\r\n        require(balance >= MIN_BALANCE, \"ERR_MIN_BALANCE\");\r\n\r\n        // Adjust the denorm and totalWeight\r\n        uint256 oldWeight = _records[token].denorm;\r\n        if (denorm > oldWeight) {\r\n            _totalWeight = badd(_totalWeight, bsub(denorm, oldWeight));\r\n            require(_totalWeight <= MAX_TOTAL_WEIGHT, \"ERR_MAX_TOTAL_WEIGHT\");\r\n        } else if (denorm < oldWeight) {\r\n            _totalWeight = bsub(_totalWeight, bsub(oldWeight, denorm));\r\n        }\r\n        _records[token].denorm = denorm;\r\n\r\n        // Adjust the balance record and actual token balance\r\n        uint256 oldBalance = _records[token].balance;\r\n        _records[token].balance = balance;\r\n        if (balance > oldBalance) {\r\n            _pullUnderlying(token, msg.sender, bsub(balance, oldBalance));\r\n        } else if (balance < oldBalance) {\r\n            // In this case liquidity is being withdrawn, so charge EXIT_FEE\r\n            uint256 tokenBalanceWithdrawn = bsub(oldBalance, balance);\r\n            uint256 tokenExitFee = bmul(tokenBalanceWithdrawn, EXIT_FEE);\r\n            _pushUnderlying(token, msg.sender, bsub(tokenBalanceWithdrawn, tokenExitFee));\r\n            _pushUnderlying(token, _factory, tokenExitFee);\r\n        }\r\n    }\r\n\r\n    function unbind(address token) external _logs_ _lock_ {\r\n        require(msg.sender == _controller, \"ERR_NOT_CONTROLLER\");\r\n        require(_records[token].bound, \"ERR_NOT_BOUND\");\r\n        require(!_finalized, \"ERR_IS_FINALIZED\");\r\n\r\n        uint256 tokenBalance = _records[token].balance;\r\n        uint256 tokenExitFee = bmul(tokenBalance, EXIT_FEE);\r\n\r\n        _totalWeight = bsub(_totalWeight, _records[token].denorm);\r\n\r\n        // Swap the token-to-unbind with the last token,\r\n        // then delete the last token\r\n        uint256 index = _records[token].index;\r\n        uint256 last = _tokens.length - 1;\r\n        _tokens[index] = _tokens[last];\r\n        _records[_tokens[index]].index = index;\r\n        _tokens.pop();\r\n        _records[token] = Record({bound: false, index: 0, denorm: 0, balance: 0});\r\n\r\n        _pushUnderlying(token, msg.sender, bsub(tokenBalance, tokenExitFee));\r\n        _pushUnderlying(token, _factory, tokenExitFee);\r\n    }\r\n\r\n    // Absorb any tokens that have been sent to this contract into the pool\r\n    function gulp(address token) external _logs_ _lock_ {\r\n        require(_records[token].bound, \"ERR_NOT_BOUND\");\r\n        _records[token].balance = IERC20Balancer(token).balanceOf(address(this));\r\n    }\r\n\r\n    function getSpotPrice(address tokenIn, address tokenOut) external view _viewlock_ returns (uint256 spotPrice) {\r\n        require(_records[tokenIn].bound, \"ERR_NOT_BOUND\");\r\n        require(_records[tokenOut].bound, \"ERR_NOT_BOUND\");\r\n        Record storage inRecord = _records[tokenIn];\r\n        Record storage outRecord = _records[tokenOut];\r\n        return calcSpotPrice(inRecord.balance, inRecord.denorm, outRecord.balance, outRecord.denorm, _swapFee);\r\n    }\r\n\r\n    function getSpotPriceSansFee(address tokenIn, address tokenOut)\r\n        external\r\n        view\r\n        _viewlock_\r\n        returns (uint256 spotPrice)\r\n    {\r\n        require(_records[tokenIn].bound, \"ERR_NOT_BOUND\");\r\n        require(_records[tokenOut].bound, \"ERR_NOT_BOUND\");\r\n        Record storage inRecord = _records[tokenIn];\r\n        Record storage outRecord = _records[tokenOut];\r\n        return calcSpotPrice(inRecord.balance, inRecord.denorm, outRecord.balance, outRecord.denorm, 0);\r\n    }\r\n\r\n    function joinPool(uint256 poolAmountOut, uint256[] calldata maxAmountsIn) external _logs_ _lock_ {\r\n        require(_finalized, \"ERR_NOT_FINALIZED\");\r\n\r\n        uint256 poolTotal = totalSupply();\r\n        uint256 ratio = bdiv(poolAmountOut, poolTotal);\r\n        require(ratio != 0, \"ERR_MATH_APPROX\");\r\n\r\n        for (uint256 i = 0; i < _tokens.length; i++) {\r\n            address t = _tokens[i];\r\n            uint256 bal = _records[t].balance;\r\n            uint256 tokenAmountIn = bmul(ratio, bal);\r\n            require(tokenAmountIn != 0, \"ERR_MATH_APPROX\");\r\n            require(tokenAmountIn <= maxAmountsIn[i], \"ERR_LIMIT_IN\");\r\n            _records[t].balance = badd(_records[t].balance, tokenAmountIn);\r\n            emit LOG_JOIN(msg.sender, t, tokenAmountIn);\r\n            _pullUnderlying(t, msg.sender, tokenAmountIn);\r\n        }\r\n        _mintPoolShare(poolAmountOut);\r\n        _pushPoolShare(msg.sender, poolAmountOut);\r\n    }\r\n\r\n    function exitPool(uint256 poolAmountIn, uint256[] calldata minAmountsOut) external _logs_ _lock_ {\r\n        require(_finalized, \"ERR_NOT_FINALIZED\");\r\n\r\n        uint256 poolTotal = totalSupply();\r\n        uint256 exitFee = bmul(poolAmountIn, EXIT_FEE);\r\n        uint256 pAiAfterExitFee = bsub(poolAmountIn, exitFee);\r\n        uint256 ratio = bdiv(pAiAfterExitFee, poolTotal);\r\n        require(ratio != 0, \"ERR_MATH_APPROX\");\r\n\r\n        _pullPoolShare(msg.sender, poolAmountIn);\r\n        _pushPoolShare(_factory, exitFee);\r\n        _burnPoolShare(pAiAfterExitFee);\r\n\r\n        for (uint256 i = 0; i < _tokens.length; i++) {\r\n            address t = _tokens[i];\r\n            uint256 bal = _records[t].balance;\r\n            uint256 tokenAmountOut = bmul(ratio, bal);\r\n            require(tokenAmountOut != 0, \"ERR_MATH_APPROX\");\r\n            require(tokenAmountOut >= minAmountsOut[i], \"ERR_LIMIT_OUT\");\r\n            _records[t].balance = bsub(_records[t].balance, tokenAmountOut);\r\n            emit LOG_EXIT(msg.sender, t, tokenAmountOut);\r\n            _pushUnderlying(t, msg.sender, tokenAmountOut);\r\n        }\r\n    }\r\n\r\n    function calcExitPool(uint256 poolAmountIn, uint256[] calldata minAmountsOut)\r\n        external\r\n        view\r\n        returns (uint256[] memory)\r\n    {\r\n        require(_finalized, \"ERR_NOT_FINALIZED\");\r\n\r\n        uint256 poolTotal = totalSupply();\r\n        uint256 exitFee = bmul(poolAmountIn, EXIT_FEE);\r\n        uint256 pAiAfterExitFee = bsub(poolAmountIn, exitFee);\r\n        uint256 ratio = bdiv(pAiAfterExitFee, poolTotal);\r\n\r\n        uint256[] memory _amounts = new uint256[](_tokens.length * 2);\r\n\r\n        for (uint256 i = 0; i < _tokens.length; i++) {\r\n            address t = _tokens[i];\r\n            uint256 bal = _records[t].balance;\r\n\r\n            _amounts[i] = bmul(ratio, bal);\r\n            _amounts[_tokens.length + i] = minAmountsOut[i];\r\n            require(_amounts[i] >= minAmountsOut[i], \"ERR_LIMIT_OUT\");\r\n        }\r\n\r\n        return _amounts;\r\n    }\r\n\r\n    function swapExactAmountIn(\r\n        address tokenIn,\r\n        uint256 tokenAmountIn,\r\n        address tokenOut,\r\n        uint256 minAmountOut,\r\n        uint256 maxPrice\r\n    ) external _logs_ _lock_ returns (uint256 tokenAmountOut, uint256 spotPriceAfter) {\r\n        require(_records[tokenIn].bound, \"ERR_NOT_BOUND\");\r\n        require(_records[tokenOut].bound, \"ERR_NOT_BOUND\");\r\n        require(_publicSwap, \"ERR_SWAP_NOT_PUBLIC\");\r\n\r\n        Record storage inRecord = _records[address(tokenIn)];\r\n        Record storage outRecord = _records[address(tokenOut)];\r\n\r\n        require(tokenAmountIn <= bmul(inRecord.balance, MAX_IN_RATIO), \"ERR_MAX_IN_RATIO\");\r\n\r\n        uint256 spotPriceBefore =\r\n            calcSpotPrice(inRecord.balance, inRecord.denorm, outRecord.balance, outRecord.denorm, _swapFee);\r\n        require(spotPriceBefore <= maxPrice, \"ERR_BAD_LIMIT_PRICE\");\r\n\r\n        tokenAmountOut = calcOutGivenIn(\r\n            inRecord.balance,\r\n            inRecord.denorm,\r\n            outRecord.balance,\r\n            outRecord.denorm,\r\n            tokenAmountIn,\r\n            _swapFee\r\n        );\r\n        require(tokenAmountOut >= minAmountOut, \"ERR_LIMIT_OUT\");\r\n\r\n        inRecord.balance = badd(inRecord.balance, tokenAmountIn);\r\n        outRecord.balance = bsub(outRecord.balance, tokenAmountOut);\r\n\r\n        spotPriceAfter = calcSpotPrice(\r\n            inRecord.balance,\r\n            inRecord.denorm,\r\n            outRecord.balance,\r\n            outRecord.denorm,\r\n            _swapFee\r\n        );\r\n        require(spotPriceAfter >= spotPriceBefore, \"ERR_MATH_APPROX\");\r\n        require(spotPriceAfter <= maxPrice, \"ERR_LIMIT_PRICE\");\r\n        require(spotPriceBefore <= bdiv(tokenAmountIn, tokenAmountOut), \"ERR_MATH_APPROX\");\r\n\r\n        emit LOG_SWAP(msg.sender, tokenIn, tokenOut, tokenAmountIn, tokenAmountOut);\r\n\r\n        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\r\n        _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\r\n\r\n        return (tokenAmountOut, spotPriceAfter);\r\n    }\r\n\r\n    function swapExactAmountOut(\r\n        address tokenIn,\r\n        uint256 maxAmountIn,\r\n        address tokenOut,\r\n        uint256 tokenAmountOut,\r\n        uint256 maxPrice\r\n    ) external _logs_ _lock_ returns (uint256 tokenAmountIn, uint256 spotPriceAfter) {\r\n        require(_records[tokenIn].bound, \"ERR_NOT_BOUND\");\r\n        require(_records[tokenOut].bound, \"ERR_NOT_BOUND\");\r\n        require(_publicSwap, \"ERR_SWAP_NOT_PUBLIC\");\r\n\r\n        Record storage inRecord = _records[address(tokenIn)];\r\n        Record storage outRecord = _records[address(tokenOut)];\r\n\r\n        require(tokenAmountOut <= bmul(outRecord.balance, MAX_OUT_RATIO), \"ERR_MAX_OUT_RATIO\");\r\n\r\n        uint256 spotPriceBefore =\r\n            calcSpotPrice(inRecord.balance, inRecord.denorm, outRecord.balance, outRecord.denorm, _swapFee);\r\n        require(spotPriceBefore <= maxPrice, \"ERR_BAD_LIMIT_PRICE\");\r\n\r\n        tokenAmountIn = calcInGivenOut(\r\n            inRecord.balance,\r\n            inRecord.denorm,\r\n            outRecord.balance,\r\n            outRecord.denorm,\r\n            tokenAmountOut,\r\n            _swapFee\r\n        );\r\n        require(tokenAmountIn <= maxAmountIn, \"ERR_LIMIT_IN\");\r\n\r\n        inRecord.balance = badd(inRecord.balance, tokenAmountIn);\r\n        outRecord.balance = bsub(outRecord.balance, tokenAmountOut);\r\n\r\n        spotPriceAfter = calcSpotPrice(\r\n            inRecord.balance,\r\n            inRecord.denorm,\r\n            outRecord.balance,\r\n            outRecord.denorm,\r\n            _swapFee\r\n        );\r\n        require(spotPriceAfter >= spotPriceBefore, \"ERR_MATH_APPROX\");\r\n        require(spotPriceAfter <= maxPrice, \"ERR_LIMIT_PRICE\");\r\n        require(spotPriceBefore <= bdiv(tokenAmountIn, tokenAmountOut), \"ERR_MATH_APPROX\");\r\n\r\n        emit LOG_SWAP(msg.sender, tokenIn, tokenOut, tokenAmountIn, tokenAmountOut);\r\n\r\n        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\r\n        _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\r\n\r\n        return (tokenAmountIn, spotPriceAfter);\r\n    }\r\n\r\n    function joinswapExternAmountIn(\r\n        address tokenIn,\r\n        uint256 tokenAmountIn,\r\n        uint256 minPoolAmountOut\r\n    ) external _logs_ _lock_ returns (uint256 poolAmountOut) {\r\n        require(_finalized, \"ERR_NOT_FINALIZED\");\r\n        require(_records[tokenIn].bound, \"ERR_NOT_BOUND\");\r\n        require(tokenAmountIn <= bmul(_records[tokenIn].balance, MAX_IN_RATIO), \"ERR_MAX_IN_RATIO\");\r\n\r\n        Record storage inRecord = _records[tokenIn];\r\n\r\n        poolAmountOut = calcPoolOutGivenSingleIn(\r\n            inRecord.balance,\r\n            inRecord.denorm,\r\n            _totalSupply,\r\n            _totalWeight,\r\n            tokenAmountIn,\r\n            _swapFee\r\n        );\r\n\r\n        require(poolAmountOut >= minPoolAmountOut, \"ERR_LIMIT_OUT\");\r\n\r\n        inRecord.balance = badd(inRecord.balance, tokenAmountIn);\r\n\r\n        emit LOG_JOIN(msg.sender, tokenIn, tokenAmountIn);\r\n\r\n        _mintPoolShare(poolAmountOut);\r\n        _pushPoolShare(msg.sender, poolAmountOut);\r\n        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\r\n\r\n        return poolAmountOut;\r\n    }\r\n\r\n    function joinswapPoolAmountOut(\r\n        address tokenIn,\r\n        uint256 poolAmountOut,\r\n        uint256 maxAmountIn\r\n    ) external _logs_ _lock_ returns (uint256 tokenAmountIn) {\r\n        require(_finalized, \"ERR_NOT_FINALIZED\");\r\n        require(_records[tokenIn].bound, \"ERR_NOT_BOUND\");\r\n\r\n        Record storage inRecord = _records[tokenIn];\r\n\r\n        tokenAmountIn = calcSingleInGivenPoolOut(\r\n            inRecord.balance,\r\n            inRecord.denorm,\r\n            _totalSupply,\r\n            _totalWeight,\r\n            poolAmountOut,\r\n            _swapFee\r\n        );\r\n\r\n        require(tokenAmountIn != 0, \"ERR_MATH_APPROX\");\r\n        require(tokenAmountIn <= maxAmountIn, \"ERR_LIMIT_IN\");\r\n\r\n        require(tokenAmountIn <= bmul(_records[tokenIn].balance, MAX_IN_RATIO), \"ERR_MAX_IN_RATIO\");\r\n\r\n        inRecord.balance = badd(inRecord.balance, tokenAmountIn);\r\n\r\n        emit LOG_JOIN(msg.sender, tokenIn, tokenAmountIn);\r\n\r\n        _mintPoolShare(poolAmountOut);\r\n        _pushPoolShare(msg.sender, poolAmountOut);\r\n        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\r\n\r\n        return tokenAmountIn;\r\n    }\r\n\r\n    function exitswapPoolAmountIn(\r\n        address tokenOut,\r\n        uint256 poolAmountIn,\r\n        uint256 minAmountOut\r\n    ) external _logs_ _lock_ returns (uint256 tokenAmountOut) {\r\n        require(_finalized, \"ERR_NOT_FINALIZED\");\r\n        require(_records[tokenOut].bound, \"ERR_NOT_BOUND\");\r\n\r\n        Record storage outRecord = _records[tokenOut];\r\n\r\n        tokenAmountOut = calcSingleOutGivenPoolIn(\r\n            outRecord.balance,\r\n            outRecord.denorm,\r\n            _totalSupply,\r\n            _totalWeight,\r\n            poolAmountIn,\r\n            _swapFee\r\n        );\r\n\r\n        require(tokenAmountOut >= minAmountOut, \"ERR_LIMIT_OUT\");\r\n\r\n        require(tokenAmountOut <= bmul(_records[tokenOut].balance, MAX_OUT_RATIO), \"ERR_MAX_OUT_RATIO\");\r\n\r\n        outRecord.balance = bsub(outRecord.balance, tokenAmountOut);\r\n\r\n        uint256 exitFee = bmul(poolAmountIn, EXIT_FEE);\r\n\r\n        emit LOG_EXIT(msg.sender, tokenOut, tokenAmountOut);\r\n\r\n        _pullPoolShare(msg.sender, poolAmountIn);\r\n        _burnPoolShare(bsub(poolAmountIn, exitFee));\r\n        _pushPoolShare(_factory, exitFee);\r\n        _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\r\n\r\n        return tokenAmountOut;\r\n    }\r\n\r\n    function exitswapExternAmountOut(\r\n        address tokenOut,\r\n        uint256 tokenAmountOut,\r\n        uint256 maxPoolAmountIn\r\n    ) external _logs_ _lock_ returns (uint256 poolAmountIn) {\r\n        require(_finalized, \"ERR_NOT_FINALIZED\");\r\n        require(_records[tokenOut].bound, \"ERR_NOT_BOUND\");\r\n        require(tokenAmountOut <= bmul(_records[tokenOut].balance, MAX_OUT_RATIO), \"ERR_MAX_OUT_RATIO\");\r\n\r\n        Record storage outRecord = _records[tokenOut];\r\n\r\n        poolAmountIn = calcPoolInGivenSingleOut(\r\n            outRecord.balance,\r\n            outRecord.denorm,\r\n            _totalSupply,\r\n            _totalWeight,\r\n            tokenAmountOut,\r\n            _swapFee\r\n        );\r\n\r\n        require(poolAmountIn != 0, \"ERR_MATH_APPROX\");\r\n        require(poolAmountIn <= maxPoolAmountIn, \"ERR_LIMIT_IN\");\r\n\r\n        outRecord.balance = bsub(outRecord.balance, tokenAmountOut);\r\n\r\n        uint256 exitFee = bmul(poolAmountIn, EXIT_FEE);\r\n\r\n        emit LOG_EXIT(msg.sender, tokenOut, tokenAmountOut);\r\n\r\n        _pullPoolShare(msg.sender, poolAmountIn);\r\n        _burnPoolShare(bsub(poolAmountIn, exitFee));\r\n        _pushPoolShare(_factory, exitFee);\r\n        _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\r\n\r\n        return poolAmountIn;\r\n    }\r\n\r\n    // ==\r\n    // 'Underlying' token-manipulation functions make external calls but are NOT locked\r\n    // You must `_lock_` or otherwise ensure reentry-safety\r\n\r\n    function _pullUnderlying(\r\n        address erc20,\r\n        address from,\r\n        uint256 amount\r\n    ) internal {\r\n        bool xfer = IERC20Balancer(erc20).transferFrom(from, address(this), amount);\r\n        require(xfer, \"ERR_ERC20_FALSE\");\r\n    }\r\n\r\n    function _pushUnderlying(\r\n        address erc20,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        bool xfer = IERC20Balancer(erc20).transfer(to, amount);\r\n        require(xfer, \"ERR_ERC20_FALSE\");\r\n    }\r\n\r\n    function _pullPoolShare(address from, uint256 amount) internal {\r\n        _pull(from, amount);\r\n    }\r\n\r\n    function _pushPoolShare(address to, uint256 amount) internal {\r\n        _push(to, amount);\r\n    }\r\n\r\n    function _mintPoolShare(uint256 amount) internal {\r\n        _mint(amount);\r\n    }\r\n\r\n    function _burnPoolShare(uint256 amount) internal {\r\n        _burn(amount);\r\n    }\r\n}\r\n"
    },
    "contracts/balancer/BToken.sol": {
      "content": "// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity 0.7.6;\r\n\r\nimport \"./BNum.sol\";\r\n\r\ninterface IERC20Balancer {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address whom) external view returns (uint256);\r\n\r\n    function allowance(address src, address dst) external view returns (uint256);\r\n\r\n    function approve(address dst, uint256 amt) external returns (bool);\r\n\r\n    function transfer(address dst, uint256 amt) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address src,\r\n        address dst,\r\n        uint256 amt\r\n    ) external returns (bool);\r\n}\r\n\r\ncontract BTokenBase is BNum {\r\n    mapping(address => uint256) internal _balance;\r\n    mapping(address => mapping(address => uint256)) internal _allowance;\r\n    uint256 internal _totalSupply;\r\n\r\n    event Approval(address indexed src, address indexed dst, uint256 amt);\r\n    event Transfer(address indexed src, address indexed dst, uint256 amt);\r\n\r\n    function _mint(uint256 amt) internal {\r\n        _balance[address(this)] = badd(_balance[address(this)], amt);\r\n        _totalSupply = badd(_totalSupply, amt);\r\n        emit Transfer(address(0), address(this), amt);\r\n    }\r\n\r\n    function _burn(uint256 amt) internal {\r\n        require(_balance[address(this)] >= amt, \"ERR_INSUFFICIENT_BAL\");\r\n        _balance[address(this)] = bsub(_balance[address(this)], amt);\r\n        _totalSupply = bsub(_totalSupply, amt);\r\n        emit Transfer(address(this), address(0), amt);\r\n    }\r\n\r\n    function _move(\r\n        address src,\r\n        address dst,\r\n        uint256 amt\r\n    ) internal {\r\n        require(_balance[src] >= amt, \"ERR_INSUFFICIENT_BAL\");\r\n        _balance[src] = bsub(_balance[src], amt);\r\n        _balance[dst] = badd(_balance[dst], amt);\r\n        emit Transfer(src, dst, amt);\r\n    }\r\n\r\n    function _push(address to, uint256 amt) internal {\r\n        _move(address(this), to, amt);\r\n    }\r\n\r\n    function _pull(address from, uint256 amt) internal {\r\n        _move(from, address(this), amt);\r\n    }\r\n}\r\n\r\ncontract BToken is BTokenBase, IERC20Balancer {\r\n    string private _name = \"Balancer Pool Token\";\r\n    string private _symbol = \"BPT\";\r\n    uint8 private _decimals = 18;\r\n\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    function allowance(address src, address dst) external view override returns (uint256) {\r\n        return _allowance[src][dst];\r\n    }\r\n\r\n    function balanceOf(address whom) external view override returns (uint256) {\r\n        return _balance[whom];\r\n    }\r\n\r\n    function totalSupply() public view override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function approve(address dst, uint256 amt) external override returns (bool) {\r\n        _allowance[msg.sender][dst] = amt;\r\n        emit Approval(msg.sender, dst, amt);\r\n        return true;\r\n    }\r\n\r\n    function increaseApproval(address dst, uint256 amt) external returns (bool) {\r\n        _allowance[msg.sender][dst] = badd(_allowance[msg.sender][dst], amt);\r\n        emit Approval(msg.sender, dst, _allowance[msg.sender][dst]);\r\n        return true;\r\n    }\r\n\r\n    function decreaseApproval(address dst, uint256 amt) external returns (bool) {\r\n        uint256 oldValue = _allowance[msg.sender][dst];\r\n        if (amt > oldValue) {\r\n            _allowance[msg.sender][dst] = 0;\r\n        } else {\r\n            _allowance[msg.sender][dst] = bsub(oldValue, amt);\r\n        }\r\n        emit Approval(msg.sender, dst, _allowance[msg.sender][dst]);\r\n        return true;\r\n    }\r\n\r\n    function transfer(address dst, uint256 amt) external override returns (bool) {\r\n        _move(msg.sender, dst, amt);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(\r\n        address src,\r\n        address dst,\r\n        uint256 amt\r\n    ) external override returns (bool) {\r\n        require(msg.sender == src || amt <= _allowance[src][msg.sender], \"ERR_BTOKEN_BAD_CALLER\");\r\n        _move(src, dst, amt);\r\n        if (msg.sender != src && _allowance[src][msg.sender] != uint256(-1)) {\r\n            _allowance[src][msg.sender] = bsub(_allowance[src][msg.sender], amt);\r\n            emit Approval(msg.sender, dst, _allowance[src][msg.sender]);\r\n        }\r\n        return true;\r\n    }\r\n}\r\n"
    },
    "contracts/balancer/BMath.sol": {
      "content": "// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity 0.7.6;\r\n\r\nimport \"./BNum.sol\";\r\n\r\ncontract BMath is BBronze, BConst, BNum {\r\n    /**********************************************************************************************\r\n    // calcSpotPrice                                                                             //\r\n    // sP = spotPrice                                                                            //\r\n    // bI = tokenBalanceIn                ( bI / wI )         1                                  //\r\n    // bO = tokenBalanceOut         sP =  -----------  *  ----------                             //\r\n    // wI = tokenWeightIn                 ( bO / wO )     ( 1 - sF )                             //\r\n    // wO = tokenWeightOut                                                                       //\r\n    // sF = swapFee                                                                              //\r\n    **********************************************************************************************/\r\n    function calcSpotPrice(\r\n        uint256 tokenBalanceIn,\r\n        uint256 tokenWeightIn,\r\n        uint256 tokenBalanceOut,\r\n        uint256 tokenWeightOut,\r\n        uint256 swapFee\r\n    ) public pure returns (uint256 spotPrice) {\r\n        uint256 numer = bdiv(tokenBalanceIn, tokenWeightIn);\r\n        uint256 denom = bdiv(tokenBalanceOut, tokenWeightOut);\r\n        uint256 ratio = bdiv(numer, denom);\r\n        uint256 scale = bdiv(BONE, bsub(BONE, swapFee));\r\n        return (spotPrice = bmul(ratio, scale));\r\n    }\r\n\r\n    /**********************************************************************************************\r\n    // calcOutGivenIn                                                                            //\r\n    // aO = tokenAmountOut                                                                       //\r\n    // bO = tokenBalanceOut                                                                      //\r\n    // bI = tokenBalanceIn              /      /            bI             \\    (wI / wO) \\      //\r\n    // aI = tokenAmountIn    aO = bO * |  1 - | --------------------------  | ^            |     //\r\n    // wI = tokenWeightIn               \\      \\ ( bI + ( aI * ( 1 - sF )) /              /      //\r\n    // wO = tokenWeightOut                                                                       //\r\n    // sF = swapFee                                                                              //\r\n    **********************************************************************************************/\r\n    function calcOutGivenIn(\r\n        uint256 tokenBalanceIn,\r\n        uint256 tokenWeightIn,\r\n        uint256 tokenBalanceOut,\r\n        uint256 tokenWeightOut,\r\n        uint256 tokenAmountIn,\r\n        uint256 swapFee\r\n    ) public pure returns (uint256 tokenAmountOut) {\r\n        uint256 weightRatio = bdiv(tokenWeightIn, tokenWeightOut);\r\n        uint256 adjustedIn = bsub(BONE, swapFee);\r\n        adjustedIn = bmul(tokenAmountIn, adjustedIn);\r\n        uint256 y = bdiv(tokenBalanceIn, badd(tokenBalanceIn, adjustedIn));\r\n        uint256 foo = bpow(y, weightRatio);\r\n        uint256 bar = bsub(BONE, foo);\r\n        tokenAmountOut = bmul(tokenBalanceOut, bar);\r\n        return tokenAmountOut;\r\n    }\r\n\r\n    /**********************************************************************************************\r\n    // calcInGivenOut                                                                            //\r\n    // aI = tokenAmountIn                                                                        //\r\n    // bO = tokenBalanceOut               /  /     bO      \\    (wO / wI)      \\                 //\r\n    // bI = tokenBalanceIn          bI * |  | ------------  | ^            - 1  |                //\r\n    // aO = tokenAmountOut    aI =        \\  \\ ( bO - aO ) /                   /                 //\r\n    // wI = tokenWeightIn           --------------------------------------------                 //\r\n    // wO = tokenWeightOut                          ( 1 - sF )                                   //\r\n    // sF = swapFee                                                                              //\r\n    **********************************************************************************************/\r\n    function calcInGivenOut(\r\n        uint256 tokenBalanceIn,\r\n        uint256 tokenWeightIn,\r\n        uint256 tokenBalanceOut,\r\n        uint256 tokenWeightOut,\r\n        uint256 tokenAmountOut,\r\n        uint256 swapFee\r\n    ) public pure returns (uint256 tokenAmountIn) {\r\n        uint256 weightRatio = bdiv(tokenWeightOut, tokenWeightIn);\r\n        uint256 diff = bsub(tokenBalanceOut, tokenAmountOut);\r\n        uint256 y = bdiv(tokenBalanceOut, diff);\r\n        uint256 foo = bpow(y, weightRatio);\r\n        foo = bsub(foo, BONE);\r\n        tokenAmountIn = bsub(BONE, swapFee);\r\n        tokenAmountIn = bdiv(bmul(tokenBalanceIn, foo), tokenAmountIn);\r\n        return tokenAmountIn;\r\n    }\r\n\r\n    /**********************************************************************************************\r\n    // calcPoolOutGivenSingleIn                                                                  //\r\n    // pAo = poolAmountOut         /                                              \\              //\r\n    // tAi = tokenAmountIn        ///      /     //    wI \\      \\\\       \\     wI \\             //\r\n    // wI = tokenWeightIn        //| tAi *| 1 - || 1 - --  | * sF || + tBi \\    --  \\            //\r\n    // tW = totalWeight     pAo=||  \\      \\     \\\\    tW /      //         | ^ tW   | * pS - pS //\r\n    // tBi = tokenBalanceIn      \\\\  ------------------------------------- /        /            //\r\n    // pS = poolSupply            \\\\                    tBi               /        /             //\r\n    // sF = swapFee                \\                                              /              //\r\n    **********************************************************************************************/\r\n\r\n    // Charge the trading fee for the proportion of tokenAi\r\n    ///  which is implicitly traded to the other pool tokens.\r\n    // That proportion is (1- weightTokenIn)\r\n    // tokenAiAfterFee = tAi * (1 - (1-weightTi) * poolFee);\r\n\r\n    function calcPoolOutGivenSingleIn(\r\n        uint256 tokenBalanceIn,\r\n        uint256 tokenWeightIn,\r\n        uint256 poolSupply,\r\n        uint256 totalWeight,\r\n        uint256 tokenAmountIn,\r\n        uint256 swapFee\r\n    ) public pure returns (uint256 poolAmountOut) {\r\n        uint256 normalizedWeight = bdiv(tokenWeightIn, totalWeight);\r\n        uint256 zaz = bmul(bsub(BONE, normalizedWeight), swapFee);\r\n        uint256 tokenAmountInAfterFee = bmul(tokenAmountIn, bsub(BONE, zaz));\r\n\r\n        uint256 newTokenBalanceIn = badd(tokenBalanceIn, tokenAmountInAfterFee);\r\n        uint256 tokenInRatio = bdiv(newTokenBalanceIn, tokenBalanceIn);\r\n\r\n        // uint newPoolSupply = (ratioTi ^ weightTi) * poolSupply;\r\n        uint256 poolRatio = bpow(tokenInRatio, normalizedWeight);\r\n        uint256 newPoolSupply = bmul(poolRatio, poolSupply);\r\n        poolAmountOut = bsub(newPoolSupply, poolSupply);\r\n        return poolAmountOut;\r\n    }\r\n\r\n    /**********************************************************************************************\r\n    // calcSingleInGivenPoolOut                                                                  //\r\n    // tAi = tokenAmountIn              //(pS + pAo)\\     /    1    \\\\                           //\r\n    // pS = poolSupply                 || ---------  | ^ | --------- || * bI - bI                //\r\n    // pAo = poolAmountOut              \\\\    pS    /     \\(wI / tW)//                           //\r\n    // bI = balanceIn          tAi =  --------------------------------------------               //\r\n    // wI = weightIn                              /      wI  \\                                   //\r\n    // tW = totalWeight                          |  1 - ----  |  * sF                            //\r\n    // sF = swapFee                               \\      tW  /                                   //\r\n    **********************************************************************************************/\r\n    function calcSingleInGivenPoolOut(\r\n        uint256 tokenBalanceIn,\r\n        uint256 tokenWeightIn,\r\n        uint256 poolSupply,\r\n        uint256 totalWeight,\r\n        uint256 poolAmountOut,\r\n        uint256 swapFee\r\n    ) public pure returns (uint256 tokenAmountIn) {\r\n        uint256 normalizedWeight = bdiv(tokenWeightIn, totalWeight);\r\n        uint256 newPoolSupply = badd(poolSupply, poolAmountOut);\r\n        uint256 poolRatio = bdiv(newPoolSupply, poolSupply);\r\n\r\n        //uint newBalTi = poolRatio^(1/weightTi) * balTi;\r\n        uint256 boo = bdiv(BONE, normalizedWeight);\r\n        uint256 tokenInRatio = bpow(poolRatio, boo);\r\n        uint256 newTokenBalanceIn = bmul(tokenInRatio, tokenBalanceIn);\r\n        uint256 tokenAmountInAfterFee = bsub(newTokenBalanceIn, tokenBalanceIn);\r\n        // Do reverse order of fees charged in joinswap_ExternAmountIn, this way\r\n        //     ``` pAo == joinswap_ExternAmountIn(Ti, joinswap_PoolAmountOut(pAo, Ti)) ```\r\n        //uint tAi = tAiAfterFee / (1 - (1-weightTi) * swapFee) ;\r\n        uint256 zar = bmul(bsub(BONE, normalizedWeight), swapFee);\r\n        tokenAmountIn = bdiv(tokenAmountInAfterFee, bsub(BONE, zar));\r\n        return tokenAmountIn;\r\n    }\r\n\r\n    /**********************************************************************************************\r\n    // calcSingleOutGivenPoolIn                                                                  //\r\n    // tAo = tokenAmountOut            /      /                                             \\\\   //\r\n    // bO = tokenBalanceOut           /      // pS - (pAi * (1 - eF)) \\     /    1    \\      \\\\  //\r\n    // pAi = poolAmountIn            | bO - || ----------------------- | ^ | --------- | * b0 || //\r\n    // ps = poolSupply                \\      \\\\          pS           /     \\(wO / tW)/      //  //\r\n    // wI = tokenWeightIn      tAo =   \\      \\                                             //   //\r\n    // tW = totalWeight                    /     /      wO \\       \\                             //\r\n    // sF = swapFee                    *  | 1 - |  1 - ---- | * sF  |                            //\r\n    // eF = exitFee                        \\     \\      tW /       /                             //\r\n    **********************************************************************************************/\r\n    function calcSingleOutGivenPoolIn(\r\n        uint256 tokenBalanceOut,\r\n        uint256 tokenWeightOut,\r\n        uint256 poolSupply,\r\n        uint256 totalWeight,\r\n        uint256 poolAmountIn,\r\n        uint256 swapFee\r\n    ) public pure returns (uint256 tokenAmountOut) {\r\n        uint256 normalizedWeight = bdiv(tokenWeightOut, totalWeight);\r\n        // charge exit fee on the pool token side\r\n        // pAiAfterExitFee = pAi*(1-exitFee)\r\n        uint256 poolAmountInAfterExitFee = bmul(poolAmountIn, bsub(BONE, EXIT_FEE));\r\n        uint256 newPoolSupply = bsub(poolSupply, poolAmountInAfterExitFee);\r\n        uint256 poolRatio = bdiv(newPoolSupply, poolSupply);\r\n\r\n        // newBalTo = poolRatio^(1/weightTo) * balTo;\r\n        uint256 tokenOutRatio = bpow(poolRatio, bdiv(BONE, normalizedWeight));\r\n        uint256 newTokenBalanceOut = bmul(tokenOutRatio, tokenBalanceOut);\r\n\r\n        uint256 tokenAmountOutBeforeSwapFee = bsub(tokenBalanceOut, newTokenBalanceOut);\r\n\r\n        // charge swap fee on the output token side\r\n        //uint tAo = tAoBeforeSwapFee * (1 - (1-weightTo) * swapFee)\r\n        uint256 zaz = bmul(bsub(BONE, normalizedWeight), swapFee);\r\n        tokenAmountOut = bmul(tokenAmountOutBeforeSwapFee, bsub(BONE, zaz));\r\n        return tokenAmountOut;\r\n    }\r\n\r\n    /**********************************************************************************************\r\n    // calcPoolInGivenSingleOut                                                                  //\r\n    // pAi = poolAmountIn               // /               tAo             \\\\     / wO \\     \\   //\r\n    // bO = tokenBalanceOut            // | bO - -------------------------- |\\   | ---- |     \\  //\r\n    // tAo = tokenAmountOut      pS - ||   \\     1 - ((1 - (tO / tW)) * sF)/  | ^ \\ tW /  * pS | //\r\n    // ps = poolSupply                 \\\\ -----------------------------------/                /  //\r\n    // wO = tokenWeightOut  pAi =       \\\\               bO                 /                /   //\r\n    // tW = totalWeight           -------------------------------------------------------------  //\r\n    // sF = swapFee                                        ( 1 - eF )                            //\r\n    // eF = exitFee                                                                              //\r\n    **********************************************************************************************/\r\n    function calcPoolInGivenSingleOut(\r\n        uint256 tokenBalanceOut,\r\n        uint256 tokenWeightOut,\r\n        uint256 poolSupply,\r\n        uint256 totalWeight,\r\n        uint256 tokenAmountOut,\r\n        uint256 swapFee\r\n    ) public pure returns (uint256 poolAmountIn) {\r\n        // charge swap fee on the output token side\r\n        uint256 normalizedWeight = bdiv(tokenWeightOut, totalWeight);\r\n        //uint tAoBeforeSwapFee = tAo / (1 - (1-weightTo) * swapFee) ;\r\n        uint256 zoo = bsub(BONE, normalizedWeight);\r\n        uint256 zar = bmul(zoo, swapFee);\r\n        uint256 tokenAmountOutBeforeSwapFee = bdiv(tokenAmountOut, bsub(BONE, zar));\r\n\r\n        uint256 newTokenBalanceOut = bsub(tokenBalanceOut, tokenAmountOutBeforeSwapFee);\r\n        uint256 tokenOutRatio = bdiv(newTokenBalanceOut, tokenBalanceOut);\r\n\r\n        //uint newPoolSupply = (ratioTo ^ weightTo) * poolSupply;\r\n        uint256 poolRatio = bpow(tokenOutRatio, normalizedWeight);\r\n        uint256 newPoolSupply = bmul(poolRatio, poolSupply);\r\n        uint256 poolAmountInAfterExitFee = bsub(poolSupply, newPoolSupply);\r\n\r\n        // charge exit fee on the pool token side\r\n        // pAi = pAiAfterExitFee/(1-exitFee)\r\n        poolAmountIn = bdiv(poolAmountInAfterExitFee, bsub(BONE, EXIT_FEE));\r\n        return poolAmountIn;\r\n    }\r\n}\r\n"
    },
    "contracts/libraries/IERC20Full.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.7.6;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\ninterface IERC20Full is IERC20 {\r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function decimals() external view returns (uint8);\r\n}\r\n"
    },
    "contracts/turbo/TurboShareTokenFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.7.6;\r\npragma abicoder v2;\r\n\r\nimport \"./OwnedShareToken.sol\";\r\n\r\nabstract contract TurboShareTokenFactory {\r\n    function createShareTokens(string[] memory _names, address _owner) internal returns (OwnedERC20[] memory) {\r\n        uint256 _numOutcomes = _names.length;\r\n        OwnedERC20[] memory _tokens = new OwnedERC20[](_numOutcomes);\r\n\r\n        for (uint256 _i = 0; _i < _numOutcomes; _i++) {\r\n            _tokens[_i] = new OwnedERC20(_names[_i], _names[_i], _owner);\r\n        }\r\n        return _tokens;\r\n    }\r\n}\r\n\r\nabstract contract TurboShareTokenFactoryV1 {\r\n    function createShareTokens(\r\n        string[] memory _names,\r\n        string[] memory _symbols,\r\n        address _owner\r\n    ) internal returns (OwnedERC20[] memory) {\r\n        uint256 _numOutcomes = _names.length;\r\n        OwnedERC20[] memory _tokens = new OwnedERC20[](_numOutcomes);\r\n\r\n        for (uint256 _i = 0; _i < _numOutcomes; _i++) {\r\n            _tokens[_i] = new OwnedERC20(_names[_i], _symbols[_i], _owner);\r\n        }\r\n        return _tokens;\r\n    }\r\n}\r\n"
    },
    "contracts/turbo/FeePot.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.7.6;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\nimport \"../libraries/SafeMathUint256.sol\";\r\nimport \"../libraries/IERC20Full.sol\";\r\n\r\ncontract FeePot is ERC20 {\r\n    using SafeMathUint256 for uint256;\r\n\r\n    uint256 internal constant magnitude = 2**128;\r\n\r\n    IERC20Full public collateral;\r\n    IERC20Full public reputationToken;\r\n\r\n    uint256 public magnifiedFeesPerShare;\r\n\r\n    mapping(address => uint256) public magnifiedFeesCorrections;\r\n    mapping(address => uint256) public storedFees;\r\n\r\n    uint256 public feeReserve;\r\n\r\n    constructor(IERC20Full _collateral, IERC20Full _reputationToken)\r\n        ERC20(\r\n            string(abi.encodePacked(\"S_\", _reputationToken.symbol())),\r\n            string(abi.encodePacked(\"S_\", _reputationToken.symbol()))\r\n        )\r\n    {\r\n        collateral = _collateral;\r\n        reputationToken = _reputationToken;\r\n\r\n        require(_collateral != IERC20Full(0));\r\n    }\r\n\r\n    function depositFees(uint256 _amount) public returns (bool) {\r\n        collateral.transferFrom(msg.sender, address(this), _amount);\r\n        uint256 _totalSupply = totalSupply(); // after collateral.transferFrom to prevent reentrancy causing stale totalSupply\r\n        if (_totalSupply == 0) {\r\n            feeReserve = feeReserve.add(_amount);\r\n            return true;\r\n        }\r\n        if (feeReserve > 0) {\r\n            _amount = _amount.add(feeReserve);\r\n            feeReserve = 0;\r\n        }\r\n        magnifiedFeesPerShare = magnifiedFeesPerShare.add((_amount).mul(magnitude) / _totalSupply);\r\n        return true;\r\n    }\r\n\r\n    function withdrawableFeesOf(address _owner) public view returns (uint256) {\r\n        return earnedFeesOf(_owner).add(storedFees[_owner]);\r\n    }\r\n\r\n    function earnedFeesOf(address _owner) public view returns (uint256) {\r\n        uint256 _ownerBalance = balanceOf(_owner);\r\n        uint256 _magnifiedFees = magnifiedFeesPerShare.mul(_ownerBalance);\r\n        return _magnifiedFees.sub(magnifiedFeesCorrections[_owner]) / magnitude;\r\n    }\r\n\r\n    function _transfer(\r\n        address _from,\r\n        address _to,\r\n        uint256 _amount\r\n    ) internal override {\r\n        storedFees[_from] = storedFees[_from].add(earnedFeesOf(_from));\r\n        super._transfer(_from, _to, _amount);\r\n\r\n        magnifiedFeesCorrections[_from] = magnifiedFeesPerShare.mul(balanceOf(_from));\r\n        magnifiedFeesCorrections[_to] = magnifiedFeesCorrections[_to].add(magnifiedFeesPerShare.mul(_amount));\r\n    }\r\n\r\n    function stake(uint256 _amount) external returns (bool) {\r\n        reputationToken.transferFrom(msg.sender, address(this), _amount);\r\n        _mint(msg.sender, _amount);\r\n        magnifiedFeesCorrections[msg.sender] = magnifiedFeesCorrections[msg.sender].add(\r\n            magnifiedFeesPerShare.mul(_amount)\r\n        );\r\n        return true;\r\n    }\r\n\r\n    function exit(uint256 _amount) external returns (bool) {\r\n        redeemInternal(msg.sender);\r\n        _burn(msg.sender, _amount);\r\n        reputationToken.transfer(msg.sender, _amount);\r\n        magnifiedFeesCorrections[msg.sender] = magnifiedFeesPerShare.mul(balanceOf(msg.sender));\r\n        return true;\r\n    }\r\n\r\n    function redeem() public returns (bool) {\r\n        redeemInternal(msg.sender);\r\n        magnifiedFeesCorrections[msg.sender] = magnifiedFeesPerShare.mul(balanceOf(msg.sender));\r\n        return true;\r\n    }\r\n\r\n    function redeemInternal(address _account) internal {\r\n        uint256 _withdrawableFees = withdrawableFeesOf(_account);\r\n        if (_withdrawableFees > 0) {\r\n            storedFees[_account] = 0;\r\n            collateral.transfer(_account, _withdrawableFees);\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/libraries/Rewardable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.7.6;\r\n\r\nabstract contract Rewardable {\r\n    // Rewards will be paid out over the lifetime of an event.\r\n    // An value of zero will start rewards immediately and proceed based on the values set in master chef.\r\n\r\n    // _Id here is the market id passed to the amm factory when creating a pool.\r\n    function getRewardEndTime(uint256 _marketId) public view virtual returns (uint256);\r\n}\r\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/turbo/OwnedShareToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.7.6;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\nimport \"../libraries/Ownable.sol\";\r\n\r\ncontract OwnedERC20 is ERC20, Ownable {\r\n    constructor(\r\n        string memory name_,\r\n        string memory symbol_,\r\n        address _owner\r\n    ) ERC20(name_, symbol_) {\r\n        owner = _owner;\r\n    }\r\n\r\n    function trustedTransfer(\r\n        address _from,\r\n        address _to,\r\n        uint256 _amount\r\n    ) external onlyOwner {\r\n        _transfer(_from, _to, _amount);\r\n    }\r\n\r\n    function trustedMint(address _target, uint256 _amount) external onlyOwner {\r\n        _mint(_target, _amount);\r\n    }\r\n\r\n    function trustedBurn(address _target, uint256 _amount) external onlyOwner {\r\n        _burn(_target, _amount);\r\n    }\r\n\r\n    function trustedBurnAll(address _target) external onlyOwner returns (uint256) {\r\n        uint256 _balance = balanceOf(_target);\r\n        _burn(_target, _balance);\r\n        return _balance;\r\n    }\r\n\r\n    function onTransferOwnership(address, address) internal override {}\r\n}\r\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../../utils/Context.sol\";\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name_, string memory symbol_) public {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal virtual {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n"
    },
    "contracts/libraries/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.7.6;\r\n\r\nimport \"./IOwnable.sol\";\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\nabstract contract Ownable is IOwnable {\r\n    address internal owner;\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function getOwner() public view override returns (address) {\r\n        return owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param _newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address _newOwner) public override onlyOwner returns (bool) {\r\n        require(_newOwner != address(0));\r\n        onTransferOwnership(owner, _newOwner);\r\n        owner = _newOwner;\r\n        return true;\r\n    }\r\n\r\n    // Subclasses of this token may want to send additional logs through the centralized Augur log emitter contract\r\n    function onTransferOwnership(address, address) internal virtual;\r\n}\r\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "contracts/libraries/IOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.7.6;\r\n\r\ninterface IOwnable {\r\n    function getOwner() external view returns (address);\r\n\r\n    function transferOwnership(address _newOwner) external returns (bool);\r\n}\r\n"
    },
    "contracts/turbo/random.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.7.6;\r\npragma abicoder v2;\r\n\r\n\r\nimport \"../libraries/IERC20Full.sol\";\r\nimport \"../balancer/BPool.sol\";\r\nimport \"./AbstractMarketFactoryV3.sol\";\r\nimport \"./FeePot.sol\";\r\nimport \"../libraries/SafeMathInt256.sol\";\r\nimport \"./MMAMarketFactoryV3.sol\";\r\nimport \"./AMMFactory.sol\";\r\nimport \"./CryptoMarketFactoryV3.sol\";\r\nimport \"./NBAMarketFactoryV3.sol\";\r\nimport \"../rewards/MasterChef.sol\";\r\nimport \"./CryptoCurrencyMarketFactoryV3.sol\";\r\nimport \"./TrustedMarketFactoryV3.sol\";\r\nimport \"./Fetcher.sol\";\r\n\r\ncontract TrustedFetcher is Fetcher {\r\n    constructor() Fetcher(\"Trusted\", \"TBD\") {}\r\n\r\n    struct SpecificMarketFactoryBundle {\r\n        MarketFactoryBundle super;\r\n    }\r\n\r\n    struct SpecificStaticMarketBundle {\r\n        StaticMarketBundle super;\r\n        // uint256 coinIndex;\r\n        // uint256 creationValue;\r\n        // uint256 resolutionTime;\r\n        // // Dynamics\r\n        // uint256 resolutionValue;\r\n        string description;\r\n    }\r\n\r\n    struct SpecificDynamicMarketBundle {\r\n        DynamicMarketBundle super;\r\n        //uint256 resolutionValue;\r\n        string description;\r\n\r\n    }\r\n\r\n    function sayHi() public view returns(uint256){\r\n        return 0; \r\n    }\r\n\r\n    function getMarket( address _marketFactory,\r\n    AMMFactory _ammFactory,\r\n    MasterChef _masterChef,\r\n    uint256 _marketId) public view returns(   SpecificStaticMarketBundle memory _bundle\r\n){\r\n    TrustedMarketFactoryV3.MarketDetails memory _details =\r\n        TrustedMarketFactoryV3(_marketFactory).getMarketDetails(_marketId);\r\n    _bundle.super = buildStaticMarketBundle(\r\n        TrustedMarketFactoryV3(_marketFactory),\r\n        _ammFactory,\r\n        _masterChef,\r\n        _marketId\r\n    );\r\n    _bundle.description = _details.description;\r\n    }\r\n\r\n\r\n  function fetchInitial(\r\n        address _marketFactory,\r\n        AMMFactory _ammFactory,\r\n        MasterChef _masterChef,\r\n        uint256 _offset,\r\n        uint256 _total\r\n    )\r\n        public\r\n        view\r\n        returns (\r\n            SpecificMarketFactoryBundle memory _marketFactoryBundle,\r\n            SpecificStaticMarketBundle[] memory _marketBundles,\r\n            uint256 _lowestMarketIndex,\r\n            uint256 _timestamp\r\n        )\r\n    {\r\n        _marketFactoryBundle = buildSpecificMarketFactoryBundle(_marketFactory);\r\n\r\n        uint256[] memory _marketIds;\r\n\r\n       (_marketIds, _lowestMarketIndex) = listOfInterestingMarkets(_marketFactory, _offset, _total);\r\n        // (_marketIds, _lowestMarketIndex) = interestingMarkets(_marketFactory, _offset, _total);\r\n\r\n        _total = _marketIds.length;\r\n        _marketBundles = new SpecificStaticMarketBundle[](_total);\r\n        for (uint256 i; i < _total; i++) {\r\n            _marketBundles[i] = buildSpecificStaticMarketBundle(\r\n                _marketFactory,\r\n                _ammFactory,\r\n                _masterChef,\r\n                 _marketIds[i]\r\n                \r\n            );\r\n        }\r\n\r\n        _timestamp = block.timestamp;\r\n    }\r\n\r\n\r\n    function buildSpecificMarketFactoryBundle(address _marketFactory)\r\n        internal\r\n        view\r\n        returns (SpecificMarketFactoryBundle memory _bundle)\r\n    {\r\n        _bundle.super = buildMarketFactoryBundle(TrustedMarketFactoryV3(_marketFactory));\r\n    }\r\n\r\n\r\n function buildSpecificStaticMarketBundle(\r\n        address _marketFactory,\r\n        AMMFactory _ammFactory,\r\n        MasterChef _masterChef,\r\n        uint256 _marketId\r\n    ) internal view returns (SpecificStaticMarketBundle memory _bundle) {\r\n        TrustedMarketFactoryV3.MarketDetails memory _details =\r\n            TrustedMarketFactoryV3(_marketFactory).getMarketDetails(_marketId);\r\n        _bundle.super = buildStaticMarketBundle(\r\n            TrustedMarketFactoryV3(_marketFactory),\r\n            _ammFactory,\r\n            _masterChef,\r\n            _marketId+1\r\n        );\r\n        _bundle.description = _details.description;\r\n        // _bundle.creationValue = _details.creationValue;\r\n        // _bundle.coinIndex = _details.coinIndex;\r\n        // _bundle.resolutionValue = _details.resolutionValue;\r\n        // _bundle.resolutionTime = _details.resolutionTime;\r\n    }\r\n\r\nfunction listOfInterestingMarkets(\r\n        address _marketFactory,\r\n        uint256 _offset,\r\n        uint256 _total\r\n    ) internal view returns (uint256[] memory _interestingMarketIds, uint256 _marketId) {\r\n        _interestingMarketIds = new uint256[](_total);\r\n        uint256 _max = AbstractMarketFactoryV3(_marketFactory).marketCount() - 1;\r\n\r\n        // No markets so return nothing. (needed to prevent integer underflow below)\r\n        if (_max == 0 || _offset >= _max) {\r\n            return (new uint256[](0), 0);\r\n        }\r\n\r\n        // Starts at the end, less offset.\r\n        // Stops before the 0th market since that market is always fake.\r\n        uint256 _collectedMarkets = 0;\r\n        _marketId = _max - _offset-1;\r\n\r\n        while (true) {\r\n            if (openOrHasWinningShares(AbstractMarketFactoryV3(_marketFactory), _marketId)) {\r\n                _interestingMarketIds[_collectedMarkets] = _marketId;\r\n                _collectedMarkets++;\r\n            }\r\n\r\n            if (_collectedMarkets >= _total) break;\r\n            if (_marketId == 0) break; // skipping 0th market, which is fake\r\n            _marketId--; // starts out oone too high, so this works\r\n        }\r\n\r\n        if (_total > _collectedMarkets) {\r\n            assembly {\r\n                // shortens array\r\n                mstore(_interestingMarketIds, _collectedMarkets)\r\n            }\r\n        }\r\n    }\r\n\r\n    function fetchDynamic(\r\n        address _marketFactory,\r\n        AMMFactory _ammFactory,\r\n        uint256 _offset,\r\n        uint256 _total\r\n    )\r\n        public\r\n        view\r\n        returns (\r\n            SpecificDynamicMarketBundle[] memory _bundles,\r\n            uint256 _lowestMarketIndex,\r\n            uint256 _timestamp\r\n        )\r\n    {\r\n        uint256[] memory _marketIds;\r\n        (_marketIds, _lowestMarketIndex) = listOfInterestingMarkets(_marketFactory, _offset, _total);\r\n\r\n        _total = _marketIds.length;\r\n        _bundles = new SpecificDynamicMarketBundle[](_total);\r\n        for (uint256 i; i < _total; i++) {\r\n            _bundles[i] = buildSpecificDynamicMarketBundle(_marketFactory, _ammFactory, _marketIds[i]);\r\n        }\r\n\r\n        _timestamp = block.timestamp;\r\n    }\r\n \r\n\r\n\r\n    function buildSpecificDynamicMarketBundle(\r\n        address _marketFactory,\r\n        AMMFactory _ammFactory,\r\n        uint256 _marketId\r\n    ) internal view returns (SpecificDynamicMarketBundle memory _bundle) {\r\n        TrustedMarketFactoryV3.MarketDetails memory _details =\r\n            TrustedMarketFactoryV3(_marketFactory).getMarketDetails(_marketId);\r\n        _bundle.super = buildDynamicMarketBundle(TrustedMarketFactoryV3(_marketFactory), _ammFactory, _marketId+1);\r\n        _bundle.description = _details.description;\r\n    }\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n// contract TrustedFetcher is Fetcher {\r\n//     constructor() Fetcher(\"Trusted\", \"TBD\") {}\r\n\r\n//     struct SpecificMarketFactoryBundle {\r\n//         MarketFactoryBundle super;\r\n//     }\r\n\r\n//     struct SpecificStaticMarketBundle {\r\n//         StaticMarketBundle super;\r\n//         // uint256 coinIndex;\r\n//         // uint256 creationValue;\r\n//         // uint256 resolutionTime;\r\n//         // // Dynamics\r\n//         // uint256 resolutionValue;\r\n//         string description;\r\n//     }\r\n\r\n//     struct SpecificDynamicMarketBundle {\r\n//         DynamicMarketBundle super;\r\n//         //uint256 resolutionValue;\r\n//         string description;\r\n\r\n//     }\r\n\r\n//     function getMarket(    address _marketFactory,\r\n//         AMMFactory _ammFactory,\r\n//         MasterChef _masterChef,\r\n//         uint256 _marketId) public view returns(   SpecificStaticMarketBundle memory _bundle\r\n// ){\r\n//         TrustedMarketFactoryV3.MarketDetails memory _details =\r\n//             TrustedMarketFactoryV3(_marketFactory).getMarketDetails(_marketId);\r\n//         _bundle.super = buildStaticMarketBundle(\r\n//             TrustedMarketFactoryV3(_marketFactory),\r\n//             _ammFactory,\r\n//             _masterChef,\r\n//             _marketId\r\n//         );\r\n//         _bundle.description = _details.description;\r\n//     }\r\n\r\n//     function buildSpecificMarketFactoryBundle(address _marketFactory)\r\n//         internal\r\n//         view\r\n//         returns (SpecificMarketFactoryBundle memory _bundle)\r\n//     {\r\n//         _bundle.super = buildMarketFactoryBundle(TrustedMarketFactoryV3(_marketFactory));\r\n//     }\r\n\r\n//     function buildSpecificStaticMarketBundle(\r\n//         address _marketFactory,\r\n//         AMMFactory _ammFactory,\r\n//         MasterChef _masterChef,\r\n//         uint256 _marketId\r\n//     ) internal view returns (SpecificStaticMarketBundle memory _bundle) {\r\n//         TrustedMarketFactoryV3.MarketDetails memory _details =\r\n//             TrustedMarketFactoryV3(_marketFactory).getMarketDetails(_marketId);\r\n//         _bundle.super = buildStaticMarketBundle(\r\n//             TrustedMarketFactoryV3(_marketFactory),\r\n//             _ammFactory,\r\n//             _masterChef,\r\n//             _marketId\r\n//         );\r\n//         _bundle.description = _details.description;\r\n//         // _bundle.creationValue = _details.creationValue;\r\n//         // _bundle.coinIndex = _details.coinIndex;\r\n//         // _bundle.resolutionValue = _details.resolutionValue;\r\n//         // _bundle.resolutionTime = _details.resolutionTime;\r\n//     }\r\n\r\n//     function buildSpecificDynamicMarketBundle(\r\n//         address _marketFactory,\r\n//         AMMFactory _ammFactory,\r\n//         uint256 _marketId\r\n//     ) internal view returns (SpecificDynamicMarketBundle memory _bundle) {\r\n//         TrustedMarketFactoryV3.MarketDetails memory _details =\r\n//             TrustedMarketFactoryV3(_marketFactory).getMarketDetails(_marketId);\r\n//         _bundle.super = buildDynamicMarketBundle(TrustedMarketFactoryV3(_marketFactory), _ammFactory, _marketId);\r\n//         _bundle.description = _details.description;\r\n//     }\r\n\r\n//     function fetchInitial(\r\n//         address _marketFactory,\r\n//         AMMFactory _ammFactory,\r\n//         MasterChef _masterChef,\r\n//         uint256 _offset,\r\n//         uint256 _total\r\n//     )\r\n//         public\r\n//         view\r\n//         returns (\r\n//             SpecificMarketFactoryBundle memory _marketFactoryBundle,\r\n//             SpecificStaticMarketBundle[] memory _marketBundles,\r\n//             uint256 _lowestMarketIndex,\r\n//             uint256 _timestamp\r\n//         )\r\n//     {\r\n//         _marketFactoryBundle = buildSpecificMarketFactoryBundle(_marketFactory);\r\n\r\n//         uint256[] memory _marketIds;\r\n//         (_marketIds, _lowestMarketIndex) = listOfInterestingMarkets(_marketFactory, _offset, _total);\r\n\r\n//         _total = _marketIds.length;\r\n//         _marketBundles = new SpecificStaticMarketBundle[](_total);\r\n//         for (uint256 i; i < _total; i++) {\r\n//             _marketBundles[i] = buildSpecificStaticMarketBundle(\r\n//                 _marketFactory,\r\n//                 _ammFactory,\r\n//                 _masterChef,\r\n//                 _marketIds[i]\r\n//             );\r\n//         }\r\n\r\n//         _timestamp = block.timestamp;\r\n//     }\r\n\r\n//     function fetchDynamic(\r\n//         address _marketFactory,\r\n//         AMMFactory _ammFactory,\r\n//         uint256 _offset,\r\n//         uint256 _total\r\n//     )\r\n//         public\r\n//         view\r\n//         returns (\r\n//             SpecificDynamicMarketBundle[] memory _bundles,\r\n//             uint256 _lowestMarketIndex,\r\n//             uint256 _timestamp\r\n//         )\r\n//     {\r\n//         uint256[] memory _marketIds;\r\n//         (_marketIds, _lowestMarketIndex) = listOfInterestingMarkets(_marketFactory, _offset, _total);\r\n\r\n//         _total = _marketIds.length;\r\n//         _bundles = new SpecificDynamicMarketBundle[](_total);\r\n//         for (uint256 i; i < _total; i++) {\r\n//             _bundles[i] = buildSpecificDynamicMarketBundle(_marketFactory, _ammFactory, _marketIds[i]);\r\n//         }\r\n\r\n//         _timestamp = block.timestamp;\r\n//     }\r\n\r\n//     // Starts from the end of the markets list because newer markets are more interesting.\r\n//     // _offset is skipping all markets, not just interesting markets\r\n//     function listOfInterestingMarkets(\r\n//         address _marketFactory,\r\n//         uint256 _offset,\r\n//         uint256 _total\r\n//     ) internal view returns (uint256[] memory _interestingMarketIds, uint256 _marketId) {\r\n//         _interestingMarketIds = new uint256[](_total);\r\n//         uint256 _max = AbstractMarketFactoryV3(_marketFactory).marketCount() - 1;\r\n\r\n//         // No markets so return nothing. (needed to prevent integer underflow below)\r\n//         if (_max == 0 || _offset >= _max) {\r\n//             return (new uint256[](0), 0);\r\n//         }\r\n\r\n//         // Starts at the end, less offset.\r\n//         // Stops before the 0th market since that market is always fake.\r\n//         uint256 _collectedMarkets = 0;\r\n//         _marketId = _max - _offset;\r\n\r\n//         while (true) {\r\n//             if (openOrHasWinningShares(AbstractMarketFactoryV3(_marketFactory), _marketId)) {\r\n//                 _interestingMarketIds[_collectedMarkets] = _marketId;\r\n//                 _collectedMarkets++;\r\n//             }\r\n\r\n//             if (_collectedMarkets >= _total) break;\r\n//             if (_marketId == 1) break; // skipping 0th market, which is fake\r\n//             _marketId--; // starts out oone too high, so this works\r\n//         }\r\n\r\n//         if (_total > _collectedMarkets) {\r\n//             assembly {\r\n//                 // shortens array\r\n//                 mstore(_interestingMarketIds, _collectedMarkets)\r\n//             }\r\n//         }\r\n//     }"
    },
    "contracts/libraries/SafeMathInt256.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.7.6;\r\n\r\n/**\r\n * @title SafeMathInt256\r\n * @dev Int256 math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMathInt256 {\r\n    // Signed ints with n bits can range from -2**(n-1) to (2**(n-1) - 1)\r\n    int256 private constant INT256_MIN = -2**(255);\r\n    int256 private constant INT256_MAX = (2**(255) - 1);\r\n\r\n    function mul(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a * b;\r\n        require(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(int256 a, int256 b) internal pure returns (int256) {\r\n        // No need to check for dividing by 0 -- Solidity automatically throws on division by 0\r\n        int256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n    function sub(int256 a, int256 b) internal pure returns (int256) {\r\n        require(((a >= 0) && (b >= a - INT256_MAX)) || ((a < 0) && (b <= a - INT256_MIN)));\r\n        return a - b;\r\n    }\r\n\r\n    function add(int256 a, int256 b) internal pure returns (int256) {\r\n        require(((a >= 0) && (b <= INT256_MAX - a)) || ((a < 0) && (b >= INT256_MIN - a)));\r\n        return a + b;\r\n    }\r\n\r\n    function min(int256 a, int256 b) internal pure returns (int256) {\r\n        if (a <= b) {\r\n            return a;\r\n        } else {\r\n            return b;\r\n        }\r\n    }\r\n\r\n    function max(int256 a, int256 b) internal pure returns (int256) {\r\n        if (a >= b) {\r\n            return a;\r\n        } else {\r\n            return b;\r\n        }\r\n    }\r\n\r\n    function abs(int256 a) internal pure returns (int256) {\r\n        if (a < 0) {\r\n            return -a;\r\n        }\r\n        return a;\r\n    }\r\n\r\n    function getInt256Min() internal pure returns (int256) {\r\n        return INT256_MIN;\r\n    }\r\n\r\n    function getInt256Max() internal pure returns (int256) {\r\n        return INT256_MAX;\r\n    }\r\n\r\n    // Float [fixed point] Operations\r\n    function fxpMul(\r\n        int256 a,\r\n        int256 b,\r\n        int256 base\r\n    ) internal pure returns (int256) {\r\n        return div(mul(a, b), base);\r\n    }\r\n\r\n    function fxpDiv(\r\n        int256 a,\r\n        int256 b,\r\n        int256 base\r\n    ) internal pure returns (int256) {\r\n        return div(mul(a, base), b);\r\n    }\r\n\r\n    function sqrt(int256 y) internal pure returns (int256 z) {\r\n        if (y > 3) {\r\n            int256 x = (y + 1) / 2;\r\n            z = y;\r\n            while (x < z) {\r\n                z = x;\r\n                x = (y / x + x) / 2;\r\n            }\r\n        } else if (y != 0) {\r\n            z = 1;\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/turbo/MMAMarketFactoryV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.7.6;\r\npragma abicoder v2;\r\n\r\nimport \"./AbstractMarketFactoryV3.sol\";\r\nimport \"./FeePot.sol\";\r\nimport \"../libraries/SafeMathInt256.sol\";\r\nimport \"../libraries/Sport.sol\";\r\nimport \"../libraries/ResolveByFiat.sol\";\r\nimport \"../libraries/HasHeadToHeadMarket.sol\";\r\nimport \"../libraries/Versioned.sol\";\r\n\r\ncontract MMAMarketFactoryV3 is AbstractMarketFactoryV3, SportView, ResolvesByFiat, HasHeadToHeadMarket, Versioned {\r\n    using SafeMathUint256 for uint256;\r\n    using SafeMathInt256 for int256;\r\n\r\n    uint256 constant HeadToHead = 0;\r\n    string constant InvalidName = \"No Contest / Draw\";\r\n\r\n    constructor(\r\n        address _owner,\r\n        IERC20Full _collateral,\r\n        uint256 _shareFactor,\r\n        FeePot _feePot,\r\n        uint256[3] memory _fees,\r\n        address _protocol,\r\n        address _linkNode\r\n    )\r\n        AbstractMarketFactoryV3(_owner, _collateral, _shareFactor, _feePot, _fees, _protocol)\r\n        Versioned(\"v1.2.0\")\r\n        ManagedByLink(_linkNode)\r\n        HasHeadToHeadMarket(HeadToHead, InvalidName)\r\n    {}\r\n\r\n    function createEvent(\r\n        uint256 _eventId,\r\n        string memory _homeTeamName,\r\n        uint256 _homeTeamId,\r\n        string memory _awayTeamName,\r\n        uint256 _awayTeamId,\r\n        uint256 _startTimestamp,\r\n        int256[2] memory _moneylines // [home,away]\r\n    ) public onlyLinkNode returns (uint256[] memory _marketIds) {\r\n        _marketIds = makeMarkets(_moneylines, _homeTeamName, _awayTeamName);\r\n        makeSportsEvent(\r\n            _eventId,\r\n            _marketIds,\r\n            build1Line(),\r\n            _startTimestamp,\r\n            _homeTeamId,\r\n            _awayTeamId,\r\n            _homeTeamName,\r\n            _awayTeamName\r\n        );\r\n    }\r\n\r\n    function makeMarkets(\r\n        int256[2] memory _moneylines,\r\n        string memory _homeTeamName,\r\n        string memory _awayTeamName\r\n    ) internal returns (uint256[] memory _marketIds) {\r\n        _marketIds = new uint256[](1);\r\n        _marketIds[HeadToHead] = makeHeadToHeadMarket(_moneylines, _homeTeamName, _awayTeamName);\r\n    }\r\n\r\n    function resolveValidEvent(SportsEvent memory _event, uint256 _whoWon) internal override {\r\n        resolveHeadToHeadMarket(_event.markets[HeadToHead], _whoWon);\r\n    }\r\n\r\n    function resolveHeadToHeadMarket(uint256 _marketId, uint256 _whoWon) internal {\r\n        uint256 _shareTokenIndex = calcHeadToHeadWinner(_whoWon);\r\n        endMarket(_marketId, _shareTokenIndex);\r\n    }\r\n\r\n    function calcHeadToHeadWinner(uint256 _whoWon) internal pure returns (uint256) {\r\n        if (WhoWonHome == _whoWon) {\r\n            return HeadToHeadHome;\r\n        } else if (WhoWonAway == _whoWon) {\r\n            return HeadToHeadAway;\r\n        } else {\r\n            return NoContest; // shouldn't happen here\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/turbo/CryptoMarketFactoryV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.7.6;\r\npragma abicoder v2;\r\n\r\nimport \"../libraries/IERC20Full.sol\";\r\nimport \"../balancer/BPool.sol\";\r\nimport \"./AbstractMarketFactoryV3.sol\";\r\nimport \"./FeePot.sol\";\r\nimport \"../libraries/SafeMathInt256.sol\";\r\nimport \"@chainlink/contracts/src/v0.7/interfaces/AggregatorV3Interface.sol\";\r\nimport \"../libraries/CalculateLinesToBPoolOdds.sol\";\r\nimport \"../libraries/Versioned.sol\";\r\nimport \"../libraries/ManagedByLink.sol\";\r\nimport \"../libraries/Rewardable.sol\";\r\n\r\ncontract CryptoMarketFactoryV3 is AbstractMarketFactoryV3, CalculateLinesToBPoolOdds, Versioned, ManagedByLink {\r\n    using SafeMathUint256 for uint256;\r\n    using SafeMathInt256 for int256;\r\n\r\n    event CoinAdded(uint256 indexed id, string name);\r\n\r\n    event NewPrices(uint256 indexed nextResolutionTime, uint256[] markets, uint256[] prices);\r\n\r\n    struct Coin {\r\n        string name;\r\n        AggregatorV3Interface priceFeed;\r\n        uint256 price;\r\n        uint8 imprecision; // how many decimals to truncate\r\n        uint256[1] currentMarkets;\r\n    }\r\n    Coin[] public coins;\r\n\r\n    enum MarketType {\r\n        PriceUpDown // 0\r\n    }\r\n    enum PriceUpDownOutcome {\r\n        Above, // 0\r\n        NotAbove // 1\r\n    }\r\n    struct MarketDetails {\r\n        MarketType marketType;\r\n        uint256 coinIndex;\r\n        uint256 creationPrice;\r\n        uint256 resolutionPrice;\r\n        uint256 resolutionTime; // price at given time; this is that time\r\n    }\r\n    // MarketId => MarketDetails\r\n    mapping(uint256 => MarketDetails) internal marketDetails;\r\n\r\n    uint256 public nextResolutionTime;\r\n\r\n    constructor(\r\n        address _owner,\r\n        IERC20Full _collateral,\r\n        uint256 _shareFactor,\r\n        FeePot _feePot,\r\n        uint256[3] memory _fees,\r\n        address _protocol,\r\n        address _linkNode\r\n    )\r\n        AbstractMarketFactoryV3(_owner, _collateral, _shareFactor, _feePot, _fees, _protocol)\r\n        Versioned(\"v1.2.0\")\r\n        ManagedByLink(_linkNode)\r\n    {\r\n        string memory _name = \"\";\r\n        coins.push(makeCoin(_name, AggregatorV3Interface(0), 0));\r\n    }\r\n\r\n    function getMarketDetails(uint256 _marketId) public view returns (MarketDetails memory) {\r\n        return marketDetails[_marketId];\r\n    }\r\n\r\n    // NOTE: Trusts the owner not to add a coin twice.\r\n    // Returns the coin index.\r\n    function addCoin(\r\n        string calldata _name,\r\n        AggregatorV3Interface _priceFeed,\r\n        uint8 _imprecision\r\n    ) external onlyOwner returns (uint256 _coinIndex) {\r\n        Coin memory _coin = makeCoin(_name, _priceFeed, _imprecision);\r\n        _coinIndex = coins.length;\r\n        coins.push(_coin);\r\n        emit CoinAdded(_coinIndex, _name);\r\n    }\r\n\r\n    function getCoin(uint256 _coinIndex) public view returns (Coin memory _coin) {\r\n        _coin = coins[_coinIndex];\r\n    }\r\n\r\n    function getCoins() public view returns (Coin[] memory _coins) {\r\n        _coins = new Coin[](coins.length);\r\n        // Skip first coin because it's always the zeroed-out fake coin.\r\n        for (uint256 i = 1; i < coins.length; i++) {\r\n            _coins[i] = coins[i];\r\n        }\r\n    }\r\n\r\n    // Iterates over all coins.\r\n    // If markets do not exist for coin, create them.\r\n    // Unless _nextResolutionTime is zero; then do not create new markets.\r\n    // If markets for coin exist and are ready to resolve, resolve them and create new markets.\r\n    // Else, error.\r\n    //\r\n    // Assume that _roundIds has a dummy value at index 0, and is 1 indexed like the\r\n    // coins array.\r\n    function createAndResolveMarkets(uint80[] calldata _roundIds, uint256 _nextResolutionTime) public onlyLinkNode {\r\n        // If market creation was stopped then it can be started again.\r\n        // If market creation wasn't stopped then you must wait for market end time to resolve.\r\n        require(block.timestamp >= nextResolutionTime, \"Must wait for market resolution\");\r\n        require(_roundIds.length == coins.length, \"Must specify one roundId for each coin\");\r\n\r\n        uint256 _resolutionTime = nextResolutionTime;\r\n        nextResolutionTime = _nextResolutionTime;\r\n\r\n        uint256[] memory _prices = new uint256[](coins.length - 1);\r\n        uint256[] memory _newMarketIds = new uint256[](coins.length - 1);\r\n        // Start at 1 to skip the fake Coin in the 0 index\r\n        for (uint256 i = 1; i < coins.length; i++) {\r\n            (_prices[i - 1], _newMarketIds[i - 1]) = createAndResolveMarketsForCoin(i, _resolutionTime, _roundIds[i]);\r\n        }\r\n\r\n        emit NewPrices(nextResolutionTime, _newMarketIds, _prices);\r\n    }\r\n\r\n    function createAndResolveMarketsForCoin(\r\n        uint256 _coinIndex,\r\n        uint256 _resolutionTime,\r\n        uint80 _roundId\r\n    ) internal returns (uint256 _price, uint256 _newMarketId) {\r\n        Coin memory _coin = coins[_coinIndex];\r\n        (uint256 _fullPrice, uint256 _newPrice) = getPrice(_coin, _roundId, _resolutionTime);\r\n\r\n        // resolve markets\r\n        if (_coin.currentMarkets[uint256(MarketType.PriceUpDown)] != 0) {\r\n            resolvePriceUpDownMarket(_coin, _newPrice, _fullPrice);\r\n        }\r\n\r\n        // update price only AFTER resolution\r\n        coins[_coinIndex].price = _newPrice;\r\n\r\n        // link node sets nextResolutionTime to zero to signify \"do not create markets after resolution\"\r\n        if (nextResolutionTime == 0) {\r\n            return (0, 0);\r\n        }\r\n\r\n        // create markets\r\n        _newMarketId = createPriceUpDownMarket(_coinIndex, linkNode, _newPrice);\r\n        coins[_coinIndex].currentMarkets[uint256(MarketType.PriceUpDown)] = _newMarketId;\r\n\r\n        return (_newPrice, _newMarketId);\r\n    }\r\n\r\n    function resolvePriceUpDownMarket(\r\n        Coin memory _coin,\r\n        uint256 _newPrice,\r\n        uint256 _fullPrice\r\n    ) internal {\r\n        uint256 _marketId = _coin.currentMarkets[uint256(MarketType.PriceUpDown)];\r\n\r\n        uint256 _winningOutcome;\r\n        if (_newPrice > _coin.price) {\r\n            _winningOutcome = uint256(PriceUpDownOutcome.Above);\r\n        } else {\r\n            _winningOutcome = uint256(PriceUpDownOutcome.NotAbove);\r\n        }\r\n\r\n        endMarket(_marketId, _winningOutcome);\r\n        marketDetails[_marketId].resolutionPrice = _fullPrice;\r\n    }\r\n\r\n    function createPriceUpDownMarket(\r\n        uint256 _coinIndex,\r\n        address _creator,\r\n        uint256 _newPrice\r\n    ) internal returns (uint256 _id) {\r\n        string[] memory _outcomes = new string[](2);\r\n        _outcomes[uint256(PriceUpDownOutcome.Above)] = \"Above\";\r\n        _outcomes[uint256(PriceUpDownOutcome.NotAbove)] = \"Not Above\";\r\n\r\n        _id = startMarket(_creator, _outcomes, evenOdds(false, 2), true);\r\n        marketDetails[_id] = MarketDetails(MarketType.PriceUpDown, _coinIndex, _newPrice, 0, nextResolutionTime);\r\n    }\r\n\r\n    // Returns the price based on a few factors.\r\n    // If _roundId is zero then it returns the latest price.\r\n    // Else, it returns the price for that round,\r\n    //       but errors if that isn't the first round after the resolution time.\r\n    // The price is then altered to match the desired precision.\r\n    function getPrice(\r\n        Coin memory _coin,\r\n        uint80 _roundId,\r\n        uint256 _resolutionTime\r\n    ) internal view returns (uint256 _fullPrice, uint256 _truncatedPrice) {\r\n        if (_roundId == 0) {\r\n            (, int256 _rawPrice, , , ) = _coin.priceFeed.latestRoundData();\r\n            require(_rawPrice >= 0, \"Price from feed is negative\");\r\n            _fullPrice = uint256(_rawPrice);\r\n        } else {\r\n            (, int256 _rawPrice, , uint256 updatedAt, ) = _coin.priceFeed.getRoundData(_roundId);\r\n            require(_rawPrice >= 0, \"Price from feed is negative\");\r\n            require(updatedAt >= _resolutionTime, \"Price hasn't been updated yet\");\r\n\r\n            // if resolution time is zero then market creation was stopped, so the previous round doesn't matter\r\n            if (_resolutionTime != 0) {\r\n                (, , , uint256 _previousRoundTime, ) = _coin.priceFeed.getRoundData(previousRound(_roundId));\r\n                require(_previousRoundTime < _resolutionTime, \"Must use first round after resolution time\");\r\n            }\r\n\r\n            _fullPrice = uint256(_rawPrice);\r\n        }\r\n\r\n        // The precision is how many decimals the price has. Zero is dollars, 2 includes cents, 3 is tenths of a cent, etc.\r\n        // Our resolution rules want a certain precision. Like BTC is to the dollar and MATIC is to the cent.\r\n        // If somehow the decimals are larger than the desired precision then add zeroes to the end to meet the precision.\r\n        // This does not change the resolution outcome but does guard against decimals() changing and therefore altering the basis.\r\n\r\n        uint8 _precision = _coin.priceFeed.decimals(); // probably constant but that isn't guaranteed, so query each time\r\n        if (_precision > _coin.imprecision) {\r\n            uint8 _truncate = _precision - _coin.imprecision;\r\n            _truncatedPrice = _fullPrice / (10**_truncate);\r\n        } else if (_precision < _coin.imprecision) {\r\n            uint8 _greaten = _coin.imprecision - _precision;\r\n            _truncatedPrice = _fullPrice * (10**_greaten);\r\n        } else {\r\n            _truncatedPrice = _fullPrice;\r\n        }\r\n\r\n        // Round up because that cleanly fits Above/Not-Above.\r\n        if (_truncatedPrice != _fullPrice) {\r\n            _truncatedPrice += 1;\r\n        }\r\n    }\r\n\r\n    function makeCoin(\r\n        string memory _name,\r\n        AggregatorV3Interface _priceFeed,\r\n        uint8 _imprecision\r\n    ) internal pure returns (Coin memory _coin) {\r\n        uint256[1] memory _currentMarkets = [uint256(0)];\r\n        _coin = Coin(_name, _priceFeed, 0, _imprecision, _currentMarkets);\r\n    }\r\n\r\n    // The roundId is the encoding of two parts: the phase and the phase-specific round id.\r\n    // To find the previous roundId:\r\n    // 1. extract the phase and phase-specific round (I call these _phaseId and _roundId)\r\n    // 2. decrement the phase-specific round\r\n    // 3. re-encode the phase and phase-specific round.\r\n    uint256 private constant PHASE_OFFSET = 64;\r\n\r\n    function previousRound(uint80 _fullRoundId) internal pure returns (uint80) {\r\n        uint256 _phaseId = uint256(uint16(_fullRoundId >> PHASE_OFFSET));\r\n        uint64 _roundId = uint64(_fullRoundId) - 1;\r\n        return uint80((_phaseId << PHASE_OFFSET) | _roundId);\r\n    }\r\n\r\n    function getRewardEndTime(uint256 _marketId) public view override returns (uint256) {\r\n        return getMarketDetails(_marketId).resolutionTime;\r\n    }\r\n}\r\n"
    },
    "contracts/turbo/NBAMarketFactoryV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.7.6;\r\npragma abicoder v2;\r\n\r\nimport \"../libraries/IERC20Full.sol\";\r\nimport \"../balancer/BPool.sol\";\r\nimport \"./AbstractMarketFactoryV3.sol\";\r\nimport \"./FeePot.sol\";\r\nimport \"../libraries/SafeMathInt256.sol\";\r\nimport \"../libraries/Sport.sol\";\r\nimport \"../libraries/HasSpreadMarket.sol\";\r\nimport \"../libraries/ResolveByScore.sol\";\r\nimport \"../libraries/Versioned.sol\";\r\n\r\ncontract NBAMarketFactoryV3 is AbstractMarketFactoryV3, SportView, HasSpreadMarket, ResolvesByScore, Versioned {\r\n    using SafeMathUint256 for uint256;\r\n    using SafeMathInt256 for int256;\r\n\r\n    uint256 constant Spread = 0;\r\n    string constant InvalidName = \"No Contest\";\r\n\r\n    constructor(\r\n        address _owner,\r\n        IERC20Full _collateral,\r\n        uint256 _shareFactor,\r\n        FeePot _feePot,\r\n        uint256[3] memory _fees,\r\n        address _protocol,\r\n        address _linkNode\r\n    )\r\n        AbstractMarketFactoryV3(_owner, _collateral, _shareFactor, _feePot, _fees, _protocol)\r\n        Versioned(\"1.5.0\")\r\n        ManagedByLink(_linkNode)\r\n        HasSpreadMarket(Spread, InvalidName)\r\n    {}\r\n\r\n    function createEvent(\r\n        uint256 _eventId,\r\n        string memory _homeTeamName,\r\n        uint256 _homeTeamId,\r\n        string memory _awayTeamName,\r\n        uint256 _awayTeamId,\r\n        uint256 _startTimestamp,\r\n        int256 _homeSpread\r\n    ) public onlyLinkNode returns (uint256[] memory _marketIds) {\r\n        _marketIds = makeMarkets(_homeTeamName, _awayTeamName);\r\n        makeSportsEvent(\r\n            _eventId,\r\n            _marketIds,\r\n            makeLine(_homeSpread),\r\n            _startTimestamp,\r\n            _homeTeamId,\r\n            _awayTeamId,\r\n            _homeTeamName,\r\n            _awayTeamName\r\n        );\r\n    }\r\n\r\n    function makeMarkets(string memory _homeTeamName, string memory _awayTeamName)\r\n        internal\r\n        returns (uint256[] memory _marketIds)\r\n    {\r\n        _marketIds = new uint256[](1);\r\n        _marketIds[Spread] = makeSpreadMarket(_homeTeamName, _awayTeamName);\r\n    }\r\n\r\n    function makeLine(int256 _homeSpread) internal pure returns (int256[] memory _line) {\r\n        _line = build1Line();\r\n        _line[0] = addHalfPoint(_homeSpread);\r\n    }\r\n\r\n    function resolveValidEvent(\r\n        SportsEvent memory _event,\r\n        uint256 _homeScore,\r\n        uint256 _awayScore\r\n    ) internal override {\r\n        resolveSpreadMarket(_event.markets[Spread], _event.lines[Spread], _homeScore, _awayScore);\r\n    }\r\n}\r\n"
    },
    "contracts/rewards/MasterChef.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.0;\r\npragma abicoder v2;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\r\nimport \"@openzeppelin/contracts/utils/EnumerableSet.sol\";\r\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\" as OpenZeppelinOwnable;\r\nimport \"../turbo/AbstractMarketFactoryV3.sol\";\r\nimport \"../turbo/AMMFactory.sol\";\r\n\r\n// MasterChef is the master of Reward. He can make Reward and he is a fair guy.\r\ncontract MasterChef is OpenZeppelinOwnable.Ownable {\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n\r\n    uint256 public constant BONE = 10**18;\r\n\r\n    // The percentage of the rewards period that early deposit bonus will payout.\r\n    // e.g. Early deposit bonus hits if LP is done in the first x percent of the period.\r\n    uint256 public constant EARLY_DEPOSIT_BONUS_REWARDS_PERCENTAGE = BONE / 10; // 10% of reward period.\r\n\r\n    // Info of each user.\r\n    struct UserInfo {\r\n        uint256 amount; // How many LP tokens the user has provided.\r\n        uint256 rewardDebt; // Reward debt. See explanation below.\r\n        uint256 lastActionTimestamp; // Timestamp of the withdrawal or deposit from this user.\r\n        //\r\n        // We do some fancy math here. Basically, any point in time, the amount of REWARDs\r\n        // entitled to a user but is pending to be distributed is:\r\n        //\r\n        //   pending reward = (user.amount * pool.accRewardsPerShare) - user.rewardDebt\r\n        //\r\n        // Whenever a user deposits or withdraws LP tokens to a pool. Here's what happens:\r\n        //   1. The pool's `accRewardsPerShare` (and `lastRewardBlock`) gets updated.\r\n        //   2. User receives the pending reward sent to his/her address.\r\n        //   3. User's `amount` gets updated.\r\n        //   4. User's `rewardDebt` gets updated.\r\n    }\r\n    // Info of each user that deposits LP tokens.\r\n    mapping(uint256 => mapping(address => UserInfo)) public userInfo;\r\n\r\n    // Info of each pool.\r\n    struct PoolInfo {\r\n        IERC20 lpToken; // Address of LP token contract.\r\n        uint256 accRewardsPerShare; // Accumulated REWARDs per share, times BONE. See below.\r\n        uint256 totalEarlyDepositBonusRewardShares; // The total number of share currently qualifying bonus REWARDs.\r\n        uint256 beginTimestamp; // The timestamp to begin calculating rewards at.\r\n        uint256 endTimestamp; // Timestamp of the end of the rewards period.\r\n        uint256 earlyDepositBonusRewards; // Amount of REWARDs to distribute to early depositors.\r\n        uint256 lastRewardTimestamp; // Last timestamp REWARDs distribution occurred.\r\n        uint256 rewardsPerSecond; // Number of rewards paid out per second.\r\n    }\r\n    // Info of each pool.\r\n    PoolInfo[] public poolInfo;\r\n\r\n    // This is a snapshot of the current state of a market.\r\n    struct PoolStatusInfo {\r\n        uint256 beginTimestamp;\r\n        uint256 endTimestamp;\r\n        uint256 earlyDepositEndTimestamp;\r\n        uint256 totalRewardsAccrued;\r\n        bool created;\r\n    }\r\n\r\n    struct PendingRewardInfo {\r\n        uint256 beginTimestamp;\r\n        uint256 endTimestamp;\r\n        uint256 earlyDepositEndTimestamp;\r\n        uint256 accruedStandardRewards;\r\n        uint256 accruedEarlyDepositBonusRewards;\r\n        uint256 pendingEarlyDepositBonusRewards;\r\n        bool created;\r\n    }\r\n\r\n    struct MarketFactoryInfo {\r\n        uint256 earlyDepositBonusRewards; // Amount of REWARDs per day to distribute to early depositors.\r\n        uint256 rewardsPeriods; // Number of days the rewards for this pool will payout.\r\n        uint256 rewardsPerPeriod; // Amount of rewards to be given out for a given period.\r\n    }\r\n    mapping(address => MarketFactoryInfo) marketFactoryRewardInfo;\r\n\r\n    struct RewardPoolLookupInfo {\r\n        uint256 pid;\r\n        bool created;\r\n    }\r\n\r\n    // AMMFactory => MarketFactory => MarketId\r\n    mapping(address => mapping(address => mapping(uint256 => RewardPoolLookupInfo))) public rewardPoolLookup;\r\n\r\n    // The REWARD TOKEN!\r\n    IERC20 private rewardsToken;\r\n\r\n    mapping(address => bool) private approvedAMMFactories;\r\n\r\n    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);\r\n    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount, address recipient);\r\n    event TrustMarketFactory(\r\n        address indexed MarketFactory,\r\n        uint256 OriginEarlyDepositBonusRewards,\r\n        uint256 OriginrewardsPeriods,\r\n        uint256 OriginRewardsPerPeriod,\r\n        uint256 EarlyDepositBonusRewards,\r\n        uint256 rewardsPeriods,\r\n        uint256 RewardsPerPeriod\r\n    );\r\n\r\n    event PoolCreated(\r\n        address indexed ammFactory,\r\n        address indexed marketFactory,\r\n        uint256 indexed marketId,\r\n        address creator,\r\n        address lpTokenRecipient\r\n    );\r\n    event LiquidityChanged(\r\n        address indexed ammFactory,\r\n        address indexed marketFactory,\r\n        uint256 indexed marketId,\r\n        address user,\r\n        address recipient,\r\n        // from the perspective of the user. e.g. collateral is negative when adding liquidity\r\n        int256 collateral,\r\n        int256 lpTokens,\r\n        uint256[] sharesReturned\r\n    );\r\n\r\n    event EmergencyWithdraw(address indexed user, uint256 indexed pid, uint256 amount);\r\n\r\n    constructor(IERC20 _rewardsToken) {\r\n        rewardsToken = _rewardsToken;\r\n    }\r\n\r\n    function trustAMMFactory(address _ammFactory) public onlyOwner {\r\n        approvedAMMFactories[_ammFactory] = true;\r\n    }\r\n\r\n    function untrustAMMFactory(address _ammFactory) public onlyOwner {\r\n        delete approvedAMMFactories[_ammFactory];\r\n    }\r\n\r\n    // This method can also be used to update rewards\r\n    function addRewards(\r\n        address _marketFactory,\r\n        uint256 _rewardsPerMarket,\r\n        uint256 _rewardDaysPerMarket,\r\n        uint256 _earlyDepositBonusRewards\r\n    ) public onlyOwner {\r\n        MarketFactoryInfo memory _oldMarketFactoryInfo = marketFactoryRewardInfo[_marketFactory];\r\n\r\n        marketFactoryRewardInfo[_marketFactory] = MarketFactoryInfo({\r\n            rewardsPeriods: _rewardDaysPerMarket,\r\n            rewardsPerPeriod: _rewardsPerMarket,\r\n            earlyDepositBonusRewards: _earlyDepositBonusRewards\r\n        });\r\n\r\n        emit TrustMarketFactory(\r\n            _marketFactory,\r\n            _oldMarketFactoryInfo.earlyDepositBonusRewards,\r\n            _oldMarketFactoryInfo.rewardsPeriods,\r\n            _oldMarketFactoryInfo.rewardsPerPeriod,\r\n            _earlyDepositBonusRewards,\r\n            _rewardDaysPerMarket,\r\n            _rewardsPerMarket\r\n        );\r\n    }\r\n\r\n    function poolLength() external view returns (uint256) {\r\n        return poolInfo.length;\r\n    }\r\n\r\n    // Add a new lp to the pool. Can only be called by the owner.\r\n    // XXX DO NOT add the same LP token more than once. Rewards will be messed up if you do.\r\n    // An _endTimestamp of zero means the rewards start immediately.\r\n    function add(\r\n        address _ammFactory,\r\n        address _marketFactory,\r\n        uint256 _marketId,\r\n        IERC20 _lpToken,\r\n        uint256 _endTimestamp\r\n    ) public onlyOwner returns (uint256 _nextPID) {\r\n        return addInternal(_ammFactory, _marketFactory, _marketId, _lpToken, _endTimestamp);\r\n    }\r\n\r\n    function addInternal(\r\n        address _ammFactory,\r\n        address _marketFactory,\r\n        uint256 _marketId,\r\n        IERC20 _lpToken,\r\n        uint256 _endTimestamp\r\n    ) internal returns (uint256 _nextPID) {\r\n        require(\r\n            !rewardPoolLookup[_ammFactory][_marketFactory][_marketId].created,\r\n            \"Reward pool has already been created.\"\r\n        );\r\n\r\n        require(approvedAMMFactories[address(_ammFactory)], \"AMMFactory must be approved to create pool\");\r\n\r\n        _nextPID = poolInfo.length;\r\n\r\n        rewardPoolLookup[_ammFactory][_marketFactory][_marketId] = RewardPoolLookupInfo({pid: _nextPID, created: true});\r\n\r\n        MarketFactoryInfo memory _marketFactoryInfo = marketFactoryRewardInfo[_marketFactory];\r\n\r\n        // Need to figure out the beginning/end of the reward period.\r\n        uint256 _rewardsPeriodsInSeconds = _marketFactoryInfo.rewardsPeriods * 1 days;\r\n        uint256 _beginTimestamp = block.timestamp;\r\n\r\n        // Add one hour buffer for LPs to withdraw before event start.\r\n        if (_endTimestamp != 0) {\r\n            _endTimestamp = _endTimestamp - 1 hours;\r\n        }\r\n\r\n        if (_endTimestamp == 0) {\r\n            _endTimestamp = _beginTimestamp + _rewardsPeriodsInSeconds;\r\n        } else if ((_endTimestamp - _rewardsPeriodsInSeconds) > block.timestamp) {\r\n            _beginTimestamp = _endTimestamp - _rewardsPeriodsInSeconds;\r\n        } else if (block.timestamp >= _endTimestamp) {\r\n            // reward period already over.\r\n            _beginTimestamp = _endTimestamp;\r\n        }\r\n        poolInfo.push(\r\n            PoolInfo({\r\n                accRewardsPerShare: 0,\r\n                beginTimestamp: _beginTimestamp,\r\n                endTimestamp: _endTimestamp,\r\n                totalEarlyDepositBonusRewardShares: 0,\r\n                earlyDepositBonusRewards: (_marketFactoryInfo.earlyDepositBonusRewards / 1 days) *\r\n                    (_endTimestamp - _beginTimestamp),\r\n                lpToken: _lpToken,\r\n                rewardsPerSecond: (_marketFactoryInfo.rewardsPerPeriod / 1 days),\r\n                lastRewardTimestamp: _beginTimestamp\r\n            })\r\n        );\r\n    }\r\n\r\n    // Return number of seconds elapsed in terms of BONEs.\r\n    function getTimeElapsed(uint256 _pid) public view returns (uint256) {\r\n        PoolInfo storage _pool = poolInfo[_pid];\r\n        uint256 _fromTimestamp = block.timestamp;\r\n\r\n        if (\r\n            // Rewards have not started yet.\r\n            _pool.beginTimestamp > _fromTimestamp ||\r\n            // Not sure how this happens but it is accounted for in the original master chef contract.\r\n            _pool.lastRewardTimestamp > _fromTimestamp ||\r\n            // No rewards to be distributed\r\n            _pool.rewardsPerSecond == 0\r\n        ) {\r\n            return 0;\r\n        }\r\n\r\n        // Rewards are over for this pool. No more rewards have accrued.\r\n        if (_pool.lastRewardTimestamp >= _pool.endTimestamp) {\r\n            return 0;\r\n        }\r\n\r\n        return min(_fromTimestamp, _pool.endTimestamp).sub(_pool.lastRewardTimestamp).add(1).mul(BONE);\r\n    }\r\n\r\n    function getPoolTokenBalance(\r\n        AMMFactory _ammFactory,\r\n        AbstractMarketFactoryV3 _marketFactory,\r\n        uint256 _marketId,\r\n        address _user\r\n    ) external view returns (uint256) {\r\n        RewardPoolLookupInfo memory _rewardPoolLookupInfo =\r\n            rewardPoolLookup[address(_ammFactory)][address(_marketFactory)][_marketId];\r\n\r\n        if (_rewardPoolLookupInfo.created) {\r\n            return userInfo[_rewardPoolLookupInfo.pid][_user].amount;\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    function getUserAmount(uint256 _pid, address _user) external view returns (uint256) {\r\n        return userInfo[_pid][_user].amount;\r\n    }\r\n\r\n    function getPoolRewardEndTimestamp(uint256 _pid) public view returns (uint256) {\r\n        PoolInfo storage _pool = poolInfo[_pid];\r\n        return _pool.endTimestamp;\r\n    }\r\n\r\n    function getEarlyDepositEndTimestamp(uint256 _pid) public view returns (uint256) {\r\n        PoolInfo storage _pool = poolInfo[_pid];\r\n        uint256 _duration = _pool.endTimestamp - _pool.beginTimestamp;\r\n\r\n        return ((_duration * EARLY_DEPOSIT_BONUS_REWARDS_PERCENTAGE) / BONE) + _pool.beginTimestamp + 1;\r\n    }\r\n\r\n    function getPoolLPTokenTotalSupply(\r\n        AMMFactory _ammFactory,\r\n        AbstractMarketFactoryV3 _marketFactory,\r\n        uint256 _marketId\r\n    ) public view returns (uint256) {\r\n        RewardPoolLookupInfo memory _rewardPoolLookupInfo =\r\n            rewardPoolLookup[address(_ammFactory)][address(_marketFactory)][_marketId];\r\n\r\n        return poolInfo[_rewardPoolLookupInfo.pid].lpToken.totalSupply();\r\n    }\r\n\r\n    function getPoolLPToken(\r\n        AMMFactory _ammFactory,\r\n        AbstractMarketFactoryV3 _marketFactory,\r\n        uint256 _marketId\r\n    ) public view returns (IERC20) {\r\n        RewardPoolLookupInfo memory _rewardPoolLookupInfo =\r\n            rewardPoolLookup[address(_ammFactory)][address(_marketFactory)][_marketId];\r\n\r\n        return poolInfo[_rewardPoolLookupInfo.pid].lpToken;\r\n    }\r\n\r\n    function getPoolInfo(\r\n        AMMFactory _ammFactory,\r\n        AbstractMarketFactoryV3 _marketFactory,\r\n        uint256 _marketId\r\n    ) public view returns (PoolStatusInfo memory _poolStatusInfo) {\r\n        RewardPoolLookupInfo memory _rewardPoolLookupInfo =\r\n            rewardPoolLookup[address(_ammFactory)][address(_marketFactory)][_marketId];\r\n\r\n        // This cannot revert as it will be used in a multicall.\r\n        if (_rewardPoolLookupInfo.created) {\r\n            PoolInfo storage _pool = poolInfo[_rewardPoolLookupInfo.pid];\r\n\r\n            _poolStatusInfo.beginTimestamp = _pool.beginTimestamp;\r\n            _poolStatusInfo.endTimestamp = _pool.endTimestamp;\r\n            _poolStatusInfo.earlyDepositEndTimestamp = getEarlyDepositEndTimestamp(_rewardPoolLookupInfo.pid);\r\n\r\n            _poolStatusInfo.totalRewardsAccrued =\r\n                (min(block.timestamp, _pool.endTimestamp) - _pool.beginTimestamp) *\r\n                _pool.rewardsPerSecond;\r\n            _poolStatusInfo.created = true;\r\n        }\r\n    }\r\n\r\n    // View function to see pending REWARDs on frontend.\r\n    function getUserPendingRewardInfo(\r\n        AMMFactory _ammFactory,\r\n        AbstractMarketFactoryV3 _marketFactory,\r\n        uint256 _marketId,\r\n        address _userAddress\r\n    ) external view returns (PendingRewardInfo memory _pendingRewardInfo) {\r\n        RewardPoolLookupInfo memory _rewardPoolLookupInfo =\r\n            rewardPoolLookup[address(_ammFactory)][address(_marketFactory)][_marketId];\r\n\r\n        if (_rewardPoolLookupInfo.created) {\r\n            PoolInfo storage _pool = poolInfo[_rewardPoolLookupInfo.pid];\r\n            UserInfo storage _user = userInfo[_rewardPoolLookupInfo.pid][_userAddress];\r\n            uint256 accRewardsPerShare = _pool.accRewardsPerShare;\r\n            uint256 lpSupply = _pool.lpToken.balanceOf(address(this));\r\n\r\n            uint256 _duration = _pool.endTimestamp - _pool.beginTimestamp;\r\n\r\n            _pendingRewardInfo.created = true;\r\n            _pendingRewardInfo.beginTimestamp = _pool.beginTimestamp;\r\n            _pendingRewardInfo.endTimestamp = _pool.endTimestamp;\r\n            _pendingRewardInfo.earlyDepositEndTimestamp = getEarlyDepositEndTimestamp(_rewardPoolLookupInfo.pid);\r\n\r\n            if (_user.lastActionTimestamp <= _pendingRewardInfo.earlyDepositEndTimestamp) {\r\n                if (_pool.totalEarlyDepositBonusRewardShares > 0 && block.timestamp > _pendingRewardInfo.endTimestamp) {\r\n                    _pendingRewardInfo.accruedEarlyDepositBonusRewards = _pool\r\n                        .earlyDepositBonusRewards\r\n                        .mul(_user.amount)\r\n                        .div(_pool.totalEarlyDepositBonusRewardShares);\r\n                } else if (_pool.totalEarlyDepositBonusRewardShares > 0) {\r\n                    _pendingRewardInfo.pendingEarlyDepositBonusRewards = _pool\r\n                        .earlyDepositBonusRewards\r\n                        .mul(_user.amount)\r\n                        .div(_pool.totalEarlyDepositBonusRewardShares);\r\n                }\r\n            }\r\n\r\n            if (block.timestamp > _pool.lastRewardTimestamp && lpSupply != 0) {\r\n                uint256 multiplier = getTimeElapsed(_rewardPoolLookupInfo.pid);\r\n                accRewardsPerShare = accRewardsPerShare.add(multiplier.mul(_pool.rewardsPerSecond).div(lpSupply));\r\n            }\r\n\r\n            _pendingRewardInfo.accruedStandardRewards = _user.amount.mul(accRewardsPerShare).div(BONE).sub(\r\n                _user.rewardDebt\r\n            );\r\n        }\r\n    }\r\n\r\n    // Update reward variables for all pools. Be careful of gas spending!\r\n    function massUpdatePools() public {\r\n        uint256 length = poolInfo.length;\r\n        for (uint256 pid = 0; pid < length; ++pid) {\r\n            updatePool(pid);\r\n        }\r\n    }\r\n\r\n    // Update reward variables of the given pool to be up-to-date.\r\n    function updatePool(uint256 _pid) public {\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        if (block.timestamp <= pool.lastRewardTimestamp) {\r\n            return;\r\n        }\r\n        uint256 lpSupply = pool.lpToken.balanceOf(address(this));\r\n        if (lpSupply == 0) {\r\n            pool.lastRewardTimestamp = block.timestamp;\r\n            return;\r\n        }\r\n        uint256 multiplier = getTimeElapsed(_pid);\r\n        pool.accRewardsPerShare = pool.accRewardsPerShare.add(multiplier.mul(pool.rewardsPerSecond).div(lpSupply));\r\n        pool.lastRewardTimestamp = block.timestamp;\r\n    }\r\n\r\n    // Deposit LP tokens to MasterChef for REWARD allocation.\r\n    // Assumes the staked tokens are already on contract.\r\n    function depositInternal(\r\n        address _userAddress,\r\n        uint256 _pid,\r\n        uint256 _amount\r\n    ) internal {\r\n        PoolInfo storage _pool = poolInfo[_pid];\r\n        UserInfo storage _user = userInfo[_pid][_userAddress];\r\n\r\n        updatePool(_pid);\r\n\r\n        if (_user.amount > 0) {\r\n            uint256 pending = _user.amount.mul(_pool.accRewardsPerShare).div(BONE).sub(_user.rewardDebt);\r\n            safeRewardsTransfer(_userAddress, pending);\r\n        }\r\n\r\n        uint256 _rewardsPeriodsInSeconds = _pool.endTimestamp - _pool.beginTimestamp;\r\n        uint256 _bonusrewardsPeriodsEndTimestamp =\r\n            ((_rewardsPeriodsInSeconds * EARLY_DEPOSIT_BONUS_REWARDS_PERCENTAGE) / BONE) + _pool.beginTimestamp + 1;\r\n\r\n        // If the user was an early deposit, remove user amount from the pool.\r\n        // Even if the pools reward period has elapsed. They must withdraw first.\r\n        if (\r\n            block.timestamp > _bonusrewardsPeriodsEndTimestamp &&\r\n            _user.lastActionTimestamp <= _bonusrewardsPeriodsEndTimestamp\r\n        ) {\r\n            _pool.totalEarlyDepositBonusRewardShares = _pool.totalEarlyDepositBonusRewardShares.sub(_user.amount);\r\n        }\r\n\r\n        // Still in the early deposit bonus period.\r\n        if (_bonusrewardsPeriodsEndTimestamp > block.timestamp) {\r\n            _pool.totalEarlyDepositBonusRewardShares = _pool.totalEarlyDepositBonusRewardShares.add(_amount);\r\n        }\r\n\r\n        _user.amount = _user.amount.add(_amount);\r\n\r\n        _user.rewardDebt = _user.amount.mul(_pool.accRewardsPerShare).div(BONE);\r\n        _user.lastActionTimestamp = block.timestamp;\r\n        emit Deposit(_userAddress, _pid, _amount);\r\n    }\r\n\r\n    function depositByMarket(\r\n        AMMFactory _ammFactory,\r\n        AbstractMarketFactoryV3 _marketFactory,\r\n        uint256 _marketId,\r\n        uint256 _amount\r\n    ) public {\r\n        RewardPoolLookupInfo memory _rewardPoolLookupInfo =\r\n            rewardPoolLookup[address(_ammFactory)][address(_marketFactory)][_marketId];\r\n\r\n        require(_rewardPoolLookupInfo.created, \"Reward pool has not been created.\");\r\n\r\n        deposit(_rewardPoolLookupInfo.pid, _amount);\r\n    }\r\n\r\n    function deposit(uint256 _pid, uint256 _amount) public {\r\n        depositInternal(msg.sender, _pid, _amount);\r\n        poolInfo[_pid].lpToken.safeTransferFrom(msg.sender, address(this), _amount);\r\n    }\r\n\r\n    // Withdraw LP tokens from MasterChef.\r\n    // Assumes caller is handling distribution of LP tokens.\r\n    function withdrawInternal(\r\n        address _userAddress,\r\n        uint256 _pid,\r\n        uint256 _amount,\r\n        address _tokenRecipientAddress\r\n    ) internal {\r\n        PoolInfo storage _pool = poolInfo[_pid];\r\n        UserInfo storage _user = userInfo[_pid][_userAddress];\r\n        require(_user.amount >= _amount, \"withdraw: not good\");\r\n\r\n        updatePool(_pid);\r\n\r\n        uint256 _rewardsPeriodsInSeconds = _pool.endTimestamp - _pool.beginTimestamp;\r\n        uint256 _bonusrewardsPeriodsEndTimestamp =\r\n            ((_rewardsPeriodsInSeconds * EARLY_DEPOSIT_BONUS_REWARDS_PERCENTAGE) / BONE) + _pool.beginTimestamp + 1;\r\n        uint256 _rewardPeriodEndTimestamp = _rewardsPeriodsInSeconds + _pool.beginTimestamp + 1;\r\n\r\n        if (_rewardPeriodEndTimestamp <= block.timestamp) {\r\n            if (\r\n                _pool.totalEarlyDepositBonusRewardShares > 0 &&\r\n                _user.lastActionTimestamp <= _bonusrewardsPeriodsEndTimestamp\r\n            ) {\r\n                uint256 _rewardsToUser =\r\n                    _pool.earlyDepositBonusRewards.mul(_user.amount).div(_pool.totalEarlyDepositBonusRewardShares);\r\n                safeRewardsTransfer(_userAddress, _rewardsToUser);\r\n            }\r\n        } else if (_bonusrewardsPeriodsEndTimestamp >= block.timestamp) {\r\n            // Still in the early deposit bonus period.\r\n            _pool.totalEarlyDepositBonusRewardShares = _pool.totalEarlyDepositBonusRewardShares.sub(_amount);\r\n        } else if (\r\n            // If the user was an early deposit, remove user amount from the pool.\r\n            _bonusrewardsPeriodsEndTimestamp >= _user.lastActionTimestamp\r\n        ) {\r\n            _pool.totalEarlyDepositBonusRewardShares = _pool.totalEarlyDepositBonusRewardShares.sub(_user.amount);\r\n        }\r\n\r\n        uint256 pending = _user.amount.mul(_pool.accRewardsPerShare).div(BONE).sub(_user.rewardDebt);\r\n\r\n        safeRewardsTransfer(_tokenRecipientAddress, pending);\r\n        _user.amount = _user.amount.sub(_amount);\r\n        _user.rewardDebt = _user.amount.mul(_pool.accRewardsPerShare).div(BONE);\r\n        _user.lastActionTimestamp = block.timestamp;\r\n\r\n        emit Withdraw(msg.sender, _pid, _amount, _tokenRecipientAddress);\r\n    }\r\n\r\n    function withdrawByMarket(\r\n        AMMFactory _ammFactory,\r\n        AbstractMarketFactoryV3 _marketFactory,\r\n        uint256 _marketId,\r\n        uint256 _amount\r\n    ) public {\r\n        RewardPoolLookupInfo memory _rewardPoolLookupInfo =\r\n            rewardPoolLookup[address(_ammFactory)][address(_marketFactory)][_marketId];\r\n\r\n        require(_rewardPoolLookupInfo.created, \"Reward pool has not been created.\");\r\n\r\n        withdraw(_rewardPoolLookupInfo.pid, _amount);\r\n    }\r\n\r\n    function withdraw(uint256 _pid, uint256 _amount) public {\r\n        withdrawInternal(msg.sender, _pid, _amount, msg.sender);\r\n        poolInfo[_pid].lpToken.safeTransfer(msg.sender, _amount);\r\n    }\r\n\r\n    function createPool(\r\n        AMMFactory _ammFactory,\r\n        AbstractMarketFactoryV3 _marketFactory,\r\n        uint256 _marketId,\r\n        uint256 _initialLiquidity,\r\n        address _lpTokenRecipient\r\n    ) public returns (uint256) {\r\n        _marketFactory.collateral().transferFrom(msg.sender, address(this), _initialLiquidity);\r\n        _marketFactory.collateral().approve(address(_ammFactory), _initialLiquidity);\r\n\r\n        uint256 _lpTokensIn = _ammFactory.createPool(_marketFactory, _marketId, _initialLiquidity, address(this));\r\n        IERC20 _lpToken = IERC20(address(_ammFactory.getPool(_marketFactory, _marketId)));\r\n\r\n        uint256 _nextPID =\r\n            addInternal(\r\n                address(_ammFactory),\r\n                address(_marketFactory),\r\n                _marketId,\r\n                _lpToken,\r\n                _marketFactory.getRewardEndTime(_marketId)\r\n            );\r\n\r\n        depositInternal(_lpTokenRecipient, _nextPID, _lpTokensIn);\r\n\r\n        AbstractMarketFactoryV3.Market memory _market = _marketFactory.getMarket(_marketId);\r\n        uint256[] memory _balances = new uint256[](_market.shareTokens.length);\r\n        for (uint256 i = 0; i < _market.shareTokens.length; i++) {\r\n            _balances[i] = 0;\r\n        }\r\n\r\n        emit PoolCreated(address(_ammFactory), address(_marketFactory), _marketId, msg.sender, _lpTokenRecipient);\r\n        emit LiquidityChanged(\r\n            address(_ammFactory),\r\n            address(_marketFactory),\r\n            _marketId,\r\n            msg.sender,\r\n            _lpTokenRecipient,\r\n            -int256(_initialLiquidity),\r\n            int256(_lpTokensIn),\r\n            _balances\r\n        );\r\n\r\n        return _lpTokensIn;\r\n    }\r\n\r\n    function addLiquidity(\r\n        AMMFactory _ammFactory,\r\n        AbstractMarketFactoryV3 _marketFactory,\r\n        uint256 _marketId,\r\n        uint256 _collateralIn,\r\n        uint256 _minLPTokensOut,\r\n        address _lpTokenRecipient\r\n    ) public returns (uint256 _poolAmountOut, uint256[] memory _balances) {\r\n        RewardPoolLookupInfo memory _rewardPoolLookupInfo =\r\n            rewardPoolLookup[address(_ammFactory)][address(_marketFactory)][_marketId];\r\n\r\n        uint256 _pid = _rewardPoolLookupInfo.pid;\r\n\r\n        // If not created should attempt to create it.\r\n        if (!_rewardPoolLookupInfo.created) {\r\n            BPool _bPool = _ammFactory.getPool(_marketFactory, _marketId);\r\n            require(_bPool != BPool(0), \"Pool not created.\");\r\n\r\n            _pid = addInternal(\r\n                address(_ammFactory),\r\n                address(_marketFactory),\r\n                _marketId,\r\n                IERC20(address(_bPool)),\r\n                _marketFactory.getRewardEndTime(_marketId)\r\n            );\r\n        }\r\n\r\n        _marketFactory.collateral().transferFrom(msg.sender, address(this), _collateralIn);\r\n        _marketFactory.collateral().approve(address(_ammFactory), _collateralIn);\r\n\r\n        (_poolAmountOut, _balances) = _ammFactory.addLiquidity(\r\n            _marketFactory,\r\n            _marketId,\r\n            _collateralIn,\r\n            _minLPTokensOut,\r\n            address(this)\r\n        );\r\n\r\n        AbstractMarketFactoryV3.Market memory _market = _marketFactory.getMarket(_marketId);\r\n        for (uint256 i = 0; i < _balances.length; i++) {\r\n            if (_balances[i] > 0) {\r\n                _market.shareTokens[i].transfer(_lpTokenRecipient, _balances[i]);\r\n            }\r\n        }\r\n\r\n        depositInternal(_lpTokenRecipient, _pid, _poolAmountOut);\r\n\r\n        emit LiquidityChanged(\r\n            address(_ammFactory),\r\n            address(_marketFactory),\r\n            _marketId,\r\n            msg.sender,\r\n            _lpTokenRecipient,\r\n            -int256(_collateralIn),\r\n            int256(_poolAmountOut),\r\n            _balances\r\n        );\r\n    }\r\n\r\n    function removeLiquidity(\r\n        AMMFactory _ammFactory,\r\n        AbstractMarketFactoryV3 _marketFactory,\r\n        uint256 _marketId,\r\n        uint256 _lpTokensIn,\r\n        uint256 _minCollateralOut,\r\n        address _collateralRecipient\r\n    ) public returns (uint256 _collateralOut, uint256[] memory _balances) {\r\n        RewardPoolLookupInfo memory _rewardPoolLookupInfo =\r\n            rewardPoolLookup[address(_ammFactory)][address(_marketFactory)][_marketId];\r\n\r\n        require(_rewardPoolLookupInfo.created, \"Reward pool has not been created.\");\r\n\r\n        withdrawInternal(msg.sender, _rewardPoolLookupInfo.pid, _lpTokensIn, _collateralRecipient);\r\n\r\n        PoolInfo storage _pool = poolInfo[_rewardPoolLookupInfo.pid];\r\n\r\n        _pool.lpToken.approve(address(_ammFactory), _lpTokensIn);\r\n\r\n        (_collateralOut, _balances) = _ammFactory.removeLiquidity(\r\n            _marketFactory,\r\n            _marketId,\r\n            _lpTokensIn,\r\n            _minCollateralOut,\r\n            _collateralRecipient\r\n        );\r\n\r\n        emit LiquidityChanged(\r\n            address(_ammFactory),\r\n            address(_marketFactory),\r\n            _marketId,\r\n            msg.sender,\r\n            _collateralRecipient,\r\n            int256(_collateralOut),\r\n            -int256(_lpTokensIn),\r\n            _balances\r\n        );\r\n    }\r\n\r\n    function withdrawRewards(uint256 _amount) external onlyOwner {\r\n        rewardsToken.transfer(msg.sender, _amount);\r\n    }\r\n\r\n    // Withdraw without caring about rewards. EMERGENCY ONLY.\r\n    function emergencyWithdraw(uint256 _pid) public {\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        UserInfo storage user = userInfo[_pid][msg.sender];\r\n        pool.lpToken.safeTransfer(address(msg.sender), user.amount);\r\n        emit EmergencyWithdraw(msg.sender, _pid, user.amount);\r\n        user.amount = 0;\r\n        user.rewardDebt = 0;\r\n        user.lastActionTimestamp = 0;\r\n    }\r\n\r\n    function safeRewardsTransfer(address _to, uint256 _amount) internal {\r\n        uint256 _rewardsBal = rewardsToken.balanceOf(address(this));\r\n        if (_amount > _rewardsBal) {\r\n            rewardsToken.transfer(_to, _rewardsBal);\r\n        } else {\r\n            rewardsToken.transfer(_to, _amount);\r\n        }\r\n    }\r\n\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a <= b) {\r\n            return a;\r\n        } else {\r\n            return b;\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/turbo/CryptoCurrencyMarketFactoryV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.7.6;\r\npragma abicoder v2;\r\n\r\nimport \"../libraries/IERC20Full.sol\";\r\nimport \"../balancer/BPool.sol\";\r\nimport \"./AbstractMarketFactoryV3.sol\";\r\nimport \"./FeePot.sol\";\r\nimport \"../libraries/SafeMathInt256.sol\";\r\nimport \"@chainlink/contracts/src/v0.7/interfaces/AggregatorV3Interface.sol\";\r\nimport \"../libraries/CalculateLinesToBPoolOdds.sol\";\r\nimport \"../libraries/Versioned.sol\";\r\nimport \"../libraries/ManagedByLink.sol\";\r\n\r\ncontract CryptoCurrencyMarketFactoryV3 is AbstractMarketFactoryV3, CalculateLinesToBPoolOdds, Versioned, ManagedByLink {\r\n    using SafeMathUint256 for uint256;\r\n    using SafeMathInt256 for int256;\r\n\r\n    event CoinAdded(uint256 indexed id, string name);\r\n    event ValueUpdate(uint256 indexed coinIndex, uint256 indexed resolutionTime, uint256 market, uint256 value);\r\n\r\n    enum Outcome {\r\n        Above, // 0\r\n        NotAbove // 1\r\n    }\r\n    string constant Above = \"Above\";\r\n    string constant NotAbove = \"Not Above\";\r\n\r\n    struct Coin {\r\n        string name;\r\n        AggregatorV3Interface feed;\r\n        uint256 value;\r\n        uint8 imprecision; // how many decimals to truncate\r\n        uint256 currentMarket; // 0 indicates no current market\r\n    }\r\n    Coin[] public coins;\r\n\r\n    struct MarketDetails {\r\n        uint256 coinIndex;\r\n        uint256 creationValue;\r\n        uint256 resolutionValue;\r\n        uint256 resolutionTime; // value at given time; this is that time\r\n    }\r\n    // MarketId => MarketDetails\r\n    mapping(uint256 => MarketDetails) internal marketDetails;\r\n\r\n    constructor(\r\n        address _owner,\r\n        IERC20Full _collateral,\r\n        uint256 _shareFactor,\r\n        FeePot _feePot,\r\n        uint256[3] memory _fees,\r\n        address _protocol,\r\n        address _linkNode\r\n    )\r\n        AbstractMarketFactoryV3(_owner, _collateral, _shareFactor, _feePot, _fees, _protocol)\r\n        Versioned(\"v1.3.3\")\r\n        ManagedByLink(_linkNode)\r\n    {\r\n        string memory _name = \"\";\r\n        coins.push(makeCoin(_name, AggregatorV3Interface(0), 0));\r\n    }\r\n\r\n    function getMarketDetails(uint256 _marketId) public view returns (MarketDetails memory) {\r\n        return marketDetails[_marketId];\r\n    }\r\n\r\n    // NOTE: Trusts the owner not to add a coin twice.\r\n    function addCoin(\r\n        string calldata _name,\r\n        AggregatorV3Interface _feed,\r\n        uint8 _imprecision\r\n    ) external onlyOwner returns (uint256 _coinIndex) {\r\n        Coin memory _coin = makeCoin(_name, _feed, _imprecision);\r\n        _coinIndex = coins.length;\r\n        coins.push(_coin);\r\n        emit CoinAdded(_coinIndex, _name);\r\n    }\r\n\r\n    function getCoin(uint256 _coinIndex) public view returns (Coin memory _coin) {\r\n        _coin = coins[_coinIndex];\r\n    }\r\n\r\n    function getCoins() public view returns (Coin[] memory _coins) {\r\n        _coins = new Coin[](coins.length);\r\n        // Skip first coin because it's always the zeroed-out fake coin.\r\n        for (uint256 i = 1; i < coins.length; i++) {\r\n            _coins[i] = coins[i];\r\n        }\r\n    }\r\n\r\n    // If _resolutionTime is 0 then do NOT create.\r\n    // If _roundId is 0 then do NOT resolve.\r\n    function pokeCoin(\r\n        uint256 _coinIndex,\r\n        uint256 _resolutionTime,\r\n        uint80 _roundId\r\n    ) public onlyLinkNode {\r\n        Coin storage _coin = coins[_coinIndex];\r\n\r\n        // There's a market to resolve.\r\n        if (_roundId != 0 && _coin.currentMarket != 0) {\r\n            resolveMarket(_coin, _roundId);\r\n        }\r\n\r\n        // Create a market\r\n        if (_resolutionTime != 0 && _coin.currentMarket == 0) {\r\n            createMarket(_coinIndex, _coin, _resolutionTime);\r\n        }\r\n    }\r\n\r\n    function createMarket(\r\n        uint256 _coinIndex,\r\n        Coin storage _coin,\r\n        uint256 _resolutionTime\r\n    ) internal returns (uint256 _marketId) {\r\n        (, uint256 _newValue) = getLatestValue(_coin);\r\n\r\n        string[] memory _outcomes = new string[](2);\r\n        _outcomes[uint256(Outcome.Above)] = Above;\r\n        _outcomes[uint256(Outcome.NotAbove)] = NotAbove;\r\n\r\n        _marketId = startMarket(linkNode, _outcomes, evenOdds(false, 2), true);\r\n        marketDetails[_marketId] = MarketDetails(_coinIndex, _newValue, 0, _resolutionTime);\r\n        _coin.currentMarket = _marketId;\r\n        _coin.value = _newValue;\r\n        emit ValueUpdate(_coinIndex, _resolutionTime, _marketId, _newValue);\r\n    }\r\n\r\n    function resolveMarket(Coin storage _coin, uint80 _roundId) internal {\r\n        uint256 _resolutionTime = marketDetails[_coin.currentMarket].resolutionTime;\r\n        (uint256 _fullValue, uint256 _newValue) = getSpecificValue(_coin, _roundId, _resolutionTime);\r\n\r\n        uint256 _winningOutcome;\r\n        if (_newValue > _coin.value) {\r\n            _winningOutcome = uint256(Outcome.Above);\r\n        } else {\r\n            _winningOutcome = uint256(Outcome.NotAbove);\r\n        }\r\n\r\n        endMarket(_coin.currentMarket, _winningOutcome);\r\n        marketDetails[_coin.currentMarket].resolutionValue = _fullValue;\r\n        _coin.currentMarket = 0;\r\n        _coin.value = 0;\r\n    }\r\n\r\n    function getLatestValue(Coin storage _coin) internal view returns (uint256 _fullValue, uint256 _truncatedValue) {\r\n        (, int256 _rawValue, , , ) = _coin.feed.latestRoundData();\r\n        require(_rawValue >= 0, \"Value from feed is negative\");\r\n        _fullValue = uint256(_rawValue);\r\n        _truncatedValue = calcTruncatedValue(_coin, _fullValue);\r\n    }\r\n\r\n    // Get value at a specific round, but fail if it isn't after a specific time.\r\n    function getSpecificValue(\r\n        Coin storage _coin,\r\n        uint80 _roundId,\r\n        uint256 _resolutionTime\r\n    ) internal view returns (uint256 _fullValue, uint256 _truncatedValue) {\r\n        (, int256 _rawValue, , uint256 _updatedAt, ) = _coin.feed.getRoundData(_roundId);\r\n        require(_rawValue >= 0, \"Value from feed is negative\");\r\n        require(_updatedAt >= _resolutionTime, \"Value hasn't been updated yet\");\r\n\r\n        (, , , uint256 _previousRoundTime, ) = _coin.feed.getRoundData(previousRound(_roundId));\r\n        require(_previousRoundTime < _resolutionTime, \"Must use first round after resolution time\");\r\n\r\n        _fullValue = uint256(_rawValue);\r\n        _truncatedValue = calcTruncatedValue(_coin, _fullValue);\r\n    }\r\n\r\n    // The precision is how many decimals the value has. Zero is dollars, 2 includes cents, 3 is tenths of a cent, etc.\r\n    // Our resolution rules want a certain precision. Like BTC is to the dollar and MATIC is to the cent.\r\n    // If somehow the decimals are larger than the desired precision then add zeroes to the end to meet the precision.\r\n    // This does not change the resolution outcome but does guard against decimals() changing and therefore altering the basis.\r\n    function calcTruncatedValue(Coin storage _coin, uint256 _fullValue)\r\n        internal\r\n        view\r\n        returns (uint256 _truncatedValue)\r\n    {\r\n        uint8 _precision = _coin.feed.decimals(); // probably constant but that isn't guaranteed, so query each time\r\n        if (_precision > _coin.imprecision) {\r\n            uint8 _truncate = _precision - _coin.imprecision;\r\n            _truncatedValue = _fullValue / (10**_truncate);\r\n        } else if (_precision < _coin.imprecision) {\r\n            uint8 _greaten = _coin.imprecision - _precision;\r\n            _truncatedValue = _fullValue * (10**_greaten);\r\n        } else {\r\n            _truncatedValue = _fullValue;\r\n        }\r\n\r\n        // Round up because that cleanly fits Above/Not-Above.\r\n        if (_truncatedValue != _fullValue) {\r\n            _truncatedValue += 1;\r\n        }\r\n    }\r\n\r\n    function makeCoin(\r\n        string memory _name,\r\n        AggregatorV3Interface _feed,\r\n        uint8 _imprecision\r\n    ) internal pure returns (Coin memory _coin) {\r\n        _coin = Coin(_name, _feed, 0, _imprecision, 0);\r\n    }\r\n\r\n    // The roundId is the encoding of two parts: the phase and the phase-specific round id.\r\n    // To find the previous roundId:\r\n    // 1. extract the phase and phase-specific round (I call these _phaseId and _roundId)\r\n    // 2. decrement the phase-specific round\r\n    // 3. re-encode the phase and phase-specific round.\r\n    uint256 private constant PHASE_OFFSET = 64;\r\n\r\n    function previousRound(uint80 _fullRoundId) internal pure returns (uint80) {\r\n        uint256 _phaseId = uint256(uint16(_fullRoundId >> PHASE_OFFSET));\r\n        uint64 _roundId = uint64(_fullRoundId) - 1;\r\n        return uint80((_phaseId << PHASE_OFFSET) | _roundId);\r\n    }\r\n\r\n    function getRewardEndTime(uint256 _marketId) public view override returns (uint256) {\r\n        return getMarketDetails(_marketId).resolutionTime;\r\n    }\r\n}\r\n"
    },
    "contracts/turbo/TrustedMarketFactoryV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.7.6;\r\npragma abicoder v2;\r\n\r\nimport \"./AbstractMarketFactoryV3.sol\";\r\nimport \"../libraries/CalculateLinesToBPoolOdds.sol\";\r\nimport \"../libraries/Versioned.sol\";\r\n\r\ncontract TrustedMarketFactoryV3 is AbstractMarketFactoryV3, CalculateLinesToBPoolOdds, Versioned {\r\n    using SafeMathUint256 for uint256;\r\n\r\n    struct MarketDetails {\r\n        string description;\r\n    }\r\n    MarketDetails[] internal marketDetails;\r\n\r\n    constructor(\r\n        address _owner,\r\n        IERC20Full _collateral,\r\n        uint256 _shareFactor,\r\n        FeePot _feePot,\r\n        uint256[3] memory _fees,\r\n        address _protocol\r\n    ) AbstractMarketFactoryV3(_owner, _collateral, _shareFactor, _feePot, _fees, _protocol) Versioned(\"v1.1.0\") {}\r\n\r\n    function createMarket(\r\n        address _creator,\r\n        string calldata _description,\r\n        string[] calldata _names,\r\n        uint256[] calldata _odds\r\n    ) public onlyOwner returns (uint256) {\r\n        marketDetails.push(MarketDetails(_description));\r\n        return startMarket(_creator, _names, _odds, true);\r\n    }\r\n\r\n    function trustedResolveMarket(uint256 _id, uint256 _winningOutcome) public onlyOwner {\r\n        endMarket(_id, _winningOutcome);\r\n    }\r\n\r\n    function getMarketDetails(uint256 _id) public view returns (MarketDetails memory) {\r\n        return marketDetails[_id];\r\n    }\r\n\r\n    function getRewardEndTime(uint256 _marketId) public view override returns (uint256) {\r\n        return 0;\r\n    }\r\n}\r\n"
    },
    "contracts/turbo/Fetcher.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.7.6;\r\npragma abicoder v2;\r\n\r\nimport \"../libraries/IERC20Full.sol\";\r\nimport \"../balancer/BPool.sol\";\r\nimport \"./AbstractMarketFactoryV3.sol\";\r\nimport \"./FeePot.sol\";\r\nimport \"../libraries/SafeMathInt256.sol\";\r\nimport \"./MMAMarketFactoryV3.sol\";\r\nimport \"./AMMFactory.sol\";\r\nimport \"./CryptoMarketFactoryV3.sol\";\r\nimport \"./NBAMarketFactoryV3.sol\";\r\nimport \"../rewards/MasterChef.sol\";\r\nimport \"./CryptoCurrencyMarketFactoryV3.sol\";\r\nimport \"./TrustedMarketFactoryV3.sol\";\r\n\r\n// Helper contract for grabbing huge amounts of data without overloading multicall.\r\nabstract contract Fetcher {\r\n    using SafeMathUint256 for uint256;\r\n    using SafeMathInt256 for int256;\r\n\r\n    struct CollateralBundle {\r\n        address addr;\r\n        string symbol;\r\n        uint256 decimals;\r\n    }\r\n\r\n    struct MarketFactoryBundle {\r\n        uint256 shareFactor;\r\n        uint256 stakerFee;\r\n        uint256 settlementFee;\r\n        uint256 protocolFee;\r\n        FeePot feePot;\r\n        CollateralBundle collateral;\r\n        uint256 marketCount;\r\n    }\r\n\r\n    struct PoolBundle {\r\n        address addr;\r\n        uint256[] tokenRatios;\r\n        uint256[] balances;\r\n        uint256[] weights;\r\n        uint256 swapFee;\r\n        uint256 totalSupply;\r\n    }\r\n\r\n    struct StaticMarketBundle {\r\n        AbstractMarketFactoryV3 factory;\r\n        uint256 marketId;\r\n        PoolBundle pool;\r\n        MasterChef.PoolStatusInfo rewards;\r\n        OwnedERC20[] shareTokens;\r\n        uint256 creationTimestamp;\r\n        OwnedERC20 winner;\r\n        uint256[] initialOdds;\r\n    }\r\n\r\n    struct DynamicMarketBundle {\r\n        AbstractMarketFactoryV3 factory;\r\n        uint256 marketId;\r\n        PoolBundle pool;\r\n        OwnedERC20 winner;\r\n    }\r\n\r\n    string public marketType;\r\n    string public version;\r\n\r\n    constructor(string memory _type, string memory _version) {\r\n        marketType = _type;\r\n        version = _version;\r\n    }\r\n\r\n    function buildCollateralBundle(IERC20Full _collateral) internal view returns (CollateralBundle memory _bundle) {\r\n        _bundle.addr = address(_collateral);\r\n        _bundle.symbol = _collateral.symbol();\r\n        _bundle.decimals = _collateral.decimals();\r\n    }\r\n\r\n    function buildMarketFactoryBundle(AbstractMarketFactoryV3 _marketFactory)\r\n        internal\r\n        view\r\n        returns (MarketFactoryBundle memory _bundle)\r\n    {\r\n        _bundle.shareFactor = _marketFactory.shareFactor();\r\n        _bundle.stakerFee = _marketFactory.stakerFee();\r\n        _bundle.settlementFee = _marketFactory.settlementFee();\r\n        _bundle.protocolFee = _marketFactory.protocolFee();\r\n        _bundle.feePot = _marketFactory.feePot();\r\n        _bundle.collateral = buildCollateralBundle(_marketFactory.collateral());\r\n        _bundle.marketCount = _marketFactory.marketCount();\r\n    }\r\n\r\n    function buildStaticMarketBundle(\r\n        AbstractMarketFactoryV3 _marketFactory,\r\n        AMMFactory _ammFactory,\r\n        MasterChef _masterChef,\r\n        uint256 _marketId\r\n    ) internal view returns (StaticMarketBundle memory _bundle) {\r\n        AbstractMarketFactoryV3.Market memory _market = _marketFactory.getMarket(_marketId);\r\n        _bundle.factory = _marketFactory;\r\n        _bundle.marketId = _marketId;\r\n        _bundle.pool = buildPoolBundle(_marketFactory, _ammFactory, _marketId);\r\n        _bundle.rewards = _masterChef.getPoolInfo(_ammFactory, _marketFactory, _marketId);\r\n        _bundle.shareTokens = _market.shareTokens;\r\n        _bundle.creationTimestamp = _market.creationTimestamp;\r\n        _bundle.winner = _market.winner;\r\n        _bundle.initialOdds = _market.initialOdds;\r\n    }\r\n\r\n    function buildDynamicMarketBundle(\r\n        AbstractMarketFactoryV3 _marketFactory,\r\n        AMMFactory _ammFactory,\r\n        uint256 _marketId\r\n    ) internal view returns (DynamicMarketBundle memory _bundle) {\r\n        AbstractMarketFactoryV3.Market memory _market = _marketFactory.getMarket(_marketId);\r\n\r\n        _bundle.factory = _marketFactory;\r\n        _bundle.marketId = _marketId;\r\n        _bundle.winner = _market.winner;\r\n        _bundle.pool = buildPoolBundle(_marketFactory, _ammFactory, _marketId);\r\n    }\r\n\r\n    function buildPoolBundle(\r\n        AbstractMarketFactoryV3 _marketFactory,\r\n        AMMFactory _ammFactory,\r\n        uint256 _marketId\r\n    ) internal view returns (PoolBundle memory _bundle) {\r\n        BPool _pool = _ammFactory.getPool(_marketFactory, _marketId);\r\n        if (_pool == BPool(address(0))) return _bundle;\r\n\r\n        _bundle.addr = address(_pool);\r\n        _bundle.totalSupply = _pool.totalSupply();\r\n        _bundle.swapFee = _ammFactory.getSwapFee(_marketFactory, _marketId);\r\n        _bundle.balances = _ammFactory.getPoolBalances(_marketFactory, _marketId);\r\n        _bundle.tokenRatios = _ammFactory.tokenRatios(_marketFactory, _marketId);\r\n        _bundle.weights = _ammFactory.getPoolWeights(_marketFactory, _marketId);\r\n    }\r\n\r\n    function openOrHasWinningShares(AbstractMarketFactoryV3 _marketFactory, uint256 _marketId)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        AbstractMarketFactoryV3.Market memory _market = _marketFactory.getMarket(_marketId);\r\n        if (_market.winner == OwnedERC20(address(0))) return true; // open\r\n        return _market.winner.totalSupply() > 0; // has winning shares\r\n    }\r\n}\r\n\r\nabstract contract SportsFetcher is Fetcher {\r\n    struct SpecificMarketFactoryBundle {\r\n        MarketFactoryBundle super;\r\n    }\r\n\r\n    struct StaticEventBundle {\r\n        uint256 id;\r\n        StaticMarketBundle[] markets;\r\n        int256[] lines;\r\n        uint256 estimatedStartTime;\r\n        uint256 homeTeamId;\r\n        uint256 awayTeamId;\r\n        string homeTeamName;\r\n        string awayTeamName;\r\n        // Dynamics\r\n        Sport.SportsEventStatus status;\r\n        uint256 homeScore;\r\n        uint256 awayScore;\r\n    }\r\n\r\n    struct DynamicEventBundle {\r\n        uint256 id;\r\n        Sport.SportsEventStatus status;\r\n        DynamicMarketBundle[] markets;\r\n        uint256 homeScore;\r\n        uint256 awayScore;\r\n    }\r\n\r\n    function buildSpecificMarketFactoryBundle(address _marketFactory)\r\n        internal\r\n        view\r\n        returns (SpecificMarketFactoryBundle memory _bundle)\r\n    {\r\n        _bundle.super = buildMarketFactoryBundle(AbstractMarketFactoryV3(_marketFactory));\r\n    }\r\n\r\n    function fetchInitial(\r\n        address _marketFactory,\r\n        AMMFactory _ammFactory,\r\n        MasterChef _masterChef,\r\n        uint256 _offset,\r\n        uint256 _total\r\n    )\r\n        public\r\n        view\r\n        returns (\r\n            SpecificMarketFactoryBundle memory _marketFactoryBundle,\r\n            StaticEventBundle[] memory _eventBundles,\r\n            uint256 _lowestEventIndex,\r\n            uint256 _timestamp\r\n        )\r\n    {\r\n        _marketFactoryBundle = buildSpecificMarketFactoryBundle(_marketFactory);\r\n        (_eventBundles, _lowestEventIndex) = buildStaticEventBundles(\r\n            _marketFactory,\r\n            _ammFactory,\r\n            _masterChef,\r\n            _offset,\r\n            _total\r\n        );\r\n        _timestamp = block.timestamp;\r\n    }\r\n\r\n    function fetchDynamic(\r\n        address _marketFactory,\r\n        AMMFactory _ammFactory,\r\n        uint256 _offset,\r\n        uint256 _total\r\n    )\r\n        public\r\n        view\r\n        returns (\r\n            DynamicEventBundle[] memory _bundles,\r\n            uint256 _lowestEventIndex,\r\n            uint256 _timestamp\r\n        )\r\n    {\r\n        (_bundles, _lowestEventIndex) = buildDynamicEventBundles(_marketFactory, _ammFactory, _offset, _total);\r\n        _timestamp = block.timestamp;\r\n    }\r\n\r\n    function buildStaticEventBundles(\r\n        address _marketFactory,\r\n        AMMFactory _ammFactory,\r\n        MasterChef _masterChef,\r\n        uint256 _offset,\r\n        uint256 _total\r\n    ) internal view returns (StaticEventBundle[] memory _bundles, uint256 _lowestEventIndex) {\r\n        uint256[] memory _eventIds;\r\n        (_eventIds, _lowestEventIndex) = listOfInterestingEvents(_marketFactory, _offset, _total);\r\n\r\n        _total = _eventIds.length;\r\n        _bundles = new StaticEventBundle[](_total);\r\n        for (uint256 i; i < _total; i++) {\r\n            _bundles[i] = buildStaticEventBundle(_marketFactory, _ammFactory, _masterChef, _eventIds[i]);\r\n        }\r\n    }\r\n\r\n    function buildDynamicEventBundles(\r\n        address _marketFactory,\r\n        AMMFactory _ammFactory,\r\n        uint256 _offset,\r\n        uint256 _total\r\n    ) internal view returns (DynamicEventBundle[] memory _bundles, uint256 _lowestEventIndex) {\r\n        uint256[] memory _eventIds;\r\n        (_eventIds, _lowestEventIndex) = listOfInterestingEvents(_marketFactory, _offset, _total);\r\n\r\n        _total = _eventIds.length;\r\n        _bundles = new DynamicEventBundle[](_total);\r\n        for (uint256 i; i < _total; i++) {\r\n            _bundles[i] = buildDynamicEventBundle(_marketFactory, _ammFactory, _eventIds[i]);\r\n        }\r\n    }\r\n\r\n    function buildStaticEventBundle(\r\n        address _marketFactory,\r\n        AMMFactory _ammFactory,\r\n        MasterChef _masterChef,\r\n        uint256 _eventId\r\n    ) internal view returns (StaticEventBundle memory _bundle) {\r\n        Sport.SportsEvent memory _event = Sport(_marketFactory).getSportsEvent(_eventId);\r\n\r\n        StaticMarketBundle[] memory _markets = new StaticMarketBundle[](_event.markets.length);\r\n        for (uint256 i = 0; i < _markets.length; i++) {\r\n            _markets[i] = buildStaticMarketBundle(\r\n                AbstractMarketFactoryV3(_marketFactory),\r\n                _ammFactory,\r\n                _masterChef,\r\n                _event.markets[i]\r\n            );\r\n        }\r\n\r\n        _bundle.id = _eventId;\r\n        _bundle.status = _event.status;\r\n        _bundle.markets = _markets;\r\n        _bundle.lines = _event.lines;\r\n        _bundle.estimatedStartTime = _event.estimatedStartTime;\r\n        _bundle.homeTeamId = _event.homeTeamId;\r\n        _bundle.awayTeamId = _event.awayTeamId;\r\n        _bundle.homeTeamName = _event.homeTeamName;\r\n        _bundle.awayTeamName = _event.awayTeamName;\r\n        _bundle.homeScore = _event.homeScore;\r\n        _bundle.awayScore = _event.awayScore;\r\n    }\r\n\r\n    function buildDynamicEventBundle(\r\n        address _marketFactory,\r\n        AMMFactory _ammFactory,\r\n        uint256 _eventId\r\n    ) internal view returns (DynamicEventBundle memory _bundle) {\r\n        Sport.SportsEvent memory _event = Sport(_marketFactory).getSportsEvent(_eventId);\r\n\r\n        DynamicMarketBundle[] memory _markets = new DynamicMarketBundle[](_event.markets.length);\r\n        for (uint256 i = 0; i < _markets.length; i++) {\r\n            _markets[i] = buildDynamicMarketBundle(\r\n                AbstractMarketFactoryV3(_marketFactory),\r\n                _ammFactory,\r\n                _event.markets[i]\r\n            );\r\n        }\r\n\r\n        _bundle.id = _eventId;\r\n        _bundle.markets = _markets;\r\n        _bundle.status = _event.status;\r\n        _bundle.homeScore = _event.homeScore;\r\n        _bundle.awayScore = _event.awayScore;\r\n    }\r\n\r\n    // Starts from the end of the events list because newer events are more interesting.\r\n    // _offset is skipping all events, not just interesting events\r\n    function listOfInterestingEvents(\r\n        address _marketFactory,\r\n        uint256 _offset,\r\n        uint256 _total\r\n    ) internal view returns (uint256[] memory _interestingEventIds, uint256 _eventIndex) {\r\n        _interestingEventIds = new uint256[](_total);\r\n\r\n        uint256 _eventCount = Sport(_marketFactory).eventCount();\r\n\r\n        // No events so return nothing. (needed to avoid integer underflow below)\r\n        if (_eventCount == 0) {\r\n            return (new uint256[](0), 0);\r\n        }\r\n\r\n        uint256 _max = _eventCount;\r\n\r\n        // No remaining events so return nothing. (needed to avoid integer underflow below)\r\n        if (_offset > _max) {\r\n            return (new uint256[](0), 0);\r\n        }\r\n\r\n        uint256 _collectedEvents = 0;\r\n        _eventIndex = _max - _offset;\r\n        while (true) {\r\n            if (_collectedEvents >= _total) break;\r\n            if (_eventIndex == 0) break;\r\n\r\n            _eventIndex--; // starts out one too high, so this works\r\n\r\n            (Sport.SportsEvent memory _event, uint256 _eventId) =\r\n                Sport(_marketFactory).getSportsEventByIndex(_eventIndex);\r\n\r\n            if (isEventInteresting(_event, AbstractMarketFactoryV3(_marketFactory))) {\r\n                _interestingEventIds[_collectedEvents] = _eventId;\r\n                _collectedEvents++;\r\n            }\r\n        }\r\n\r\n        if (_total > _collectedEvents) {\r\n            assembly {\r\n                // shortens array\r\n                mstore(_interestingEventIds, _collectedEvents)\r\n            }\r\n        }\r\n    }\r\n\r\n    function isEventInteresting(Sport.SportsEvent memory _event, AbstractMarketFactoryV3 _marketFactory)\r\n        private\r\n        view\r\n        returns (bool)\r\n    {\r\n        for (uint256 i = 0; i < _event.markets.length; i++) {\r\n            uint256 _marketId = _event.markets[i];\r\n            if (openOrHasWinningShares(_marketFactory, _marketId)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n}\r\n\r\ncontract NBAFetcher is SportsFetcher {\r\n    constructor() Fetcher(\"NBA\", \"TBD\") {}\r\n}\r\n\r\ncontract MLBFetcher is SportsFetcher {\r\n    constructor() Fetcher(\"MLB\", \"TBD\") {}\r\n}\r\n\r\ncontract MMAFetcher is SportsFetcher {\r\n    constructor() Fetcher(\"MMA\", \"TBD\") {}\r\n}\r\n\r\ncontract NFLFetcher is SportsFetcher {\r\n    constructor() Fetcher(\"NFL\", \"TBD\") {}\r\n}\r\n\r\ncontract CryptoFetcher is Fetcher {\r\n    constructor() Fetcher(\"Crypto\", \"TBD\") {}\r\n\r\n    struct SpecificMarketFactoryBundle {\r\n        MarketFactoryBundle super;\r\n    }\r\n\r\n    struct SpecificStaticMarketBundle {\r\n        StaticMarketBundle super;\r\n        uint8 marketType;\r\n        uint256 coinIndex;\r\n        uint256 creationPrice;\r\n        uint256 resolutionTime;\r\n        // Dynamics\r\n        uint256 resolutionPrice;\r\n    }\r\n\r\n    struct SpecificDynamicMarketBundle {\r\n        DynamicMarketBundle super;\r\n        uint256 resolutionPrice;\r\n    }\r\n\r\n    function buildSpecificMarketFactoryBundle(address _marketFactory)\r\n        internal\r\n        view\r\n        returns (SpecificMarketFactoryBundle memory _bundle)\r\n    {\r\n        _bundle.super = buildMarketFactoryBundle(CryptoMarketFactoryV3(_marketFactory));\r\n    }\r\n\r\n    function buildSpecificStaticMarketBundle(\r\n        address _marketFactory,\r\n        AMMFactory _ammFactory,\r\n        MasterChef _masterChef,\r\n        uint256 _marketId\r\n    ) internal view returns (SpecificStaticMarketBundle memory _bundle) {\r\n        CryptoMarketFactoryV3.MarketDetails memory _details =\r\n            CryptoMarketFactoryV3(_marketFactory).getMarketDetails(_marketId);\r\n        _bundle.super = buildStaticMarketBundle(\r\n            CryptoMarketFactoryV3(_marketFactory),\r\n            _ammFactory,\r\n            _masterChef,\r\n            _marketId\r\n        );\r\n        _bundle.marketType = uint8(_details.marketType);\r\n        _bundle.creationPrice = _details.creationPrice;\r\n        _bundle.coinIndex = _details.coinIndex;\r\n        _bundle.resolutionPrice = _details.resolutionPrice;\r\n        _bundle.resolutionTime = _details.resolutionTime;\r\n    }\r\n\r\n    function buildSpecificDynamicMarketBundle(\r\n        address _marketFactory,\r\n        AMMFactory _ammFactory,\r\n        uint256 _marketId\r\n    ) internal view returns (SpecificDynamicMarketBundle memory _bundle) {\r\n        CryptoMarketFactoryV3.MarketDetails memory _details =\r\n            CryptoMarketFactoryV3(_marketFactory).getMarketDetails(_marketId);\r\n        _bundle.super = buildDynamicMarketBundle(CryptoMarketFactoryV3(_marketFactory), _ammFactory, _marketId);\r\n        _bundle.resolutionPrice = _details.resolutionPrice;\r\n    }\r\n\r\n    function fetchInitial(\r\n        address _marketFactory,\r\n        AMMFactory _ammFactory,\r\n        MasterChef _masterChef,\r\n        uint256 _offset,\r\n        uint256 _total\r\n    )\r\n        public\r\n        view\r\n        returns (\r\n            SpecificMarketFactoryBundle memory _marketFactoryBundle,\r\n            SpecificStaticMarketBundle[] memory _marketBundles,\r\n            uint256 _lowestMarketIndex,\r\n            uint256 _timestamp\r\n        )\r\n    {\r\n        _marketFactoryBundle = buildSpecificMarketFactoryBundle(_marketFactory);\r\n\r\n        uint256[] memory _marketIds;\r\n        (_marketIds, _lowestMarketIndex) = listOfInterestingMarkets(_marketFactory, _offset, _total);\r\n\r\n        _total = _marketIds.length;\r\n        _marketBundles = new SpecificStaticMarketBundle[](_total);\r\n        for (uint256 i; i < _total; i++) {\r\n            _marketBundles[i] = buildSpecificStaticMarketBundle(\r\n                _marketFactory,\r\n                _ammFactory,\r\n                _masterChef,\r\n                _marketIds[i]\r\n            );\r\n        }\r\n\r\n        _timestamp = block.timestamp;\r\n    }\r\n\r\n    function fetchDynamic(\r\n        address _marketFactory,\r\n        AMMFactory _ammFactory,\r\n        uint256 _offset,\r\n        uint256 _total\r\n    )\r\n        public\r\n        view\r\n        returns (\r\n            SpecificDynamicMarketBundle[] memory _bundles,\r\n            uint256 _lowestMarketIndex,\r\n            uint256 _timestamp\r\n        )\r\n    {\r\n        uint256[] memory _marketIds;\r\n        (_marketIds, _lowestMarketIndex) = listOfInterestingMarkets(_marketFactory, _offset, _total);\r\n\r\n        _total = _marketIds.length;\r\n        _bundles = new SpecificDynamicMarketBundle[](_total);\r\n        for (uint256 i; i < _total; i++) {\r\n            _bundles[i] = buildSpecificDynamicMarketBundle(_marketFactory, _ammFactory, _marketIds[i]);\r\n        }\r\n\r\n        _timestamp = block.timestamp;\r\n    }\r\n\r\n    // Starts from the end of the markets list because newer markets are more interesting.\r\n    // _offset is skipping all markets, not just interesting markets\r\n    function listOfInterestingMarkets(\r\n        address _marketFactory,\r\n        uint256 _offset,\r\n        uint256 _total\r\n    ) internal view returns (uint256[] memory _interestingMarketIds, uint256 _marketId) {\r\n        _interestingMarketIds = new uint256[](_total);\r\n        uint256 _max = AbstractMarketFactoryV3(_marketFactory).marketCount() - 1;\r\n\r\n        // No markets so return nothing. (needed to prevent integer underflow below)\r\n        if (_max == 0 || _offset >= _max) {\r\n            return (new uint256[](0), 0);\r\n        }\r\n\r\n        // Starts at the end, less offset.\r\n        // Stops before the 0th market since that market is always fake.\r\n        uint256 _collectedMarkets = 0;\r\n        _marketId = _max - _offset;\r\n\r\n        while (true) {\r\n            if (openOrHasWinningShares(AbstractMarketFactoryV3(_marketFactory), _marketId)) {\r\n                _interestingMarketIds[_collectedMarkets] = _marketId;\r\n                _collectedMarkets++;\r\n            }\r\n\r\n            if (_collectedMarkets >= _total) break;\r\n            if (_marketId == 1) break; // skipping 0th market, which is fake\r\n            _marketId--; // starts out oone too high, so this works\r\n        }\r\n\r\n        if (_total > _collectedMarkets) {\r\n            assembly {\r\n                // shortens array\r\n                mstore(_interestingMarketIds, _collectedMarkets)\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ncontract CryptoCurrencyFetcher is Fetcher {\r\n    constructor() Fetcher(\"CryptoCurrency\", \"TBD\") {}\r\n\r\n    struct SpecificMarketFactoryBundle {\r\n        MarketFactoryBundle super;\r\n    }\r\n\r\n    struct SpecificStaticMarketBundle {\r\n        StaticMarketBundle super;\r\n        uint256 coinIndex;\r\n        uint256 creationValue;\r\n        uint256 resolutionTime;\r\n        // Dynamics\r\n        uint256 resolutionValue;\r\n    }\r\n\r\n    struct SpecificDynamicMarketBundle {\r\n        DynamicMarketBundle super;\r\n        uint256 resolutionValue;\r\n    }\r\n\r\n    function buildSpecificMarketFactoryBundle(address _marketFactory)\r\n        internal\r\n        view\r\n        returns (SpecificMarketFactoryBundle memory _bundle)\r\n    {\r\n        _bundle.super = buildMarketFactoryBundle(CryptoCurrencyMarketFactoryV3(_marketFactory));\r\n    }\r\n\r\n    function buildSpecificStaticMarketBundle(\r\n        address _marketFactory,\r\n        AMMFactory _ammFactory,\r\n        MasterChef _masterChef,\r\n        uint256 _marketId\r\n    ) internal view returns (SpecificStaticMarketBundle memory _bundle) {\r\n        CryptoCurrencyMarketFactoryV3.MarketDetails memory _details =\r\n            CryptoCurrencyMarketFactoryV3(_marketFactory).getMarketDetails(_marketId);\r\n        _bundle.super = buildStaticMarketBundle(\r\n            CryptoCurrencyMarketFactoryV3(_marketFactory),\r\n            _ammFactory,\r\n            _masterChef,\r\n            _marketId\r\n        );\r\n        _bundle.creationValue = _details.creationValue;\r\n        _bundle.coinIndex = _details.coinIndex;\r\n        _bundle.resolutionValue = _details.resolutionValue;\r\n        _bundle.resolutionTime = _details.resolutionTime;\r\n    }\r\n\r\n    function buildSpecificDynamicMarketBundle(\r\n        address _marketFactory,\r\n        AMMFactory _ammFactory,\r\n        uint256 _marketId\r\n    ) internal view returns (SpecificDynamicMarketBundle memory _bundle) {\r\n        CryptoCurrencyMarketFactoryV3.MarketDetails memory _details =\r\n            CryptoCurrencyMarketFactoryV3(_marketFactory).getMarketDetails(_marketId);\r\n        _bundle.super = buildDynamicMarketBundle(CryptoCurrencyMarketFactoryV3(_marketFactory), _ammFactory, _marketId);\r\n        _bundle.resolutionValue = _details.resolutionValue;\r\n    }\r\n\r\n    function fetchInitial(\r\n        address _marketFactory,\r\n        AMMFactory _ammFactory,\r\n        MasterChef _masterChef,\r\n        uint256 _offset,\r\n        uint256 _total\r\n    )\r\n        public\r\n        view\r\n        returns (\r\n            SpecificMarketFactoryBundle memory _marketFactoryBundle,\r\n            SpecificStaticMarketBundle[] memory _marketBundles,\r\n            uint256 _lowestMarketIndex,\r\n            uint256 _timestamp\r\n        )\r\n    {\r\n        _marketFactoryBundle = buildSpecificMarketFactoryBundle(_marketFactory);\r\n\r\n        uint256[] memory _marketIds;\r\n        (_marketIds, _lowestMarketIndex) = listOfInterestingMarkets(_marketFactory, _offset, _total);\r\n\r\n        _total = _marketIds.length;\r\n        _marketBundles = new SpecificStaticMarketBundle[](_total);\r\n        for (uint256 i; i < _total; i++) {\r\n            _marketBundles[i] = buildSpecificStaticMarketBundle(\r\n                _marketFactory,\r\n                _ammFactory,\r\n                _masterChef,\r\n                _marketIds[i]\r\n            );\r\n        }\r\n\r\n        _timestamp = block.timestamp;\r\n    }\r\n\r\n    function fetchDynamic(\r\n        address _marketFactory,\r\n        AMMFactory _ammFactory,\r\n        uint256 _offset,\r\n        uint256 _total\r\n    )\r\n        public\r\n        view\r\n        returns (\r\n            SpecificDynamicMarketBundle[] memory _bundles,\r\n            uint256 _lowestMarketIndex,\r\n            uint256 _timestamp\r\n        )\r\n    {\r\n        uint256[] memory _marketIds;\r\n        (_marketIds, _lowestMarketIndex) = listOfInterestingMarkets(_marketFactory, _offset, _total);\r\n\r\n        _total = _marketIds.length;\r\n        _bundles = new SpecificDynamicMarketBundle[](_total);\r\n        for (uint256 i; i < _total; i++) {\r\n            _bundles[i] = buildSpecificDynamicMarketBundle(_marketFactory, _ammFactory, _marketIds[i]);\r\n        }\r\n\r\n        _timestamp = block.timestamp;\r\n    }\r\n\r\n    // Starts from the end of the markets list because newer markets are more interesting.\r\n    // _offset is skipping all markets, not just interesting markets\r\n    function listOfInterestingMarkets(\r\n        address _marketFactory,\r\n        uint256 _offset,\r\n        uint256 _total\r\n    ) internal view returns (uint256[] memory _interestingMarketIds, uint256 _marketId) {\r\n        _interestingMarketIds = new uint256[](_total);\r\n        uint256 _max = AbstractMarketFactoryV3(_marketFactory).marketCount() - 1;\r\n\r\n        // No markets so return nothing. (needed to prevent integer underflow below)\r\n        if (_max == 0 || _offset >= _max) {\r\n            return (new uint256[](0), 0);\r\n        }\r\n\r\n        // Starts at the end, less offset.\r\n        // Stops before the 0th market since that market is always fake.\r\n        uint256 _collectedMarkets = 0;\r\n        _marketId = _max - _offset;\r\n\r\n        while (true) {\r\n            if (openOrHasWinningShares(AbstractMarketFactoryV3(_marketFactory), _marketId)) {\r\n                _interestingMarketIds[_collectedMarkets] = _marketId;\r\n                _collectedMarkets++;\r\n            }\r\n\r\n            if (_collectedMarkets >= _total) break;\r\n            if (_marketId == 1) break; // skipping 0th market, which is fake\r\n            _marketId--; // starts out oone too high, so this works\r\n        }\r\n\r\n        if (_total > _collectedMarkets) {\r\n            assembly {\r\n                // shortens array\r\n                mstore(_interestingMarketIds, _collectedMarkets)\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// contract TrustedFetcher is Fetcher {\r\n//     constructor() Fetcher(\"Trusted\", \"TBD\") {}\r\n\r\n//     struct SpecificMarketFactoryBundle {\r\n//         MarketFactoryBundle super;\r\n//     }\r\n\r\n//     struct SpecificStaticMarketBundle {\r\n//         StaticMarketBundle super;\r\n//         // uint256 coinIndex;\r\n//         // uint256 creationValue;\r\n//         // uint256 resolutionTime;\r\n//         // // Dynamics\r\n//         // uint256 resolutionValue;\r\n//         string description;\r\n//     }\r\n\r\n//     struct SpecificDynamicMarketBundle {\r\n//         DynamicMarketBundle super;\r\n//         //uint256 resolutionValue;\r\n//         string description;\r\n\r\n//     }\r\n\r\n//     function getMarket(    address _marketFactory,\r\n//         AMMFactory _ammFactory,\r\n//         MasterChef _masterChef,\r\n//         uint256 _marketId) public view returns(   SpecificStaticMarketBundle memory _bundle\r\n// ){\r\n//         TrustedMarketFactoryV3.MarketDetails memory _details =\r\n//             TrustedMarketFactoryV3(_marketFactory).getMarketDetails(_marketId);\r\n//         _bundle.super = buildStaticMarketBundle(\r\n//             TrustedMarketFactoryV3(_marketFactory),\r\n//             _ammFactory,\r\n//             _masterChef,\r\n//             _marketId\r\n//         );\r\n//         _bundle.description = _details.description;\r\n//     }\r\n\r\n//     function buildSpecificMarketFactoryBundle(address _marketFactory)\r\n//         internal\r\n//         view\r\n//         returns (SpecificMarketFactoryBundle memory _bundle)\r\n//     {\r\n//         _bundle.super = buildMarketFactoryBundle(TrustedMarketFactoryV3(_marketFactory));\r\n//     }\r\n\r\n//     function buildSpecificStaticMarketBundle(\r\n//         address _marketFactory,\r\n//         AMMFactory _ammFactory,\r\n//         MasterChef _masterChef,\r\n//         uint256 _marketId\r\n//     ) internal view returns (SpecificStaticMarketBundle memory _bundle) {\r\n//         TrustedMarketFactoryV3.MarketDetails memory _details =\r\n//             TrustedMarketFactoryV3(_marketFactory).getMarketDetails(_marketId);\r\n//         _bundle.super = buildStaticMarketBundle(\r\n//             TrustedMarketFactoryV3(_marketFactory),\r\n//             _ammFactory,\r\n//             _masterChef,\r\n//             _marketId\r\n//         );\r\n//         _bundle.description = _details.description;\r\n//         // _bundle.creationValue = _details.creationValue;\r\n//         // _bundle.coinIndex = _details.coinIndex;\r\n//         // _bundle.resolutionValue = _details.resolutionValue;\r\n//         // _bundle.resolutionTime = _details.resolutionTime;\r\n//     }\r\n\r\n//     function buildSpecificDynamicMarketBundle(\r\n//         address _marketFactory,\r\n//         AMMFactory _ammFactory,\r\n//         uint256 _marketId\r\n//     ) internal view returns (SpecificDynamicMarketBundle memory _bundle) {\r\n//         TrustedMarketFactoryV3.MarketDetails memory _details =\r\n//             TrustedMarketFactoryV3(_marketFactory).getMarketDetails(_marketId);\r\n//         _bundle.super = buildDynamicMarketBundle(TrustedMarketFactoryV3(_marketFactory), _ammFactory, _marketId);\r\n//         _bundle.description = _details.description;\r\n//     }\r\n\r\n//     function fetchInitial(\r\n//         address _marketFactory,\r\n//         AMMFactory _ammFactory,\r\n//         MasterChef _masterChef,\r\n//         uint256 _offset,\r\n//         uint256 _total\r\n//     )\r\n//         public\r\n//         view\r\n//         returns (\r\n//             SpecificMarketFactoryBundle memory _marketFactoryBundle,\r\n//             SpecificStaticMarketBundle[] memory _marketBundles,\r\n//             uint256 _lowestMarketIndex,\r\n//             uint256 _timestamp\r\n//         )\r\n//     {\r\n//         _marketFactoryBundle = buildSpecificMarketFactoryBundle(_marketFactory);\r\n\r\n//         uint256[] memory _marketIds;\r\n//         (_marketIds, _lowestMarketIndex) = listOfInterestingMarkets(_marketFactory, _offset, _total);\r\n\r\n//         _total = _marketIds.length;\r\n//         _marketBundles = new SpecificStaticMarketBundle[](_total);\r\n//         for (uint256 i; i < _total; i++) {\r\n//             _marketBundles[i] = buildSpecificStaticMarketBundle(\r\n//                 _marketFactory,\r\n//                 _ammFactory,\r\n//                 _masterChef,\r\n//                 _marketIds[i]\r\n//             );\r\n//         }\r\n\r\n//         _timestamp = block.timestamp;\r\n//     }\r\n\r\n//     function fetchDynamic(\r\n//         address _marketFactory,\r\n//         AMMFactory _ammFactory,\r\n//         uint256 _offset,\r\n//         uint256 _total\r\n//     )\r\n//         public\r\n//         view\r\n//         returns (\r\n//             SpecificDynamicMarketBundle[] memory _bundles,\r\n//             uint256 _lowestMarketIndex,\r\n//             uint256 _timestamp\r\n//         )\r\n//     {\r\n//         uint256[] memory _marketIds;\r\n//         (_marketIds, _lowestMarketIndex) = listOfInterestingMarkets(_marketFactory, _offset, _total);\r\n\r\n//         _total = _marketIds.length;\r\n//         _bundles = new SpecificDynamicMarketBundle[](_total);\r\n//         for (uint256 i; i < _total; i++) {\r\n//             _bundles[i] = buildSpecificDynamicMarketBundle(_marketFactory, _ammFactory, _marketIds[i]);\r\n//         }\r\n\r\n//         _timestamp = block.timestamp;\r\n//     }\r\n\r\n//     // Starts from the end of the markets list because newer markets are more interesting.\r\n//     // _offset is skipping all markets, not just interesting markets\r\n//     function listOfInterestingMarkets(\r\n//         address _marketFactory,\r\n//         uint256 _offset,\r\n//         uint256 _total\r\n//     ) internal view returns (uint256[] memory _interestingMarketIds, uint256 _marketId) {\r\n//         _interestingMarketIds = new uint256[](_total);\r\n//         uint256 _max = AbstractMarketFactoryV3(_marketFactory).marketCount() - 1;\r\n\r\n//         // No markets so return nothing. (needed to prevent integer underflow below)\r\n//         if (_max == 0 || _offset >= _max) {\r\n//             return (new uint256[](0), 0);\r\n//         }\r\n\r\n//         // Starts at the end, less offset.\r\n//         // Stops before the 0th market since that market is always fake.\r\n//         uint256 _collectedMarkets = 0;\r\n//         _marketId = _max - _offset;\r\n\r\n//         while (true) {\r\n//             if (openOrHasWinningShares(AbstractMarketFactoryV3(_marketFactory), _marketId)) {\r\n//                 _interestingMarketIds[_collectedMarkets] = _marketId;\r\n//                 _collectedMarkets++;\r\n//             }\r\n\r\n//             if (_collectedMarkets >= _total) break;\r\n//             if (_marketId == 1) break; // skipping 0th market, which is fake\r\n//             _marketId--; // starts out oone too high, so this works\r\n//         }\r\n\r\n//         if (_total > _collectedMarkets) {\r\n//             assembly {\r\n//                 // shortens array\r\n//                 mstore(_interestingMarketIds, _collectedMarkets)\r\n//             }\r\n//         }\r\n//     }\r\n// }\r\n"
    },
    "contracts/libraries/Sport.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.7.6;\r\npragma abicoder v2;\r\n\r\nimport \"../turbo/AbstractMarketFactoryV3.sol\";\r\nimport \"./LineHelper.sol\";\r\n\r\nabstract contract Sport is AbstractMarketFactoryV3, LineHelper {\r\n    event SportsEventCreated(\r\n        uint256 id,\r\n        uint256[] markets,\r\n        int256[] lines,\r\n        uint256 homeTeamId,\r\n        uint256 awayTeamId,\r\n        string homeTeamName,\r\n        string awayTeamName,\r\n        uint256 estimatedStartTime\r\n    );\r\n\r\n    enum SportsEventStatus {Unknown, Scheduled, Final, Postponed, Canceled}\r\n    struct SportsEvent {\r\n        SportsEventStatus status;\r\n        uint256[] markets;\r\n        int256[] lines;\r\n        uint256 estimatedStartTime;\r\n        uint256 homeTeamId;\r\n        uint256 awayTeamId;\r\n        string homeTeamName;\r\n        string awayTeamName;\r\n        uint256 homeScore;\r\n        uint256 awayScore;\r\n    }\r\n    // EventId => EventDetails\r\n    mapping(uint256 => SportsEvent) public sportsEvents;\r\n    uint256[] public listOfSportsEvents;\r\n    mapping(uint256 => uint256) public marketIdToEventIdMapping;\r\n    uint256 constant NoContest = 0;\r\n\r\n    function eventCount() public view returns (uint256) {\r\n        return listOfSportsEvents.length;\r\n    }\r\n\r\n    function getSportsEvent(uint256 _eventId) public view returns (SportsEvent memory) {\r\n        return sportsEvents[_eventId];\r\n    }\r\n\r\n    function getSportsEventByIndex(uint256 _index) public view returns (SportsEvent memory _event, uint256 _eventId) {\r\n        _eventId = listOfSportsEvents[_index];\r\n        _event = getSportsEvent(_eventId);\r\n    }\r\n\r\n    function makeSportsEvent(\r\n        uint256 _eventId,\r\n        uint256[] memory _markets,\r\n        int256[] memory _lines,\r\n        uint256 _estimatedStartTime,\r\n        uint256 _homeTeamId,\r\n        uint256 _awayTeamId,\r\n        string memory _homeTeamName,\r\n        string memory _awayTeamName\r\n    ) internal {\r\n        // Cannot create markets for an event twice.\r\n        require(sportsEvents[_eventId].status == SportsEventStatus.Unknown, \"event exists\");\r\n\r\n        for (uint256 i = 0; i < _markets.length; i++) {\r\n            marketIdToEventIdMapping[_markets[i]] = _eventId;\r\n        }\r\n\r\n        listOfSportsEvents.push(_eventId);\r\n        sportsEvents[_eventId].status = SportsEventStatus.Scheduled; // new events must be Scheduled\r\n        sportsEvents[_eventId].markets = _markets;\r\n        sportsEvents[_eventId].lines = _lines;\r\n        sportsEvents[_eventId].estimatedStartTime = _estimatedStartTime;\r\n        sportsEvents[_eventId].homeTeamId = _homeTeamId;\r\n        sportsEvents[_eventId].awayTeamId = _awayTeamId;\r\n        sportsEvents[_eventId].homeTeamName = _homeTeamName;\r\n        sportsEvents[_eventId].awayTeamName = _awayTeamName;\r\n        // homeScore and awayScore default to zero, which is correct for new events\r\n\r\n        emit SportsEventCreated(\r\n            _eventId,\r\n            _markets,\r\n            _lines,\r\n            _homeTeamId,\r\n            _awayTeamId,\r\n            _homeTeamName,\r\n            _awayTeamName,\r\n            _estimatedStartTime\r\n        );\r\n    }\r\n\r\n    uint256 constant WhoWonUnknown = 0;\r\n    uint256 constant WhoWonHome = 1;\r\n    uint256 constant WhoWonAway = 2;\r\n    uint256 constant WhoWonDraw = 3;\r\n\r\n    function eventIsNoContest(\r\n        SportsEvent memory _event,\r\n        SportsEventStatus _eventStatus,\r\n        uint256 _homeTeamId,\r\n        uint256 _awayTeamId,\r\n        uint256 _whoWon // pass in WhoWonUnknown if using a scoring sport\r\n    ) internal pure returns (bool) {\r\n        bool _draw = _whoWon == WhoWonDraw;\r\n        bool _notFinal = _eventStatus != SportsEventStatus.Final;\r\n        bool _unstableHomeTeamId = _event.homeTeamId != _homeTeamId;\r\n        bool _unstableAwayTeamId = _event.awayTeamId != _awayTeamId;\r\n        return _draw || _notFinal || _unstableHomeTeamId || _unstableAwayTeamId;\r\n    }\r\n\r\n    function resolveInvalidEvent(uint256 _eventId) internal {\r\n        uint256[] memory _marketIds = sportsEvents[_eventId].markets;\r\n        for (uint256 i = 0; i < _marketIds.length; i++) {\r\n            uint256 _marketId = _marketIds[i];\r\n            if (_marketId == 0) continue; // skip non-created markets\r\n            endMarket(_marketId, NoContest);\r\n        }\r\n    }\r\n\r\n    // TODO is this needed? getSportsEvent should do the same\r\n    function getEventMarkets(uint256 _eventId) public view returns (uint256[] memory _markets) {\r\n        uint256[] storage _original = sportsEvents[_eventId].markets;\r\n        uint256 _len = _original.length;\r\n        _markets = new uint256[](_len);\r\n        for (uint256 i = 0; i < _len; i++) {\r\n            _markets[i] = _original[i];\r\n        }\r\n    }\r\n\r\n    function getRewardEndTime(uint256 _marketId) public view override returns (uint256) {\r\n        uint256 _eventId = marketIdToEventIdMapping[_marketId];\r\n        return getSportsEvent(_eventId).estimatedStartTime;\r\n    }\r\n}\r\n\r\n// TODO change this to work with the Fetcher contracts and use it there, since it's offchain-read-only.\r\nabstract contract SportView is Sport {\r\n    // Only usable off-chain. Gas cost can easily eclipse block limit.\r\n    // Lists all events that could be resolved with a call to resolveEvent.\r\n    // Not all will be resolvable because this does not ensure the game ended.\r\n    function listResolvableEvents() external view returns (uint256[] memory) {\r\n        uint256 _totalResolvable = countResolvableEvents();\r\n        uint256[] memory _resolvableEvents = new uint256[](_totalResolvable);\r\n\r\n        uint256 n = 0;\r\n        for (uint256 i = 0; i < listOfSportsEvents.length; i++) {\r\n            if (n > _totalResolvable) break;\r\n            uint256 _eventId = listOfSportsEvents[i];\r\n            if (isEventResolvable(_eventId)) {\r\n                _resolvableEvents[n] = _eventId;\r\n                n++;\r\n            }\r\n        }\r\n\r\n        return _resolvableEvents;\r\n    }\r\n\r\n    function countResolvableEvents() internal view returns (uint256) {\r\n        uint256 _totalResolvable = 0;\r\n        for (uint256 i = 0; i < listOfSportsEvents.length; i++) {\r\n            uint256 _eventId = listOfSportsEvents[i];\r\n            if (isEventResolvable(_eventId)) {\r\n                _totalResolvable++;\r\n            }\r\n        }\r\n        return _totalResolvable;\r\n    }\r\n\r\n    // Returns true if a call to resolveEvent is potentially useful.\r\n    function isEventResolvable(uint256 _eventId) internal view returns (bool) {\r\n        uint256[] memory _markets = getEventMarkets(_eventId);\r\n\r\n        bool _unresolved = false; // default because non-existing markets aren't resolvable\r\n        for (uint256 i = 0; i < _markets.length; i++) {\r\n            uint256 _marketId = _markets[i];\r\n            if (_marketId != 0 && !isMarketResolved(_marketId)) {\r\n                _unresolved = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        return _unresolved;\r\n    }\r\n}\r\n"
    },
    "contracts/libraries/ResolveByFiat.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.7.6;\r\npragma abicoder v2;\r\n\r\nimport \"./Sport.sol\";\r\nimport \"./ManagedByLink.sol\";\r\n\r\nabstract contract ResolvesByFiat is Sport, ManagedByLink {\r\n    function resolveEvent(\r\n        uint256 _eventId,\r\n        SportsEventStatus _eventStatus,\r\n        uint256 _homeTeamId, // for verifying team stability\r\n        uint256 _awayTeamId, // for verifying team stability\r\n        uint256 _whoWon\r\n    ) public onlyLinkNode {\r\n        SportsEvent storage _event = sportsEvents[_eventId];\r\n\r\n        require(_event.status == SportsEventStatus.Scheduled);\r\n        require(SportsEventStatus(_eventStatus) != SportsEventStatus.Scheduled);\r\n\r\n        if (eventIsNoContest(_event, _eventStatus, _homeTeamId, _awayTeamId, _whoWon)) {\r\n            resolveInvalidEvent(_eventId);\r\n        } else {\r\n            resolveValidEvent(_event, _whoWon);\r\n        }\r\n\r\n        sportsEvents[_eventId].status = _eventStatus;\r\n    }\r\n\r\n    function resolveValidEvent(SportsEvent memory _event, uint256 _whoWon) internal virtual;\r\n}\r\n"
    },
    "contracts/libraries/HasHeadToHeadMarket.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.7.6;\r\npragma abicoder v2;\r\n\r\nimport \"../turbo/AbstractMarketFactoryV3.sol\";\r\nimport \"./Sport.sol\";\r\nimport \"./CalculateLinesToBPoolOdds.sol\";\r\nimport \"./TokenNamesFromTeams.sol\";\r\n\r\nabstract contract HasHeadToHeadMarket is\r\n    AbstractMarketFactoryV3,\r\n    Sport,\r\n    CalculateLinesToBPoolOdds,\r\n    TokenNamesFromTeams\r\n{\r\n    using SafeMathUint256 for uint256;\r\n    using SafeMathInt256 for int256;\r\n\r\n    uint256 private headToHeadMarketType;\r\n    string private noContestName;\r\n\r\n    uint256 constant HeadToHeadAway = 1;\r\n    uint256 constant HeadToHeadHome = 2;\r\n\r\n    constructor(uint256 _marketType, string memory _noContestName) {\r\n        headToHeadMarketType = _marketType;\r\n        noContestName = _noContestName;\r\n    }\r\n\r\n    function makeHeadToHeadMarket(\r\n        int256[2] memory _moneylines,\r\n        string memory _homeTeamName,\r\n        string memory _awayTeamName\r\n    ) internal returns (uint256) {\r\n        // moneylines is [home,away] but the outcomes are listed [NC,away,home] so they must be reversed\r\n        return\r\n            makeSportsMarket(\r\n                noContestName,\r\n                _homeTeamName,\r\n                _awayTeamName,\r\n                oddsFromLines(_moneylines[1], _moneylines[0])\r\n            );\r\n    }\r\n\r\n    function resolveHeadToHeadMarket(\r\n        uint256 _marketId,\r\n        uint256 _homeScore,\r\n        uint256 _awayScore\r\n    ) internal {\r\n        uint256 _shareTokenIndex = calcHeadToHeadWinner(_homeScore, _awayScore);\r\n        endMarket(_marketId, _shareTokenIndex);\r\n    }\r\n\r\n    function calcHeadToHeadWinner(uint256 _homeScore, uint256 _awayScore) private pure returns (uint256) {\r\n        if (_homeScore > _awayScore) {\r\n            return HeadToHeadHome;\r\n        } else if (_homeScore < _awayScore) {\r\n            return HeadToHeadAway;\r\n        } else {\r\n            return NoContest;\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/libraries/Versioned.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.7.6;\r\n\r\nabstract contract Versioned {\r\n    string internal version;\r\n\r\n    constructor(string memory _version) {\r\n        version = _version;\r\n    }\r\n\r\n    function getVersion() public view returns (string memory) {\r\n        return version;\r\n    }\r\n}\r\n"
    },
    "contracts/libraries/LineHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.7.6;\r\n\r\nabstract contract LineHelper {\r\n    function build1Line() internal pure returns (int256[] memory _lines) {\r\n        _lines = new int256[](1);\r\n    }\r\n\r\n    function build3Lines(int256 _homeSpread, int256 _totalScore) internal pure returns (int256[] memory _lines) {\r\n        _lines = new int256[](3);\r\n        // 0 is the Head-to-Head market, which has no lines\r\n        _lines[1] = addHalfPoint(_homeSpread);\r\n        _lines[2] = addHalfPoint(_totalScore);\r\n    }\r\n\r\n    function addHalfPoint(int256 _line) internal pure returns (int256) {\r\n        // The line is a quantity of tenths. So 55 is 5.5 and -6 is -60.\r\n        // If the line is a whole number then make it a half point more extreme, to eliminate ties.\r\n        // So 50 becomes 55, -60 becomes -65, and 0 becomes 5.\r\n        if (_line >= 0 && _line % 10 == 0) {\r\n            return _line + 5;\r\n        } else if (_line < 0 && (-_line) % 10 == 0) {\r\n            return _line - 5;\r\n        } else {\r\n            return _line;\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/libraries/ManagedByLink.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.7.6;\r\n\r\nimport \"./Ownable.sol\";\r\n\r\nabstract contract ManagedByLink is Ownable {\r\n    event LinkNodeChanged(address newLinkNode);\r\n\r\n    address public linkNode;\r\n\r\n    constructor(address _linkNode) {\r\n        linkNode = _linkNode;\r\n    }\r\n\r\n    function setLinkNode(address _newLinkNode) external onlyOwner {\r\n        linkNode = _newLinkNode;\r\n        emit LinkNodeChanged(_newLinkNode);\r\n    }\r\n\r\n    modifier onlyLinkNode() {\r\n        require(msg.sender == linkNode);\r\n        _;\r\n    }\r\n}\r\n"
    },
    "contracts/libraries/CalculateLinesToBPoolOdds.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.7.6;\r\n\r\nimport \"./SafeMathUint256.sol\";\r\nimport \"./SafeMathInt256.sol\";\r\n\r\nabstract contract CalculateLinesToBPoolOdds {\r\n    using SafeMathUint256 for uint256;\r\n    using SafeMathInt256 for int256;\r\n\r\n    uint256 constant MAX_BPOOL_WEIGHT = 50e18;\r\n\r\n    function ratioOdds(uint256[] memory _proportions) internal pure returns (uint256[] memory _odds) {\r\n        uint256 _total = sum(_proportions);\r\n\r\n        _odds = new uint256[](_proportions.length);\r\n        for (uint256 i = 0; i < _proportions.length; i++) {\r\n            _odds[i] = (MAX_BPOOL_WEIGHT).mul(_proportions[i]).div(_total);\r\n            require(_odds[i] >= 1e18, \"min outcome weight is 2%\");\r\n        }\r\n    }\r\n\r\n    function sum(uint256[] memory _numbers) private pure returns (uint256 _sum) {\r\n        for (uint256 i = 0; i < _numbers.length; i++) {\r\n            _sum += _numbers[i];\r\n        }\r\n    }\r\n\r\n    function evenOdds(bool _invalid, uint256 _outcomes) internal pure returns (uint256[] memory _odds) {\r\n        uint256 _size = _outcomes + (_invalid ? 1 : 0);\r\n        _odds = new uint256[](_size);\r\n\r\n        if (_invalid) _odds[0] = 1e18; // 2%\r\n\r\n        uint256 _each = (_invalid ? 49e18 : 50e18) / _outcomes;\r\n        for (uint256 i = _invalid ? 1 : 0; i < _size; i++) {\r\n            _odds[i] = _each;\r\n        }\r\n    }\r\n\r\n    function oddsFromLines(int256 _moneyline1, int256 _moneyline2) internal pure returns (uint256[] memory _odds) {\r\n        uint256 _odds1 = __calcLineToOdds(_moneyline1);\r\n        uint256 _odds2 = __calcLineToOdds(_moneyline2);\r\n\r\n        uint256 _total = _odds1 + _odds2;\r\n\r\n        _odds1 = uint256(49e18).mul(_odds1).div(_total);\r\n        _odds2 = uint256(49e18).mul(_odds2).div(_total);\r\n\r\n        // Moneyline odds are too skewed: would have under 2% odds.\r\n        require(_odds1 >= 1e18);\r\n        require(_odds2 >= 1e18);\r\n\r\n        _odds = new uint256[](3);\r\n        _odds[0] = 1e18; // Invalid, 2%\r\n        _odds[1] = _odds1;\r\n        _odds[2] = _odds2;\r\n    }\r\n\r\n    function __calcLineToOdds(int256 _line) internal pure returns (uint256) {\r\n        if (_line < 0) {\r\n            // favored\r\n            uint256 _posLine = uint256(-_line);\r\n            return _posLine.mul(49e18).div(_posLine.add(100)); // 49e18 * _line / (_line + 100)\r\n        } else {\r\n            // underdog\r\n            return uint256(4900e18).div(uint256(_line).add(100)); // 49e18 * 100 / (_line + 100)\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/libraries/TokenNamesFromTeams.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.7.6;\r\npragma abicoder v2;\r\n\r\nimport \"./Sport.sol\";\r\n\r\nabstract contract TokenNamesFromTeams is Sport {\r\n    uint256 constant Away = 1;\r\n    uint256 constant Home = 2;\r\n\r\n    function makeSportsMarket(\r\n        string memory _noContestName,\r\n        string memory _homeTeamName,\r\n        string memory _awayTeamName,\r\n        uint256[] memory _odds\r\n    ) internal returns (uint256) {\r\n        string[] memory _outcomeNames = makeOutcomeNames(_noContestName, _homeTeamName, _awayTeamName);\r\n        return startMarket(msg.sender, _outcomeNames, _odds, true);\r\n    }\r\n\r\n    function makeOutcomeNames(\r\n        string memory _noContestName,\r\n        string memory _homeTeamName,\r\n        string memory _awayTeamName\r\n    ) private pure returns (string[] memory _names) {\r\n        _names = new string[](3);\r\n        _names[NoContest] = _noContestName;\r\n        _names[Away] = _awayTeamName;\r\n        _names[Home] = _homeTeamName;\r\n    }\r\n}\r\n"
    },
    "@chainlink/contracts/src/v0.7/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\ninterface AggregatorV3Interface {\n\n  function decimals()\n    external\n    view\n    returns (\n      uint8\n    );\n\n  function description()\n    external\n    view\n    returns (\n      string memory\n    );\n\n  function version()\n    external\n    view\n    returns (\n      uint256\n    );\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(\n    uint80 _roundId\n  )\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n}\n"
    },
    "contracts/libraries/HasSpreadMarket.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.7.6;\r\npragma abicoder v2;\r\n\r\nimport \"../turbo/AbstractMarketFactoryV3.sol\";\r\nimport \"./Sport.sol\";\r\nimport \"./CalculateLinesToBPoolOdds.sol\";\r\nimport \"./TokenNamesFromTeams.sol\";\r\n\r\nabstract contract HasSpreadMarket is AbstractMarketFactoryV3, Sport, CalculateLinesToBPoolOdds, TokenNamesFromTeams {\r\n    using SafeMathUint256 for uint256;\r\n    using SafeMathInt256 for int256;\r\n\r\n    uint256 private spreadMarketType;\r\n    string private noContestName;\r\n\r\n    uint256 constant SpreadAway = 1;\r\n    uint256 constant SpreadHome = 2;\r\n\r\n    constructor(uint256 _marketType, string memory _noContestName) {\r\n        spreadMarketType = _marketType;\r\n        noContestName = _noContestName;\r\n    }\r\n\r\n    function makeSpreadMarket(string memory _homeTeamName, string memory _awayTeamName) internal returns (uint256) {\r\n        return makeSportsMarket(noContestName, _homeTeamName, _awayTeamName, evenOdds(true, 2));\r\n    }\r\n\r\n    function resolveSpreadMarket(\r\n        uint256 _marketId,\r\n        int256 _line,\r\n        uint256 _homeScore,\r\n        uint256 _awayScore\r\n    ) internal {\r\n        uint256 _shareTokenIndex = calcSpreadWinner(_homeScore, _awayScore, _line);\r\n        endMarket(_marketId, _shareTokenIndex);\r\n    }\r\n\r\n    function calcSpreadWinner(\r\n        uint256 _homeScore,\r\n        uint256 _awayScore,\r\n        int256 _targetSpread\r\n    ) internal pure returns (uint256) {\r\n        int256 _adjustedHomeScore = int256(_homeScore) + int256(_targetSpread);\r\n\r\n        if (_adjustedHomeScore > int256(_awayScore)) {\r\n            return SpreadHome; // home spread greater\r\n        } else if (_adjustedHomeScore < int256(_awayScore)) {\r\n            return SpreadAway; // away spread lesser\r\n        } else {\r\n            // draw / tie; some sports eliminate this with half-points\r\n            return NoContest;\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/libraries/ResolveByScore.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.7.6;\r\npragma abicoder v2;\r\n\r\nimport \"./Sport.sol\";\r\nimport \"./ManagedByLink.sol\";\r\n\r\nabstract contract ResolvesByScore is Sport, ManagedByLink {\r\n    function resolveEvent(\r\n        uint256 _eventId,\r\n        SportsEventStatus _eventStatus,\r\n        uint256 _homeTeamId, // for verifying team stability\r\n        uint256 _awayTeamId, // for verifying team stability\r\n        uint256 _homeScore,\r\n        uint256 _awayScore\r\n    ) public onlyLinkNode {\r\n        SportsEvent storage _event = sportsEvents[_eventId];\r\n\r\n        require(_event.status == SportsEventStatus.Scheduled);\r\n        require(uint8(_eventStatus) >= uint8(SportsEventStatus.Final));\r\n\r\n        if (eventIsNoContest(_event, _eventStatus, _homeTeamId, _awayTeamId, WhoWonUnknown)) {\r\n            resolveInvalidEvent(_eventId);\r\n        } else {\r\n            resolveValidEvent(_event, _homeScore, _awayScore);\r\n        }\r\n\r\n        _event.status = _eventStatus;\r\n        _event.homeScore = _homeScore;\r\n        _event.awayScore = _awayScore;\r\n    }\r\n\r\n    function resolveValidEvent(\r\n        SportsEvent memory _event,\r\n        uint256 _homeScore,\r\n        uint256 _awayScore\r\n    ) internal virtual;\r\n}\r\n"
    },
    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping (bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            bytes32 lastvalue = set._values[lastIndex];\n\n            // Move the last value to the index where the value to delete is\n            set._values[toDeleteIndex] = lastvalue;\n            // Update the index for the moved value\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\n        return set._values[index];\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../utils/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/turbo/GroupFetcher.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.7.6;\r\npragma abicoder v2;\r\n\r\nimport \"./Fetcher.sol\";\r\nimport \"./Grouped.sol\";\r\n\r\nabstract contract GroupFetcher is Fetcher {\r\n    struct SpecificMarketFactoryBundle {\r\n        MarketFactoryBundle super;\r\n    }\r\n\r\n    struct StaticGroupBundle {\r\n        uint256 id;\r\n        string name;\r\n        StaticMarketBundle[] markets;\r\n        string[] marketNames;\r\n        StaticMarketBundle invalidMarket;\r\n        string invalidMarketName;\r\n        uint256 endTime;\r\n        string category;\r\n        // Dynamics\r\n        Grouped.GroupStatus status;\r\n    }\r\n\r\n    struct DynamicGroupBundle {\r\n        uint256 id;\r\n        Grouped.GroupStatus status;\r\n        DynamicMarketBundle[] markets;\r\n        DynamicMarketBundle invalidMarket;\r\n    }\r\n\r\n    function buildSpecificMarketFactoryBundle(address _marketFactory)\r\n        internal\r\n        view\r\n        returns (SpecificMarketFactoryBundle memory _bundle)\r\n    {\r\n        _bundle.super = buildMarketFactoryBundle(AbstractMarketFactoryV3(_marketFactory));\r\n    }\r\n\r\n    function fetchInitial(\r\n        address _marketFactory,\r\n        AMMFactory _ammFactory,\r\n        MasterChef _masterChef,\r\n        uint256 _offset,\r\n        uint256 _total\r\n    )\r\n        public\r\n        view\r\n        returns (\r\n            SpecificMarketFactoryBundle memory _marketFactoryBundle,\r\n            StaticGroupBundle[] memory _groupBundles,\r\n            uint256 _lowestGroupIndex,\r\n            uint256 _timestamp\r\n        )\r\n    {\r\n        _marketFactoryBundle = buildSpecificMarketFactoryBundle(_marketFactory);\r\n        (_groupBundles, _lowestGroupIndex) = buildStaticGroupBundles(\r\n            _marketFactory,\r\n            _ammFactory,\r\n            _masterChef,\r\n            _offset,\r\n            _total\r\n        );\r\n        _timestamp = block.timestamp;\r\n    }\r\n\r\n    function fetchDynamic(\r\n        address _marketFactory,\r\n        AMMFactory _ammFactory,\r\n        uint256 _offset,\r\n        uint256 _total\r\n    )\r\n        public\r\n        view\r\n        returns (\r\n            DynamicGroupBundle[] memory _bundles,\r\n            uint256 _lowestGroupIndex,\r\n            uint256 _timestamp\r\n        )\r\n    {\r\n        (_bundles, _lowestGroupIndex) = buildDynamicGroupBundles(_marketFactory, _ammFactory, _offset, _total);\r\n        _timestamp = block.timestamp;\r\n    }\r\n\r\n    function buildStaticGroupBundles(\r\n        address _marketFactory,\r\n        AMMFactory _ammFactory,\r\n        MasterChef _masterChef,\r\n        uint256 _offset,\r\n        uint256 _total\r\n    ) internal view returns (StaticGroupBundle[] memory _bundles, uint256 _lowestGroupIndex) {\r\n        uint256[] memory _groupIds;\r\n        (_groupIds, _lowestGroupIndex) = listOfInterestingGroups(_marketFactory, _offset, _total);\r\n\r\n        _total = _groupIds.length;\r\n        _bundles = new StaticGroupBundle[](_total);\r\n        for (uint256 i; i < _total; i++) {\r\n            _bundles[i] = buildStaticGroupBundle(_marketFactory, _ammFactory, _masterChef, _groupIds[i]);\r\n        }\r\n    }\r\n\r\n    function buildDynamicGroupBundles(\r\n        address _marketFactory,\r\n        AMMFactory _ammFactory,\r\n        uint256 _offset,\r\n        uint256 _total\r\n    ) internal view returns (DynamicGroupBundle[] memory _bundles, uint256 _lowestGroupIndex) {\r\n        uint256[] memory _groupIds;\r\n        (_groupIds, _lowestGroupIndex) = listOfInterestingGroups(_marketFactory, _offset, _total);\r\n\r\n        _total = _groupIds.length;\r\n        _bundles = new DynamicGroupBundle[](_total);\r\n        for (uint256 i; i < _total; i++) {\r\n            _bundles[i] = buildDynamicGroupBundle(_marketFactory, _ammFactory, _groupIds[i]);\r\n        }\r\n    }\r\n\r\n    function buildStaticGroupBundle(\r\n        address _marketFactory,\r\n        AMMFactory _ammFactory,\r\n        MasterChef _masterChef,\r\n        uint256 _groupId\r\n    ) internal view returns (StaticGroupBundle memory _bundle) {\r\n        Grouped.MarketGroup memory _group = Grouped(_marketFactory).getGroup(_groupId);\r\n\r\n        StaticMarketBundle[] memory _markets = new StaticMarketBundle[](_group.markets.length);\r\n        for (uint256 i = 0; i < _markets.length; i++) {\r\n            _markets[i] = buildStaticMarketBundle(\r\n                AbstractMarketFactoryV3(_marketFactory),\r\n                _ammFactory,\r\n                _masterChef,\r\n                _group.markets[i]\r\n            );\r\n        }\r\n\r\n        _bundle.id = _groupId;\r\n        _bundle.name = _group.name;\r\n        _bundle.status = _group.status;\r\n        _bundle.markets = _markets;\r\n        _bundle.endTime = _group.endTime;\r\n        _bundle.invalidMarket = buildStaticMarketBundle(\r\n            AbstractMarketFactoryV3(_marketFactory),\r\n            _ammFactory,\r\n            _masterChef,\r\n            _group.invalidMarket\r\n        );\r\n        _bundle.invalidMarketName = _group.invalidMarketName;\r\n        _bundle.marketNames = _group.marketNames;\r\n        _bundle.category = _group.category;\r\n    }\r\n\r\n    function buildDynamicGroupBundle(\r\n        address _marketFactory,\r\n        AMMFactory _ammFactory,\r\n        uint256 _groupId\r\n    ) internal view returns (DynamicGroupBundle memory _bundle) {\r\n        Grouped.MarketGroup memory _group = Grouped(_marketFactory).getGroup(_groupId);\r\n\r\n        DynamicMarketBundle[] memory _markets = new DynamicMarketBundle[](_group.markets.length);\r\n        for (uint256 i = 0; i < _markets.length; i++) {\r\n            _markets[i] = buildDynamicMarketBundle(\r\n                AbstractMarketFactoryV3(_marketFactory),\r\n                _ammFactory,\r\n                _group.markets[i]\r\n            );\r\n        }\r\n\r\n        _bundle.id = _groupId;\r\n        _bundle.markets = _markets;\r\n        _bundle.invalidMarket = buildDynamicMarketBundle(\r\n            AbstractMarketFactoryV3(_marketFactory),\r\n            _ammFactory,\r\n            _group.invalidMarket\r\n        );\r\n        _bundle.status = _group.status;\r\n    }\r\n\r\n    // Starts from the end of the groups list because newer groups are more interesting.\r\n    // _offset is skipping all groups, not just interesting groups\r\n    function listOfInterestingGroups(\r\n        address _marketFactory,\r\n        uint256 _offset,\r\n        uint256 _total\r\n    ) internal view returns (uint256[] memory _interestingGroupIds, uint256 _groupIndex) {\r\n        _interestingGroupIds = new uint256[](_total);\r\n\r\n        uint256 _groupCount = Grouped(_marketFactory).groupCount();\r\n\r\n        // No groups so return nothing. (needed to avoid integer underflow below)\r\n        if (_groupCount == 0) {\r\n            return (new uint256[](0), 0);\r\n        }\r\n\r\n        uint256 _max = _groupCount;\r\n\r\n        // No remaining groups so return nothing. (needed to avoid integer underflow below)\r\n        if (_offset > _max) {\r\n            return (new uint256[](0), 0);\r\n        }\r\n\r\n        uint256 _collectedGroups = 0;\r\n        _groupIndex = _max - _offset;\r\n        while (true) {\r\n            if (_collectedGroups >= _total) break;\r\n            if (_groupIndex == 0) break;\r\n\r\n            _groupIndex--; // starts out one too high, so this works\r\n\r\n            (Grouped.MarketGroup memory _group, uint256 _groupId) =\r\n                Grouped(_marketFactory).getGroupByIndex(_groupIndex);\r\n\r\n            if (isGroupInteresting(_group, AbstractMarketFactoryV3(_marketFactory))) {\r\n                _interestingGroupIds[_collectedGroups] = _groupId;\r\n                _collectedGroups++;\r\n            }\r\n        }\r\n\r\n        if (_total > _collectedGroups) {\r\n            assembly {\r\n                // shortens array\r\n                mstore(_interestingGroupIds, _collectedGroups)\r\n            }\r\n        }\r\n    }\r\n\r\n    function isGroupInteresting(Grouped.MarketGroup memory _group, AbstractMarketFactoryV3 _marketFactory)\r\n        private\r\n        view\r\n        returns (bool)\r\n    {\r\n        for (uint256 i = 0; i < _group.markets.length; i++) {\r\n            uint256 _marketId = _group.markets[i];\r\n            if (openOrHasWinningShares(_marketFactory, _marketId)) {\r\n                return true;\r\n            }\r\n        }\r\n        if (openOrHasWinningShares(_marketFactory, _group.invalidMarket)) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n}\r\n\r\ncontract GroupedFetcher is GroupFetcher {\r\n    constructor() Fetcher(\"Grouped\", \"TBD\") {}\r\n}\r\n"
    },
    "contracts/turbo/Grouped.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.7.6;\r\npragma abicoder v2;\r\n\r\nimport \"./AbstractMarketFactoryV3.sol\";\r\nimport \"../libraries/CalculateLinesToBPoolOdds.sol\";\r\nimport \"./GroupFetcher.sol\";\r\n\r\nabstract contract Grouped is AbstractMarketFactoryV3, CalculateLinesToBPoolOdds {\r\n    event GroupCreated(uint256 indexed id, uint256 endTime, uint256 invalidMarketId, string invalidMarketName);\r\n    event GroupMarketAdded(uint256 indexed groupId, uint256 marketId, string marketName);\r\n    event GroupFinalizing(uint256 indexed groupId, uint256 winningMarketIndex);\r\n    event GroupResolved(uint256 indexed id, bool valid);\r\n\r\n    enum GroupStatus {Unknown, Scheduled, Finalizing, Final, Invalid}\r\n\r\n    struct MarketGroup {\r\n        GroupStatus status;\r\n        string name;\r\n        uint256[] markets;\r\n        string[] marketNames;\r\n        uint256 invalidMarket;\r\n        string invalidMarketName;\r\n        uint256 endTime;\r\n        string category;\r\n        uint256 winningMarketIndex; // ignore when status is Scheduled. MAX_UINT is invalid\r\n    }\r\n    // GroupId => MarketGroup\r\n    mapping(uint256 => MarketGroup) public marketGroups;\r\n    uint256[] public listOfMarketGroups;\r\n\r\n    // For regular markets, YES means the team won and NO means the team did not win.\r\n    // For the invalid market, YES means none of the teams won and NO means a team won.\r\n    uint256 constant OUTCOME_NO = 0;\r\n    uint256 constant OUTCOME_YES = 1;\r\n\r\n    uint256 constant MAX_UINT = 2**256 - 1;\r\n\r\n    function groupCount() public view returns (uint256) {\r\n        return listOfMarketGroups.length;\r\n    }\r\n\r\n    function getGroup(uint256 _groupId) public view returns (MarketGroup memory) {\r\n        return marketGroups[_groupId];\r\n    }\r\n\r\n    function getGroupByIndex(uint256 _index) public view returns (MarketGroup memory _group, uint256 _groupId) {\r\n        _groupId = listOfMarketGroups[_index];\r\n        _group = getGroup(_groupId);\r\n    }\r\n\r\n    function startCreatingMarketGroup(\r\n        uint256 _groupId,\r\n        string memory _groupName,\r\n        uint256 _endTime,\r\n        string memory _invalidMarketName,\r\n        string memory _category\r\n    ) internal {\r\n        require(marketGroups[_groupId].status == GroupStatus.Unknown, \"group exists\");\r\n\r\n        listOfMarketGroups.push(_groupId);\r\n        marketGroups[_groupId].status = GroupStatus.Scheduled;\r\n        marketGroups[_groupId].name = _groupName;\r\n        marketGroups[_groupId].endTime = _endTime;\r\n        marketGroups[_groupId].category = _category;\r\n\r\n        uint256 _invalidMarket = startMarket(msg.sender, buildOutcomesNames(_invalidMarketName), invalidOdds(), true);\r\n        marketGroups[_groupId].invalidMarket = _invalidMarket;\r\n        marketGroups[_groupId].invalidMarketName = _invalidMarketName;\r\n\r\n        emit GroupCreated(_groupId, _endTime, _invalidMarket, _invalidMarketName);\r\n        emit GroupMarketAdded(_groupId, _invalidMarket, _invalidMarketName);\r\n    }\r\n\r\n    function addMarketToMarketGroup(\r\n        uint256 _groupId,\r\n        string memory _marketName,\r\n        uint256[] memory _odds\r\n    ) internal {\r\n        require(marketGroups[_groupId].status == GroupStatus.Scheduled, \"group must be Scheduled\");\r\n\r\n        uint256 _marketId = startMarket(msg.sender, buildOutcomesNames(_marketName), _odds, true);\r\n        marketGroups[_groupId].markets.push(_marketId);\r\n        marketGroups[_groupId].marketNames.push(_marketName);\r\n        emit GroupMarketAdded(_groupId, _marketId, _marketName);\r\n    }\r\n\r\n    // Use MAX_UINT for _winningMarketIndex to indicate INVALID\r\n    function startResolvingMarketGroup(uint256 _groupId, uint256 _winningMarketIndex) internal {\r\n        bool _isInvalid = _winningMarketIndex == MAX_UINT;\r\n        MarketGroup memory _group = marketGroups[_groupId];\r\n\r\n        require(_group.status == GroupStatus.Scheduled, \"group not Scheduled\");\r\n\r\n        resolveInvalidMarket(_group, _isInvalid);\r\n        marketGroups[_groupId].status = GroupStatus.Finalizing;\r\n        marketGroups[_groupId].winningMarketIndex = _winningMarketIndex;\r\n        emit GroupFinalizing(_groupId, _winningMarketIndex);\r\n    }\r\n\r\n    function resolveFinalizingGroupMarket(uint256 _groupId, uint256 _marketIndex) internal {\r\n        MarketGroup memory _group = marketGroups[_groupId];\r\n        require(_group.status == GroupStatus.Finalizing, \"must be finalizing\");\r\n\r\n        uint256 _marketId = _group.markets[_marketIndex];\r\n        bool _wins = _marketIndex == _group.winningMarketIndex;\r\n        resolveGroupMarket(_marketId, _wins);\r\n    }\r\n\r\n    function finalizeMarketGroup(uint256 _groupId) internal {\r\n        MarketGroup storage _group = marketGroups[_groupId];\r\n        require(_group.status == GroupStatus.Finalizing);\r\n\r\n        bool _valid = _group.winningMarketIndex != MAX_UINT;\r\n\r\n        _group.status = _valid ? GroupStatus.Final : GroupStatus.Invalid;\r\n\r\n        emit GroupResolved(_groupId, _valid);\r\n    }\r\n\r\n    function resolveGroupMarket(uint256 _marketId, bool _wins) internal {\r\n        uint256 _winningOutcome = _wins ? OUTCOME_YES : OUTCOME_NO;\r\n        endMarket(_marketId, _winningOutcome);\r\n    }\r\n\r\n    function resolveInvalidMarket(MarketGroup memory _group, bool _invalid) private {\r\n        uint256 _outcomeIndex = _invalid ? OUTCOME_YES : OUTCOME_NO;\r\n        endMarket(_group.invalidMarket, _outcomeIndex);\r\n    }\r\n\r\n    function buildOutcomesNames(string memory _marketName) internal pure returns (string[] memory _names) {\r\n        _names = new string[](2);\r\n        _names[OUTCOME_NO] = string(abi.encodePacked(\"NO - \", _marketName));\r\n        _names[OUTCOME_YES] = string(abi.encodePacked(\"YES - \", _marketName));\r\n    }\r\n\r\n    function invalidOdds() private pure returns (uint256[] memory _odds) {\r\n        _odds = new uint256[](2);\r\n        _odds[OUTCOME_YES] = 1e18;\r\n        _odds[OUTCOME_NO] = 49e18;\r\n    }\r\n}\r\n"
    },
    "contracts/turbo/GroupedMarketFactoryV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.7.6;\r\npragma abicoder v2;\r\n\r\nimport \"./AbstractMarketFactoryV3.sol\";\r\nimport \"./FeePot.sol\";\r\nimport \"../libraries/SafeMathInt256.sol\";\r\nimport \"./Grouped.sol\";\r\nimport \"../libraries/ManagedByLink.sol\";\r\nimport \"../libraries/Versioned.sol\";\r\n\r\ncontract GroupedMarketFactoryV3 is AbstractMarketFactoryV3, Grouped, ManagedByLink, Versioned {\r\n    using SafeMathUint256 for uint256;\r\n    using SafeMathInt256 for int256;\r\n\r\n    constructor(\r\n        address _owner,\r\n        IERC20Full _collateral,\r\n        uint256 _shareFactor,\r\n        FeePot _feePot,\r\n        uint256[3] memory _fees,\r\n        address _protocol,\r\n        address _linkNode\r\n    )\r\n        AbstractMarketFactoryV3(_owner, _collateral, _shareFactor, _feePot, _fees, _protocol)\r\n        Versioned(\"v1.2.0\")\r\n        ManagedByLink(_linkNode)\r\n    {}\r\n\r\n    function initializeGroup(\r\n        uint256 _groupId,\r\n        string memory _groupName,\r\n        string memory _invalidMarketName,\r\n        uint256 _endTime,\r\n        string memory _category\r\n    ) public onlyLinkNode {\r\n        startCreatingMarketGroup(_groupId, _groupName, _endTime, _invalidMarketName, _category);\r\n    }\r\n\r\n    function addOutcomesToGroup(\r\n        uint256 _groupId,\r\n        string[] memory _marketNames,\r\n        uint256[][] memory _odds\r\n    ) public onlyLinkNode {\r\n        require(_marketNames.length == _odds.length);\r\n\r\n        for (uint256 i = 0; i < _marketNames.length; i++) {\r\n            addMarketToMarketGroup(_groupId, _marketNames[i], _odds[i]);\r\n        }\r\n    }\r\n\r\n    // Set _winner to MAX_UINT (2*256 - 1) to indicate invalid\r\n    function beginResolvingGroup(uint256 _groupId, uint256 _winningMarketIndex) public onlyLinkNode {\r\n        startResolvingMarketGroup(_groupId, _winningMarketIndex);\r\n    }\r\n\r\n    function resolveMarkets(uint256 _groupId, uint256[] memory _marketIndexes) public onlyLinkNode {\r\n        MarketGroup memory _group = marketGroups[_groupId];\r\n        require(_group.status == GroupStatus.Finalizing);\r\n\r\n        for (uint256 i = 0; i < _marketIndexes.length; i++) {\r\n            uint256 _marketIndex = _marketIndexes[i];\r\n            uint256 _marketId = _group.markets[_marketIndex];\r\n            if (isMarketResolved(_marketId)) continue; // skip resolved markets\r\n            resolveFinalizingGroupMarket(_groupId, _marketIndex);\r\n        }\r\n    }\r\n\r\n    function finalizeGroup(uint256 _groupId) public onlyLinkNode {\r\n        finalizeMarketGroup(_groupId);\r\n    }\r\n\r\n    // Used when some markets in a group can resolve early as NO.\r\n    // ex: Teams eliminated early from a tournament cannot win the overall tournament.\r\n    function resolveMarketAsNo(uint256 _marketId) public onlyLinkNode {\r\n        require(markets[_marketId].active, \"market inactive\");\r\n        resolveGroupMarket(_marketId, false);\r\n    }\r\n\r\n    function getRewardEndTime(uint256 _eventId) public view override returns (uint256) {\r\n        return 0;\r\n    }\r\n}\r\n"
    },
    "contracts/turbo/NFLMarketFactoryV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.7.6;\r\npragma abicoder v2;\r\n\r\nimport \"../libraries/IERC20Full.sol\";\r\nimport \"../balancer/BPool.sol\";\r\nimport \"./AbstractMarketFactoryV3.sol\";\r\nimport \"./FeePot.sol\";\r\nimport \"../libraries/SafeMathInt256.sol\";\r\nimport \"../libraries/Sport.sol\";\r\nimport \"../libraries/HasHeadToHeadMarket.sol\";\r\nimport \"../libraries/HasSpreadMarket.sol\";\r\nimport \"../libraries/HasOverUnderMarket.sol\";\r\nimport \"../libraries/ResolveByScore.sol\";\r\nimport \"../libraries/Versioned.sol\";\r\n\r\n// NFL is standard except ties are fine: they become NoContestOrDraw.\r\n// As a consequence, half points are not added to the lines.\r\ncontract NFLMarketFactoryV3 is\r\n    AbstractMarketFactoryV3,\r\n    SportView,\r\n    HasHeadToHeadMarket,\r\n    HasSpreadMarket,\r\n    HasOverUnderMarket,\r\n    ResolvesByScore,\r\n    Versioned\r\n{\r\n    using SafeMathUint256 for uint256;\r\n    using SafeMathInt256 for int256;\r\n\r\n    uint256 constant HeadToHead = 0;\r\n    uint256 constant Spread = 1;\r\n    uint256 constant OverUnder = 2;\r\n\r\n    constructor(\r\n        address _owner,\r\n        IERC20Full _collateral,\r\n        uint256 _shareFactor,\r\n        FeePot _feePot,\r\n        uint256[3] memory _fees,\r\n        address _protocol,\r\n        address _linkNode\r\n    )\r\n        AbstractMarketFactoryV3(_owner, _collateral, _shareFactor, _feePot, _fees, _protocol)\r\n        Versioned(\"v1.2.0\")\r\n        ManagedByLink(_linkNode)\r\n        HasHeadToHeadMarket(HeadToHead, \"No Contest / Draw\")\r\n        HasSpreadMarket(Spread, \"No Contest\")\r\n        HasOverUnderMarket(OverUnder, \"No Contest\")\r\n    {}\r\n\r\n    function createEvent(\r\n        uint256 _eventId,\r\n        string memory _homeTeamName,\r\n        uint256 _homeTeamId,\r\n        string memory _awayTeamName,\r\n        uint256 _awayTeamId,\r\n        uint256 _startTimestamp,\r\n        int256 _homeSpread,\r\n        int256 _totalScore,\r\n        int256[2] memory _moneylines // [home,away]\r\n    ) public onlyLinkNode returns (uint256[] memory _marketIds) {\r\n        _marketIds = makeMarkets(_moneylines, _homeTeamName, _awayTeamName);\r\n        makeSportsEvent(\r\n            _eventId,\r\n            _marketIds,\r\n            build3Lines(_homeSpread, _totalScore),\r\n            _startTimestamp,\r\n            _homeTeamId,\r\n            _awayTeamId,\r\n            _homeTeamName,\r\n            _awayTeamName\r\n        );\r\n    }\r\n\r\n    function makeMarkets(\r\n        int256[2] memory _moneylines,\r\n        string memory _homeTeamName,\r\n        string memory _awayTeamName\r\n    ) internal returns (uint256[] memory _marketIds) {\r\n        _marketIds = new uint256[](3);\r\n\r\n        _marketIds[HeadToHead] = makeHeadToHeadMarket(_moneylines, _homeTeamName, _awayTeamName);\r\n        _marketIds[Spread] = makeSpreadMarket(_homeTeamName, _awayTeamName);\r\n        _marketIds[OverUnder] = makeOverUnderMarket();\r\n    }\r\n\r\n    function resolveValidEvent(\r\n        SportsEvent memory _event,\r\n        uint256 _homeScore,\r\n        uint256 _awayScore\r\n    ) internal override {\r\n        resolveHeadToHeadMarket(_event.markets[HeadToHead], _homeScore, _awayScore);\r\n        resolveSpreadMarket(_event.markets[Spread], _event.lines[Spread], _homeScore, _awayScore);\r\n        resolveOverUnderMarket(_event.markets[OverUnder], _event.lines[OverUnder], _homeScore, _awayScore);\r\n    }\r\n}\r\n"
    },
    "contracts/libraries/HasOverUnderMarket.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.7.6;\r\npragma abicoder v2;\r\n\r\nimport \"../turbo/AbstractMarketFactoryV3.sol\";\r\nimport \"./Sport.sol\";\r\nimport \"./CalculateLinesToBPoolOdds.sol\";\r\n\r\nabstract contract HasOverUnderMarket is AbstractMarketFactoryV3, Sport, CalculateLinesToBPoolOdds {\r\n    using SafeMathUint256 for uint256;\r\n    using SafeMathInt256 for int256;\r\n\r\n    uint256 private overUnderMarketType;\r\n    string private noContestName;\r\n\r\n    uint256 constant Over = 1;\r\n    uint256 constant Under = 2;\r\n\r\n    constructor(uint256 _marketType, string memory _noContestName) {\r\n        overUnderMarketType = _marketType;\r\n        noContestName = _noContestName;\r\n    }\r\n\r\n    function makeOverUnderMarket() internal returns (uint256) {\r\n        string[] memory _outcomeNames = makeOutcomeNames(noContestName);\r\n        return startMarket(msg.sender, _outcomeNames, evenOdds(true, 2), true);\r\n    }\r\n\r\n    function resolveOverUnderMarket(\r\n        uint256 _marketId,\r\n        int256 _line,\r\n        uint256 _homeScore,\r\n        uint256 _awayScore\r\n    ) internal {\r\n        uint256 _shareTokenIndex = calcOverUnderWinner(_homeScore, _awayScore, _line);\r\n        endMarket(_marketId, _shareTokenIndex);\r\n    }\r\n\r\n    function calcOverUnderWinner(\r\n        uint256 _homeScore,\r\n        uint256 _awayScore,\r\n        int256 _targetTotal\r\n    ) internal pure returns (uint256) {\r\n        int256 _actualTotal = int256(_homeScore).add(int256(_awayScore));\r\n\r\n        if (_actualTotal > _targetTotal) {\r\n            return Over; // total score above than line\r\n        } else if (_actualTotal < _targetTotal) {\r\n            return Under; // total score below line\r\n        } else {\r\n            return NoContest; // draw / tie; some sports eliminate this with half-points\r\n        }\r\n    }\r\n\r\n    function makeOutcomeNames(string memory _noContestName) private pure returns (string[] memory _names) {\r\n        _names = new string[](3);\r\n        _names[NoContest] = _noContestName;\r\n        _names[Over] = \"Over\";\r\n        _names[Under] = \"Under\";\r\n    }\r\n}\r\n"
    },
    "contracts/turbo/NCAAFBMarketFactoryV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.7.6;\r\npragma abicoder v2;\r\n\r\nimport \"../libraries/IERC20Full.sol\";\r\nimport \"../balancer/BPool.sol\";\r\nimport \"./AbstractMarketFactoryV3.sol\";\r\nimport \"./FeePot.sol\";\r\nimport \"../libraries/SafeMathInt256.sol\";\r\nimport \"../libraries/Sport.sol\";\r\nimport \"../libraries/HasHeadToHeadMarket.sol\";\r\nimport \"../libraries/HasSpreadMarket.sol\";\r\nimport \"../libraries/HasOverUnderMarket.sol\";\r\nimport \"../libraries/ResolveByScore.sol\";\r\nimport \"../libraries/Versioned.sol\";\r\n\r\n// NCAA-FB is identical to NFL except there are no ties.\r\n// As a consequence, spread and over-under lines add a half-point,\r\n// and the invalid outcome is just No Contest.\r\ncontract NCAAFBMarketFactoryV3 is\r\n    AbstractMarketFactoryV3,\r\n    SportView,\r\n    HasHeadToHeadMarket,\r\n    HasSpreadMarket,\r\n    HasOverUnderMarket,\r\n    ResolvesByScore,\r\n    Versioned\r\n{\r\n    using SafeMathUint256 for uint256;\r\n    using SafeMathInt256 for int256;\r\n\r\n    uint256 constant HeadToHead = 0;\r\n    uint256 constant Spread = 1;\r\n    uint256 constant OverUnder = 2;\r\n    string constant InvalidName = \"No Contest\";\r\n\r\n    constructor(\r\n        address _owner,\r\n        IERC20Full _collateral,\r\n        uint256 _shareFactor,\r\n        FeePot _feePot,\r\n        uint256[3] memory _fees,\r\n        address _protocol,\r\n        address _linkNode\r\n    )\r\n        AbstractMarketFactoryV3(_owner, _collateral, _shareFactor, _feePot, _fees, _protocol)\r\n        Versioned(\"v1.2.0\")\r\n        ManagedByLink(_linkNode)\r\n        HasHeadToHeadMarket(HeadToHead, InvalidName)\r\n        HasSpreadMarket(Spread, InvalidName)\r\n        HasOverUnderMarket(OverUnder, InvalidName)\r\n    {}\r\n\r\n    function createEvent(\r\n        uint256 _eventId,\r\n        string memory _homeTeamName,\r\n        uint256 _homeTeamId,\r\n        string memory _awayTeamName,\r\n        uint256 _awayTeamId,\r\n        uint256 _startTimestamp,\r\n        int256 _homeSpread,\r\n        int256 _totalScore,\r\n        int256[2] memory _moneylines // [home,away]\r\n    ) public onlyLinkNode returns (uint256[] memory _marketIds) {\r\n        _marketIds = makeMarkets(_moneylines, _homeTeamName, _awayTeamName);\r\n        makeSportsEvent(\r\n            _eventId,\r\n            _marketIds,\r\n            build3Lines(_homeSpread, _totalScore),\r\n            _startTimestamp,\r\n            _homeTeamId,\r\n            _awayTeamId,\r\n            _homeTeamName,\r\n            _awayTeamName\r\n        );\r\n    }\r\n\r\n    function makeMarkets(\r\n        int256[2] memory _moneylines,\r\n        string memory _homeTeamName,\r\n        string memory _awayTeamName\r\n    ) internal returns (uint256[] memory _marketIds) {\r\n        _marketIds = new uint256[](3);\r\n\r\n        _marketIds[HeadToHead] = makeHeadToHeadMarket(_moneylines, _homeTeamName, _awayTeamName);\r\n        _marketIds[Spread] = makeSpreadMarket(_homeTeamName, _awayTeamName);\r\n        _marketIds[OverUnder] = makeOverUnderMarket();\r\n    }\r\n\r\n    function resolveValidEvent(\r\n        SportsEvent memory _event,\r\n        uint256 _homeScore,\r\n        uint256 _awayScore\r\n    ) internal override {\r\n        resolveHeadToHeadMarket(_event.markets[HeadToHead], _homeScore, _awayScore);\r\n        resolveSpreadMarket(_event.markets[Spread], _event.lines[Spread], _homeScore, _awayScore);\r\n        resolveOverUnderMarket(_event.markets[OverUnder], _event.lines[OverUnder], _homeScore, _awayScore);\r\n    }\r\n}\r\n"
    },
    "contracts/turbo/TrustedMarketFactoryV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.7.6;\r\npragma abicoder v2;\r\n\r\nimport \"../libraries/IERC20Full.sol\";\r\nimport \"../balancer/BPool.sol\";\r\nimport \"./AbstractMarketFactoryV2.sol\";\r\nimport \"./FeePot.sol\";\r\nimport \"../libraries/CalculateLinesToBPoolOdds.sol\";\r\n\r\ncontract TrustedMarketFactoryV2 is AbstractMarketFactoryV2, CalculateLinesToBPoolOdds {\r\n    using SafeMathUint256 for uint256;\r\n\r\n    event MarketCreated(uint256 id, address creator, uint256 _endTime, string description, string[] outcomes);\r\n    event MarketResolved(uint256 id, address winner);\r\n\r\n    struct MarketDetails {\r\n        string description;\r\n    }\r\n    MarketDetails[] internal marketDetails;\r\n\r\n    constructor(\r\n        address _owner,\r\n        IERC20Full _collateral,\r\n        uint256 _shareFactor,\r\n        FeePot _feePot,\r\n        uint256 _stakerFee,\r\n        uint256 _settlementFee,\r\n        address _protocol,\r\n        uint256 _protocolFee\r\n    )\r\n        AbstractMarketFactoryV2(\r\n            _owner,\r\n            _collateral,\r\n            _shareFactor,\r\n            _feePot,\r\n            _stakerFee,\r\n            _settlementFee,\r\n            _protocol,\r\n            _protocolFee\r\n        )\r\n    {}\r\n\r\n    function createMarket(\r\n        address _creator,\r\n        uint256 _endTime,\r\n        string calldata _description,\r\n        string[] calldata _names,\r\n        string[] calldata _symbols,\r\n        uint256[] calldata _odds\r\n    ) public onlyOwner returns (uint256) {\r\n        require(\r\n            _names.length == _symbols.length && _symbols.length == _odds.length,\r\n            \"names, symbols, and odds must be the same length\"\r\n        );\r\n\r\n        uint256 _id = markets.length;\r\n        markets.push(makeMarket(_creator, _names, _symbols, _endTime, _odds));\r\n        marketDetails.push(MarketDetails(_description));\r\n\r\n        emit MarketCreated(_id, _creator, _endTime, _description, _symbols);\r\n        return _id;\r\n    }\r\n\r\n    function resolveMarket(uint256) public pure override {\r\n        require(false, \"Only the TrustedMarketFactory owner can resolve the market, using trustedResolveMarket\");\r\n    }\r\n\r\n    function trustedResolveMarket(uint256 _id, uint256 _winningOutcome) public onlyOwner {\r\n        OwnedERC20 _winner = markets[_id].shareTokens[_winningOutcome];\r\n        markets[_id].winner = _winner;\r\n        emit MarketResolved(_id, address(_winner));\r\n    }\r\n\r\n    function getMarketDetails(uint256 _id) public view returns (MarketDetails memory) {\r\n        return marketDetails[_id];\r\n    }\r\n}\r\n"
    },
    "contracts/turbo/AbstractMarketFactoryV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.7.6;\r\npragma abicoder v2;\r\n\r\nimport \"../libraries/IERC20Full.sol\";\r\nimport \"../balancer/BPool.sol\";\r\nimport \"./TurboShareTokenFactory.sol\";\r\nimport \"./FeePot.sol\";\r\n\r\nabstract contract AbstractMarketFactoryV2 is TurboShareTokenFactoryV1, Ownable {\r\n    using SafeMathUint256 for uint256;\r\n\r\n    // Should always have ID. Others are optional.\r\n    // event MarketCreated(uint256 id, address settlementAddress, uint256 endTime, ...);\r\n\r\n    // Should always have ID. Others are optional.\r\n    // event MarketResolved(uint256 id, ...);\r\n\r\n    event SharesMinted(uint256 id, uint256 amount, address receiver);\r\n    event SharesBurned(uint256 id, uint256 amount, address receiver);\r\n    event WinningsClaimed(\r\n        uint256 id,\r\n        address winningOutcome,\r\n        uint256 amount,\r\n        uint256 settlementFee,\r\n        uint256 payout,\r\n        address indexed receiver\r\n    );\r\n\r\n    event SettlementFeeClaimed(address settlementAddress, uint256 amount, address indexed receiver);\r\n    event ProtocolFeeClaimed(address protocol, uint256 amount);\r\n\r\n    event ProtocolChanged(address protocol);\r\n    event ProtocolFeeChanged(uint256 fee);\r\n    event SettlementFeeChanged(uint256 fee);\r\n    event StakerFeeChanged(uint256 fee);\r\n\r\n    IERC20Full public collateral;\r\n    FeePot public feePot;\r\n\r\n    // fees are out of 1e18 and only apply to new markets\r\n    uint256 public stakerFee;\r\n    uint256 public settlementFee;\r\n    uint256 public protocolFee;\r\n\r\n    address public protocol; // collects protocol fees\r\n\r\n    uint256 public accumulatedProtocolFee = 0;\r\n    // settlement address => amount of collateral\r\n    mapping(address => uint256) public accumulatedSettlementFees;\r\n\r\n    // How many shares equals one collateral.\r\n    // Necessary to account for math errors from small numbers in balancer.\r\n    // shares = collateral / shareFactor\r\n    // collateral = shares * shareFactor\r\n    uint256 public shareFactor;\r\n\r\n    struct Market {\r\n        address settlementAddress;\r\n        OwnedERC20[] shareTokens;\r\n        uint256 endTime;\r\n        OwnedERC20 winner;\r\n        uint256 settlementFee;\r\n        uint256 protocolFee;\r\n        uint256 stakerFee;\r\n        uint256 creationTimestamp;\r\n        uint256[] initialOdds;\r\n    }\r\n    Market[] internal markets;\r\n\r\n    uint256 private constant MAX_UINT = 2**256 - 1;\r\n\r\n    constructor(\r\n        address _owner,\r\n        IERC20Full _collateral,\r\n        uint256 _shareFactor,\r\n        FeePot _feePot,\r\n        uint256 _stakerFee,\r\n        uint256 _settlementFee,\r\n        address _protocol,\r\n        uint256 _protocolFee\r\n    ) {\r\n        owner = _owner; // controls fees for new markets\r\n        collateral = _collateral;\r\n        shareFactor = _shareFactor;\r\n        feePot = _feePot;\r\n        stakerFee = _stakerFee;\r\n        settlementFee = _settlementFee;\r\n        protocol = _protocol;\r\n        protocolFee = _protocolFee;\r\n\r\n        _collateral.approve(address(_feePot), MAX_UINT);\r\n\r\n        // First market is always empty so that marketid zero means \"no market\"\r\n        makeEmptyMarket();\r\n    }\r\n\r\n    function makeEmptyMarket() internal {\r\n        string[] memory _noStrings = new string[](0);\r\n        uint256[] memory _noUint256s = new uint256[](0);\r\n        markets.push(makeMarket(address(0), _noStrings, _noStrings, 0, _noUint256s));\r\n    }\r\n\r\n    // function createMarket(address _settlementAddress, uint256 _endTime, ...) public returns (uint256);\r\n\r\n    function resolveMarket(uint256 _id) public virtual;\r\n\r\n    // Returns an empty struct if the market doesn't exist.\r\n    // Can check market existence before calling this by comparing _id against markets.length.\r\n    // Can check market existence of the return struct by checking that shareTokens[0] isn't the null address\r\n    function getMarket(uint256 _id) public view returns (Market memory) {\r\n        if (_id >= markets.length) {\r\n            return Market(address(0), new OwnedERC20[](0), 0, OwnedERC20(0), 0, 0, 0, 0, new uint256[](0));\r\n        } else {\r\n            return markets[_id];\r\n        }\r\n    }\r\n\r\n    function marketCount() public view returns (uint256) {\r\n        return markets.length;\r\n    }\r\n\r\n    // Returns factory-specific details about a market.\r\n    // function getMarketDetails(uint256 _id) public view returns (MarketDetails memory);\r\n\r\n    function mintShares(\r\n        uint256 _id,\r\n        uint256 _shareToMint,\r\n        address _receiver\r\n    ) public {\r\n        require(markets.length > _id, \"No such market\");\r\n        require(!isMarketResolved(_id), \"Cannot mint shares for resolved market\");\r\n\r\n        uint256 _cost = calcCost(_shareToMint);\r\n        collateral.transferFrom(msg.sender, address(this), _cost);\r\n\r\n        Market memory _market = markets[_id];\r\n        for (uint256 _i = 0; _i < _market.shareTokens.length; _i++) {\r\n            _market.shareTokens[_i].trustedMint(_receiver, _shareToMint);\r\n        }\r\n\r\n        emit SharesMinted(_id, _shareToMint, _receiver);\r\n    }\r\n\r\n    function burnShares(\r\n        uint256 _id,\r\n        uint256 _sharesToBurn,\r\n        address _receiver\r\n    ) public returns (uint256) {\r\n        require(markets.length > _id, \"No such market\");\r\n        require(!isMarketResolved(_id), \"Cannot burn shares for resolved market\");\r\n\r\n        Market memory _market = markets[_id];\r\n        for (uint256 _i = 0; _i < _market.shareTokens.length; _i++) {\r\n            // errors if sender doesn't have enough shares\r\n            _market.shareTokens[_i].trustedBurn(msg.sender, _sharesToBurn);\r\n        }\r\n\r\n        uint256 _payout = calcCost(_sharesToBurn);\r\n        uint256 _protocolFee = _payout.mul(_market.protocolFee).div(10**18);\r\n        uint256 _stakerFee = _payout.mul(_market.stakerFee).div(10**18);\r\n        _payout = _payout.sub(_protocolFee).sub(_stakerFee);\r\n\r\n        accumulatedProtocolFee += _protocolFee;\r\n        collateral.transfer(_receiver, _payout);\r\n        feePot.depositFees(_stakerFee);\r\n\r\n        emit SharesBurned(_id, _sharesToBurn, msg.sender);\r\n        return _payout;\r\n    }\r\n\r\n    function claimWinnings(uint256 _id, address _receiver) public returns (uint256) {\r\n        if (!isMarketResolved(_id)) {\r\n            // errors if market does not exist or is not resolved or resolvable\r\n            resolveMarket(_id);\r\n        }\r\n\r\n        Market memory _market = markets[_id];\r\n        uint256 _winningShares = _market.winner.trustedBurnAll(msg.sender);\r\n        _winningShares = (_winningShares / shareFactor) * shareFactor; // remove unusable dust\r\n\r\n        uint256 _payout = calcCost(_winningShares); // will fail if there are no winnings to claim\r\n        uint256 _settlementFee = _payout.mul(_market.settlementFee).div(10**18);\r\n        _payout = _payout.sub(_settlementFee);\r\n\r\n        accumulatedSettlementFees[_market.settlementAddress] += _settlementFee;\r\n        collateral.transfer(_receiver, _payout);\r\n\r\n        emit WinningsClaimed(_id, address(_market.winner), _winningShares, _settlementFee, _payout, _receiver);\r\n        return _payout;\r\n    }\r\n\r\n    function claimManyWinnings(uint256[] memory _ids, address _receiver) public returns (uint256) {\r\n        uint256 _totalWinnings = 0;\r\n        for (uint256 i = 0; i < _ids.length; i++) {\r\n            _totalWinnings = _totalWinnings.add(claimWinnings(_ids[i], _receiver));\r\n        }\r\n        return _totalWinnings;\r\n    }\r\n\r\n    function claimSettlementFees(address _receiver) public returns (uint256) {\r\n        uint256 _fees = accumulatedSettlementFees[msg.sender];\r\n        if (_fees > 0) {\r\n            accumulatedSettlementFees[msg.sender] = 0;\r\n            collateral.transfer(_receiver, _fees);\r\n            emit SettlementFeeClaimed(msg.sender, _fees, _receiver);\r\n        }\r\n        return _fees;\r\n    }\r\n\r\n    function claimProtocolFees() public returns (uint256) {\r\n        require(msg.sender == protocol || msg.sender == address(this), \"Only protocol can claim protocol fee\");\r\n        uint256 _fees = accumulatedProtocolFee;\r\n        if (_fees > 0) {\r\n            accumulatedProtocolFee = 0;\r\n            collateral.transfer(protocol, _fees);\r\n            emit ProtocolFeeClaimed(protocol, _fees);\r\n        }\r\n        return _fees;\r\n    }\r\n\r\n    function setSettlementFee(uint256 _newFee) external onlyOwner {\r\n        settlementFee = _newFee;\r\n        emit SettlementFeeChanged(_newFee);\r\n    }\r\n\r\n    function setStakerFee(uint256 _newFee) external onlyOwner {\r\n        stakerFee = _newFee;\r\n        emit StakerFeeChanged(_newFee);\r\n    }\r\n\r\n    function setProtocolFee(uint256 _newFee) external onlyOwner {\r\n        protocolFee = _newFee;\r\n        emit ProtocolFeeChanged(_newFee);\r\n    }\r\n\r\n    function setProtocol(address _newProtocol, bool _claimFirst) external onlyOwner {\r\n        if (_claimFirst) {\r\n            claimProtocolFees();\r\n        }\r\n        protocol = _newProtocol;\r\n        emit ProtocolChanged(_newProtocol);\r\n    }\r\n\r\n    function makeMarket(\r\n        address _settlementAddress,\r\n        string[] memory _names,\r\n        string[] memory _symbols,\r\n        uint256 _endTime,\r\n        uint256[] memory _initialOdds\r\n    ) internal returns (Market memory _market) {\r\n        _market = Market(\r\n            _settlementAddress,\r\n            createShareTokens(_names, _symbols, address(this)),\r\n            _endTime,\r\n            OwnedERC20(0),\r\n            settlementFee,\r\n            protocolFee,\r\n            stakerFee,\r\n            block.timestamp,\r\n            _initialOdds\r\n        );\r\n    }\r\n\r\n    function isMarketResolved(uint256 _id) public view returns (bool) {\r\n        Market memory _market = markets[_id];\r\n        return _market.winner != OwnedERC20(0);\r\n    }\r\n\r\n    // Only usable off-chain. Gas cost can easily eclipse block limit.\r\n    function listUnresolvedMarkets() public view returns (uint256[] memory) {\r\n        uint256 _totalUnresolved = 0;\r\n        for (uint256 i = 0; i < markets.length; i++) {\r\n            if (!isMarketResolved(i)) {\r\n                _totalUnresolved++;\r\n            }\r\n        }\r\n\r\n        uint256[] memory _marketIds = new uint256[](_totalUnresolved);\r\n\r\n        uint256 n = 0;\r\n        for (uint256 i = 0; i < markets.length; i++) {\r\n            if (n >= _totalUnresolved) break;\r\n\r\n            if (!isMarketResolved(i)) {\r\n                _marketIds[n] = i;\r\n                n++;\r\n            }\r\n        }\r\n\r\n        return _marketIds;\r\n    }\r\n\r\n    // shares => collateral\r\n    function calcCost(uint256 _shares) public view returns (uint256) {\r\n        require(\r\n            _shares >= shareFactor && _shares % shareFactor == 0,\r\n            \"Shares must be both greater than (or equal to) and divisible by shareFactor\"\r\n        );\r\n        return _shares / shareFactor;\r\n    }\r\n\r\n    // collateral => shares\r\n    function calcShares(uint256 _collateralIn) public view returns (uint256) {\r\n        return _collateralIn * shareFactor;\r\n    }\r\n\r\n    function onTransferOwnership(address, address) internal override {}\r\n}\r\n"
    },
    "contracts/turbo/SportsLinkMarketFactoryV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.7.6;\r\npragma abicoder v2;\r\n\r\nimport \"../libraries/IERC20Full.sol\";\r\nimport \"../balancer/BPool.sol\";\r\nimport \"./AbstractMarketFactoryV2.sol\";\r\nimport \"./FeePot.sol\";\r\nimport \"../libraries/SafeMathInt256.sol\";\r\nimport \"../libraries/CalculateLinesToBPoolOdds.sol\";\r\n\r\ncontract SportsLinkMarketFactoryV2 is AbstractMarketFactoryV2, CalculateLinesToBPoolOdds {\r\n    using SafeMathUint256 for uint256;\r\n    using SafeMathInt256 for int256;\r\n\r\n    event MarketCreated(\r\n        uint256 id,\r\n        address creator,\r\n        uint256 endTime,\r\n        MarketType marketType,\r\n        uint256 indexed eventId,\r\n        uint256 homeTeamId,\r\n        uint256 awayTeamId,\r\n        uint256 estimatedStartTime,\r\n        int256 score\r\n    );\r\n    event MarketResolved(uint256 id, address winner);\r\n    event LinkNodeChanged(address newLinkNode);\r\n\r\n    enum MarketType {HeadToHead, Spread, OverUnder}\r\n    enum HeadToHeadOutcome {\r\n        NoContest, // 0\r\n        Away, // 1\r\n        Home // 2\r\n    }\r\n    enum SpreadOutcome {\r\n        NoContest, // 0\r\n        Away, // 1\r\n        Home // 2\r\n    }\r\n    enum OverUnderOutcome {\r\n        NoContest, // 0\r\n        Over, // 1\r\n        Under // 2\r\n    }\r\n    struct MarketDetails {\r\n        uint256 eventId;\r\n        uint256 homeTeamId;\r\n        uint256 awayTeamId;\r\n        uint256 estimatedStartTime;\r\n        MarketType marketType;\r\n        EventStatus eventStatus;\r\n        // This value depends on the marketType.\r\n        // HeadToHead: ignored\r\n        // Spread: the home team spread\r\n        // OverUnder: total score in game\r\n        int256 value0;\r\n    }\r\n    // MarketId => MarketDetails\r\n    mapping(uint256 => MarketDetails) internal marketDetails;\r\n\r\n    enum EventStatus {Unknown, Scheduled, Final, Postponed, Canceled}\r\n    struct EventDetails {\r\n        uint256[3] markets;\r\n        uint256 startTime;\r\n        uint256 homeScore;\r\n        uint256 awayScore;\r\n        EventStatus status;\r\n        // If there is a resolution time then the market is resolved but not necessarily finalized.\r\n        // A market is finalized when its last two score updates were identical.\r\n        // Score updates must occur after a period of time spedcified by resolutionBuffer.\r\n        // This mechanism exists to reduce the risk of bad scores being sent by the API then later corrected.\r\n        // The downside is slower resolution.\r\n        uint256 resolutionTime; // time since last score update\r\n        bool finalized; // true after event resolves and has stable scores\r\n    }\r\n    // EventId => EventDetails\r\n    mapping(uint256 => EventDetails) public events;\r\n    uint256[] public listOfEvents;\r\n\r\n    address public linkNode;\r\n    uint256 public sportId;\r\n\r\n    constructor(\r\n        address _owner,\r\n        IERC20Full _collateral,\r\n        uint256 _shareFactor,\r\n        FeePot _feePot,\r\n        uint256 _stakerFee,\r\n        uint256 _settlementFee,\r\n        address _protocol,\r\n        uint256 _protocolFee,\r\n        address _linkNode,\r\n        uint256 _sportId\r\n    )\r\n        AbstractMarketFactoryV2(\r\n            _owner,\r\n            _collateral,\r\n            _shareFactor,\r\n            _feePot,\r\n            _stakerFee,\r\n            _settlementFee,\r\n            _protocol,\r\n            _protocolFee\r\n        )\r\n    {\r\n        linkNode = _linkNode;\r\n        sportId = _sportId;\r\n    }\r\n\r\n    function createMarket(\r\n        uint256 _eventId,\r\n        uint256 _homeTeamId,\r\n        uint256 _awayTeamId,\r\n        uint256 _startTimestamp,\r\n        int256 _homeSpread,\r\n        uint256 _totalScore,\r\n        bool _makeSpread,\r\n        bool _makeTotalScore,\r\n        int256[2] memory _moneylines // [home,away]\r\n    ) public returns (uint256[3] memory _ids) {\r\n        require(msg.sender == linkNode, \"Only link node can create markets\");\r\n\r\n        address _creator = msg.sender;\r\n        uint256 _endTime = _startTimestamp.add(60 * 8); // 8 hours\r\n\r\n        _ids = events[_eventId].markets;\r\n\r\n        if (_ids[0] == 0 && _moneylines[0] != 0 && _moneylines[1] != 0) {\r\n            _ids[0] = createHeadToHeadMarket(\r\n                _creator,\r\n                _endTime,\r\n                _eventId,\r\n                _homeTeamId,\r\n                _awayTeamId,\r\n                _startTimestamp,\r\n                _moneylines\r\n            );\r\n        }\r\n\r\n        if (_ids[1] == 0 && _makeSpread) {\r\n            // spread market hasn't been created and is ready to be created\r\n            _ids[1] = createSpreadMarket(\r\n                _creator,\r\n                _endTime,\r\n                _eventId,\r\n                _homeTeamId,\r\n                _awayTeamId,\r\n                _startTimestamp,\r\n                _homeSpread\r\n            );\r\n        }\r\n\r\n        if (_ids[2] == 0 && _makeTotalScore) {\r\n            // over-under market hasn't been created and is ready to be created\r\n            _ids[2] = createOverUnderMarket(\r\n                _creator,\r\n                _endTime,\r\n                _eventId,\r\n                _homeTeamId,\r\n                _awayTeamId,\r\n                _startTimestamp,\r\n                _totalScore\r\n            );\r\n        }\r\n\r\n        events[_eventId].status = EventStatus.Scheduled;\r\n        events[_eventId].startTime = _startTimestamp;\r\n        events[_eventId].markets = _ids;\r\n        listOfEvents.push(_eventId);\r\n    }\r\n\r\n    function createHeadToHeadMarket(\r\n        address _creator,\r\n        uint256 _endTime,\r\n        uint256 _eventId,\r\n        uint256 _homeTeamId,\r\n        uint256 _awayTeamId,\r\n        uint256 _startTimestamp,\r\n        int256[2] memory _moneylines // [home,away]\r\n    ) internal returns (uint256) {\r\n        string[] memory _outcomes = new string[](3);\r\n        _outcomes[uint256(HeadToHeadOutcome.NoContest)] = \"No Contest\";\r\n        _outcomes[uint256(HeadToHeadOutcome.Away)] = \"Away\";\r\n        _outcomes[uint256(HeadToHeadOutcome.Home)] = \"Home\";\r\n\r\n        uint256 _id = markets.length;\r\n        // moneylines is [home,away] but the outcomes are listed [NC,away,home] so they must be reversed\r\n        markets.push(\r\n            makeMarket(_creator, _outcomes, _outcomes, _endTime, oddsFromLines(_moneylines[1], _moneylines[0]))\r\n        );\r\n        marketDetails[_id] = MarketDetails(\r\n            _eventId,\r\n            _homeTeamId,\r\n            _awayTeamId,\r\n            _startTimestamp,\r\n            MarketType.HeadToHead,\r\n            EventStatus.Scheduled,\r\n            0\r\n        );\r\n        emit MarketCreated(\r\n            _id,\r\n            _creator,\r\n            _endTime,\r\n            MarketType.HeadToHead,\r\n            _eventId,\r\n            _homeTeamId,\r\n            _awayTeamId,\r\n            _startTimestamp,\r\n            0\r\n        );\r\n        return _id;\r\n    }\r\n\r\n    function createSpreadMarket(\r\n        address _creator,\r\n        uint256 _endTime,\r\n        uint256 _eventId,\r\n        uint256 _homeTeamId,\r\n        uint256 _awayTeamId,\r\n        uint256 _startTimestamp,\r\n        int256 _homeSpread\r\n    ) internal returns (uint256) {\r\n        string[] memory _outcomes = new string[](3);\r\n        _outcomes[uint256(SpreadOutcome.NoContest)] = \"No Contest\";\r\n        _outcomes[uint256(SpreadOutcome.Away)] = \"Away\";\r\n        _outcomes[uint256(SpreadOutcome.Home)] = \"Home\";\r\n\r\n        // The spread is a quantity of tenths. So 55 is 5.5 and -6 is -60.\r\n        // If the spread is a whole number then make it a half point more extreme, to eliminate ties.\r\n        // So 50 becomes 55, -60 becomes -65, and 0 becomes 5.\r\n        if (_homeSpread >= 0 && _homeSpread % 10 == 0) {\r\n            _homeSpread += 5;\r\n        } else if (_homeSpread < 0 && (-_homeSpread) % 10 == 0) {\r\n            _homeSpread -= 5;\r\n        }\r\n\r\n        uint256 _id = markets.length;\r\n        markets.push(makeMarket(_creator, _outcomes, _outcomes, _endTime, evenOdds(true, 2)));\r\n        marketDetails[_id] = MarketDetails(\r\n            _eventId,\r\n            _homeTeamId,\r\n            _awayTeamId,\r\n            _startTimestamp,\r\n            MarketType.Spread,\r\n            EventStatus.Scheduled,\r\n            _homeSpread\r\n        );\r\n        emit MarketCreated(\r\n            _id,\r\n            _creator,\r\n            _endTime,\r\n            MarketType.Spread,\r\n            _eventId,\r\n            _homeTeamId,\r\n            _awayTeamId,\r\n            _startTimestamp,\r\n            _homeSpread\r\n        );\r\n        return _id;\r\n    }\r\n\r\n    function createOverUnderMarket(\r\n        address _creator,\r\n        uint256 _endTime,\r\n        uint256 _eventId,\r\n        uint256 _homeTeamId,\r\n        uint256 _awayTeamId,\r\n        uint256 _startTimestamp,\r\n        uint256 _overUnderTotal\r\n    ) internal returns (uint256) {\r\n        string[] memory _outcomes = new string[](3);\r\n        _outcomes[uint256(OverUnderOutcome.NoContest)] = \"No Contest\";\r\n        _outcomes[uint256(OverUnderOutcome.Over)] = \"Over\";\r\n        _outcomes[uint256(OverUnderOutcome.Under)] = \"Under\";\r\n\r\n        // The total is a quantity of tenths. So 55 is 5.5 and -6 is -60.\r\n        // If the total is a whole number then make it a half point higher, to eliminate ties.\r\n        // So 50 becomes 55 and 0 becomes 5.\r\n        if (_overUnderTotal >= 0 && _overUnderTotal % 10 == 0) {\r\n            _overUnderTotal += 5;\r\n        }\r\n\r\n        uint256 _id = markets.length;\r\n        markets.push(makeMarket(_creator, _outcomes, _outcomes, _endTime, evenOdds(true, 2)));\r\n        marketDetails[_id] = MarketDetails(\r\n            _eventId,\r\n            _homeTeamId,\r\n            _awayTeamId,\r\n            _startTimestamp,\r\n            MarketType.OverUnder,\r\n            EventStatus.Scheduled,\r\n            int256(_overUnderTotal)\r\n        );\r\n        emit MarketCreated(\r\n            _id,\r\n            _creator,\r\n            _endTime,\r\n            MarketType.OverUnder,\r\n            _eventId,\r\n            _homeTeamId,\r\n            _awayTeamId,\r\n            _startTimestamp,\r\n            int256(_overUnderTotal)\r\n        );\r\n        return _id;\r\n    }\r\n\r\n    function resolveMarket(uint256) public pure override {\r\n        require(false, \"Only the link node can resolve the market, using trustedResolveMarkets\");\r\n    }\r\n\r\n    function trustedResolveMarkets(\r\n        uint256 _eventId,\r\n        uint256 _eventStatus,\r\n        uint256 _homeScore,\r\n        uint256 _awayScore\r\n    ) public {\r\n        require(msg.sender == linkNode, \"Only link node can resolve markets\");\r\n\r\n        EventDetails storage _event = events[_eventId];\r\n        uint256[3] memory _ids = _event.markets;\r\n\r\n        require(_ids[0] != 0 || _ids[1] != 0 || _ids[2] != 0, \"Cannot resolve markets that weren't created\");\r\n\r\n        require(EventStatus(_eventStatus) != EventStatus.Scheduled, \"cannot resolve SCHEDULED markets\");\r\n\r\n        // resolve markets as No Contest\r\n        if (EventStatus(_eventStatus) != EventStatus.Final) {\r\n            for (uint256 i = 0; i < _ids.length; i++) {\r\n                uint256 _id = _ids[i];\r\n                if (_id == 0) continue; // skip non-created markets\r\n                OwnedERC20 _winner = markets[_id].shareTokens[0]; // 0th outcome is No Contest for all market types\r\n                markets[_id].winner = _winner;\r\n                emit MarketResolved(_id, address(_winner));\r\n            }\r\n            return;\r\n        }\r\n\r\n        // only resolve markets that were created\r\n        if (_ids[0] != 0) {\r\n            resolveHeadToHeadMarket(_ids[0], _homeScore, _awayScore);\r\n        }\r\n        if (_ids[1] != 0) {\r\n            resolveSpreadMarket(_ids[1], _homeScore, _awayScore);\r\n        }\r\n        if (_ids[2] != 0) {\r\n            resolveOverUnderMarket(_ids[2], _homeScore, _awayScore);\r\n        }\r\n    }\r\n\r\n    function resolveHeadToHeadMarket(\r\n        uint256 _id,\r\n        uint256 _homeScore,\r\n        uint256 _awayScore\r\n    ) internal {\r\n        OwnedERC20 _winner;\r\n        if (_homeScore > _awayScore) {\r\n            _winner = markets[_id].shareTokens[uint256(HeadToHeadOutcome.Home)]; // home team won\r\n        } else if (_homeScore < _awayScore) {\r\n            _winner = markets[_id].shareTokens[uint256(HeadToHeadOutcome.Away)]; // away team won\r\n        } else {\r\n            _winner = markets[_id].shareTokens[uint256(HeadToHeadOutcome.NoContest)]; // no contest\r\n        }\r\n\r\n        markets[_id].winner = _winner;\r\n        emit MarketResolved(_id, address(_winner));\r\n    }\r\n\r\n    function resolveSpreadMarket(\r\n        uint256 _id,\r\n        uint256 _homeScore,\r\n        uint256 _awayScore\r\n    ) internal {\r\n        MarketDetails memory _details = marketDetails[_id];\r\n        int256 _targetSpread = _details.value0;\r\n\r\n        int256 _actualSpread = int256(_homeScore).sub(int256(_awayScore));\r\n\r\n        OwnedERC20 _winner;\r\n        if (_actualSpread > _targetSpread) {\r\n            _winner = markets[_id].shareTokens[uint256(SpreadOutcome.Home)]; // home spread greater\r\n        } else if (_actualSpread < _targetSpread) {\r\n            _winner = markets[_id].shareTokens[uint256(SpreadOutcome.Away)]; // home spread lesser\r\n        } else {\r\n            _winner = markets[_id].shareTokens[uint256(SpreadOutcome.NoContest)]; // no contest\r\n        }\r\n\r\n        markets[_id].winner = _winner;\r\n        emit MarketResolved(_id, address(_winner));\r\n    }\r\n\r\n    function resolveOverUnderMarket(\r\n        uint256 _id,\r\n        uint256 _homeScore,\r\n        uint256 _awayScore\r\n    ) internal {\r\n        MarketDetails memory _details = marketDetails[_id];\r\n        int256 _targetTotal = _details.value0;\r\n\r\n        int256 _actualTotal = int256(_homeScore).add(int256(_awayScore));\r\n\r\n        OwnedERC20 _winner;\r\n        if (_actualTotal > _targetTotal) {\r\n            _winner = markets[_id].shareTokens[uint256(OverUnderOutcome.Over)]; // over\r\n        } else if (_actualTotal < _targetTotal) {\r\n            _winner = markets[_id].shareTokens[uint256(OverUnderOutcome.Under)]; // under\r\n        } else {\r\n            _winner = markets[_id].shareTokens[uint256(OverUnderOutcome.NoContest)]; // no contest\r\n        }\r\n\r\n        markets[_id].winner = _winner;\r\n        emit MarketResolved(_id, address(_winner));\r\n    }\r\n\r\n    function getMarketDetails(uint256 _marketId) public view returns (MarketDetails memory) {\r\n        return marketDetails[_marketId];\r\n    }\r\n\r\n    function setLinkNode(address _newLinkNode) external onlyOwner {\r\n        linkNode = _newLinkNode;\r\n        emit LinkNodeChanged(_newLinkNode);\r\n    }\r\n\r\n    function getEventMarkets(uint256 _eventId) external view returns (uint256[3] memory) {\r\n        uint256[3] memory _event = events[_eventId].markets;\r\n        return _event;\r\n    }\r\n\r\n    // Events can be partially registered, by only creating some markets.\r\n    // This returns true only if an event is fully registered.\r\n    function isEventRegistered(uint256 _eventId) public view returns (bool) {\r\n        uint256[3] memory _event = events[_eventId].markets;\r\n        return _event[0] != 0 && _event[1] != 0 && _event[2] != 0;\r\n    }\r\n\r\n    function isEventResolved(uint256 _eventId) public view returns (bool) {\r\n        // check the event's head-to-head market since it will always exist if the event's markets exist\r\n        uint256 _marketId = events[_eventId].markets[0];\r\n        return isMarketResolved(_marketId);\r\n    }\r\n\r\n    // Only usable off-chain. Gas cost can easily eclipse block limit.\r\n    // Lists all events that could be resolved with a call to resolveEvent.\r\n    // Not all will be resolvable because this does not ensure the game ended.\r\n    function listResolvableEvents() external view returns (uint256[] memory) {\r\n        uint256 _totalResolvable = countResolvableEvents();\r\n        uint256[] memory _resolvableEvents = new uint256[](_totalResolvable);\r\n\r\n        uint256 n = 0;\r\n        for (uint256 i = 0; i < listOfEvents.length; i++) {\r\n            if (n > _totalResolvable) break;\r\n            uint256 _eventId = listOfEvents[i];\r\n            if (isEventResolvable(_eventId)) {\r\n                _resolvableEvents[n] = _eventId;\r\n                n++;\r\n            }\r\n        }\r\n\r\n        return _resolvableEvents;\r\n    }\r\n\r\n    function countResolvableEvents() internal view returns (uint256) {\r\n        uint256 _totalResolvable = 0;\r\n        for (uint256 i = 0; i < listOfEvents.length; i++) {\r\n            uint256 _eventId = listOfEvents[i];\r\n            if (isEventResolvable(_eventId)) {\r\n                _totalResolvable++;\r\n            }\r\n        }\r\n        return _totalResolvable;\r\n    }\r\n\r\n    // Returns true if a call to resolveEvent is potentially useful.\r\n    function isEventResolvable(uint256 _eventId) internal view returns (bool) {\r\n        EventDetails memory _event = events[_eventId];\r\n\r\n        bool _unresolved = false; // default because non-existing markets aren't resolvable\r\n        for (uint256 i = 0; i < _event.markets.length; i++) {\r\n            uint256 _marketId = _event.markets[i];\r\n            if (_marketId != 0 && !isMarketResolved(_marketId)) {\r\n                _unresolved = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        return _unresolved;\r\n    }\r\n}\r\n"
    },
    "contracts/turbo/SportsLinkMarketFactoryV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.7.6;\r\npragma abicoder v2;\r\n\r\nimport \"../libraries/IERC20Full.sol\";\r\nimport \"../balancer/BPool.sol\";\r\nimport \"./AbstractMarketFactoryV1.sol\";\r\nimport \"./FeePot.sol\";\r\nimport \"../libraries/SafeMathInt256.sol\";\r\n\r\ncontract SportsLinkMarketFactoryV1 is AbstractMarketFactoryV1 {\r\n    using SafeMathUint256 for uint256;\r\n    using SafeMathInt256 for int256;\r\n\r\n    event MarketCreated(\r\n        uint256 id,\r\n        address creator,\r\n        uint256 endTime,\r\n        MarketType marketType,\r\n        uint256 indexed eventId,\r\n        uint256 homeTeamId,\r\n        uint256 awayTeamId,\r\n        uint256 estimatedStartTime,\r\n        int256 score\r\n    );\r\n    event MarketResolved(uint256 id, address winner);\r\n    event LinkNodeChanged(address newLinkNode);\r\n\r\n    enum MarketType {HeadToHead, Spread, OverUnder}\r\n    enum HeadToHeadOutcome {\r\n        NoContest, // 0\r\n        Away, // 1\r\n        Home // 2\r\n    }\r\n    enum SpreadOutcome {\r\n        NoContest, // 0\r\n        Away, // 1\r\n        Home // 2\r\n    }\r\n    enum OverUnderOutcome {\r\n        NoContest, // 0\r\n        Over, // 1\r\n        Under // 2\r\n    }\r\n    struct MarketDetails {\r\n        uint256 eventId;\r\n        uint256 homeTeamId;\r\n        uint256 awayTeamId;\r\n        uint256 estimatedStartTime;\r\n        MarketType marketType;\r\n        EventStatus eventStatus;\r\n        // This value depends on the marketType.\r\n        // HeadToHead: ignored\r\n        // Spread: the home team spread\r\n        // OverUnder: total score in game\r\n        int256 value0;\r\n    }\r\n    // MarketId => MarketDetails\r\n    mapping(uint256 => MarketDetails) internal marketDetails;\r\n\r\n    enum EventStatus {Unknown, Scheduled, Final, Postponed, Canceled}\r\n    struct EventDetails {\r\n        uint256[3] markets;\r\n        uint256 startTime;\r\n        uint256 homeScore;\r\n        uint256 awayScore;\r\n        EventStatus status;\r\n        // If there is a resolution time then the market is resolved but not necessarily finalized.\r\n        // A market is finalized when its last two score updates were identical.\r\n        // Score updates must occur after a period of time spedcified by resolutionBuffer.\r\n        // This mechanism exists to reduce the risk of bad scores being sent by the API then later corrected.\r\n        // The downside is slower resolution.\r\n        uint256 resolutionTime; // time since last score update\r\n        bool finalized; // true after event resolves and has stable scores\r\n    }\r\n    // EventId => EventDetails\r\n    mapping(uint256 => EventDetails) public events;\r\n    uint256[] public listOfEvents;\r\n\r\n    address public linkNode;\r\n    uint256 public sportId;\r\n\r\n    constructor(\r\n        address _owner,\r\n        IERC20Full _collateral,\r\n        uint256 _shareFactor,\r\n        FeePot _feePot,\r\n        uint256 _stakerFee,\r\n        uint256 _settlementFee,\r\n        address _protocol,\r\n        uint256 _protocolFee,\r\n        address _linkNode,\r\n        uint256 _sportId\r\n    )\r\n        AbstractMarketFactoryV1(\r\n            _owner,\r\n            _collateral,\r\n            _shareFactor,\r\n            _feePot,\r\n            _stakerFee,\r\n            _settlementFee,\r\n            _protocol,\r\n            _protocolFee\r\n        )\r\n    {\r\n        linkNode = _linkNode;\r\n        sportId = _sportId;\r\n    }\r\n\r\n    function createMarket(\r\n        uint256 _eventId,\r\n        uint256 _homeTeamId,\r\n        uint256 _awayTeamId,\r\n        uint256 _startTimestamp,\r\n        int256 _homeSpread,\r\n        uint256 _totalScore,\r\n        bool _makeSpread,\r\n        bool _makeTotalScore\r\n    ) public returns (uint256[3] memory _ids) {\r\n        require(msg.sender == linkNode, \"Only link node can create markets\");\r\n\r\n        address _creator = msg.sender;\r\n        uint256 _endTime = _startTimestamp.add(60 * 8); // 8 hours\r\n\r\n        _ids = events[_eventId].markets;\r\n\r\n        if (_ids[0] == 0) {\r\n            _ids[0] = createHeadToHeadMarket(_creator, _endTime, _eventId, _homeTeamId, _awayTeamId, _startTimestamp);\r\n        }\r\n\r\n        if (_ids[1] == 0 && _makeSpread) {\r\n            // spread market hasn't been created and is ready to be created\r\n            _ids[1] = createSpreadMarket(\r\n                _creator,\r\n                _endTime,\r\n                _eventId,\r\n                _homeTeamId,\r\n                _awayTeamId,\r\n                _startTimestamp,\r\n                _homeSpread\r\n            );\r\n        }\r\n\r\n        if (_ids[2] == 0 && _makeTotalScore) {\r\n            // over-under market hasn't been created and is ready to be created\r\n            _ids[2] = createOverUnderMarket(\r\n                _creator,\r\n                _endTime,\r\n                _eventId,\r\n                _homeTeamId,\r\n                _awayTeamId,\r\n                _startTimestamp,\r\n                _totalScore\r\n            );\r\n        }\r\n\r\n        events[_eventId].status = EventStatus.Scheduled;\r\n        events[_eventId].startTime = _startTimestamp;\r\n        events[_eventId].markets = _ids;\r\n        listOfEvents.push(_eventId);\r\n    }\r\n\r\n    function createHeadToHeadMarket(\r\n        address _creator,\r\n        uint256 _endTime,\r\n        uint256 _eventId,\r\n        uint256 _homeTeamId,\r\n        uint256 _awayTeamId,\r\n        uint256 _startTimestamp\r\n    ) internal returns (uint256) {\r\n        string[] memory _outcomes = new string[](3);\r\n        _outcomes[uint256(HeadToHeadOutcome.NoContest)] = \"No Contest\";\r\n        _outcomes[uint256(HeadToHeadOutcome.Away)] = \"Away\";\r\n        _outcomes[uint256(HeadToHeadOutcome.Home)] = \"Home\";\r\n\r\n        uint256 _id = markets.length;\r\n        markets.push(makeMarket(_creator, _outcomes, _outcomes, _endTime));\r\n        marketDetails[_id] = MarketDetails(\r\n            _eventId,\r\n            _homeTeamId,\r\n            _awayTeamId,\r\n            _startTimestamp,\r\n            MarketType.HeadToHead,\r\n            EventStatus.Scheduled,\r\n            0\r\n        );\r\n        emit MarketCreated(\r\n            _id,\r\n            _creator,\r\n            _endTime,\r\n            MarketType.HeadToHead,\r\n            _eventId,\r\n            _homeTeamId,\r\n            _awayTeamId,\r\n            _startTimestamp,\r\n            0\r\n        );\r\n        return _id;\r\n    }\r\n\r\n    function createSpreadMarket(\r\n        address _creator,\r\n        uint256 _endTime,\r\n        uint256 _eventId,\r\n        uint256 _homeTeamId,\r\n        uint256 _awayTeamId,\r\n        uint256 _startTimestamp,\r\n        int256 _homeSpread\r\n    ) internal returns (uint256) {\r\n        string[] memory _outcomes = new string[](3);\r\n        _outcomes[uint256(SpreadOutcome.NoContest)] = \"No Contest\";\r\n        _outcomes[uint256(SpreadOutcome.Away)] = \"Away\";\r\n        _outcomes[uint256(SpreadOutcome.Home)] = \"Home\";\r\n\r\n        // The spread is a quantity of tenths. So 55 is 5.5 and -6 is -60.\r\n        // If the spread is a whole number then make it a half point more extreme, to eliminate ties.\r\n        // So 50 becomes 55, -60 becomes -65, and 0 becomes 5.\r\n        if (_homeSpread >= 0 && _homeSpread % 10 == 0) {\r\n            _homeSpread += 5;\r\n        } else if (_homeSpread < 0 && (-_homeSpread) % 10 == 0) {\r\n            _homeSpread -= 5;\r\n        }\r\n\r\n        uint256 _id = markets.length;\r\n        markets.push(makeMarket(_creator, _outcomes, _outcomes, _endTime));\r\n        marketDetails[_id] = MarketDetails(\r\n            _eventId,\r\n            _homeTeamId,\r\n            _awayTeamId,\r\n            _startTimestamp,\r\n            MarketType.Spread,\r\n            EventStatus.Scheduled,\r\n            _homeSpread\r\n        );\r\n        emit MarketCreated(\r\n            _id,\r\n            _creator,\r\n            _endTime,\r\n            MarketType.Spread,\r\n            _eventId,\r\n            _homeTeamId,\r\n            _awayTeamId,\r\n            _startTimestamp,\r\n            _homeSpread\r\n        );\r\n        return _id;\r\n    }\r\n\r\n    function createOverUnderMarket(\r\n        address _creator,\r\n        uint256 _endTime,\r\n        uint256 _eventId,\r\n        uint256 _homeTeamId,\r\n        uint256 _awayTeamId,\r\n        uint256 _startTimestamp,\r\n        uint256 _overUnderTotal\r\n    ) internal returns (uint256) {\r\n        string[] memory _outcomes = new string[](3);\r\n        _outcomes[uint256(OverUnderOutcome.NoContest)] = \"No Contest\";\r\n        _outcomes[uint256(OverUnderOutcome.Over)] = \"Over\";\r\n        _outcomes[uint256(OverUnderOutcome.Under)] = \"Under\";\r\n\r\n        // The total is a quantity of tenths. So 55 is 5.5 and -6 is -60.\r\n        // If the total is a whole number then make it a half point higher, to eliminate ties.\r\n        // So 50 becomes 55 and 0 becomes 5.\r\n        if (_overUnderTotal >= 0 && _overUnderTotal % 10 == 0) {\r\n            _overUnderTotal += 5;\r\n        }\r\n\r\n        uint256 _id = markets.length;\r\n        markets.push(makeMarket(_creator, _outcomes, _outcomes, _endTime));\r\n        marketDetails[_id] = MarketDetails(\r\n            _eventId,\r\n            _homeTeamId,\r\n            _awayTeamId,\r\n            _startTimestamp,\r\n            MarketType.OverUnder,\r\n            EventStatus.Scheduled,\r\n            int256(_overUnderTotal)\r\n        );\r\n        emit MarketCreated(\r\n            _id,\r\n            _creator,\r\n            _endTime,\r\n            MarketType.OverUnder,\r\n            _eventId,\r\n            _homeTeamId,\r\n            _awayTeamId,\r\n            _startTimestamp,\r\n            int256(_overUnderTotal)\r\n        );\r\n        return _id;\r\n    }\r\n\r\n    function resolveMarket(uint256) public pure override {\r\n        require(false, \"Only the link node can resolve the market, using trustedResolveMarkets\");\r\n    }\r\n\r\n    function trustedResolveMarkets(\r\n        uint256 _eventId,\r\n        uint256 _eventStatus,\r\n        uint256 _homeScore,\r\n        uint256 _awayScore\r\n    ) public {\r\n        require(msg.sender == linkNode, \"Only link node can resolve markets\");\r\n\r\n        EventDetails storage _event = events[_eventId];\r\n        uint256[3] memory _ids = _event.markets;\r\n\r\n        require(_ids[0] != 0 || _ids[1] != 0 || _ids[2] != 0, \"Cannot resolve markets that weren't created\");\r\n\r\n        require(EventStatus(_eventStatus) != EventStatus.Scheduled, \"cannot resolve SCHEDULED markets\");\r\n\r\n        // resolve markets as No Contest\r\n        if (EventStatus(_eventStatus) != EventStatus.Final) {\r\n            for (uint256 i = 0; i < _ids.length; i++) {\r\n                uint256 _id = _ids[i];\r\n                if (_id == 0) continue; // skip non-created markets\r\n                OwnedERC20 _winner = markets[_id].shareTokens[0]; // 0th outcome is No Contest for all market types\r\n                markets[_id].winner = _winner;\r\n                emit MarketResolved(_id, address(_winner));\r\n            }\r\n            return;\r\n        }\r\n\r\n        // only resolve markets that were created\r\n        if (_ids[0] != 0) {\r\n            resolveHeadToHeadMarket(_ids[0], _homeScore, _awayScore);\r\n        }\r\n        if (_ids[1] != 0) {\r\n            resolveSpreadMarket(_ids[1], _homeScore, _awayScore);\r\n        }\r\n        if (_ids[2] != 0) {\r\n            resolveOverUnderMarket(_ids[2], _homeScore, _awayScore);\r\n        }\r\n    }\r\n\r\n    function resolveHeadToHeadMarket(\r\n        uint256 _id,\r\n        uint256 _homeScore,\r\n        uint256 _awayScore\r\n    ) internal {\r\n        OwnedERC20 _winner;\r\n        if (_homeScore > _awayScore) {\r\n            _winner = markets[_id].shareTokens[uint256(HeadToHeadOutcome.Home)]; // home team won\r\n        } else if (_homeScore < _awayScore) {\r\n            _winner = markets[_id].shareTokens[uint256(HeadToHeadOutcome.Away)]; // away team won\r\n        } else {\r\n            _winner = markets[_id].shareTokens[uint256(HeadToHeadOutcome.NoContest)]; // no contest\r\n        }\r\n\r\n        markets[_id].winner = _winner;\r\n        emit MarketResolved(_id, address(_winner));\r\n    }\r\n\r\n    function resolveSpreadMarket(\r\n        uint256 _id,\r\n        uint256 _homeScore,\r\n        uint256 _awayScore\r\n    ) internal {\r\n        MarketDetails memory _details = marketDetails[_id];\r\n        int256 _targetSpread = _details.value0;\r\n\r\n        int256 _actualSpread = int256(_homeScore).sub(int256(_awayScore));\r\n\r\n        OwnedERC20 _winner;\r\n        if (_actualSpread > _targetSpread) {\r\n            _winner = markets[_id].shareTokens[uint256(SpreadOutcome.Home)]; // home spread greater\r\n        } else if (_actualSpread < _targetSpread) {\r\n            _winner = markets[_id].shareTokens[uint256(SpreadOutcome.Away)]; // home spread lesser\r\n        } else {\r\n            _winner = markets[_id].shareTokens[uint256(SpreadOutcome.NoContest)]; // no contest\r\n        }\r\n\r\n        markets[_id].winner = _winner;\r\n        emit MarketResolved(_id, address(_winner));\r\n    }\r\n\r\n    function resolveOverUnderMarket(\r\n        uint256 _id,\r\n        uint256 _homeScore,\r\n        uint256 _awayScore\r\n    ) internal {\r\n        MarketDetails memory _details = marketDetails[_id];\r\n        int256 _targetTotal = _details.value0;\r\n\r\n        int256 _actualTotal = int256(_homeScore).add(int256(_awayScore));\r\n\r\n        OwnedERC20 _winner;\r\n        if (_actualTotal > _targetTotal) {\r\n            _winner = markets[_id].shareTokens[uint256(OverUnderOutcome.Over)]; // over\r\n        } else if (_actualTotal < _targetTotal) {\r\n            _winner = markets[_id].shareTokens[uint256(OverUnderOutcome.Under)]; // under\r\n        } else {\r\n            _winner = markets[_id].shareTokens[uint256(OverUnderOutcome.NoContest)]; // no contest\r\n        }\r\n\r\n        markets[_id].winner = _winner;\r\n        emit MarketResolved(_id, address(_winner));\r\n    }\r\n\r\n    function getMarketDetails(uint256 _marketId) public view returns (MarketDetails memory) {\r\n        return marketDetails[_marketId];\r\n    }\r\n\r\n    function setLinkNode(address _newLinkNode) external onlyOwner {\r\n        linkNode = _newLinkNode;\r\n        emit LinkNodeChanged(_newLinkNode);\r\n    }\r\n\r\n    function getEventMarkets(uint256 _eventId) external view returns (uint256[3] memory) {\r\n        uint256[3] memory _event = events[_eventId].markets;\r\n        return _event;\r\n    }\r\n\r\n    // Events can be partially registered, by only creating some markets.\r\n    // This returns true only if an event is fully registered.\r\n    function isEventRegistered(uint256 _eventId) public view returns (bool) {\r\n        uint256[3] memory _event = events[_eventId].markets;\r\n        return _event[0] != 0 && _event[1] != 0 && _event[2] != 0;\r\n    }\r\n\r\n    function isEventResolved(uint256 _eventId) public view returns (bool) {\r\n        // check the event's head-to-head market since it will always exist if the event's markets exist\r\n        uint256 _marketId = events[_eventId].markets[0];\r\n        return isMarketResolved(_marketId);\r\n    }\r\n\r\n    // Only usable off-chain. Gas cost can easily eclipse block limit.\r\n    // Lists all events that could be resolved with a call to resolveEvent.\r\n    // Not all will be resolvable because this does not ensure the game ended.\r\n    function listResolvableEvents() external view returns (uint256[] memory) {\r\n        uint256 _totalResolvable = countResolvableEvents();\r\n        uint256[] memory _resolvableEvents = new uint256[](_totalResolvable);\r\n\r\n        uint256 n = 0;\r\n        for (uint256 i = 0; i < listOfEvents.length; i++) {\r\n            if (n > _totalResolvable) break;\r\n            uint256 _eventId = listOfEvents[i];\r\n            if (isEventResolvable(_eventId)) {\r\n                _resolvableEvents[n] = _eventId;\r\n                n++;\r\n            }\r\n        }\r\n\r\n        return _resolvableEvents;\r\n    }\r\n\r\n    function countResolvableEvents() internal view returns (uint256) {\r\n        uint256 _totalResolvable = 0;\r\n        for (uint256 i = 0; i < listOfEvents.length; i++) {\r\n            uint256 _eventId = listOfEvents[i];\r\n            if (isEventResolvable(_eventId)) {\r\n                _totalResolvable++;\r\n            }\r\n        }\r\n        return _totalResolvable;\r\n    }\r\n\r\n    // Returns true if a call to resolveEvent is potentially useful.\r\n    function isEventResolvable(uint256 _eventId) internal view returns (bool) {\r\n        EventDetails memory _event = events[_eventId];\r\n\r\n        bool _unresolved = false; // default because non-existing markets aren't resolvable\r\n        for (uint256 i = 0; i < _event.markets.length; i++) {\r\n            uint256 _marketId = _event.markets[i];\r\n            if (_marketId != 0 && !isMarketResolved(_marketId)) {\r\n                _unresolved = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        return _unresolved;\r\n    }\r\n}\r\n"
    },
    "contracts/turbo/AbstractMarketFactoryV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.7.6;\r\npragma abicoder v2;\r\n\r\nimport \"../libraries/IERC20Full.sol\";\r\nimport \"../balancer/BPool.sol\";\r\nimport \"./TurboShareTokenFactory.sol\";\r\nimport \"./FeePot.sol\";\r\n\r\nabstract contract AbstractMarketFactoryV1 is TurboShareTokenFactoryV1, Ownable {\r\n    using SafeMathUint256 for uint256;\r\n\r\n    // Should always have ID. Others are optional.\r\n    // event MarketCreated(uint256 id, address settlementAddress, uint256 endTime, ...);\r\n\r\n    // Should always have ID. Others are optional.\r\n    // event MarketResolved(uint256 id, ...);\r\n\r\n    event SharesMinted(uint256 id, uint256 amount, address receiver);\r\n    event SharesBurned(uint256 id, uint256 amount, address receiver);\r\n    event WinningsClaimed(\r\n        uint256 id,\r\n        address winningOutcome,\r\n        uint256 amount,\r\n        uint256 settlementFee,\r\n        uint256 payout,\r\n        address indexed receiver\r\n    );\r\n\r\n    event SettlementFeeClaimed(address settlementAddress, uint256 amount, address indexed receiver);\r\n    event ProtocolFeeClaimed(address protocol, uint256 amount);\r\n\r\n    event ProtocolChanged(address protocol);\r\n    event ProtocolFeeChanged(uint256 fee);\r\n    event SettlementFeeChanged(uint256 fee);\r\n    event StakerFeeChanged(uint256 fee);\r\n\r\n    IERC20Full public collateral;\r\n    FeePot public feePot;\r\n\r\n    // fees are out of 1e18 and only apply to new markets\r\n    uint256 public stakerFee;\r\n    uint256 public settlementFee;\r\n    uint256 public protocolFee;\r\n\r\n    address public protocol; // collects protocol fees\r\n\r\n    uint256 public accumulatedProtocolFee = 0;\r\n    // settlement address => amount of collateral\r\n    mapping(address => uint256) public accumulatedSettlementFees;\r\n\r\n    // How many shares equals one collateral.\r\n    // Necessary to account for math errors from small numbers in balancer.\r\n    // shares = collateral / shareFactor\r\n    // collateral = shares * shareFactor\r\n    uint256 public shareFactor;\r\n\r\n    struct Market {\r\n        address settlementAddress;\r\n        OwnedERC20[] shareTokens;\r\n        uint256 endTime;\r\n        OwnedERC20 winner;\r\n        uint256 settlementFee;\r\n        uint256 protocolFee;\r\n        uint256 stakerFee;\r\n        uint256 creationTimestamp;\r\n    }\r\n    Market[] internal markets;\r\n\r\n    uint256 private constant MAX_UINT = 2**256 - 1;\r\n\r\n    constructor(\r\n        address _owner,\r\n        IERC20Full _collateral,\r\n        uint256 _shareFactor,\r\n        FeePot _feePot,\r\n        uint256 _stakerFee,\r\n        uint256 _settlementFee,\r\n        address _protocol,\r\n        uint256 _protocolFee\r\n    ) {\r\n        owner = _owner; // controls fees for new markets\r\n        collateral = _collateral;\r\n        shareFactor = _shareFactor;\r\n        feePot = _feePot;\r\n        stakerFee = _stakerFee;\r\n        settlementFee = _settlementFee;\r\n        protocol = _protocol;\r\n        protocolFee = _protocolFee;\r\n\r\n        _collateral.approve(address(_feePot), MAX_UINT);\r\n\r\n        // First market is always empty so that marketid zero means \"no market\"\r\n        string[] memory _nothing = new string[](0);\r\n        markets.push(makeMarket(address(0), _nothing, _nothing, 0));\r\n    }\r\n\r\n    // function createMarket(address _settlementAddress, uint256 _endTime, ...) public returns (uint256);\r\n\r\n    function resolveMarket(uint256 _id) public virtual;\r\n\r\n    // Returns an empty struct if the market doesn't exist.\r\n    // Can check market existence before calling this by comparing _id against markets.length.\r\n    // Can check market existence of the return struct by checking that shareTokens[0] isn't the null address\r\n    function getMarket(uint256 _id) public view returns (Market memory) {\r\n        if (_id >= markets.length) {\r\n            return Market(address(0), new OwnedERC20[](0), 0, OwnedERC20(0), 0, 0, 0, 0);\r\n        } else {\r\n            return markets[_id];\r\n        }\r\n    }\r\n\r\n    function marketCount() public view returns (uint256) {\r\n        return markets.length;\r\n    }\r\n\r\n    // Returns factory-specific details about a market.\r\n    // function getMarketDetails(uint256 _id) public view returns (MarketDetails memory);\r\n\r\n    function mintShares(\r\n        uint256 _id,\r\n        uint256 _shareToMint,\r\n        address _receiver\r\n    ) public {\r\n        require(markets.length > _id, \"No such market\");\r\n        require(!isMarketResolved(_id), \"Cannot mint shares for resolved market\");\r\n\r\n        uint256 _cost = calcCost(_shareToMint);\r\n        collateral.transferFrom(msg.sender, address(this), _cost);\r\n\r\n        Market memory _market = markets[_id];\r\n        for (uint256 _i = 0; _i < _market.shareTokens.length; _i++) {\r\n            _market.shareTokens[_i].trustedMint(_receiver, _shareToMint);\r\n        }\r\n\r\n        emit SharesMinted(_id, _shareToMint, _receiver);\r\n    }\r\n\r\n    function burnShares(\r\n        uint256 _id,\r\n        uint256 _sharesToBurn,\r\n        address _receiver\r\n    ) public returns (uint256) {\r\n        require(markets.length > _id, \"No such market\");\r\n        require(!isMarketResolved(_id), \"Cannot burn shares for resolved market\");\r\n\r\n        Market memory _market = markets[_id];\r\n        for (uint256 _i = 0; _i < _market.shareTokens.length; _i++) {\r\n            // errors if sender doesn't have enough shares\r\n            _market.shareTokens[_i].trustedBurn(msg.sender, _sharesToBurn);\r\n        }\r\n\r\n        uint256 _payout = calcCost(_sharesToBurn);\r\n        uint256 _protocolFee = _payout.mul(_market.protocolFee).div(10**18);\r\n        uint256 _stakerFee = _payout.mul(_market.stakerFee).div(10**18);\r\n        _payout = _payout.sub(_protocolFee).sub(_stakerFee);\r\n\r\n        accumulatedProtocolFee += _protocolFee;\r\n        collateral.transfer(_receiver, _payout);\r\n        feePot.depositFees(_stakerFee);\r\n\r\n        emit SharesBurned(_id, _sharesToBurn, msg.sender);\r\n        return _payout;\r\n    }\r\n\r\n    function claimWinnings(uint256 _id, address _receiver) public returns (uint256) {\r\n        if (!isMarketResolved(_id)) {\r\n            // errors if market does not exist or is not resolved or resolvable\r\n            resolveMarket(_id);\r\n        }\r\n\r\n        Market memory _market = markets[_id];\r\n        uint256 _winningShares = _market.winner.trustedBurnAll(msg.sender);\r\n        _winningShares = (_winningShares / shareFactor) * shareFactor; // remove unusable dust\r\n\r\n        uint256 _payout = calcCost(_winningShares); // will fail if there are no winnings to claim\r\n        uint256 _settlementFee = _payout.mul(_market.settlementFee).div(10**18);\r\n        _payout = _payout.sub(_settlementFee);\r\n\r\n        accumulatedSettlementFees[_market.settlementAddress] += _settlementFee;\r\n        collateral.transfer(_receiver, _payout);\r\n\r\n        emit WinningsClaimed(_id, address(_market.winner), _winningShares, _settlementFee, _payout, _receiver);\r\n        return _payout;\r\n    }\r\n\r\n    function claimManyWinnings(uint256[] memory _ids, address _receiver) public returns (uint256) {\r\n        uint256 _totalWinnings = 0;\r\n        for (uint256 i = 0; i < _ids.length; i++) {\r\n            _totalWinnings = _totalWinnings.add(claimWinnings(_ids[i], _receiver));\r\n        }\r\n        return _totalWinnings;\r\n    }\r\n\r\n    function claimSettlementFees(address _receiver) public returns (uint256) {\r\n        uint256 _fees = accumulatedSettlementFees[msg.sender];\r\n        if (_fees > 0) {\r\n            accumulatedSettlementFees[msg.sender] = 0;\r\n            collateral.transfer(_receiver, _fees);\r\n            emit SettlementFeeClaimed(msg.sender, _fees, _receiver);\r\n        }\r\n        return _fees;\r\n    }\r\n\r\n    function claimProtocolFees() public returns (uint256) {\r\n        require(msg.sender == protocol || msg.sender == address(this), \"Only protocol can claim protocol fee\");\r\n        uint256 _fees = accumulatedProtocolFee;\r\n        if (_fees > 0) {\r\n            accumulatedProtocolFee = 0;\r\n            collateral.transfer(protocol, _fees);\r\n            emit ProtocolFeeClaimed(protocol, _fees);\r\n        }\r\n        return _fees;\r\n    }\r\n\r\n    function setSettlementFee(uint256 _newFee) external onlyOwner {\r\n        settlementFee = _newFee;\r\n        emit SettlementFeeChanged(_newFee);\r\n    }\r\n\r\n    function setStakerFee(uint256 _newFee) external onlyOwner {\r\n        stakerFee = _newFee;\r\n        emit StakerFeeChanged(_newFee);\r\n    }\r\n\r\n    function setProtocolFee(uint256 _newFee) external onlyOwner {\r\n        protocolFee = _newFee;\r\n        emit ProtocolFeeChanged(_newFee);\r\n    }\r\n\r\n    function setProtocol(address _newProtocol, bool _claimFirst) external onlyOwner {\r\n        if (_claimFirst) {\r\n            claimProtocolFees();\r\n        }\r\n        protocol = _newProtocol;\r\n        emit ProtocolChanged(_newProtocol);\r\n    }\r\n\r\n    function makeMarket(\r\n        address _settlementAddress,\r\n        string[] memory _names,\r\n        string[] memory _symbols,\r\n        uint256 _endTime\r\n    ) internal returns (Market memory _market) {\r\n        _market = Market(\r\n            _settlementAddress,\r\n            createShareTokens(_names, _symbols, address(this)),\r\n            _endTime,\r\n            OwnedERC20(0),\r\n            settlementFee,\r\n            protocolFee,\r\n            stakerFee,\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    function isMarketResolved(uint256 _id) public view returns (bool) {\r\n        Market memory _market = markets[_id];\r\n        return _market.winner != OwnedERC20(0);\r\n    }\r\n\r\n    // Only usable off-chain. Gas cost can easily eclipse block limit.\r\n    function listUnresolvedMarkets() public view returns (uint256[] memory) {\r\n        uint256 _totalUnresolved = 0;\r\n        for (uint256 i = 0; i < markets.length; i++) {\r\n            if (!isMarketResolved(i)) {\r\n                _totalUnresolved++;\r\n            }\r\n        }\r\n\r\n        uint256[] memory _marketIds = new uint256[](_totalUnresolved);\r\n\r\n        uint256 n = 0;\r\n        for (uint256 i = 0; i < markets.length; i++) {\r\n            if (n >= _totalUnresolved) break;\r\n\r\n            if (!isMarketResolved(i)) {\r\n                _marketIds[n] = i;\r\n                n++;\r\n            }\r\n        }\r\n\r\n        return _marketIds;\r\n    }\r\n\r\n    // shares => collateral\r\n    function calcCost(uint256 _shares) public view returns (uint256) {\r\n        require(\r\n            _shares >= shareFactor && _shares % shareFactor == 0,\r\n            \"Shares must be both greater than (or equal to) and divisible by shareFactor\"\r\n        );\r\n        return _shares / shareFactor;\r\n    }\r\n\r\n    // collateral => shares\r\n    function calcShares(uint256 _collateralIn) public view returns (uint256) {\r\n        return _collateralIn * shareFactor;\r\n    }\r\n\r\n    function onTransferOwnership(address, address) internal override {}\r\n}\r\n"
    },
    "contracts/turbo/NFLMarketFactoryV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.7.6;\r\npragma abicoder v2;\r\n\r\nimport \"../libraries/IERC20Full.sol\";\r\nimport \"../balancer/BPool.sol\";\r\nimport \"./AbstractMarketFactoryV2.sol\";\r\nimport \"./FeePot.sol\";\r\nimport \"../libraries/SafeMathInt256.sol\";\r\nimport \"../libraries/CalculateLinesToBPoolOdds.sol\";\r\n\r\ncontract NFLMarketFactoryV2 is AbstractMarketFactoryV2, CalculateLinesToBPoolOdds {\r\n    using SafeMathUint256 for uint256;\r\n    using SafeMathInt256 for int256;\r\n\r\n    event MarketCreated(\r\n        uint256 id,\r\n        address creator,\r\n        uint256 endTime,\r\n        MarketType marketType,\r\n        uint256 indexed eventId,\r\n        string homeTeamName,\r\n        uint256 homeTeamId,\r\n        string awayTeamName,\r\n        uint256 awayTeamId,\r\n        uint256 estimatedStartTime,\r\n        int256 score\r\n    );\r\n    event MarketResolved(uint256 id, address winner);\r\n    event LinkNodeChanged(address newLinkNode);\r\n\r\n    enum MarketType {HeadToHead, Spread, OverUnder}\r\n    enum HeadToHeadOutcome {\r\n        NoContest, // 0\r\n        Away, // 1\r\n        Home // 2\r\n    }\r\n    enum SpreadOutcome {\r\n        NoContest, // 0\r\n        Away, // 1\r\n        Home // 2\r\n    }\r\n    enum OverUnderOutcome {\r\n        NoContest, // 0\r\n        Over, // 1\r\n        Under // 2\r\n    }\r\n    struct MarketDetails {\r\n        uint256 eventId;\r\n        string homeTeamName;\r\n        uint256 homeTeamId;\r\n        string awayTeamName;\r\n        uint256 awayTeamId;\r\n        uint256 estimatedStartTime;\r\n        MarketType marketType;\r\n        EventStatus eventStatus;\r\n        // This value depends on the marketType.\r\n        // HeadToHead: ignored\r\n        // Spread: the home team spread\r\n        // OverUnder: total score in game\r\n        int256 value0;\r\n    }\r\n    // MarketId => MarketDetails\r\n    mapping(uint256 => MarketDetails) internal marketDetails;\r\n\r\n    enum EventStatus {Unknown, Scheduled, Final, Postponed, Canceled}\r\n    struct EventDetails {\r\n        uint256[3] markets;\r\n        uint256 startTime;\r\n        uint256 homeScore;\r\n        uint256 awayScore;\r\n        EventStatus status;\r\n        // If there is a resolution time then the market is resolved but not necessarily finalized.\r\n        // A market is finalized when its last two score updates were identical.\r\n        // Score updates must occur after a period of time specified by resolutionBuffer.\r\n        // This mechanism exists to reduce the risk of bad scores being sent by the API then later corrected.\r\n        // The downside is slower resolution.\r\n        uint256 resolutionTime; // time since last score update\r\n        bool finalized; // true after event resolves and has stable scores\r\n    }\r\n    // EventId => EventDetails\r\n    mapping(uint256 => EventDetails) public events;\r\n    uint256[] public listOfEvents;\r\n\r\n    address public linkNode;\r\n    uint256 public sportId;\r\n\r\n    constructor(\r\n        address _owner,\r\n        IERC20Full _collateral,\r\n        uint256 _shareFactor,\r\n        FeePot _feePot,\r\n        uint256 _stakerFee,\r\n        uint256 _settlementFee,\r\n        address _protocol,\r\n        uint256 _protocolFee,\r\n        address _linkNode,\r\n        uint256 _sportId\r\n    )\r\n        AbstractMarketFactoryV2(\r\n            _owner,\r\n            _collateral,\r\n            _shareFactor,\r\n            _feePot,\r\n            _stakerFee,\r\n            _settlementFee,\r\n            _protocol,\r\n            _protocolFee\r\n        )\r\n    {\r\n        linkNode = _linkNode;\r\n        sportId = _sportId;\r\n    }\r\n\r\n    function createMarket(\r\n        uint256 _eventId,\r\n        string memory _homeTeamName,\r\n        uint256 _homeTeamId,\r\n        string memory _awayTeamName,\r\n        uint256 _awayTeamId,\r\n        uint256 _startTimestamp,\r\n        int256 _homeSpread,\r\n        uint256 _totalScore,\r\n        bool _makeSpread,\r\n        bool _makeTotalScore,\r\n        int256[2] memory _moneylines // [home,away]\r\n    ) public returns (uint256[3] memory _ids) {\r\n        require(msg.sender == linkNode, \"Only link node can create markets\");\r\n\r\n        uint256 _endTime = _startTimestamp.add(60 * 8); // 8 hours\r\n\r\n        _ids = events[_eventId].markets;\r\n\r\n        if (_ids[0] == 0 && _moneylines[0] != 0 && _moneylines[1] != 0) {\r\n            _ids[0] = createHeadToHeadMarket(\r\n                msg.sender,\r\n                _endTime,\r\n                _eventId,\r\n                _homeTeamName,\r\n                _homeTeamId,\r\n                _awayTeamName,\r\n                _awayTeamId,\r\n                _startTimestamp,\r\n                _moneylines\r\n            );\r\n        }\r\n\r\n        if (_ids[1] == 0 && _makeSpread) {\r\n            // spread market hasn't been created and is ready to be created\r\n            _ids[1] = createSpreadMarket(\r\n                msg.sender,\r\n                _endTime,\r\n                _eventId,\r\n                _homeTeamName,\r\n                _homeTeamId,\r\n                _awayTeamName,\r\n                _awayTeamId,\r\n                _startTimestamp,\r\n                _homeSpread\r\n            );\r\n        }\r\n\r\n        if (_ids[2] == 0 && _makeTotalScore) {\r\n            // over-under market hasn't been created and is ready to be created\r\n            _ids[2] = createOverUnderMarket(\r\n                msg.sender,\r\n                _endTime,\r\n                _eventId,\r\n                _homeTeamName,\r\n                _homeTeamId,\r\n                _awayTeamName,\r\n                _awayTeamId,\r\n                _startTimestamp,\r\n                _totalScore\r\n            );\r\n        }\r\n\r\n        events[_eventId].status = EventStatus.Scheduled;\r\n        events[_eventId].startTime = _startTimestamp;\r\n        events[_eventId].markets = _ids;\r\n        listOfEvents.push(_eventId);\r\n    }\r\n\r\n    function createHeadToHeadMarket(\r\n        address _creator,\r\n        uint256 _endTime,\r\n        uint256 _eventId,\r\n        string memory _homeTeamName,\r\n        uint256 _homeTeamId,\r\n        string memory _awayTeamName,\r\n        uint256 _awayTeamId,\r\n        uint256 _startTimestamp,\r\n        int256[2] memory _moneylines // [home,away]\r\n    ) internal returns (uint256) {\r\n        string[] memory _outcomes = new string[](3);\r\n        _outcomes[uint256(HeadToHeadOutcome.NoContest)] = \"No Contest / Draw\";\r\n        _outcomes[uint256(HeadToHeadOutcome.Away)] = _awayTeamName;\r\n        _outcomes[uint256(HeadToHeadOutcome.Home)] = _homeTeamName;\r\n\r\n        uint256 _id = markets.length;\r\n        // moneylines is [home,away] but the outcomes are listed [NC,away,home] so they must be reversed\r\n        markets.push(\r\n            makeMarket(_creator, _outcomes, _outcomes, _endTime, oddsFromLines(_moneylines[1], _moneylines[0]))\r\n        );\r\n        marketDetails[_id] = MarketDetails(\r\n            _eventId,\r\n            _homeTeamName,\r\n            _homeTeamId,\r\n            _awayTeamName,\r\n            _awayTeamId,\r\n            _startTimestamp,\r\n            MarketType.HeadToHead,\r\n            EventStatus.Scheduled,\r\n            0\r\n        );\r\n        emit MarketCreated(\r\n            _id,\r\n            _creator,\r\n            _endTime,\r\n            MarketType.HeadToHead,\r\n            _eventId,\r\n            _homeTeamName,\r\n            _homeTeamId,\r\n            _awayTeamName,\r\n            _awayTeamId,\r\n            _startTimestamp,\r\n            0\r\n        );\r\n        return _id;\r\n    }\r\n\r\n    function createSpreadMarket(\r\n        address _creator,\r\n        uint256 _endTime,\r\n        uint256 _eventId,\r\n        string memory _homeTeamName,\r\n        uint256 _homeTeamId,\r\n        string memory _awayTeamName,\r\n        uint256 _awayTeamId,\r\n        uint256 _startTimestamp,\r\n        int256 _homeSpread\r\n    ) internal returns (uint256) {\r\n        string[] memory _outcomes = new string[](3);\r\n        _outcomes[uint256(SpreadOutcome.NoContest)] = \"No Contest\";\r\n        _outcomes[uint256(SpreadOutcome.Away)] = _awayTeamName;\r\n        _outcomes[uint256(SpreadOutcome.Home)] = _homeTeamName;\r\n\r\n        // The spread is a quantity of tenths. So 55 is 5.5 and -6 is -60.\r\n        // If the spread is a whole number then make it a half point more extreme, to eliminate ties.\r\n        // So 50 becomes 55, -60 becomes -65, and 0 becomes 5.\r\n        if (_homeSpread >= 0 && _homeSpread % 10 == 0) {\r\n            _homeSpread += 5;\r\n        } else if (_homeSpread < 0 && (-_homeSpread) % 10 == 0) {\r\n            _homeSpread -= 5;\r\n        }\r\n\r\n        uint256 _id = markets.length;\r\n        markets.push(makeMarket(_creator, _outcomes, _outcomes, _endTime, evenOdds(true, 2)));\r\n        marketDetails[_id] = MarketDetails(\r\n            _eventId,\r\n            _homeTeamName,\r\n            _homeTeamId,\r\n            _awayTeamName,\r\n            _awayTeamId,\r\n            _startTimestamp,\r\n            MarketType.Spread,\r\n            EventStatus.Scheduled,\r\n            _homeSpread\r\n        );\r\n        emit MarketCreated(\r\n            _id,\r\n            _creator,\r\n            _endTime,\r\n            MarketType.Spread,\r\n            _eventId,\r\n            _homeTeamName,\r\n            _homeTeamId,\r\n            _awayTeamName,\r\n            _awayTeamId,\r\n            _startTimestamp,\r\n            _homeSpread\r\n        );\r\n        return _id;\r\n    }\r\n\r\n    function createOverUnderMarket(\r\n        address _creator,\r\n        uint256 _endTime,\r\n        uint256 _eventId,\r\n        string memory _homeTeamName,\r\n        uint256 _homeTeamId,\r\n        string memory _awayTeamName,\r\n        uint256 _awayTeamId,\r\n        uint256 _startTimestamp,\r\n        uint256 _overUnderTotal\r\n    ) internal returns (uint256) {\r\n        string[] memory _outcomes = new string[](3);\r\n        _outcomes[uint256(OverUnderOutcome.NoContest)] = \"No Contest\";\r\n        _outcomes[uint256(OverUnderOutcome.Over)] = \"Over\";\r\n        _outcomes[uint256(OverUnderOutcome.Under)] = \"Under\";\r\n\r\n        // The total is a quantity of tenths. So 55 is 5.5 and -6 is -60.\r\n        // If the total is a whole number then make it a half point higher, to eliminate ties.\r\n        // So 50 becomes 55 and 0 becomes 5.\r\n        if (_overUnderTotal >= 0 && _overUnderTotal % 10 == 0) {\r\n            _overUnderTotal += 5;\r\n        }\r\n\r\n        uint256 _id = markets.length;\r\n        markets.push(makeMarket(_creator, _outcomes, _outcomes, _endTime, evenOdds(true, 2)));\r\n        marketDetails[_id] = MarketDetails(\r\n            _eventId,\r\n            _homeTeamName,\r\n            _homeTeamId,\r\n            _awayTeamName,\r\n            _awayTeamId,\r\n            _startTimestamp,\r\n            MarketType.OverUnder,\r\n            EventStatus.Scheduled,\r\n            int256(_overUnderTotal)\r\n        );\r\n        emit MarketCreated(\r\n            _id,\r\n            _creator,\r\n            _endTime,\r\n            MarketType.OverUnder,\r\n            _eventId,\r\n            _homeTeamName,\r\n            _homeTeamId,\r\n            _awayTeamName,\r\n            _awayTeamId,\r\n            _startTimestamp,\r\n            int256(_overUnderTotal)\r\n        );\r\n        return _id;\r\n    }\r\n\r\n    function resolveMarket(uint256) public pure override {\r\n        require(false, \"Only the link node can resolve the market, using trustedResolveMarkets\");\r\n    }\r\n\r\n    function trustedResolveMarkets(\r\n        uint256 _eventId,\r\n        uint256 _eventStatus,\r\n        uint256 _homeScore,\r\n        uint256 _awayScore\r\n    ) public {\r\n        require(msg.sender == linkNode, \"Only link node can resolve markets\");\r\n\r\n        EventDetails storage _event = events[_eventId];\r\n        uint256[3] memory _ids = _event.markets;\r\n\r\n        require(_ids[0] != 0 || _ids[1] != 0 || _ids[2] != 0, \"Cannot resolve markets that weren't created\");\r\n\r\n        require(EventStatus(_eventStatus) != EventStatus.Scheduled, \"cannot resolve SCHEDULED markets\");\r\n\r\n        // resolve markets as No Contest\r\n        if (EventStatus(_eventStatus) != EventStatus.Final) {\r\n            for (uint256 i = 0; i < _ids.length; i++) {\r\n                uint256 _id = _ids[i];\r\n                if (_id == 0) continue; // skip non-created markets\r\n                OwnedERC20 _winner = markets[_id].shareTokens[0]; // 0th outcome is No Contest for all market types\r\n                markets[_id].winner = _winner;\r\n                emit MarketResolved(_id, address(_winner));\r\n            }\r\n            return;\r\n        }\r\n\r\n        // only resolve markets that were created\r\n        if (_ids[0] != 0) {\r\n            resolveHeadToHeadMarket(_ids[0], _homeScore, _awayScore);\r\n        }\r\n        if (_ids[1] != 0) {\r\n            resolveSpreadMarket(_ids[1], _homeScore, _awayScore);\r\n        }\r\n        if (_ids[2] != 0) {\r\n            resolveOverUnderMarket(_ids[2], _homeScore, _awayScore);\r\n        }\r\n    }\r\n\r\n    function resolveHeadToHeadMarket(\r\n        uint256 _id,\r\n        uint256 _homeScore,\r\n        uint256 _awayScore\r\n    ) internal {\r\n        OwnedERC20 _winner;\r\n        if (_homeScore > _awayScore) {\r\n            _winner = markets[_id].shareTokens[uint256(HeadToHeadOutcome.Home)]; // home team won\r\n        } else if (_homeScore < _awayScore) {\r\n            _winner = markets[_id].shareTokens[uint256(HeadToHeadOutcome.Away)]; // away team won\r\n        } else {\r\n            _winner = markets[_id].shareTokens[uint256(HeadToHeadOutcome.NoContest)]; // no contest\r\n        }\r\n\r\n        markets[_id].winner = _winner;\r\n        emit MarketResolved(_id, address(_winner));\r\n    }\r\n\r\n    function resolveSpreadMarket(\r\n        uint256 _id,\r\n        uint256 _homeScore,\r\n        uint256 _awayScore\r\n    ) internal {\r\n        MarketDetails memory _details = marketDetails[_id];\r\n        int256 _targetSpread = _details.value0;\r\n\r\n        int256 _actualSpread = int256(_homeScore).sub(int256(_awayScore));\r\n\r\n        OwnedERC20 _winner;\r\n        if (_actualSpread > _targetSpread) {\r\n            _winner = markets[_id].shareTokens[uint256(SpreadOutcome.Home)]; // home spread greater\r\n        } else if (_actualSpread < _targetSpread) {\r\n            _winner = markets[_id].shareTokens[uint256(SpreadOutcome.Away)]; // home spread lesser\r\n        } else {\r\n            _winner = markets[_id].shareTokens[uint256(SpreadOutcome.NoContest)]; // no contest\r\n        }\r\n\r\n        markets[_id].winner = _winner;\r\n        emit MarketResolved(_id, address(_winner));\r\n    }\r\n\r\n    function resolveOverUnderMarket(\r\n        uint256 _id,\r\n        uint256 _homeScore,\r\n        uint256 _awayScore\r\n    ) internal {\r\n        MarketDetails memory _details = marketDetails[_id];\r\n        int256 _targetTotal = _details.value0;\r\n\r\n        int256 _actualTotal = int256(_homeScore).add(int256(_awayScore));\r\n\r\n        OwnedERC20 _winner;\r\n        if (_actualTotal > _targetTotal) {\r\n            _winner = markets[_id].shareTokens[uint256(OverUnderOutcome.Over)]; // over\r\n        } else if (_actualTotal < _targetTotal) {\r\n            _winner = markets[_id].shareTokens[uint256(OverUnderOutcome.Under)]; // under\r\n        } else {\r\n            _winner = markets[_id].shareTokens[uint256(OverUnderOutcome.NoContest)]; // no contest\r\n        }\r\n\r\n        markets[_id].winner = _winner;\r\n        emit MarketResolved(_id, address(_winner));\r\n    }\r\n\r\n    function getMarketDetails(uint256 _marketId) public view returns (MarketDetails memory) {\r\n        return marketDetails[_marketId];\r\n    }\r\n\r\n    function setLinkNode(address _newLinkNode) external onlyOwner {\r\n        linkNode = _newLinkNode;\r\n        emit LinkNodeChanged(_newLinkNode);\r\n    }\r\n\r\n    function getEventMarkets(uint256 _eventId) external view returns (uint256[3] memory) {\r\n        uint256[3] memory _event = events[_eventId].markets;\r\n        return _event;\r\n    }\r\n\r\n    // Events can be partially registered, by only creating some markets.\r\n    // This returns true only if an event is fully registered.\r\n    function isEventRegistered(uint256 _eventId) public view returns (bool) {\r\n        uint256[3] memory _event = events[_eventId].markets;\r\n        return _event[0] != 0 && _event[1] != 0 && _event[2] != 0;\r\n    }\r\n\r\n    function isEventResolved(uint256 _eventId) public view returns (bool) {\r\n        // check the event's head-to-head market since it will always exist if the event's markets exist\r\n        uint256 _marketId = events[_eventId].markets[0];\r\n        return isMarketResolved(_marketId);\r\n    }\r\n\r\n    // Only usable off-chain. Gas cost can easily eclipse block limit.\r\n    // Lists all events that could be resolved with a call to resolveEvent.\r\n    // Not all will be resolvable because this does not ensure the game ended.\r\n    function listResolvableEvents() external view returns (uint256[] memory) {\r\n        uint256 _totalResolvable = countResolvableEvents();\r\n        uint256[] memory _resolvableEvents = new uint256[](_totalResolvable);\r\n\r\n        uint256 n = 0;\r\n        for (uint256 i = 0; i < listOfEvents.length; i++) {\r\n            if (n > _totalResolvable) break;\r\n            uint256 _eventId = listOfEvents[i];\r\n            if (isEventResolvable(_eventId)) {\r\n                _resolvableEvents[n] = _eventId;\r\n                n++;\r\n            }\r\n        }\r\n\r\n        return _resolvableEvents;\r\n    }\r\n\r\n    function countResolvableEvents() internal view returns (uint256) {\r\n        uint256 _totalResolvable = 0;\r\n        for (uint256 i = 0; i < listOfEvents.length; i++) {\r\n            uint256 _eventId = listOfEvents[i];\r\n            if (isEventResolvable(_eventId)) {\r\n                _totalResolvable++;\r\n            }\r\n        }\r\n        return _totalResolvable;\r\n    }\r\n\r\n    // Returns true if a call to resolveEvent is potentially useful.\r\n    function isEventResolvable(uint256 _eventId) internal view returns (bool) {\r\n        EventDetails memory _event = events[_eventId];\r\n\r\n        bool _unresolved = false; // default because non-existing markets aren't resolvable\r\n        for (uint256 i = 0; i < _event.markets.length; i++) {\r\n            uint256 _marketId = _event.markets[i];\r\n            if (_marketId != 0 && !isMarketResolved(_marketId)) {\r\n                _unresolved = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        return _unresolved;\r\n    }\r\n}\r\n"
    },
    "contracts/turbo/MMALinkMarketFactoryV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.7.6;\r\npragma abicoder v2;\r\n\r\nimport \"../libraries/IERC20Full.sol\";\r\nimport \"../balancer/BPool.sol\";\r\nimport \"./AbstractMarketFactoryV2.sol\";\r\nimport \"./FeePot.sol\";\r\nimport \"../libraries/SafeMathInt256.sol\";\r\nimport \"../libraries/CalculateLinesToBPoolOdds.sol\";\r\n\r\ncontract MMALinkMarketFactoryV2 is AbstractMarketFactoryV2, CalculateLinesToBPoolOdds {\r\n    using SafeMathUint256 for uint256;\r\n    using SafeMathInt256 for int256;\r\n\r\n    event MarketCreated(\r\n        uint256 id,\r\n        address creator,\r\n        uint256 endTime,\r\n        MarketType marketType,\r\n        uint256 indexed eventId,\r\n        string homeFighterName,\r\n        uint256 homeFighterId,\r\n        string awayFighterName,\r\n        uint256 awayFighterId,\r\n        uint256 estimatedStartTime\r\n    );\r\n    event MarketResolved(uint256 id, address winner);\r\n    event LinkNodeChanged(address newLinkNode);\r\n\r\n    enum MarketType {HeadToHead}\r\n    enum HeadToHeadOutcome {\r\n        NoContest, // 0\r\n        Away, // 1\r\n        Home // 2\r\n    }\r\n\r\n    struct MarketDetails {\r\n        uint256 eventId;\r\n        string homeFighterName;\r\n        uint256 homeFighterId;\r\n        string awayFighterName;\r\n        uint256 awayFighterId;\r\n        uint256 estimatedStartTime;\r\n        MarketType marketType;\r\n        EventStatus eventStatus;\r\n    }\r\n    // MarketId => MarketDetails\r\n    mapping(uint256 => MarketDetails) internal marketDetails;\r\n\r\n    enum EventStatus {Unknown, Scheduled, Final, Postponed, Canceled}\r\n    struct EventDetails {\r\n        uint256[1] markets;\r\n        uint256 homeFighterId;\r\n        uint256 awayFighterId;\r\n        uint256 startTime;\r\n        EventStatus eventStatus;\r\n    }\r\n\r\n    // EventId => EventDetails\r\n    mapping(uint256 => EventDetails) public events;\r\n    uint256[] public listOfEvents;\r\n\r\n    address public linkNode;\r\n    uint256 public sportId;\r\n\r\n    constructor(\r\n        address _owner,\r\n        IERC20Full _collateral,\r\n        uint256 _shareFactor,\r\n        FeePot _feePot,\r\n        uint256 _stakerFee,\r\n        uint256 _settlementFee,\r\n        address _protocol,\r\n        uint256 _protocolFee,\r\n        address _linkNode,\r\n        uint256 _sportId\r\n    )\r\n        AbstractMarketFactoryV2(\r\n            _owner,\r\n            _collateral,\r\n            _shareFactor,\r\n            _feePot,\r\n            _stakerFee,\r\n            _settlementFee,\r\n            _protocol,\r\n            _protocolFee\r\n        )\r\n    {\r\n        linkNode = _linkNode;\r\n        sportId = _sportId;\r\n    }\r\n\r\n    function createMarket(\r\n        uint256 _eventId,\r\n        string memory _homeFighterName,\r\n        uint256 _homeFighterId,\r\n        string memory _awayFighterName,\r\n        uint256 _awayFighterId,\r\n        uint256 _startTimestamp,\r\n        int256[2] memory _moneylines // [home,away]\r\n    ) public {\r\n        require(msg.sender == linkNode, \"Only link node can create markets\");\r\n\r\n        address _creator = msg.sender;\r\n        uint256 _endTime = _startTimestamp.add(60 * 8); // 8 hours\r\n\r\n        uint256[1] memory _ids = events[_eventId].markets;\r\n        // require(_ids[0] == 0, \"This event was already used to create markets\");\r\n\r\n        _ids[0] = createHeadToHeadMarket(\r\n            _creator,\r\n            _endTime,\r\n            _eventId,\r\n            _homeFighterName,\r\n            _homeFighterId,\r\n            _awayFighterName,\r\n            _awayFighterId,\r\n            _startTimestamp,\r\n            _moneylines\r\n        );\r\n\r\n        events[_eventId].markets = _ids;\r\n        events[_eventId].homeFighterId = _homeFighterId;\r\n        events[_eventId].awayFighterId = _awayFighterId;\r\n        events[_eventId].startTime = _startTimestamp;\r\n        events[_eventId].eventStatus = EventStatus.Scheduled;\r\n        listOfEvents.push(_eventId);\r\n    }\r\n\r\n    function createHeadToHeadMarket(\r\n        address _creator,\r\n        uint256 _endTime,\r\n        uint256 _eventId,\r\n        string memory _homeTeamName,\r\n        uint256 _homeFighterId,\r\n        string memory _awayTeamName,\r\n        uint256 _awayFighterId,\r\n        uint256 _startTimestamp,\r\n        int256[2] memory _moneylines // [home,away]\r\n    ) internal returns (uint256) {\r\n        string[] memory _outcomes = new string[](3);\r\n        _outcomes[uint256(HeadToHeadOutcome.NoContest)] = \"No Contest\";\r\n        _outcomes[uint256(HeadToHeadOutcome.Away)] = _awayTeamName;\r\n        _outcomes[uint256(HeadToHeadOutcome.Home)] = _homeTeamName;\r\n\r\n        uint256 _id = markets.length;\r\n        // moneylines is [home,away] but the outcomes are listed [NC,away,home] so they must be reversed\r\n        markets.push(\r\n            makeMarket(_creator, _outcomes, _outcomes, _endTime, oddsFromLines(_moneylines[1], _moneylines[0]))\r\n        );\r\n        marketDetails[_id] = MarketDetails(\r\n            _eventId,\r\n            _homeTeamName,\r\n            _homeFighterId,\r\n            _awayTeamName,\r\n            _awayFighterId,\r\n            _startTimestamp,\r\n            MarketType.HeadToHead,\r\n            EventStatus.Scheduled\r\n        );\r\n        emit MarketCreated(\r\n            _id,\r\n            _creator,\r\n            _endTime,\r\n            MarketType.HeadToHead,\r\n            _eventId,\r\n            _homeTeamName,\r\n            _homeFighterId,\r\n            _awayTeamName,\r\n            _awayFighterId,\r\n            _startTimestamp\r\n        );\r\n        return _id;\r\n    }\r\n\r\n    enum WhoWon {Unknown, Home, Away, Draw}\r\n\r\n    function trustedResolveMarkets(\r\n        uint256 _eventId,\r\n        EventStatus _eventStatus,\r\n        uint256 _homeFighterId,\r\n        uint256 _awayFighterId,\r\n        WhoWon _whoWon\r\n    ) public {\r\n        require(msg.sender == linkNode, \"Only link node can resolve markets\");\r\n\r\n        EventDetails memory _event = events[_eventId];\r\n        require(_event.markets[0] != 0, \"Cannot resolve markets that weren't created\");\r\n        require(EventStatus(_eventStatus) != EventStatus.Scheduled, \"Cannot resolve SCHEDULED markets\");\r\n\r\n        if (eventIsNoContest(_event, _eventStatus, _homeFighterId, _awayFighterId, _whoWon)) {\r\n            resolveMarketsAsNoContest(_eventId);\r\n        } else {\r\n            resolveHeadToHeadMarket(_event.markets[0], _whoWon);\r\n        }\r\n\r\n        events[_eventId].eventStatus = _eventStatus;\r\n    }\r\n\r\n    function eventIsNoContest(\r\n        EventDetails memory _event,\r\n        EventStatus _eventStatus,\r\n        uint256 _homeFighterId,\r\n        uint256 _awayFighterId,\r\n        WhoWon _whoWon\r\n    ) internal pure returns (bool) {\r\n        bool _draw = _whoWon == WhoWon.Draw;\r\n        bool _notFinal = _eventStatus != EventStatus.Final;\r\n        bool _unstableHomeFighterId = _event.homeFighterId != _homeFighterId;\r\n        bool _unstableAwayFighterId = _event.awayFighterId != _awayFighterId;\r\n        return _draw || _notFinal || _unstableHomeFighterId || _unstableAwayFighterId;\r\n    }\r\n\r\n    function resolveMarketsAsNoContest(uint256 _eventId) internal {\r\n        uint256[1] memory _marketIds = events[_eventId].markets;\r\n        for (uint256 i = 0; i < _marketIds.length; i++) {\r\n            uint256 _marketId = _marketIds[i];\r\n            if (_marketId == 0) continue; // skip non-created markets\r\n            OwnedERC20 _winner = markets[_marketId].shareTokens[0]; // 0th outcome is No Contest for all market types\r\n            markets[_marketId].winner = _winner;\r\n            emit MarketResolved(_marketId, address(_winner));\r\n        }\r\n    }\r\n\r\n    function resolveHeadToHeadMarket(uint256 _marketId, WhoWon _whoWon) internal {\r\n        OwnedERC20 _winner;\r\n        if (WhoWon.Home == _whoWon) {\r\n            _winner = markets[_marketId].shareTokens[uint256(HeadToHeadOutcome.Home)];\r\n        } else if (WhoWon.Away == _whoWon) {\r\n            _winner = markets[_marketId].shareTokens[uint256(HeadToHeadOutcome.Away)];\r\n        } else {\r\n            require(false, \"Bad market resolution choice\");\r\n        }\r\n\r\n        markets[_marketId].winner = _winner;\r\n        emit MarketResolved(_marketId, address(_winner));\r\n    }\r\n\r\n    function getMarketDetails(uint256 _marketId) public view returns (MarketDetails memory) {\r\n        return marketDetails[_marketId];\r\n    }\r\n\r\n    // Only usable off-chain. Gas cost can easily eclipse block limit.\r\n    // Lists all events that could be resolved with a call to resolveEvent.\r\n    // Not all will be resolvable because this does not ensure the game ended.\r\n    function listResolvableEvents() external view returns (uint256[] memory) {\r\n        uint256 _totalResolvable = countResolvableEvents();\r\n        uint256[] memory _resolvableEvents = new uint256[](_totalResolvable);\r\n\r\n        uint256 n = 0;\r\n        for (uint256 i = 0; i < listOfEvents.length; i++) {\r\n            if (n > _totalResolvable) break;\r\n            uint256 _eventId = listOfEvents[i];\r\n            if (isEventResolvable(_eventId)) {\r\n                _resolvableEvents[n] = _eventId;\r\n                n++;\r\n            }\r\n        }\r\n\r\n        return _resolvableEvents;\r\n    }\r\n\r\n    function countResolvableEvents() internal view returns (uint256) {\r\n        uint256 _totalResolvable = 0;\r\n        for (uint256 i = 0; i < listOfEvents.length; i++) {\r\n            uint256 _eventId = listOfEvents[i];\r\n            if (isEventResolvable(_eventId)) {\r\n                _totalResolvable++;\r\n            }\r\n        }\r\n        return _totalResolvable;\r\n    }\r\n\r\n    // Returns true if a call to resolveEvent is potentially useful.\r\n    function isEventResolvable(uint256 _eventId) internal view returns (bool) {\r\n        EventDetails memory _event = events[_eventId];\r\n\r\n        bool _unresolved = false; // default because non-existing markets aren't resolvable\r\n        for (uint256 i = 0; i < _event.markets.length; i++) {\r\n            uint256 _marketId = _event.markets[i];\r\n            if (_marketId != 0 && !isMarketResolved(_marketId)) {\r\n                _unresolved = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        return _unresolved;\r\n    }\r\n\r\n    function getEvent(uint256 _eventId) external view returns (EventDetails memory _event) {\r\n        _event = events[_eventId];\r\n    }\r\n\r\n    function setLinkNode(address _newLinkNode) external onlyOwner {\r\n        linkNode = _newLinkNode;\r\n        emit LinkNodeChanged(_newLinkNode);\r\n    }\r\n\r\n    function resolveMarket(uint256) public pure override {\r\n        require(false, \"Only the link node can resolve the market, using trustedResolveMarkets\");\r\n    }\r\n}\r\n"
    },
    "contracts/turbo/MLBMarketFactoryV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.7.6;\r\npragma abicoder v2;\r\n\r\nimport \"../libraries/IERC20Full.sol\";\r\nimport \"../balancer/BPool.sol\";\r\nimport \"./AbstractMarketFactoryV3.sol\";\r\nimport \"./FeePot.sol\";\r\nimport \"../libraries/SafeMathInt256.sol\";\r\nimport \"../libraries/Sport.sol\";\r\nimport \"../libraries/HasHeadToHeadMarket.sol\";\r\nimport \"../libraries/ResolveByScore.sol\";\r\nimport \"../libraries/Versioned.sol\";\r\n\r\ncontract MLBMarketFactoryV3 is AbstractMarketFactoryV3, SportView, HasHeadToHeadMarket, ResolvesByScore, Versioned {\r\n    using SafeMathUint256 for uint256;\r\n    using SafeMathInt256 for int256;\r\n\r\n    uint256 constant HeadToHead = 0;\r\n    string constant InvalidName = \"No Contest\";\r\n\r\n    constructor(\r\n        address _owner,\r\n        IERC20Full _collateral,\r\n        uint256 _shareFactor,\r\n        FeePot _feePot,\r\n        uint256[3] memory _fees,\r\n        address _protocol,\r\n        address _linkNode\r\n    )\r\n        AbstractMarketFactoryV3(_owner, _collateral, _shareFactor, _feePot, _fees, _protocol)\r\n        Versioned(\"v1.4.0\")\r\n        ManagedByLink(_linkNode)\r\n        HasHeadToHeadMarket(HeadToHead, InvalidName)\r\n    {}\r\n\r\n    function createEvent(\r\n        uint256 _eventId,\r\n        string memory _homeTeamName,\r\n        uint256 _homeTeamId,\r\n        string memory _awayTeamName,\r\n        uint256 _awayTeamId,\r\n        uint256 _startTimestamp,\r\n        int256[2] memory _moneylines // [home,away]\r\n    ) public onlyLinkNode returns (uint256[] memory _marketIds) {\r\n        _marketIds = makeMarkets(_moneylines, _homeTeamName, _awayTeamName);\r\n        makeSportsEvent(\r\n            _eventId,\r\n            _marketIds,\r\n            build1Line(),\r\n            _startTimestamp,\r\n            _homeTeamId,\r\n            _awayTeamId,\r\n            _homeTeamName,\r\n            _awayTeamName\r\n        );\r\n    }\r\n\r\n    function makeMarkets(\r\n        int256[2] memory _moneylines,\r\n        string memory _homeTeamName,\r\n        string memory _awayTeamName\r\n    ) internal returns (uint256[] memory _marketIds) {\r\n        _marketIds = new uint256[](1);\r\n        _marketIds[HeadToHead] = makeHeadToHeadMarket(_moneylines, _homeTeamName, _awayTeamName);\r\n    }\r\n\r\n    function resolveValidEvent(\r\n        SportsEvent memory _event,\r\n        uint256 _homeScore,\r\n        uint256 _awayScore\r\n    ) internal override {\r\n        resolveHeadToHeadMarket(_event.markets[HeadToHead], _homeScore, _awayScore);\r\n    }\r\n}\r\n"
    },
    "contracts/turbo/CryptoMarketFactoryV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.7.6;\r\npragma abicoder v2;\r\n\r\nimport \"../libraries/IERC20Full.sol\";\r\nimport \"../balancer/BPool.sol\";\r\nimport \"./AbstractMarketFactoryV2.sol\";\r\nimport \"./FeePot.sol\";\r\nimport \"../libraries/SafeMathInt256.sol\";\r\n\r\nimport \"@chainlink/contracts/src/v0.7/interfaces/AggregatorV3Interface.sol\";\r\nimport \"../libraries/CalculateLinesToBPoolOdds.sol\";\r\n\r\ncontract CryptoMarketFactoryV2 is AbstractMarketFactoryV2, CalculateLinesToBPoolOdds {\r\n    using SafeMathUint256 for uint256;\r\n    using SafeMathInt256 for int256;\r\n\r\n    event MarketCreated(\r\n        uint256 id,\r\n        address creator,\r\n        uint256 indexed endTime,\r\n        MarketType marketType,\r\n        uint256 indexed coinIndex,\r\n        uint256 price\r\n    );\r\n    event MarketResolved(uint256 id, address winner);\r\n\r\n    struct Coin {\r\n        string name;\r\n        AggregatorV3Interface priceFeed;\r\n        uint256 price;\r\n        uint8 imprecision; // how many decimals to truncate\r\n        uint256[1] currentMarkets;\r\n    }\r\n    Coin[] public coins;\r\n\r\n    enum MarketType {\r\n        PriceUpDown // 0\r\n    }\r\n    enum PriceUpDownOutcome {\r\n        Above, // 0\r\n        NotAbove // 1\r\n    }\r\n    struct MarketDetails {\r\n        MarketType marketType;\r\n        uint256 coinIndex;\r\n        uint256 creationPrice;\r\n        uint256 resolutionPrice;\r\n    }\r\n    // MarketId => MarketDetails\r\n    mapping(uint256 => MarketDetails) internal marketDetails;\r\n\r\n    address public linkNode; // market creator and resolver\r\n\r\n    uint256 public nextResolutionTime;\r\n\r\n    constructor(\r\n        address _owner,\r\n        IERC20Full _collateral,\r\n        uint256 _shareFactor,\r\n        FeePot _feePot,\r\n        uint256 _stakerFee,\r\n        uint256 _settlementFee,\r\n        address _protocol,\r\n        uint256 _protocolFee,\r\n        address _linkNode\r\n    )\r\n        AbstractMarketFactoryV2(\r\n            _owner,\r\n            _collateral,\r\n            _shareFactor,\r\n            _feePot,\r\n            _stakerFee,\r\n            _settlementFee,\r\n            _protocol,\r\n            _protocolFee\r\n        )\r\n    {\r\n        linkNode = _linkNode;\r\n\r\n        string memory _name = \"\";\r\n        coins.push(makeCoin(_name, AggregatorV3Interface(0), 0));\r\n    }\r\n\r\n    function getMarketDetails(uint256 _marketId) public view returns (MarketDetails memory) {\r\n        return marketDetails[_marketId];\r\n    }\r\n\r\n    // NOTE: Trusts the owner not to add a coin twice.\r\n    // Returns the coin index.\r\n    function addCoin(\r\n        string calldata _name,\r\n        AggregatorV3Interface _priceFeed,\r\n        uint8 _imprecision\r\n    ) external onlyOwner returns (uint256 _coinIndex) {\r\n        Coin memory _coin = makeCoin(_name, _priceFeed, _imprecision);\r\n        _coinIndex = coins.length;\r\n        coins.push(_coin);\r\n    }\r\n\r\n    function getCoin(uint256 _coinIndex) public view returns (Coin memory _coin) {\r\n        _coin = coins[_coinIndex];\r\n    }\r\n\r\n    function getCoins() public view returns (Coin[] memory _coins) {\r\n        _coins = new Coin[](coins.length);\r\n        // Skip first coin because it's always the zeroed-out fake coin.\r\n        for (uint256 i = 1; i < coins.length; i++) {\r\n            _coins[i] = coins[i];\r\n        }\r\n    }\r\n\r\n    // Iterates over all coins.\r\n    // If markets do not exist for coin, create them.\r\n    // Unless _nextResolutionTime is zero; then do not create new markets.\r\n    // If markets for coin exist and are ready to resolve, resolve them and create new markets.\r\n    // Else, error.\r\n    //\r\n    // Assume that _roundIds has a dummy value at index 0, and is 1 indexed like the\r\n    // coins array.\r\n    function createAndResolveMarkets(uint80[] calldata _roundIds, uint256 _nextResolutionTime) public {\r\n        require(msg.sender == linkNode, \"Only link node can create markets\");\r\n        // If market creation was stopped then it can be started again.\r\n        // If market creation wasn't stopped then you must wait for market end time to resolve.\r\n        require(block.timestamp >= nextResolutionTime, \"Must wait for market resolution\");\r\n        require(_roundIds.length == coins.length, \"Must specify one roundId for each coin\");\r\n\r\n        uint256 _resolutionTime = nextResolutionTime;\r\n        nextResolutionTime = _nextResolutionTime;\r\n\r\n        // Start at 1 to skip the fake Coin in the 0 index\r\n        for (uint256 i = 1; i < coins.length; i++) {\r\n            createAndResolveMarketsForCoin(i, _resolutionTime, _roundIds[i]);\r\n        }\r\n    }\r\n\r\n    function createAndResolveMarketsForCoin(\r\n        uint256 _coinIndex,\r\n        uint256 _resolutionTime,\r\n        uint80 _roundId\r\n    ) internal {\r\n        Coin memory _coin = coins[_coinIndex];\r\n        (uint256 _fullPrice, uint256 _newPrice) = getPrice(_coin, _roundId, _resolutionTime);\r\n\r\n        // resolve markets\r\n        if (_coin.currentMarkets[uint256(MarketType.PriceUpDown)] != 0) {\r\n            resolvePriceUpDownMarket(_coin, _newPrice, _fullPrice);\r\n        }\r\n\r\n        // update price only AFTER resolution\r\n        coins[_coinIndex].price = _newPrice;\r\n\r\n        // link node sets nextResolutionTime to zero to signify \"do not create markets after resolution\"\r\n        if (nextResolutionTime == 0) {\r\n            return;\r\n        }\r\n\r\n        // create markets\r\n        coins[_coinIndex].currentMarkets[uint256(MarketType.PriceUpDown)] = createPriceUpDownMarket(\r\n            _coinIndex,\r\n            linkNode,\r\n            _newPrice\r\n        );\r\n    }\r\n\r\n    function resolvePriceUpDownMarket(\r\n        Coin memory _coin,\r\n        uint256 _newPrice,\r\n        uint256 _fullPrice\r\n    ) internal {\r\n        uint256 _marketId = _coin.currentMarkets[uint256(MarketType.PriceUpDown)];\r\n\r\n        OwnedERC20 _winner;\r\n        if (_newPrice > _coin.price) {\r\n            _winner = markets[_marketId].shareTokens[uint256(PriceUpDownOutcome.Above)];\r\n        } else {\r\n            _winner = markets[_marketId].shareTokens[uint256(PriceUpDownOutcome.NotAbove)];\r\n        }\r\n\r\n        markets[_marketId].winner = _winner;\r\n        marketDetails[_marketId].resolutionPrice = _fullPrice;\r\n        emit MarketResolved(_marketId, address(_winner));\r\n    }\r\n\r\n    function createPriceUpDownMarket(\r\n        uint256 _coinIndex,\r\n        address _creator,\r\n        uint256 _newPrice\r\n    ) internal returns (uint256 _id) {\r\n        string[] memory _outcomes = new string[](2);\r\n        _outcomes[uint256(PriceUpDownOutcome.Above)] = \"Above\";\r\n        _outcomes[uint256(PriceUpDownOutcome.NotAbove)] = \"Not Above\";\r\n\r\n        uint256 _nextResolutionTime = nextResolutionTime;\r\n        _id = markets.length;\r\n        markets.push(makeMarket(_creator, _outcomes, _outcomes, _nextResolutionTime, evenOdds(false, 2)));\r\n        marketDetails[_id] = MarketDetails(MarketType.PriceUpDown, _coinIndex, _newPrice, 0);\r\n        emit MarketCreated(_id, _creator, _nextResolutionTime, MarketType.PriceUpDown, _coinIndex, _newPrice);\r\n    }\r\n\r\n    // Returns the price based on a few factors.\r\n    // If _roundId is zero then it returns the latest price.\r\n    // Else, it returns the price for that round,\r\n    //       but errors if that isn't the first round after the resolution time.\r\n    // The price is then altered to match the desired precision.\r\n    function getPrice(\r\n        Coin memory _coin,\r\n        uint80 _roundId,\r\n        uint256 _resolutionTime\r\n    ) internal view returns (uint256 _fullPrice, uint256 _truncatedPrice) {\r\n        if (_roundId == 0) {\r\n            (, int256 _rawPrice, , , ) = _coin.priceFeed.latestRoundData();\r\n            require(_rawPrice >= 0, \"Price from feed is negative\");\r\n            _fullPrice = uint256(_rawPrice);\r\n        } else {\r\n            (, int256 _rawPrice, , uint256 updatedAt, ) = _coin.priceFeed.getRoundData(_roundId);\r\n            require(_rawPrice >= 0, \"Price from feed is negative\");\r\n            require(updatedAt >= _resolutionTime, \"Price hasn't been updated yet\");\r\n\r\n            // if resolution time is zero then market creation was stopped, so the previous round doesn't matter\r\n            if (_resolutionTime != 0) {\r\n                (, , , uint256 _previousRoundTime, ) = _coin.priceFeed.getRoundData(previousRound(_roundId));\r\n                require(_previousRoundTime < _resolutionTime, \"Must use first round after resolution time\");\r\n            }\r\n\r\n            _fullPrice = uint256(_rawPrice);\r\n        }\r\n\r\n        // The precision is how many decimals the price has. Zero is dollars, 2 includes cents, 3 is tenths of a cent, etc.\r\n        // Our resolution rules want a certain precision. Like BTC is to the dollar and MATIC is to the cent.\r\n        // If somehow the decimals are larger than the desired precision then add zeroes to the end to meet the precision.\r\n        // This does not change the resolution outcome but does guard against decimals() changing and therefore altering the basis.\r\n\r\n        uint8 _precision = _coin.priceFeed.decimals(); // probably constant but that isn't guaranteed, so query each time\r\n        if (_precision > _coin.imprecision) {\r\n            uint8 _truncate = _precision - _coin.imprecision;\r\n            _truncatedPrice = _fullPrice / (10**_truncate);\r\n        } else if (_precision < _coin.imprecision) {\r\n            uint8 _greaten = _coin.imprecision - _precision;\r\n            _truncatedPrice = _fullPrice * (10**_greaten);\r\n        } else {\r\n            _truncatedPrice = _fullPrice;\r\n        }\r\n\r\n        // Round up because that cleanly fits Above/Not-Above.\r\n        if (_truncatedPrice != _fullPrice) {\r\n            _truncatedPrice += 1;\r\n        }\r\n    }\r\n\r\n    function makeCoin(\r\n        string memory _name,\r\n        AggregatorV3Interface _priceFeed,\r\n        uint8 _imprecision\r\n    ) internal pure returns (Coin memory _coin) {\r\n        uint256[1] memory _currentMarkets = [uint256(0)];\r\n        _coin = Coin(_name, _priceFeed, 0, _imprecision, _currentMarkets);\r\n    }\r\n\r\n    function resolveMarket(uint256) public pure override {\r\n        require(false, \"Use createAndResolveMarkets\");\r\n    }\r\n\r\n    // The roundId is the encoding of two parts: the phase and the phase-specific round id.\r\n    // To find the previous roundId:\r\n    // 1. extract the phase and phase-specific round (I call these _phaseId and _roundId)\r\n    // 2. decrement the phase-specific round\r\n    // 3. re-encode the phase and phase-specific round.\r\n    uint256 private constant PHASE_OFFSET = 64;\r\n\r\n    function previousRound(uint80 _fullRoundId) internal pure returns (uint80) {\r\n        uint256 _phaseId = uint256(uint16(_fullRoundId >> PHASE_OFFSET));\r\n        uint64 _roundId = uint64(_fullRoundId) - 1;\r\n        return uint80((_phaseId << PHASE_OFFSET) | _roundId);\r\n    }\r\n}\r\n"
    },
    "contracts/libraries/FakePriceFeed.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.7.6;\r\n\r\nimport \"@chainlink/contracts/src/v0.7/interfaces/AggregatorV3Interface.sol\";\r\n\r\ncontract FakePriceFeed is AggregatorV3Interface {\r\n    uint8 decimals_;\r\n    string description_;\r\n    uint256 version_;\r\n\r\n    struct Round {\r\n        uint80 roundId;\r\n        int256 answer;\r\n        uint256 startedAt;\r\n        uint256 updatedAt;\r\n        uint80 answeredInRound;\r\n    }\r\n    mapping(uint80 => Round) rounds;\r\n    uint80 latestRoundId;\r\n\r\n    constructor(\r\n        uint8 _decimals,\r\n        string memory _description,\r\n        uint256 _version\r\n    ) {\r\n        decimals_ = _decimals;\r\n        description_ = _description;\r\n        version_ = _version;\r\n    }\r\n\r\n    function decimals() external view override returns (uint8) {\r\n        return decimals_;\r\n    }\r\n\r\n    function description() external view override returns (string memory) {\r\n        return description_;\r\n    }\r\n\r\n    function version() external view override returns (uint256) {\r\n        return version_;\r\n    }\r\n\r\n    // getRoundData and latestRoundData should both raise \"No data present\"\r\n    // if they do not have data to report, instead of returning unset values\r\n    // which could be misinterpreted as actual reported values.\r\n    function getRoundData(uint80 roundId_)\r\n        public\r\n        view\r\n        override\r\n        returns (\r\n            uint80 _roundId,\r\n            int256 _answer,\r\n            uint256 _startedAt,\r\n            uint256 _updatedAt,\r\n            uint80 _answeredInRound\r\n        )\r\n    {\r\n        Round memory _round = rounds[roundId_];\r\n        _roundId = _round.roundId;\r\n        _answer = _round.answer;\r\n        _startedAt = _round.startedAt;\r\n        _updatedAt = _round.updatedAt;\r\n        _answeredInRound = _round.answeredInRound;\r\n    }\r\n\r\n    function latestRoundData()\r\n        public\r\n        view\r\n        override\r\n        returns (\r\n            uint80 _roundId,\r\n            int256 _answer,\r\n            uint256 _startedAt,\r\n            uint256 _updatedAt,\r\n            uint80 _answeredInRound\r\n        )\r\n    {\r\n        return getRoundData(latestRoundId);\r\n    }\r\n\r\n    function addRound(\r\n        uint80 _roundId,\r\n        int256 _answer,\r\n        uint256 _startedAt,\r\n        uint256 _updatedAt,\r\n        uint80 _answeredInRound\r\n    ) external {\r\n        rounds[_roundId] = Round(_roundId, _answer, _startedAt, _updatedAt, _answeredInRound);\r\n        latestRoundId = _roundId;\r\n    }\r\n}\r\n"
    },
    "contracts/turbo/CDSMarketFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.7.6;\r\npragma abicoder v2;\r\n\r\nimport \"./AbstractMarketFactoryV3.sol\";\r\nimport \"../libraries/CalculateLinesToBPoolOdds.sol\";\r\nimport \"../libraries/Versioned.sol\";\r\n\r\ncontract CDSMarketFactory is AbstractMarketFactoryV3, CalculateLinesToBPoolOdds, Versioned {\r\n    using SafeMathUint256 for uint256;\r\n\r\n    struct MarketDetails {\r\n        string description;\r\n    }\r\n    MarketDetails[] internal marketDetails;\r\n\r\n    constructor(\r\n        address _owner,\r\n        IERC20Full _collateral,\r\n        uint256 _shareFactor,\r\n        FeePot _feePot,\r\n        uint256[3] memory _fees,\r\n        address _protocol\r\n    ) AbstractMarketFactoryV3(_owner, _collateral, _shareFactor, _feePot, _fees, _protocol) Versioned(\"v1.1.0\") {}\r\n\r\n    function createMarket(\r\n        address _creator,\r\n        string calldata _description,\r\n        string[] calldata _names,\r\n        uint256[] calldata _odds\r\n    ) public onlyOwner returns (uint256) {\r\n        marketDetails.push(MarketDetails(_description));\r\n        return startMarket(_creator, _names, _odds, true);\r\n    }\r\n\r\n    function trustedResolveMarket(uint256 _id, uint256 _winningOutcome) public onlyOwner {\r\n        endMarket(_id, _winningOutcome);\r\n    }\r\n\r\n    function getMarketDetails(uint256 _id) public view returns (MarketDetails memory) {\r\n        return marketDetails[_id];\r\n    }\r\n\r\n    function getRewardEndTime(uint256 _marketId) public view override returns (uint256) {\r\n        return 0;\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../../utils/Context.sol\";\nimport \"./IERC721.sol\";\nimport \"./IERC721Metadata.sol\";\nimport \"./IERC721Enumerable.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"../../introspection/ERC165.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/EnumerableSet.sol\";\nimport \"../../utils/EnumerableMap.sol\";\nimport \"../../utils/Strings.sol\";\n\n/**\n * @title ERC721 Non-Fungible Token Standard basic implementation\n * @dev see https://eips.ethereum.org/EIPS/eip-721\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata, IERC721Enumerable {\n    using SafeMath for uint256;\n    using Address for address;\n    using EnumerableSet for EnumerableSet.UintSet;\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\n    using Strings for uint256;\n\n    // Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\n\n    // Mapping from holder address to their (enumerable) set of owned tokens\n    mapping (address => EnumerableSet.UintSet) private _holderTokens;\n\n    // Enumerable mapping from token ids to their owners\n    EnumerableMap.UintToAddressMap private _tokenOwners;\n\n    // Mapping from token ID to approved address\n    mapping (uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping (address => mapping (address => bool)) private _operatorApprovals;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Optional mapping for token URIs\n    mapping (uint256 => string) private _tokenURIs;\n\n    // Base URI\n    string private _baseURI;\n\n    /*\n     *     bytes4(keccak256('balanceOf(address)')) == 0x70a08231\n     *     bytes4(keccak256('ownerOf(uint256)')) == 0x6352211e\n     *     bytes4(keccak256('approve(address,uint256)')) == 0x095ea7b3\n     *     bytes4(keccak256('getApproved(uint256)')) == 0x081812fc\n     *     bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465\n     *     bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c5\n     *     bytes4(keccak256('transferFrom(address,address,uint256)')) == 0x23b872dd\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) == 0x42842e0e\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)')) == 0xb88d4fde\n     *\n     *     => 0x70a08231 ^ 0x6352211e ^ 0x095ea7b3 ^ 0x081812fc ^\n     *        0xa22cb465 ^ 0xe985e9c5 ^ 0x23b872dd ^ 0x42842e0e ^ 0xb88d4fde == 0x80ac58cd\n     */\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\n\n    /*\n     *     bytes4(keccak256('name()')) == 0x06fdde03\n     *     bytes4(keccak256('symbol()')) == 0x95d89b41\n     *     bytes4(keccak256('tokenURI(uint256)')) == 0xc87b56dd\n     *\n     *     => 0x06fdde03 ^ 0x95d89b41 ^ 0xc87b56dd == 0x5b5e139f\n     */\n    bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\n\n    /*\n     *     bytes4(keccak256('totalSupply()')) == 0x18160ddd\n     *     bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) == 0x2f745c59\n     *     bytes4(keccak256('tokenByIndex(uint256)')) == 0x4f6ccce7\n     *\n     *     => 0x18160ddd ^ 0x2f745c59 ^ 0x4f6ccce7 == 0x780e9d63\n     */\n    bytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor (string memory name_, string memory symbol_) public {\n        _name = name_;\n        _symbol = symbol_;\n\n        // register the supported interfaces to conform to ERC721 via ERC165\n        _registerInterface(_INTERFACE_ID_ERC721);\n        _registerInterface(_INTERFACE_ID_ERC721_METADATA);\n        _registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return _holderTokens[owner].length();\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        return _tokenOwners.get(tokenId, \"ERC721: owner query for nonexistent token\");\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory _tokenURI = _tokenURIs[tokenId];\n        string memory base = baseURI();\n\n        // If there is no base URI, return the token URI.\n        if (bytes(base).length == 0) {\n            return _tokenURI;\n        }\n        // If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).\n        if (bytes(_tokenURI).length > 0) {\n            return string(abi.encodePacked(base, _tokenURI));\n        }\n        // If there is a baseURI but no tokenURI, concatenate the tokenID to the baseURI.\n        return string(abi.encodePacked(base, tokenId.toString()));\n    }\n\n    /**\n    * @dev Returns the base URI set via {_setBaseURI}. This will be\n    * automatically added as a prefix in {tokenURI} to each token's URI, or\n    * to the token ID if no specific URI is set for that token ID.\n    */\n    function baseURI() public view virtual returns (string memory) {\n        return _baseURI;\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\n        return _holderTokens[owner].at(index);\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        // _tokenOwners are indexed by tokenIds, so .length() returns the number of tokenIds\n        return _tokenOwners.length();\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\n        (uint256 tokenId, ) = _tokenOwners.at(index);\n        return tokenId;\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(_msgSender() == owner || ERC721.isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        require(operator != _msgSender(), \"ERC721: approve to caller\");\n\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _tokenOwners.contains(tokenId);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || ERC721.isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     d*\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal virtual {\n        _mint(to, tokenId);\n        require(_checkOnERC721Received(address(0), to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _holderTokens[to].add(tokenId);\n\n        _tokenOwners.set(tokenId, to);\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId); // internal owner\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        // Clear metadata (if any)\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\n            delete _tokenURIs[tokenId];\n        }\n\n        _holderTokens[owner].remove(tokenId);\n\n        _tokenOwners.remove(tokenId);\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\"); // internal owner\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _holderTokens[from].remove(tokenId);\n        _holderTokens[to].add(tokenId);\n\n        _tokenOwners.set(tokenId, to);\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\n        require(_exists(tokenId), \"ERC721Metadata: URI set of nonexistent token\");\n        _tokenURIs[tokenId] = _tokenURI;\n    }\n\n    /**\n     * @dev Internal function to set the base URI for all token IDs. It is\n     * automatically added as a prefix to the value returned in {tokenURI},\n     * or to the token ID if {tokenURI} is empty.\n     */\n    function _setBaseURI(string memory baseURI_) internal virtual {\n        _baseURI = baseURI_;\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\n        private returns (bool)\n    {\n        if (!to.isContract()) {\n            return true;\n        }\n        bytes memory returndata = to.functionCall(abi.encodeWithSelector(\n            IERC721Receiver(to).onERC721Received.selector,\n            _msgSender(),\n            from,\n            tokenId,\n            _data\n        ), \"ERC721: transfer to non ERC721Receiver implementer\");\n        bytes4 retval = abi.decode(returndata, (bytes4));\n        return (retval == _ERC721_RECEIVED);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId); // internal owner\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual { }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\nimport \"../../introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\n      *\n      * Requirements:\n      *\n      * - `from` cannot be the zero address.\n      * - `to` cannot be the zero address.\n      * - `tokenId` token must exist and be owned by `from`.\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n      *\n      * Emits a {Transfer} event.\n      */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\nimport \"./IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\nimport \"./IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts may inherit from this and call {_registerInterface} to declare\n * their support of an interface.\n */\nabstract contract ERC165 is IERC165 {\n    /*\n     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\n     */\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\n\n    /**\n     * @dev Mapping of interface ids to whether or not it's supported.\n     */\n    mapping(bytes4 => bool) private _supportedInterfaces;\n\n    constructor () internal {\n        // Derived contracts need only register support for their own interfaces,\n        // we register support for ERC165 itself here\n        _registerInterface(_INTERFACE_ID_ERC165);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     *\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return _supportedInterfaces[interfaceId];\n    }\n\n    /**\n     * @dev Registers the contract as an implementer of the interface defined by\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\n     * registering its interface id is not required.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * Requirements:\n     *\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\n     */\n    function _registerInterface(bytes4 interfaceId) internal virtual {\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\n        _supportedInterfaces[interfaceId] = true;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/EnumerableMap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Library for managing an enumerable variant of Solidity's\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\n * type.\n *\n * Maps have the following properties:\n *\n * - Entries are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\n *\n *     // Declare a set state variable\n *     EnumerableMap.UintToAddressMap private myMap;\n * }\n * ```\n *\n * As of v3.0.0, only maps of type `uint256 -> address` (`UintToAddressMap`) are\n * supported.\n */\nlibrary EnumerableMap {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Map type with\n    // bytes32 keys and values.\n    // The Map implementation uses private functions, and user-facing\n    // implementations (such as Uint256ToAddressMap) are just wrappers around\n    // the underlying Map.\n    // This means that we can only create new EnumerableMaps for types that fit\n    // in bytes32.\n\n    struct MapEntry {\n        bytes32 _key;\n        bytes32 _value;\n    }\n\n    struct Map {\n        // Storage of map keys and values\n        MapEntry[] _entries;\n\n        // Position of the entry defined by a key in the `entries` array, plus 1\n        // because index 0 means a key is not in the map.\n        mapping (bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function _set(Map storage map, bytes32 key, bytes32 value) private returns (bool) {\n        // We read and store the key's index to prevent multiple reads from the same storage slot\n        uint256 keyIndex = map._indexes[key];\n\n        if (keyIndex == 0) { // Equivalent to !contains(map, key)\n            map._entries.push(MapEntry({ _key: key, _value: value }));\n            // The entry is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            map._indexes[key] = map._entries.length;\n            return true;\n        } else {\n            map._entries[keyIndex - 1]._value = value;\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a key-value pair from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function _remove(Map storage map, bytes32 key) private returns (bool) {\n        // We read and store the key's index to prevent multiple reads from the same storage slot\n        uint256 keyIndex = map._indexes[key];\n\n        if (keyIndex != 0) { // Equivalent to contains(map, key)\n            // To delete a key-value pair from the _entries array in O(1), we swap the entry to delete with the last one\n            // in the array, and then remove the last entry (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = keyIndex - 1;\n            uint256 lastIndex = map._entries.length - 1;\n\n            // When the entry to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            MapEntry storage lastEntry = map._entries[lastIndex];\n\n            // Move the last entry to the index where the entry to delete is\n            map._entries[toDeleteIndex] = lastEntry;\n            // Update the index for the moved entry\n            map._indexes[lastEntry._key] = toDeleteIndex + 1; // All indexes are 1-based\n\n            // Delete the slot where the moved entry was stored\n            map._entries.pop();\n\n            // Delete the index for the deleted slot\n            delete map._indexes[key];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function _contains(Map storage map, bytes32 key) private view returns (bool) {\n        return map._indexes[key] != 0;\n    }\n\n    /**\n     * @dev Returns the number of key-value pairs in the map. O(1).\n     */\n    function _length(Map storage map) private view returns (uint256) {\n        return map._entries.length;\n    }\n\n   /**\n    * @dev Returns the key-value pair stored at position `index` in the map. O(1).\n    *\n    * Note that there are no guarantees on the ordering of entries inside the\n    * array, and it may change when more entries are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function _at(Map storage map, uint256 index) private view returns (bytes32, bytes32) {\n        require(map._entries.length > index, \"EnumerableMap: index out of bounds\");\n\n        MapEntry storage entry = map._entries[index];\n        return (entry._key, entry._value);\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function _tryGet(Map storage map, bytes32 key) private view returns (bool, bytes32) {\n        uint256 keyIndex = map._indexes[key];\n        if (keyIndex == 0) return (false, 0); // Equivalent to contains(map, key)\n        return (true, map._entries[keyIndex - 1]._value); // All indexes are 1-based\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function _get(Map storage map, bytes32 key) private view returns (bytes32) {\n        uint256 keyIndex = map._indexes[key];\n        require(keyIndex != 0, \"EnumerableMap: nonexistent key\"); // Equivalent to contains(map, key)\n        return map._entries[keyIndex - 1]._value; // All indexes are 1-based\n    }\n\n    /**\n     * @dev Same as {_get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {_tryGet}.\n     */\n    function _get(Map storage map, bytes32 key, string memory errorMessage) private view returns (bytes32) {\n        uint256 keyIndex = map._indexes[key];\n        require(keyIndex != 0, errorMessage); // Equivalent to contains(map, key)\n        return map._entries[keyIndex - 1]._value; // All indexes are 1-based\n    }\n\n    // UintToAddressMap\n\n    struct UintToAddressMap {\n        Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(UintToAddressMap storage map, uint256 key, address value) internal returns (bool) {\n        return _set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\n        return _remove(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\n        return _contains(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\n        return _length(map._inner);\n    }\n\n   /**\n    * @dev Returns the element stored at position `index` in the set. O(1).\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\n        (bytes32 key, bytes32 value) = _at(map._inner, index);\n        return (uint256(key), address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     *\n     * _Available since v3.4._\n     */\n    function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\n        (bool success, bytes32 value) = _tryGet(map._inner, bytes32(key));\n        return (success, address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\n        return address(uint160(uint256(_get(map._inner, bytes32(key)))));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(UintToAddressMap storage map, uint256 key, string memory errorMessage) internal view returns (address) {\n        return address(uint160(uint256(_get(map._inner, bytes32(key), errorMessage))));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        uint256 index = digits - 1;\n        temp = value;\n        while (temp != 0) {\n            buffer[index--] = bytes1(uint8(48 + temp % 10));\n            temp /= 10;\n        }\n        return string(buffer);\n    }\n}\n"
    },
    "@openzeppelin/contracts/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/utils/ERC721Enhanced.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// code borrowed from OpenZeppelin and @uniswap/v3-periphery\r\npragma solidity 0.7.6;\r\n\r\nimport \"@openzeppelin/contracts/drafts/EIP712.sol\";\r\nimport \"@openzeppelin/contracts/cryptography/ECDSA.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\r\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\r\n\r\n\r\n\r\n/// @title Interface for verifying contract-based account signatures\r\n/// @notice Interface that verifies provided signature for the data\r\n/// @dev Interface defined by EIP-1271\r\ninterface IERC1271 {\r\n    /// @notice Returns whether the provided signature is valid for the provided data\r\n    /// @dev MUST return the bytes4 magic value 0x1626ba7e when function passes.\r\n    /// MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5).\r\n    /// MUST allow external calls.\r\n    /// @param hash Hash of the data to be signed\r\n    /// @param signature Signature byte array associated with _data\r\n    /// @return magicValue The bytes4 magic value 0x1626ba7e\r\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\r\n}\r\n\r\n/**\r\n * @title ERC721Enhanced\r\n * @author solace.fi\r\n * @notice An extension of `ERC721`.\r\n *\r\n * The base is OpenZeppelin's `ERC721Enumerable` which also includes the `Metadata` extension. This extension includes simpler transfers, gasless approvals, and changeable URIs.\r\n */\r\nabstract contract ERC721Enhanced is ERC721, EIP712 {\r\n    using Strings for uint256;\r\n\r\n    /// @dev The nonces used in the permit signature verification.\r\n    /// tokenID => nonce\r\n    mapping(uint256 => uint256) private _nonces;\r\n\r\n    /// @dev Value is equal to keccak256(\"Permit(address spender,uint256 tokenID,uint256 nonce,uint256 deadline)\");\r\n    // solhint-disable-next-line var-name-mixedcase\r\n    bytes32 private immutable _PERMIT_TYPEHASH = 0x137406564cdcf9b40b1700502a9241e87476728da7ae3d0edfcf0541e5b49b3e;\r\n\r\n    string public _baseURI_;\r\n\r\n    /**\r\n     * @notice Constructs the `ERC721Enhanced` contract.\r\n     * @param name_ The name of the token.\r\n     * @param symbol_ The symbol of the token.\r\n     */\r\n    constructor(\r\n        string memory name_,\r\n        string memory symbol_\r\n    ) ERC721(name_, symbol_) EIP712(name_, \"1\") {\r\n        _baseURI_ = \"\";\r\n    }\r\n\r\n    /***************************************\r\n    SIMPLER TRANSFERS\r\n    ***************************************/\r\n\r\n    /**\r\n     * @notice Transfers `tokenID` from `msg.sender` to `to`.\r\n     * @dev This was excluded from the official `ERC721` standard in favor of `transferFrom(address from, address to, uint256 tokenID)`. We elect to include it.\r\n     * @param to The receipient of the token.\r\n     * @param tokenID The token to transfer.\r\n     */\r\n    function transfer(address to, uint256 tokenID) public  {\r\n        super.transferFrom(msg.sender, to, tokenID);\r\n    }\r\n\r\n    /**\r\n     * @notice Safely transfers `tokenID` from `msg.sender` to `to`.\r\n     * @dev This was excluded from the official `ERC721` standard in favor of `safeTransferFrom(address from, address to, uint256 tokenID)`. We elect to include it.\r\n     * @param to The receipient of the token.\r\n     * @param tokenID The token to transfer.\r\n     */\r\n    function safeTransfer(address to, uint256 tokenID) public  {\r\n        super.safeTransferFrom(msg.sender, to, tokenID, \"\");\r\n    }\r\n\r\n    /***************************************\r\n    GASLESS APPROVALS\r\n    ***************************************/\r\n\r\n    /**\r\n     * @notice Approve of a specific `tokenID` for spending by `spender` via signature.\r\n     * @param spender The account that is being approved.\r\n     * @param tokenID The ID of the token that is being approved for spending.\r\n     * @param deadline The deadline timestamp by which the call must be mined for the approve to work.\r\n     * @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`.\r\n     * @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`.\r\n     * @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`.\r\n     */\r\n    function permit(\r\n        address spender,\r\n        uint256 tokenID,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external  {\r\n        require(_exists(tokenID), \"query for nonexistent token\");\r\n        // solhint-disable-next-line not-rely-on-time\r\n        require(block.timestamp <= deadline, \"permit expired\");\r\n\r\n        uint256 nonce = _nonces[tokenID]++; // get then increment\r\n        bytes32 digest =\r\n            keccak256(\r\n                abi.encodePacked(\r\n                    \"\\x19\\x01\",\r\n                    DOMAIN_SEPARATOR(),\r\n                    keccak256(abi.encode(_PERMIT_TYPEHASH, spender, tokenID, nonce, deadline))\r\n                )\r\n            );\r\n        address owner = ownerOf(tokenID);\r\n        require(spender != owner, \"cannot permit to self\");\r\n\r\n        if (Address.isContract(owner)) {\r\n            require(IERC1271(owner).isValidSignature(digest, abi.encodePacked(r, s, v)) == 0x1626ba7e, \"unauthorized\");\r\n        } else {\r\n            address recoveredAddress = ecrecover(digest, v, r, s);\r\n            require(recoveredAddress != address(0), \"invalid signature\");\r\n            require(recoveredAddress == owner, \"unauthorized\");\r\n        }\r\n\r\n        approve(spender, tokenID);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the current nonce for `tokenID`. This value must be\r\n     * included whenever a signature is generated for `permit`.\r\n     * Every successful call to `permit` increases ``tokenID``'s nonce by one. This\r\n     * prevents a signature from being used multiple times.\r\n     * @param tokenID ID of the token to request nonce.\r\n     * @return nonce Nonce of the token.\r\n     */\r\n    function nonces(uint256 tokenID) external view  returns (uint256 nonce) {\r\n        return _nonces[tokenID];\r\n    }\r\n\r\n    /**\r\n     * @notice The permit typehash used in the `permit` signature.\r\n     * @return typehash The typehash for the `permit`.\r\n     */\r\n    // solhint-disable-next-line func-name-mixedcase\r\n    function PERMIT_TYPEHASH() external pure  returns (bytes32 typehash) {\r\n        return _PERMIT_TYPEHASH;\r\n    }\r\n\r\n    /**\r\n     * @notice The domain separator used in the encoding of the signature for `permit`, as defined by `EIP712`.\r\n     * @return seperator The domain seperator for `permit`.\r\n     */\r\n    // solhint-disable-next-line func-name-mixedcase\r\n    function DOMAIN_SEPARATOR() public view  returns (bytes32 seperator) {\r\n        return _domainSeparatorV4();\r\n    }\r\n\r\n    /***************************************\r\n    CHANGEABLE URIS\r\n    ***************************************/\r\n\r\n    /**\r\n     * @notice Returns the Uniform Resource Identifier (URI) for `tokenID` token.\r\n     */\r\n    function tokenURI(uint256 tokenID) public view virtual override tokenMustExist(tokenID) returns (string memory) {\r\n        string memory baseURI_ = _baseURI_;\r\n        return string(abi.encodePacked(baseURI_, tokenID.toString()));\r\n    }\r\n\r\n    /**\r\n     * @notice Base URI for computing `tokenURI`. If set, the resulting URI for each\r\n     * token will be the concatenation of the `baseURI` and the `tokenID`. Empty\r\n     * by default, can be overriden in child contracts.\r\n     */\r\n    function _baseURI() internal view virtual  returns (string memory baseURI_) {\r\n        return _baseURI_;\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the base URI for computing `tokenURI`.\r\n     * @dev Remember to add access control to inheriting contracts.\r\n     * @param baseURI_ The new base URI.\r\n     */\r\n    function _setBaseURI(string memory baseURI_) internal override {\r\n        _baseURI_ = baseURI_;\r\n       // emit BaseURISet(baseURI_);\r\n    }\r\n\r\n    /***************************************\r\n    MODIFIERS\r\n    ***************************************/\r\n\r\n    // Call will revert if the token does not exist.\r\n    modifier tokenMustExist(uint256 tokenID) {\r\n        require(_exists(tokenID), \"query for nonexistent token\");\r\n        _;\r\n    }\r\n\r\n    // Call will revert if not made by owner.\r\n    // Call will revert if the token does not exist.\r\n    modifier onlyOwner(uint256 tokenID) {\r\n        require(ownerOf(tokenID) == msg.sender, \"only owner\");\r\n        _;\r\n    }\r\n\r\n    // Call will revert if not made by owner or approved.\r\n    // Call will revert if the token does not exist.\r\n    modifier onlyOwnerOrApproved(uint256 tokenID) {\r\n        require(_isApprovedOrOwner(msg.sender, tokenID), \"only owner or approved\");\r\n        _;\r\n    }\r\n\r\n    /***************************************\r\n    MORE HOOKS\r\n    ***************************************/\r\n\r\n    /**\r\n     * @notice Mints `tokenID` and transfers it to `to`.\r\n     * @param to The receiver of the token.\r\n     * @param tokenID The ID of the token to mint.\r\n     */\r\n    function _mint(address to, uint256 tokenID) internal virtual override{\r\n        super._mint(to, tokenID);\r\n        _afterTokenTransfer(address(0), to, tokenID);\r\n    }\r\n\r\n    /**\r\n     * @notice Destroys `tokenID`.\r\n     * @param tokenID The ID of the token to burn.\r\n     */\r\n    function _burn(uint256 tokenID) internal virtual override{\r\n        address owner = ERC721.ownerOf(tokenID);\r\n        super._burn(tokenID);\r\n        _afterTokenTransfer(owner, address(0), tokenID);\r\n    }\r\n\r\n    /**\r\n     * @notice Transfers `tokenID` from `from` to `to`.\r\n     * @param from The account to transfer the token from.\r\n     * @param to The account to transfer the token to.\r\n     * @param tokenID The ID of the token to transfer.\r\n     */\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 tokenID\r\n    ) internal virtual override {\r\n        super._transfer(from, to, tokenID);\r\n        _afterTokenTransfer(from, to, tokenID);\r\n    }\r\n\r\n    /**\r\n     * @notice Hook that is called after any token transfer. This includes minting and burning.\r\n     * @param from The user that sends the token, or zero if minting.\r\n     * @param to The zero that receives the token, or zero if burning.\r\n     * @param tokenID The ID of the token being transferred.\r\n     */\r\n    function _afterTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 tokenID\r\n    // solhint-disable-next-line no-empty-blocks\r\n    ) internal virtual {}\r\n\r\n    /***************************************\r\n    MISC\r\n    ***************************************/\r\n\r\n    /**\r\n     * @notice Determines if a token exists or not.\r\n     * @param tokenID The ID of the token to query.\r\n     * @return status True if the token exists, false if it doesn't.\r\n     */\r\n    function exists(uint256 tokenID) external view  returns (bool status) {\r\n        return _exists(tokenID);\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts/drafts/EIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n */\nabstract contract EIP712 {\n    /* solhint-disable var-name-mixedcase */\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\n    uint256 private immutable _CACHED_CHAIN_ID;\n\n    bytes32 private immutable _HASHED_NAME;\n    bytes32 private immutable _HASHED_VERSION;\n    bytes32 private immutable _TYPE_HASH;\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) internal {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        bytes32 typeHash = keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n        _CACHED_CHAIN_ID = _getChainId();\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\n        _TYPE_HASH = typeHash;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view virtual returns (bytes32) {\n        if (_getChainId() == _CACHED_CHAIN_ID) {\n            return _CACHED_DOMAIN_SEPARATOR;\n        } else {\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\n        }\n    }\n\n    function _buildDomainSeparator(bytes32 typeHash, bytes32 name, bytes32 version) private view returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                typeHash,\n                name,\n                version,\n                _getChainId(),\n                address(this)\n            )\n        );\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", _domainSeparatorV4(), structHash));\n    }\n\n    function _getChainId() private view returns (uint256 chainId) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            chainId := chainid()\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        // Check the signature length\n        if (signature.length != 65) {\n            revert(\"ECDSA: invalid signature length\");\n        }\n\n        // Divide the signature in r, s and v variables\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        // ecrecover takes the signature parameters, and the only way to get them\n        // currently is to use assembly.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r := mload(add(signature, 0x20))\n            s := mload(add(signature, 0x40))\n            v := byte(0, mload(add(signature, 0x60)))\n        }\n\n        return recover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover-bytes32-bytes-} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (281): 0 < s < secp256k1n  2 + 1, and for v in (282): v  {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, \"ECDSA: invalid signature 's' value\");\n        require(v == 27 || v == 28, \"ECDSA: invalid signature 'v' value\");\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        require(signer != address(0), \"ECDSA: invalid signature\");\n\n        return signer;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * replicates the behavior of the\n     * https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign[`eth_sign`]\n     * JSON-RPC method.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n}\n"
    },
    "contracts/staking/iDSlocker.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity 0.7.6;\r\npragma abicoder v2;\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\r\n//import \"@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\r\nimport \"@openzeppelin/contracts/utils/EnumerableSet.sol\";\r\nimport \"@openzeppelin/contracts/utils/EnumerableMap.sol\";\r\n// import \"@openzeppelin/contracts/utils/cryptography/draft-EIP712.sol\";\r\n//import \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\r\nimport \"./../utils/ERC721Enhanced.sol\";\r\n// import \"./../utils/Governable.sol\";\r\n// import \"./../interfaces/staking/IxsListener.sol\";\r\n// import \"./../interfaces/staking/IxsLocker.sol\";\r\n\r\n\r\nstruct Lock {\r\n    uint256 amount;\r\n    uint256 end;}\r\n\r\ncontract iDSLocker is ERC721Enhanced, ReentrancyGuard{\r\n    using EnumerableSet for EnumerableSet.AddressSet;\r\n\r\n\r\n\r\n    address collateral_address;\r\n    uint256 public constant  MAX_LOCK_DURATION = 4 * (365 days);\r\n    uint256 public  totalNumLocks;\r\n\r\n    mapping(uint256 => Lock) private _locks;\r\n    EnumerableSet.AddressSet private _iDSLockListeners;\r\n\r\n    constructor(address collateral_address_)\r\n        ERC721Enhanced(\"iDS lock\", \"iDSLOCK\")\r\n    {\r\n        collateral_address = collateral_address_;\r\n    }\r\n\r\n    function locks(uint256 iDSLockID) external view  tokenMustExist(iDSLockID) returns (Lock memory lock_) {\r\n        return _locks[iDSLockID];\r\n    }\r\n\r\n\r\n    function isLocked(uint256 iDSLockID) external view  tokenMustExist(iDSLockID) returns (bool locked) {\r\n        // solhint-disable-next-line not-rely-on-time\r\n        return _locks[iDSLockID].end > block.timestamp;\r\n    }\r\n\r\n    function timeLeft(uint256 iDSLockID) external view  tokenMustExist(iDSLockID) returns (uint256 time) {\r\n        // solhint-disable-next-line not-rely-on-time\r\n        return (_locks[iDSLockID].end > block.timestamp)\r\n            // solhint-disable-next-line not-rely-on-time\r\n            ? _locks[iDSLockID].end - block.timestamp // locked\r\n            : 0; // unlocked\r\n    }\r\n\r\n\r\n    function stakedBalance(address account) external view  returns (uint256 balance) {\r\n        uint256 numOfLocks = balanceOf(account);\r\n        balance = 0;\r\n        for (uint256 i = 0; i < numOfLocks; i++) {\r\n            uint256 iDSLockID = tokenOfOwnerByIndex(account, i);\r\n            balance += _locks[iDSLockID].amount;\r\n        }\r\n        return balance;\r\n\r\n    }\r\n\r\n    function createLock(address recipient, uint256 amount, uint256 end) external  nonReentrant returns (uint256 iDSLockID) {\r\n        // pull solace\r\n        SafeERC20.safeTransferFrom(IERC20(collateral_address), msg.sender, address(this), amount);\r\n        // accounting\r\n        return _createLock(recipient, amount, end);\r\n    }\r\n\r\n\r\n\r\n    function _createLock(address recipient, uint256 amount, uint256 end) internal returns (uint256 iDSLockID) {\r\n        iDSLockID = ++totalNumLocks;\r\n        Lock memory newLock = Lock(amount, end);\r\n        // solhint-disable-next-line not-rely-on-time\r\n        require(newLock.end <= block.timestamp + MAX_LOCK_DURATION, \"Max lock is 4 years\");\r\n        // accounting\r\n        _locks[iDSLockID] = newLock;\r\n        _safeMint(recipient, iDSLockID);\r\n    }\r\n\r\n    function increaseAmount(uint256 iDSLockID, uint256 amount) external  nonReentrant tokenMustExist(iDSLockID) {\r\n        // pull solace\r\n        SafeERC20.safeTransferFrom(IERC20(collateral_address), msg.sender, address(this), amount);\r\n        // accounting\r\n        uint256 newAmount = _locks[iDSLockID].amount + amount;\r\n        _updateLock(iDSLockID, newAmount, _locks[iDSLockID].end);\r\n    }\r\n    \r\n    function _updateLock(uint256 iDSLockID, uint256 amount, uint256 end) internal {\r\n        // checks\r\n        Lock memory prevLock = _locks[iDSLockID];\r\n        Lock memory newLock = Lock(amount, end); // end was sanitized before passed in\r\n        // accounting\r\n        _locks[iDSLockID] = newLock;\r\n       // address owner = ownerOf(iDSLockID);\r\n       // _notify(iDSLockID, owner, owner, prevLock, newLock);\r\n     //   emit LockUpdated(iDSLockID, amount, newLock.end);\r\n    }\r\n\r\n    function withdrawInPart(uint256 iDSLockID, address recipient, uint256 amount) external  nonReentrant onlyOwnerOrApproved(iDSLockID) {\r\n        require(amount <= _locks[iDSLockID].amount, \"excess withdraw\");\r\n        _withdraw(iDSLockID, amount);\r\n        // transfer solace\r\n        SafeERC20.safeTransfer(IERC20(collateral_address), recipient, amount);\r\n    }\r\n\r\n   function _withdraw(uint256 iDSLockID, uint256 amount) internal {\r\n        // solhint-disable-next-line not-rely-on-time\r\n        require(_locks[iDSLockID].end <= block.timestamp, \"locked\"); // cannot withdraw while locked\r\n        // accounting\r\n        if(amount == _locks[iDSLockID].amount) {\r\n            _burn(iDSLockID);\r\n            delete _locks[iDSLockID];\r\n        }\r\n        else {\r\n            Lock memory oldLock = _locks[iDSLockID];\r\n            Lock memory newLock = Lock(oldLock.amount-amount, oldLock.end);\r\n            _locks[iDSLockID].amount -= amount;\r\n            // address owner = ownerOf(iDSLockID);\r\n            // _notify(iDSLockID, owner, owner, oldLock, newLock);\r\n        }\r\n       // emit Withdrawl(iDSLockID, amount);\r\n    }\r\n\r\n\r\n\r\n\r\n}\r\n\r\n\r\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor () internal {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/staking/insurance.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity 0.7.6;\r\npragma abicoder v2;\r\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Enumerable.sol\";\r\nimport \"./iDSlocker.sol\";\r\n\r\n//Returned to insurannce stakers, who stake erc20 stablecoins to get this in return \r\ncontract iDS  {\r\n    uint256 public constant  MAX_LOCK_DURATION = 4 * 365 days; // 4 years\r\n    uint256 public constant  MAX_LOCK_MULTIPLIER_BPS = 40000;  // 4X\r\n    uint256 public constant  UNLOCKED_MULTIPLIER_BPS = 10000; // 1X\r\n    // 1 bps = 1/10000\r\n    uint256 internal constant MAX_BPS = 10000;\r\n\r\n    address idsLocker;\r\n\r\n    constructor(address idsLocker_ ) {\r\n        idsLocker = idsLocker_;\r\n    }\r\n\r\n\r\n\r\n    function balanceOf(address account) external view  returns (uint256 balance) {\r\n        IERC721Enumerable locker = IERC721Enumerable(idsLocker);\r\n        uint256 numOfLocks = locker.balanceOf(account);\r\n        balance = 0;\r\n        for (uint256 i = 0; i < numOfLocks; i++) {\r\n            uint256 idsLocker = locker.tokenOfOwnerByIndex(account, i);\r\n            balance += balanceOfLock(idsLocker);\r\n        }\r\n        return balance;\r\n    }\r\n\r\n  \r\n    function balanceOfLock(uint256 iDSLockID) public view  returns (uint256 balance) {\r\n        iDSLocker locker = iDSLocker(idsLocker);\r\n        Lock memory lock = locker.locks(iDSLockID);\r\n        uint256 base = lock.amount * UNLOCKED_MULTIPLIER_BPS / MAX_BPS;\r\n        // solhint-disable-next-line not-rely-on-time\r\n        uint256 bonus = (lock.end <= block.timestamp)\r\n            ? 0 // unlocked\r\n            // solhint-disable-next-line not-rely-on-time\r\n            : lock.amount * (lock.end - block.timestamp) * (MAX_LOCK_MULTIPLIER_BPS - UNLOCKED_MULTIPLIER_BPS) / (MAX_LOCK_DURATION * MAX_BPS); // locked\r\n        return base + bonus;\r\n    }\r\n\r\n\r\n    function totalSupply() external view  returns (uint256 supply) {\r\n        IERC721Enumerable locker = IERC721Enumerable(idsLocker);\r\n        uint256 numOfLocks = locker.totalSupply();\r\n        supply = 0;\r\n        for (uint256 i = 0; i < numOfLocks; i++) {\r\n            uint256 xsLockID = locker.tokenByIndex(i);\r\n            supply += balanceOfLock(xsLockID);\r\n        }\r\n        return supply;\r\n    }\r\n\r\n    function name() external pure  returns (string memory) {\r\n        return \"iDS\";\r\n    }\r\n\r\n    function symbol() external pure  returns (string memory) {\r\n        return \"iDS\";\r\n    }\r\n\r\n\r\n    function decimals() external pure  returns (uint8) {\r\n        return 18;\r\n    }\r\n\r\n    function allowance(address owner, address spender) external pure  returns (uint256) {\r\n        return 0;\r\n    }\r\n\r\n  \r\n    function transfer(address recipient, uint256 amount) external  returns (bool success) {\r\n        revert(\"transfer not allowed\");\r\n    }\r\n\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) external  returns (bool success) {\r\n        revert(\"transfer not allowed\");\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) external  returns (bool success) {\r\n        revert(\"transfer not allowed\");\r\n    }\r\n}\r\n"
    },
    "contracts/staking/voting.sol": {
      "content": "pragma solidity 0.7.6; \r\n\r\npragma abicoder v2;\r\n\r\nimport \"../stablecoin/DSS.sol\";\r\nimport \"hardhat/console.sol\";\r\nimport \"../Common/SafeMath.sol\";\r\nimport \"@openzeppelin/contracts/utils/EnumerableSet.sol\";\r\n\r\n//Code borrowed and adapted from Tokemak \r\n\r\n/// @notice Vote payload to be submitted to Vote Tracker\r\nstruct UserVotePayload {\r\n    address account;\r\n    bytes32 voteSessionKey;\r\n    uint256 nonce;\r\n    uint256 chainId;\r\n    uint256 totalVotes;\r\n    UserVoteAllocationItem[] allocations;\r\n}\r\n\r\n/// @notice Individual allocation to an asset, exchange, or asset-pair\r\nstruct UserVoteAllocationItem {\r\n    bytes32 reactorKey;\r\n    uint256 amount; //18 Decimals\r\n}\r\n\r\n\r\nstruct UserVoteDetails {\r\n    uint256 totalUsedVotes;\r\n    uint256 totalAvailableVotes;\r\n}\r\ncontract VoteTracker {\r\n    using SafeMath for uint256;\r\n\r\n\tDSS public dss;\r\n\r\n\r\n\tmapping(address => UserVoteDetails) userVoteDetails;\r\n    mapping(address => bytes32[]) public userVoteKeys;\r\n    mapping(address => mapping(bytes32 => uint256)) public userVoteItems;\r\n    mapping(bytes32 => uint256) public systemAggregations;\r\n\r\n    /// @dev Stores the users next valid vote nonce\r\n    EnumerableSet.Bytes32Set private allowedreactorKeys;\r\n\tmapping(address => uint256) public  userNonces; \r\n\r\n\tconstructor (address dss_address) public{\r\n\t\tdss = DSS(dss_address);\r\n\t}\r\n\r\n\r\n\r\n    //single user will call this vote function from UI, vote allocation for \r\n    //each potential borrowers \r\n\tfunction vote(bytes32 _voteSessionKey, uint256 _nonce, uint256 _totalVotes,\r\n        bytes32[] memory reactorKeys, uint256[] memory amounts)\r\n\texternal  {\r\n        uint256 key_lengths = reactorKeys.length; \r\n        UserVoteAllocationItem[] memory _allocations = new UserVoteAllocationItem[](key_lengths); \r\n\r\n\r\n        for (uint256 i=0; i < key_lengths; i++){\r\n            _allocations[i] = UserVoteAllocationItem({\r\n                reactorKey : reactorKeys[i], \r\n                amount: amounts[i]\r\n                });\r\n\r\n        }\r\n\r\n\r\n        UserVotePayload memory payload  = UserVotePayload({\r\n            account : msg.sender, \r\n            voteSessionKey : _voteSessionKey, \r\n            nonce: _nonce, \r\n            chainId : 0, \r\n            totalVotes: _totalVotes, \r\n            allocations: _allocations\r\n            }); \r\n\r\n        _vote(payload);\r\n\r\n\t}\r\n\r\n\r\n    function _removeUserVoteKey(address account, bytes32 reactorKey) internal  {\r\n        for (uint256 i = 0; i < userVoteKeys[account].length; i++) {\r\n            if (userVoteKeys[account][i] == reactorKey) {\r\n                userVoteKeys[account][i] = userVoteKeys[account][userVoteKeys[account].length - 1];\r\n                userVoteKeys[account].pop();\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    \r\n\r\n\tfunction _vote(UserVotePayload memory userVotePayload) internal  {\r\n\t\taddress account = userVotePayload.account; \r\n\t\tuint256 totalUsedVotes = userVoteDetails[account].totalUsedVotes;\r\n\r\n        console.log('nonce', userNonces[account]);\r\n\t\trequire(userNonces[account] == userVotePayload.nonce, \"INVALID_NONCE\");\r\n\r\n\t\t// Ensure the message cannot be replayed\r\n        userNonces[account] = userNonces[account].add(1);\r\n\r\n\t\tfor (uint256 i = 0; i < userVotePayload.allocations.length; i++) {\r\n\t\t\tbytes32 reactorKey = userVotePayload.allocations[i].reactorKey;\r\n\t\t\tuint256 amount = userVotePayload.allocations[i].amount; \r\n\r\n            //Ensure where they are voting is allowed\r\n\t\t\t//require(allowedreactorKeys.contains(reactorKey),  \"PLACEMENT_NOT_ALLOWED\"); \r\n\r\n            // check if user has already voted for this reactor\r\n\t\t\tif (userVoteItems[account][reactorKey]>0){\r\n\t\t\t\tif (amount ==0){\r\n\t\t\t\t\t_removeUserVoteKey(account, reactorKey);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tuint256 currentAmount = userVoteItems[account][reactorKey];\r\n\r\n            }\r\n\r\n            else{\r\n                \r\n\t\t\t\tif(amount>0){\r\n\t\t\t\t\tuserVoteKeys[account].push(reactorKey);\r\n\t\t\t\t\tuserVoteItems[account][reactorKey] = amount; \r\n\t\t\t\t\tsystemAggregations[reactorKey] = systemAggregations[reactorKey].add(amount);\r\n\t\t\t\t\ttotalUsedVotes = totalUsedVotes.add(amount);\r\n\t\t\t\t}\r\n\r\n            }\r\n\r\n\t\t\t\r\n\t\t}\r\n\r\n        console.log('totalusedvotes',totalUsedVotes,  userVotePayload.totalVotes);\r\n\t\trequire(totalUsedVotes == userVotePayload.totalVotes, \"VOTE_TOTAL_MISMATCH\");\r\n\r\n        uint256 totalAvailableVotes = getMaxVoteBalance(account);\r\n     //   require(totalUsedVotes <= totalAvailableVotes, \"NOT_ENOUGH_VOTES\");\r\n\r\n        userVoteDetails[account] = UserVoteDetails({\r\n        \ttotalUsedVotes: totalUsedVotes,\r\n            totalAvailableVotes: totalAvailableVotes\r\n        \t}); \r\n\r\n\r\n\r\n\t}\r\n\r\n\r\n\r\n    function getMaxVoteBalance(address account) public view returns (uint256) {\r\n    \tuint256 dssbalance = dss.balanceOf(account); \r\n\r\n        return _getVotingPower(dssbalance);\r\n    }\r\n\r\n    function _getVotingPower(uint256 balance) private view returns (uint256) {\r\n\t\treturn balance; \r\n    }\r\n\r\n\r\n    //get vote for one borrower \r\n    function getVotes(bytes32 reactorKey) public view returns (uint256){\r\n        return systemAggregations[reactorKey]; \r\n    }\r\n\r\n\r\n}"
    },
    "contracts/stablecoin/DSS.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.7.6;\r\nimport \"../ERC20/ERC20Custom.sol\";\r\nimport \"../Common/AccessControl.sol\";\r\nimport \"../Common/Ownable.sol\";\r\n\r\ncontract DSS is ERC20Custom, AccessControl, Ownable {\r\n    /* ========== STATE VARIABLES ========== */\r\n    \r\n    address[] public pools_array;\r\n    mapping(address => bool) pools;\r\n    \r\n    address public creator_address;\r\n    address timelock_address;\r\n    address public DEFAULT_ADMIN_ADDRESS;\r\n    uint256 constant genesis_supply = 1000000e18;\r\n\r\n    \r\n    /* ========== MODIFIERS ========== */\r\n    modifier onlyPools() {\r\n        require(pools[msg.sender] == true, \"Only pools can call this function\");\r\n        _;\r\n    }\r\n\r\n    constructor (\r\n        address _creator_address,\r\n        address _timelock_address\r\n    )  ERC20Custom(\"Debita Stablecoin Share\",\"DSS\") Ownable(_creator_address)\r\n    {\r\n        _mint(_creator_address, genesis_supply);\r\n        creator_address = _creator_address;\r\n        timelock_address = _timelock_address;\r\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\r\n        DEFAULT_ADMIN_ADDRESS = _msgSender();\r\n        _grantRole(DEFAULT_ADMIN_ROLE, _creator_address);\r\n    }\r\n\r\n    function addPool(address pool_address) public onlyOwner {\r\n        require(pool_address != address(0), \"Zero address detected\");\r\n\r\n        require(pools[pool_address] == false, \"Address already exists\");\r\n        pools[pool_address] = true; \r\n        pools_array.push(pool_address);\r\n\r\n        //emit PoolAdded(pool_address);\r\n    }\r\n    \r\n    // Used by pools when user redeems\r\n    function pool_burn(address b_address, uint256 b_amount) public onlyPools {\r\n        super._burn(b_address, b_amount);\r\n    }\r\n\r\n    function pool_mint(address m_address, uint256 m_amount) public onlyPools {\r\n        super._mint(m_address, m_amount);\r\n    }\r\n\r\n    function dss_price() public view returns(uint256){\r\n        return 1e6; \r\n    }\r\n\r\n    function get_collateral_ratio() public view returns(uint256){\r\n        return 1e6;\r\n    }\r\n}"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n\t}\n\n\tfunction logUint(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    },
    "contracts/Common/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        uint256 c = a + b;\r\n        if (c < a) return (false, 0);\r\n        return (true, c);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b > a) return (false, 0);\r\n        return (true, a - b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) return (true, 0);\r\n        uint256 c = a * b;\r\n        if (c / a != b) return (false, 0);\r\n        return (true, c);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b == 0) return (false, 0);\r\n        return (true, a / b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b == 0) return (false, 0);\r\n        return (true, a % b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) return 0;\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {trySub}.\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting with custom message when dividing by zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryMod}.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}"
    },
    "contracts/ERC20/ERC20Custom.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.7.6;\r\n\r\nimport \"./IERC20.sol\";\r\nimport \"../Common/Context.sol\";\r\n\r\ncontract ERC20Custom is Context, IERC20 {\r\n    mapping(address => uint256) private _balances;\r\n\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n\r\n    /**\r\n     * @dev Sets the values for {name} and {symbol}.\r\n     *\r\n     * The default value of {decimals} is 18. To select a different value for\r\n     * {decimals} you should overload it.\r\n     *\r\n     * All two of these values are immutable: they can only be set once during\r\n     * construction.\r\n     */\r\n    constructor(string memory name_, string memory symbol_) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view virtual returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public view virtual returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\r\n     * overridden;\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function decimals() public view virtual returns (uint8) {\r\n        return 18;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-totalSupply}.\r\n     */\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-balanceOf}.\r\n     */\r\n    function balanceOf(address account) public view virtual override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\r\n        address owner = _msgSender();\r\n        _transfer(owner, to, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-allowance}.\r\n     */\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-approve}.\r\n     *\r\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\r\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        address owner = _msgSender();\r\n        _approve(owner, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transferFrom}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of {ERC20}.\r\n     *\r\n     * NOTE: Does not update the allowance if the current allowance\r\n     * is the maximum `uint256`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` and `to` cannot be the zero address.\r\n     * - `from` must have a balance of at least `amount`.\r\n     * - the caller must have allowance for ``from``'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) public virtual override returns (bool) {\r\n        address spender = _msgSender();\r\n        _spendAllowance(from, spender, amount);\r\n        _transfer(from, to, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        address owner = _msgSender();\r\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        address owner = _msgSender();\r\n        uint256 currentAllowance = allowance(owner, spender);\r\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\r\n        // unchecked {\r\n        //     _approve(owner, spender, currentAllowance - subtractedValue);\r\n        // }\r\n        _approve(owner, spender, currentAllowance - subtractedValue);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves `amount` of tokens from `from` to `to`.\r\n     *\r\n     * This internal function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `from` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(from != address(0), \"ERC20: transfer from the zero address\");\r\n        require(to != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(from, to, amount);\r\n\r\n        uint256 fromBalance = _balances[from];\r\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\r\n        // unchecked {\r\n        //     _balances[from] = fromBalance - amount;\r\n        //     // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\r\n        //     // decrementing then incrementing.\r\n        //     _balances[to] += amount;\r\n        // }\r\n        _balances[from] = fromBalance - amount;\r\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\r\n            // decrementing then incrementing.\r\n            _balances[to] += amount;\r\n\r\n        emit Transfer(from, to, amount);\r\n\r\n        _afterTokenTransfer(from, to, amount);\r\n    }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a {Transfer} event with `from` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     */\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _beforeTokenTransfer(address(0), account, amount);\r\n\r\n        _totalSupply += amount;\r\n        // unchecked {\r\n        //     // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\r\n        //     _balances[account] += amount;\r\n        // }\r\n        _balances[account] += amount;\r\n        emit Transfer(address(0), account, amount);\r\n\r\n        _afterTokenTransfer(address(0), account, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a {Transfer} event with `to` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _beforeTokenTransfer(account, address(0), amount);\r\n\r\n        uint256 accountBalance = _balances[account];\r\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\r\n        // unchecked {\r\n        //     _balances[account] = accountBalance - amount;\r\n        //     // Overflow not possible: amount <= accountBalance <= totalSupply.\r\n        //     _totalSupply -= amount;\r\n        // }\r\n        _balances[account] = accountBalance - amount;\r\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\r\n            _totalSupply -= amount;\r\n\r\n        emit Transfer(account, address(0), amount);\r\n\r\n        _afterTokenTransfer(account, address(0), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\r\n     *\r\n     * This internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\r\n     *\r\n     * Does not update the allowance amount in case of infinite allowance.\r\n     * Revert if not enough allowance is available.\r\n     *\r\n     * Might emit an {Approval} event.\r\n     */\r\n    function _spendAllowance(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        uint256 currentAllowance = allowance(owner, spender);\r\n        if (currentAllowance != type(uint256).max) {\r\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\r\n            // unchecked {\r\n            //     _approve(owner, spender, currentAllowance - amount);\r\n            // }\r\n            _approve(owner, spender, currentAllowance - amount);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * will be transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {}\r\n\r\n    /**\r\n     * @dev Hook that is called after any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * has been transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _afterTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {}\r\n}"
    },
    "contracts/Common/AccessControl.sol": {
      "content": "pragma solidity 0.7.6;\r\n\r\nimport \"./IAccessControl.sol\";\r\nimport \"./Context.sol\";\r\nimport \"../utils/Strings.sol\";\r\nimport \"../utils/ERC165.sol\";\r\n\r\n/**\r\n * @dev Contract module that allows children to implement role-based access\r\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\r\n * members except through off-chain means by accessing the contract event logs. Some\r\n * applications may benefit from on-chain enumerability, for those cases see\r\n * {AccessControlEnumerable}.\r\n *\r\n * Roles are referred to by their `bytes32` identifier. These should be exposed\r\n * in the external API and be unique. The best way to achieve this is by\r\n * using `public constant` hash digests:\r\n *\r\n * ```\r\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\r\n * ```\r\n *\r\n * Roles can be used to represent a set of permissions. To restrict access to a\r\n * function call, use {hasRole}:\r\n *\r\n * ```\r\n * function foo() public {\r\n *     require(hasRole(MY_ROLE, msg.sender));\r\n *     ...\r\n * }\r\n * ```\r\n *\r\n * Roles can be granted and revoked dynamically via the {grantRole} and\r\n * {revokeRole} functions. Each role has an associated admin role, and only\r\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\r\n *\r\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\r\n * that only accounts with this role will be able to grant or revoke other\r\n * roles. More complex role relationships can be created by using\r\n * {_setRoleAdmin}.\r\n *\r\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\r\n * grant and revoke this role. Extra precautions should be taken to secure\r\n * accounts that have been granted it.\r\n */\r\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\r\n    struct RoleData {\r\n        mapping(address => bool) members;\r\n        bytes32 adminRole;\r\n    }\r\n\r\n    mapping(bytes32 => RoleData) private _roles;\r\n\r\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\r\n\r\n    /**\r\n     * @dev Modifier that checks that an account has a specific role. Reverts\r\n     * with a standardized message including the required role.\r\n     *\r\n     * The format of the revert reason is given by the following regular expression:\r\n     *\r\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\r\n     *\r\n     * _Available since v4.1._\r\n     */\r\n    modifier onlyRole(bytes32 role) {\r\n        _checkRole(role);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns `true` if `account` has been granted `role`.\r\n     */\r\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\r\n        return _roles[role].members[account];\r\n    }\r\n\r\n    /**\r\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\r\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\r\n     *\r\n     * Format of the revert message is described in {_checkRole}.\r\n     *\r\n     * _Available since v4.6._\r\n     */\r\n    function _checkRole(bytes32 role) internal view virtual {\r\n        _checkRole(role, _msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Revert with a standard message if `account` is missing `role`.\r\n     *\r\n     * The format of the revert reason is given by the following regular expression:\r\n     *\r\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\r\n     */\r\n    function _checkRole(bytes32 role, address account) internal view virtual {\r\n        if (!hasRole(role, account)) {\r\n            revert(\r\n                string(\r\n                    abi.encodePacked(\r\n                        \"AccessControl: account \",\r\n                        Strings.toHexString(account),\r\n                        \" is missing role \",\r\n                        Strings.toHexString(uint256(role), 32)\r\n                    )\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\r\n     * {revokeRole}.\r\n     *\r\n     * To change a role's admin, use {_setRoleAdmin}.\r\n     */\r\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\r\n        return _roles[role].adminRole;\r\n    }\r\n\r\n    /**\r\n     * @dev Grants `role` to `account`.\r\n     *\r\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\r\n     * event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must have ``role``'s admin role.\r\n     *\r\n     * May emit a {RoleGranted} event.\r\n     */\r\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\r\n        _grantRole(role, account);\r\n    }\r\n\r\n    /**\r\n     * @dev Revokes `role` from `account`.\r\n     *\r\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must have ``role``'s admin role.\r\n     *\r\n     * May emit a {RoleRevoked} event.\r\n     */\r\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\r\n        _revokeRole(role, account);\r\n    }\r\n\r\n    /**\r\n     * @dev Revokes `role` from the calling account.\r\n     *\r\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\r\n     * purpose is to provide a mechanism for accounts to lose their privileges\r\n     * if they are compromised (such as when a trusted device is misplaced).\r\n     *\r\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\r\n     * event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must be `account`.\r\n     *\r\n     * May emit a {RoleRevoked} event.\r\n     */\r\n    function renounceRole(bytes32 role, address account) public virtual override {\r\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\r\n\r\n        _revokeRole(role, account);\r\n    }\r\n\r\n    /**\r\n     * @dev Grants `role` to `account`.\r\n     *\r\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\r\n     * event. Note that unlike {grantRole}, this function doesn't perform any\r\n     * checks on the calling account.\r\n     *\r\n     * May emit a {RoleGranted} event.\r\n     *\r\n     * [WARNING]\r\n     * ====\r\n     * This function should only be called from the constructor when setting\r\n     * up the initial roles for the system.\r\n     *\r\n     * Using this function in any other way is effectively circumventing the admin\r\n     * system imposed by {AccessControl}.\r\n     * ====\r\n     *\r\n     * NOTE: This function is deprecated in favor of {_grantRole}.\r\n     */\r\n    function _setupRole(bytes32 role, address account) internal virtual {\r\n        _grantRole(role, account);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `adminRole` as ``role``'s admin role.\r\n     *\r\n     * Emits a {RoleAdminChanged} event.\r\n     */\r\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\r\n        bytes32 previousAdminRole = getRoleAdmin(role);\r\n        _roles[role].adminRole = adminRole;\r\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\r\n    }\r\n\r\n    /**\r\n     * @dev Grants `role` to `account`.\r\n     *\r\n     * Internal function without access restriction.\r\n     *\r\n     * May emit a {RoleGranted} event.\r\n     */\r\n    function _grantRole(bytes32 role, address account) internal virtual {\r\n        if (!hasRole(role, account)) {\r\n            _roles[role].members[account] = true;\r\n            emit RoleGranted(role, account, _msgSender());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Revokes `role` from `account`.\r\n     *\r\n     * Internal function without access restriction.\r\n     *\r\n     * May emit a {RoleRevoked} event.\r\n     */\r\n    function _revokeRole(bytes32 role, address account) internal virtual {\r\n        if (hasRole(role, account)) {\r\n            _roles[role].members[account] = false;\r\n            emit RoleRevoked(role, account, _msgSender());\r\n        }\r\n    }\r\n}"
    },
    "contracts/Common/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\r\n\r\npragma solidity 0.7.6;\r\n\r\nimport \"./Context.sol\";\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor(address creator_address) {\r\n        _transferOwnership(creator_address);\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the sender is not the owner.\r\n     */\r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}"
    },
    "contracts/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity 0.7.6;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}"
    },
    "contracts/Common/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\npragma solidity 0.7.6;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}"
    },
    "contracts/Common/IAccessControl.sol": {
      "content": "pragma solidity 0.7.6;\r\n\r\n/**\r\n * @dev External interface of AccessControl declared to support ERC165 detection.\r\n */\r\ninterface IAccessControl {\r\n    /**\r\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\r\n     *\r\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\r\n     * {RoleAdminChanged} not being emitted signaling this.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\r\n\r\n    /**\r\n     * @dev Emitted when `account` is granted `role`.\r\n     *\r\n     * `sender` is the account that originated the contract call, an admin role\r\n     * bearer except when using {AccessControl-_setupRole}.\r\n     */\r\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\r\n\r\n    /**\r\n     * @dev Emitted when `account` is revoked `role`.\r\n     *\r\n     * `sender` is the account that originated the contract call:\r\n     *   - if using `revokeRole`, it is the admin role bearer\r\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\r\n     */\r\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\r\n\r\n    /**\r\n     * @dev Returns `true` if `account` has been granted `role`.\r\n     */\r\n    function hasRole(bytes32 role, address account) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\r\n     * {revokeRole}.\r\n     *\r\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\r\n     */\r\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\r\n\r\n    /**\r\n     * @dev Grants `role` to `account`.\r\n     *\r\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\r\n     * event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must have ``role``'s admin role.\r\n     */\r\n    function grantRole(bytes32 role, address account) external;\r\n\r\n    /**\r\n     * @dev Revokes `role` from `account`.\r\n     *\r\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must have ``role``'s admin role.\r\n     */\r\n    function revokeRole(bytes32 role, address account) external;\r\n\r\n    /**\r\n     * @dev Revokes `role` from the calling account.\r\n     *\r\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\r\n     * purpose is to provide a mechanism for accounts to lose their privileges\r\n     * if they are compromised (such as when a trusted device is misplaced).\r\n     *\r\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\r\n     * event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must be `account`.\r\n     */\r\n    function renounceRole(bytes32 role, address account) external;\r\n}"
    },
    "contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\r\n\r\npragma solidity 0.7.6;\r\n\r\n/**\r\n * @dev String operations.\r\n */\r\nlibrary Strings {\r\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\r\n    uint8 private constant _ADDRESS_LENGTH = 20;\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\r\n     */\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        // Inspired by OraclizeAPI's implementation - MIT licence\r\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\r\n\r\n        if (value == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        while (value != 0) {\r\n            digits -= 1;\r\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n            value /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\r\n     */\r\n    function toHexString(uint256 value) internal pure returns (string memory) {\r\n        if (value == 0) {\r\n            return \"0x00\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 length = 0;\r\n        while (temp != 0) {\r\n            length++;\r\n            temp >>= 8;\r\n        }\r\n        return toHexString(value, length);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\r\n     */\r\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\r\n        bytes memory buffer = new bytes(2 * length + 2);\r\n        buffer[0] = \"0\";\r\n        buffer[1] = \"x\";\r\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\r\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\r\n            value >>= 4;\r\n        }\r\n        require(value == 0, \"Strings: hex length insufficient\");\r\n        return string(buffer);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\r\n     */\r\n    function toHexString(address addr) internal pure returns (string memory) {\r\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\r\n    }\r\n}"
    },
    "contracts/utils/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\r\n\r\npragma solidity 0.7.6;\r\n\r\nimport \"./IERC165.sol\";\r\n\r\n/**\r\n * @dev Implementation of the {IERC165} interface.\r\n *\r\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\r\n * for the additional interface id that will be supported. For example:\r\n *\r\n * ```solidity\r\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\r\n * }\r\n * ```\r\n *\r\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\r\n */\r\nabstract contract ERC165 is IERC165 {\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n        return interfaceId == type(IERC165).interfaceId;\r\n    }\r\n}"
    },
    "contracts/utils/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\r\n\r\npragma solidity 0.7.6;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}"
    },
    "contracts/staking/stakingpool.sol": {
      "content": "pragma solidity 0.7.6;\r\n\r\nimport \"../stablecoin/DS.sol\"; \r\nimport \"../stablecoin/owned.sol\";\r\nimport \"../stablecoin/TransferHelper.sol\";\r\n\r\nimport \"./stakedDS.sol\";\r\nimport \"../ERC20/ERC20.sol\";\r\nimport \"../Common/SafeMath.sol\";\r\n//import \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\n\r\n\r\ncontract StakingPool is Owned{\r\n\r\n\r\n    using SafeMath for uint256;\r\n\r\n    address ds_address; \r\n    address collateral_address; \r\n    address creator_address; \r\n\r\n    ERC20 private collateral_token;\r\n    DS private DScontract;\r\n    sDS private sDScontract;\r\n\r\n    uint256 missing_decimals; \r\n\r\n   mapping(address=>bool)  userStaked; \r\n   constructor (\r\n        address _ds_address,\r\n        address _collateral_address,\r\n        address _creator_address,\r\n\r\n        address _sDS_address\r\n        \r\n    ) public Owned(_creator_address){\r\n        require(\r\n            (_ds_address != address(0))\r\n            && (_collateral_address != address(0))\r\n            && (_creator_address != address(0))\r\n        , \"Zero address detected\"); \r\n        DScontract = DS(_ds_address);\r\n        sDScontract = sDS(_sDS_address);\r\n        collateral_token = ERC20(_collateral_address); \r\n\r\n        ds_address = _ds_address; \r\n        collateral_address = _collateral_address; \r\n        creator_address = _creator_address; \r\n\r\n    \r\n        missing_decimals = uint(18).sub(collateral_token.decimals());\r\n        \r\n        \r\n    }\r\n\tfunction stake(uint256 amount) public virtual{\r\n\t\tuint256 exchange_rate = get_exchange_rate();\r\n        TransferHelper.safeTransferFrom(address(ds_address), msg.sender, address(sDScontract), amount);\r\n        sDScontract.mint(msg.sender, amount, exchange_rate); \r\n\r\n        userStaked[msg.sender] = true; \r\n\r\n\r\n\t}\r\n\r\n\tfunction withdraw(uint256 amount) public virtual{\r\n\t\tuint256 exchange_rate = get_exchange_rate();\r\n\r\n\t\tsDScontract.burn(msg.sender, amount, exchange_rate);\r\n\r\n\t\tif (sDScontract.balanceOf(msg.sender) == 0){\r\n\t\tuserStaked[msg.sender] = false; \r\n\t\t}\r\n\r\n\r\n\t}\r\n\tfunction get_exchange_rate() private returns(uint256){\r\n\t\treturn 1e6; \r\n\t}\r\n}"
    },
    "contracts/stablecoin/DS.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.7.6;\r\n\r\nimport \"../ERC20/ERC20Custom.sol\";\r\nimport \"../Common/AccessControl.sol\";\r\nimport \"../Common/Ownable.sol\";\r\n\r\ncontract DS is ERC20Custom, AccessControl, Ownable {\r\n    /* ========== STATE VARIABLES ========== */\r\n    \r\n    mapping(address => bool) pools;\r\n    \r\n    address[] public pools_array;\r\n    address public creator_address;\r\n    address timelock_address;\r\n    address public DEFAULT_ADMIN_ADDRESS;\r\n    \r\n    uint256 constant genesis_supply = 1000000e18;\r\n\r\n    \r\n    /* ========== MODIFIERS ========== */\r\n    modifier onlyPools() {\r\n        require(pools[msg.sender] == true, \"Only pools can call this function\");\r\n        _;\r\n    }\r\n\r\n    constructor (\r\n        address _creator_address,\r\n        address _timelock_address\r\n    )  ERC20Custom(\"Debita Stablecoin\",\"DS\") Ownable(_creator_address)\r\n    {\r\n        _mint(_creator_address, genesis_supply);\r\n        creator_address = _creator_address;\r\n        timelock_address = _timelock_address;\r\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\r\n        DEFAULT_ADMIN_ADDRESS = _msgSender();\r\n        _grantRole(DEFAULT_ADMIN_ROLE, _creator_address);\r\n    }\r\n\r\n    function addPool(address pool_address) public onlyOwner {\r\n        require(pool_address != address(0), \"Zero address detected\");\r\n\r\n        require(pools[pool_address] == false, \"Address already exists\");\r\n        pools[pool_address] = true; \r\n        pools_array.push(pool_address);\r\n\r\n        //emit PoolAdded(pool_address);\r\n    }\r\n    \r\n    // Used by pools when user redeems\r\n    function pool_burn(address b_address, uint256 b_amount) public onlyPools {\r\n        super._burn(b_address, b_amount);\r\n    }\r\n\r\n    function pool_mint(address m_address, uint256 m_amount) public onlyPools {\r\n        super._mint(m_address, m_amount);\r\n    }\r\n\r\n    function dss_price() public view returns(uint256){\r\n        return 1e6; \r\n    }\r\n\r\n    function get_collateral_ratio() public view returns(uint256){\r\n        return 1e6;\r\n    }\r\n}"
    },
    "contracts/stablecoin/owned.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity 0.7.6;\r\n\r\n// https://docs.synthetix.io/contracts/Owned\r\ncontract Owned {\r\n    address public owner;\r\n    address public nominatedOwner;\r\n\r\n    constructor (address _owner) public {\r\n        require(_owner != address(0), \"Owner address cannot be 0\");\r\n        owner = _owner;\r\n        emit OwnerChanged(address(0), _owner);\r\n    }\r\n\r\n    function nominateNewOwner(address _owner) external onlyOwner {\r\n        nominatedOwner = _owner;\r\n        emit OwnerNominated(_owner);\r\n    }\r\n\r\n    function acceptOwnership() external {\r\n        require(msg.sender == nominatedOwner, \"You must be nominated before you can accept ownership\");\r\n        emit OwnerChanged(owner, nominatedOwner);\r\n        owner = nominatedOwner;\r\n        nominatedOwner = address(0);\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner, \"Only the contract owner may perform this action\");\r\n        _;\r\n    }\r\n\r\n    event OwnerNominated(address newOwner);\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n}"
    },
    "contracts/stablecoin/TransferHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.7.6;\r\n\r\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\r\nlibrary TransferHelper {\r\n    function safeApprove(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\r\n    }\r\n\r\n    function safeTransfer(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\r\n    }\r\n\r\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\r\n    }\r\n\r\n    function safeTransferETH(address to, uint value) internal {\r\n        (bool success,) = to.call{value:value}(new bytes(0));\r\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\r\n    }\r\n}"
    },
    "contracts/staking/stakedDS.sol": {
      "content": "pragma solidity 0.7.6;\r\n\r\n//import \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\nimport \"../ERC20/ERC20.sol\";\r\nimport \"../stablecoin/owned.sol\";\r\nimport \"../stablecoin/TransferHelper.sol\";\r\nimport \"../Common/SafeMath.sol\";\r\n//import \"../stablecoin/safemath.sol\";\r\n\r\n\r\ncontract sDS is ERC20, Owned {\r\n\r\n  mapping(address => bool) pools;\r\n   using SafeMath for uint256;\r\n\r\n  address[] public pools_array;\r\n  address deployer_address; \r\n  address timelock_address; \r\n  address ds_address; \r\n\r\n\r\n  constructor(string memory _name,\r\n        string memory _symbol,\r\n        address _deployer_address,\r\n        address _timelock_address,\r\n        address _ds_address) ERC20(_name, _symbol) Owned(_deployer_address) {\r\n\r\n    deployer_address = _deployer_address;\r\n    timelock_address = _timelock_address; \r\n    ds_address = _ds_address; \r\n\r\n  }\r\n\r\n  modifier onlyByOwner() {\r\n        require(msg.sender == owner , \"Not the owner, controller, or the governance timelock\");\r\n        _;\r\n    }\r\n  \r\n  modifier onlyPools() {\r\n     require(pools[msg.sender] == true, \"Only pools can call this function\");\r\n      _;\r\n  } \r\n\r\n  function addPool(address pool_address) public onlyByOwner {\r\n      require(pool_address != address(0), \"Zero address detected\");\r\n\r\n      require(pools[pool_address] == false, \"Address already exists\");\r\n      pools[pool_address] = true; \r\n      pools_array.push(pool_address);\r\n\r\n      //emit PoolAdded(pool_address);\r\n  }\r\n\r\n\r\n  function mint(address to, uint256 amount, uint256 exchange_rate) public onlyPools {\r\n  \tuint256 amountScaled = amount.mul(uint(1e6)).div(exchange_rate); //exchange_rate >=1\r\n\r\n    _mint(to, amountScaled);\r\n  }\r\n\r\n  function burn(address account, uint256 amount, uint256 exchange_rate) public onlyPools {\r\n  \tuint256 amountScaled =amount.mul(uint(1e6)).div(exchange_rate);\r\n   _burn(account, amount);\r\n\tTransferHelper.safeTransfer(ds_address, account ,amountScaled); \r\n\r\n  }\r\n\r\n\r\n}"
    },
    "contracts/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)\r\n\r\npragma solidity 0.7.6;\r\n\r\nimport \"./IERC20.sol\";\r\nimport \"./IERC20Metadata.sol\";\r\nimport \"../Common/Context.sol\";\r\n\r\n\r\n/**\r\n * @dev Implementation of the {IERC20} interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using {_mint}.\r\n * For a generic mechanism see {ERC20PresetMinterPauser}.\r\n *\r\n * TIP: For a detailed writeup see our guide\r\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\r\n * to implement supply mechanisms].\r\n *\r\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\r\n * instead returning `false` on failure. This behavior is nonetheless\r\n * conventional and does not conflict with the expectations of ERC20\r\n * applications.\r\n *\r\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn't required by the specification.\r\n *\r\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See {IERC20-approve}.\r\n */\r\ncontract ERC20 is Context, IERC20, IERC20Metadata {\r\n    mapping(address => uint256) private _balances;\r\n\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n\r\n    /**\r\n     * @dev Sets the values for {name} and {symbol}.\r\n     *\r\n     * The default value of {decimals} is 18. To select a different value for\r\n     * {decimals} you should overload it.\r\n     *\r\n     * All two of these values are immutable: they can only be set once during\r\n     * construction.\r\n     */\r\n    constructor(string memory name_, string memory symbol_) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\r\n     * overridden;\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function decimals() public view virtual override returns (uint8) {\r\n        return 18;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-totalSupply}.\r\n     */\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-balanceOf}.\r\n     */\r\n    function balanceOf(address account) public view virtual override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\r\n        address owner = _msgSender();\r\n        _transfer(owner, to, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-allowance}.\r\n     */\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-approve}.\r\n     *\r\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\r\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        address owner = _msgSender();\r\n        _approve(owner, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transferFrom}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of {ERC20}.\r\n     *\r\n     * NOTE: Does not update the allowance if the current allowance\r\n     * is the maximum `uint256`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` and `to` cannot be the zero address.\r\n     * - `from` must have a balance of at least `amount`.\r\n     * - the caller must have allowance for ``from``'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) public virtual override returns (bool) {\r\n        address spender = _msgSender();\r\n        _spendAllowance(from, spender, amount);\r\n        _transfer(from, to, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        address owner = _msgSender();\r\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        address owner = _msgSender();\r\n        uint256 currentAllowance = allowance(owner, spender);\r\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\r\n        // unchecked {\r\n        //     _approve(owner, spender, currentAllowance - subtractedValue);\r\n        // }\r\n        _approve(owner, spender, currentAllowance - subtractedValue);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves `amount` of tokens from `from` to `to`.\r\n     *\r\n     * This internal function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `from` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(from != address(0), \"ERC20: transfer from the zero address\");\r\n        require(to != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(from, to, amount);\r\n\r\n        uint256 fromBalance = _balances[from];\r\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\r\n        // unchecked {\r\n        //     _balances[from] = fromBalance - amount;\r\n        //     // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\r\n        //     // decrementing then incrementing.\r\n        //     _balances[to] += amount;\r\n        // }\r\n        _balances[from] = fromBalance - amount;\r\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\r\n            // decrementing then incrementing.\r\n        _balances[to] += amount;\r\n\r\n        emit Transfer(from, to, amount);\r\n\r\n        _afterTokenTransfer(from, to, amount);\r\n    }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a {Transfer} event with `from` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     */\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _beforeTokenTransfer(address(0), account, amount);\r\n\r\n        _totalSupply += amount;\r\n        // unchecked {\r\n        //     // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\r\n        //     _balances[account] += amount;\r\n        // }\r\n        _balances[account] += amount;\r\n        emit Transfer(address(0), account, amount);\r\n\r\n        _afterTokenTransfer(address(0), account, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a {Transfer} event with `to` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _beforeTokenTransfer(account, address(0), amount);\r\n\r\n        uint256 accountBalance = _balances[account];\r\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\r\n        // unchecked {\r\n        //     _balances[account] = accountBalance - amount;\r\n        //     // Overflow not possible: amount <= accountBalance <= totalSupply.\r\n        //     _totalSupply -= amount;\r\n        // }\r\n        _balances[account] = accountBalance - amount;\r\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\r\n            _totalSupply -= amount;\r\n\r\n        emit Transfer(account, address(0), amount);\r\n\r\n        _afterTokenTransfer(account, address(0), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\r\n     *\r\n     * This internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\r\n     *\r\n     * Does not update the allowance amount in case of infinite allowance.\r\n     * Revert if not enough allowance is available.\r\n     *\r\n     * Might emit an {Approval} event.\r\n     */\r\n    function _spendAllowance(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        uint256 currentAllowance = allowance(owner, spender);\r\n        if (currentAllowance != type(uint256).max) {\r\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\r\n            // unchecked {\r\n            //     _approve(owner, spender, currentAllowance - amount);\r\n            // }\r\n            _approve(owner, spender, currentAllowance - amount);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * will be transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {}\r\n\r\n    /**\r\n     * @dev Hook that is called after any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * has been transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _afterTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {}\r\n}"
    },
    "contracts/ERC20/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\r\n\r\npragma solidity 0.7.6;\r\n\r\nimport \"./IERC20.sol\";\r\n\r\n/**\r\n * @dev Interface for the optional metadata functions from the ERC20 standard.\r\n *\r\n * _Available since v4.1._\r\n */\r\ninterface IERC20Metadata is IERC20 {\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the decimals places of the token.\r\n     */\r\n    function decimals() external view returns (uint8);\r\n}"
    },
    "contracts/stablecoin/lendingpool.sol": {
      "content": "pragma solidity 0.7.6;\r\npragma abicoder v2; \r\n\r\nimport \"./owned.sol\";\r\nimport \"./DS.sol\"; \r\nimport \"./DSS.sol\"; \r\nimport \"./TransferHelper.sol\";\r\nimport \"../ERC20/ERC20.sol\";\r\nimport \"../Common/SafeMath.sol\";\r\n//import \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\n\r\nimport \"hardhat/console.sol\";\r\n\r\n//borrowers borrow and repay from this lendingpool \r\ncontract LendingPool is Owned {\r\n\r\n    struct LoanMetadata {\r\n        ERC20 underlyingToken;\r\n        uint256 principal;\r\n        uint256 totalDebt;\r\n        uint256 amountRepaid;\r\n        uint256 duration;\r\n        uint256 repaymentDate;\r\n        address recipient;\r\n    }\r\n\r\n    struct LoanData{\r\n        uint256 _total_borrowed_amount; \r\n        uint256 _accrued_interest; \r\n    }\r\n\r\n\r\n    using SafeMath for uint256;\r\n\r\n    address ds_address; \r\n    address dss_address; \r\n    address collateral_address; \r\n    address creator_address; \r\n    address timelock_address; \r\n\r\n\r\n    uint256 pool_ceiling;\r\n    uint256 bonus_rate;\r\n    uint256 redemption_delay;\r\n    uint256 minting_fee;\r\n    uint256 redemption_fee;\r\n    uint256 buyback_fee;\r\n    uint256 recollat_fee;\r\n    uint256 missing_decimals; \r\n\r\n    uint256 private constant PRICE_PRECISION = 1e6;\r\n\r\n    ERC20 private collateral_token;\r\n\r\n    DS private DScontract;\r\n    DSS private DSScontract;\r\n\r\n    mapping (address => uint256) public redeemDSSBalances;\r\n    mapping (address => uint256) public redeemCollateralBalances;\r\n    uint256 public unclaimedPoolCollateral;\r\n    uint256 public unclaimedPoolDSS;\r\n    mapping (address => uint256) public lastRedeemed;\r\n\r\n    //Borrowers Variable \r\n    mapping(address=>bool) public isBorrower;\r\n    mapping(address=>bool) public isRegistered;\r\n    mapping(address=>uint256) public borrower_allowance; \r\n    mapping(address=>uint256) public borrower_debt; \r\n    mapping(address=>LoanMetadata) public borrower_data; \r\n    uint256 total_borrowed_amount;\r\n    uint256 immutable public proposal_fee;\r\n    uint256 accrued_interest;\r\n\r\n    modifier onlyByOwnGov() {\r\n        require(msg.sender == timelock_address || msg.sender == owner, \"Not owner or timelock\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyBorrower(){\r\n        require(isBorrower[msg.sender], \"Is Not Borrower\"); \r\n        _;\r\n\r\n    }\r\n\r\n    modifier onlyRegistered(address addr) {\r\n        require(isRegistered[addr], \"is not registered\");\r\n        _;\r\n    }\r\n\r\n    constructor (\r\n        address _ds_address,\r\n        address _dss_address,\r\n        address _collateral_address,\r\n        address _creator_address,\r\n        address _timelock_address\r\n       // uint256 _pool_ceiling\r\n        \r\n    ) public Owned(_creator_address){\r\n        require(\r\n            (_ds_address != address(0))\r\n            && (_dss_address != address(0))\r\n            && (_collateral_address != address(0))\r\n            && (_creator_address != address(0))\r\n            && (_timelock_address != address(0))\r\n        , \"Zero address detected\"); \r\n        DScontract = DS(_ds_address);\r\n        DSScontract = DSS(_dss_address); \r\n        ds_address = _ds_address; \r\n        dss_address = _dss_address; \r\n        collateral_address = _collateral_address; \r\n        creator_address = _creator_address; \r\n        timelock_address = _timelock_address; \r\n        collateral_address = _collateral_address; \r\n        collateral_token = ERC20(_collateral_address); \r\n        \r\n        missing_decimals = uint(18).sub(collateral_token.decimals());\r\n        proposal_fee = 1e19;\r\n        \r\n    }\r\n\r\n    function mintDS(uint256 collateral_amount, uint256 DS_out_min) external  {\r\n        uint256 collateral_amount_d18 = collateral_amount * (10 ** missing_decimals);\r\n      \r\n        uint256 DS_amount_18 = collateral_amount_d18; //1to1\r\n        DS_amount_18 = (DS_amount_18.mul(uint(1e6).sub(minting_fee))).div(uint(1e6));\r\n        require(DS_out_min <= DS_amount_18); \r\n\r\n        TransferHelper.safeTransferFrom(address(collateral_token), msg.sender, address(this), collateral_amount);\r\n        DScontract.pool_mint(msg.sender, DS_amount_18);\r\n        \r\n    }\r\n\r\n\r\n    function redeemDS(uint256 DS_amount, uint256 DSS_out_min, uint256 COLLATERAL_out_min) external {\r\n        uint256 dss_price = DScontract.dss_price();\r\n        uint256 collateral_ratio = DScontract.get_collateral_ratio(); \r\n        uint256 DS_amount_18 = DS_amount.mul(10**missing_decimals);\r\n\r\n        uint256 DS_amount_post_fee = (DS_amount.mul(uint(1e6).sub(redemption_fee))).div(uint(1e6)); \r\n        uint256 dss_dollar_value = DS_amount_post_fee.sub(DS_amount_post_fee.mul(collateral_ratio).div(PRICE_PRECISION)); \r\n        uint256 dss_amount = dss_dollar_value.mul(PRICE_PRECISION).div(dss_price); \r\n\r\n        uint256 DS_amount_precision = DS_amount_post_fee;\r\n        uint256 collateral_dollar_value = DS_amount_precision.mul(collateral_ratio).div(PRICE_PRECISION);\r\n        uint256 collateral_amount = collateral_dollar_value;//.mul(10**missing_decimals); //for now assume collateral is stable \r\n\r\n        redeemCollateralBalances[msg.sender] = redeemCollateralBalances[msg.sender].add(collateral_amount);\r\n        unclaimedPoolCollateral = unclaimedPoolCollateral.add(collateral_amount);\r\n\r\n        redeemDSSBalances[msg.sender] = redeemDSSBalances[msg.sender].add(dss_amount);\r\n        unclaimedPoolDSS = unclaimedPoolDSS.add(dss_amount);\r\n\r\n        lastRedeemed[msg.sender] = block.number; \r\n        DScontract.pool_burn(msg.sender, DS_amount_18);\r\n        DSScontract.pool_mint(address(this), dss_amount);\r\n\r\n\r\n\r\n    }\r\n\r\n    function collectRedemption(uint256 col_idx) external returns (uint256 dss_amount, uint256 collateral_amount) {\r\n        // require(redeemPaused[col_idx] == false, \"Redeeming is paused\");\r\n        // require((lastRedeemed[msg.sender].add(redemption_delay)) <= block.number, \"Too soon\");\r\n        bool sendDSS = false; \r\n        bool sendCollateral = false; \r\n\r\n        if (redeemDSSBalances[msg.sender]>0){\r\n            dss_amount = redeemDSSBalances[msg.sender]; \r\n            redeemDSSBalances[msg.sender] = 0; \r\n            unclaimedPoolDSS = unclaimedPoolDSS.sub(dss_amount); \r\n            sendDSS = true;\r\n        }\r\n\r\n        if (redeemCollateralBalances[msg.sender]>0){\r\n            collateral_amount = redeemCollateralBalances[msg.sender]; \r\n            redeemCollateralBalances[msg.sender] = 0; \r\n            unclaimedPoolCollateral = unclaimedPoolCollateral.sub(collateral_amount);\r\n            sendCollateral = true;\r\n        }\r\n\r\n        if (sendDSS){\r\n            TransferHelper.safeTransfer(address(DSScontract), msg.sender, dss_amount);\r\n        }\r\n\r\n        if (sendCollateral){\r\n            TransferHelper.safeTransfer(collateral_address, msg.sender, collateral_amount);\r\n\r\n        }\r\n\r\n    }\r\n    function setPoolParameters(uint256 new_ceiling, uint256 new_bonus_rate, uint256 new_redemption_delay, uint256 new_mint_fee, uint256 new_redeem_fee, uint256 new_buyback_fee, uint256 new_recollat_fee) external onlyByOwnGov {\r\n        pool_ceiling = new_ceiling;\r\n        bonus_rate = new_bonus_rate;\r\n        redemption_delay = new_redemption_delay;\r\n        minting_fee = new_mint_fee;\r\n        redemption_fee = new_redeem_fee;\r\n        buyback_fee = new_buyback_fee;\r\n        recollat_fee = new_recollat_fee;\r\n\r\n        //emit PoolParametersSet(new_ceiling, new_bonus_rate, new_redemption_delay, new_mint_fee, new_redeem_fee, new_buyback_fee, new_recollat_fee);\r\n    }\r\n\r\n\r\n\r\n    //Borrowing and Repaying \r\n\r\n    //Approved Borrower is added by owner or governance \r\n    function addBorrower(address _recipient, uint256 _principal, \r\n        uint256 _totalDebt, uint256 _duration, ERC20 _underlyingToken) public onlyByOwnGov {\r\n        require(!isBorrower[_recipient], \"Already Approved Borrower\"); \r\n        isBorrower[_recipient] = true;\r\n        borrower_allowance[_recipient] = _principal;\r\n\r\n        borrower_data[_recipient] = LoanMetadata(\r\n            _underlyingToken,\r\n            _principal,\r\n            _totalDebt,\r\n            0,\r\n            _duration,\r\n            _duration + block.timestamp,\r\n            _recipient\r\n        );\r\n    }\r\n\r\n    function approveBorrower(address _recipient) public onlyByOwnGov onlyRegistered(_recipient) {\r\n        require(!isBorrower[_recipient], \"Already Approved Borrower\"); \r\n        isBorrower[_recipient] = true;\r\n    }\r\n\r\n    function registerBorrower() external {\r\n        require(!isRegistered[msg.sender], \"already paid proposal fee\");\r\n        TransferHelper.safeTransferFrom(address(collateral_token), msg.sender,address(this), proposal_fee);\r\n        isRegistered[msg.sender] = true;\r\n    }\r\n\r\n    function submitProposal (\r\n        address _recipient, \r\n        uint256 _principal, \r\n        uint256 _totalDebt, \r\n        uint256 _duration, \r\n        ERC20 _underlyingToken\r\n    ) public onlyRegistered(_recipient) {\r\n        require(!isBorrower[_recipient], \"Already Approved Borrower\");\r\n        require(_recipient != address(0));\r\n        borrower_data[_recipient] = LoanMetadata(\r\n            _underlyingToken,\r\n            _principal,\r\n            _totalDebt,\r\n            0,\r\n            _duration,\r\n            _duration + block.timestamp,\r\n            _recipient\r\n        );\r\n    }\r\n\r\n    function getRegistrationStatus(address addr) external view returns (bool) {\r\n        return isRegistered[addr];\r\n    }\r\n\r\n\r\n    function borrow(uint256 amount) external onlyBorrower onlyRegistered(msg.sender) {\r\n        require(amount <= borrower_allowance[msg.sender], \"Exceeds borrow allowance\");\r\n        require(borrower_debt[msg.sender] <= borrower_data[msg.sender].principal, \"Already Borrowed\"); \r\n\r\n        borrower_allowance[msg.sender] = borrower_allowance[msg.sender].sub(amount); \r\n        TransferHelper.safeTransfer(collateral_address, msg.sender, amount);\r\n        borrower_debt[msg.sender] = borrower_debt[msg.sender].add(amount); \r\n        total_borrowed_amount = total_borrowed_amount.add(amount); \r\n\r\n\r\n    }\r\n\r\n    function repay(uint256 repay_principal, uint256 repay_interest) external onlyBorrower {\r\n\r\n        uint256 total_repayment = repay_principal.add(repay_interest);\r\n        TransferHelper.safeTransferFrom(collateral_address, msg.sender, address(this), total_repayment); \r\n\r\n        borrower_debt[msg.sender] = borrower_debt[msg.sender].sub(repay_principal); \r\n        accrued_interest.add(repay_interest);\r\n        console.log('total_borrowed_amount', total_borrowed_amount);\r\n        total_borrowed_amount = total_borrowed_amount.sub(repay_principal);\r\n\r\n        if (borrower_debt[msg.sender]==0){\r\n            isBorrower[msg.sender] = false; \r\n            delete borrower_data[msg.sender]; \r\n\r\n        }\r\n    }\r\n\r\n\r\n    function getBorrowerData(address borrower_address) public view returns (LoanMetadata memory)  {\r\n        return borrower_data[borrower_address]; \r\n\r\n    }\r\n\r\n    function _isBorrower(address borrower_address) public view returns(bool){ // solidity automatically creates getter.\r\n        return isBorrower[borrower_address]; \r\n    }\r\n\r\n    function get_loan_data() public view returns(LoanData memory){\r\n        LoanData memory loandata = LoanData({\r\n            _total_borrowed_amount: total_borrowed_amount, \r\n            _accrued_interest : accrued_interest\r\n            });\r\n        return loandata; \r\n    }\r\n\r\n\r\n}"
    },
    "contracts/libraries/EvenTheOdds.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.7.6;\r\npragma abicoder v2;\r\n\r\nimport \"../balancer/BPool.sol\";\r\nimport \"../turbo/AbstractMarketFactoryV3.sol\";\r\nimport \"hardhat/console.sol\";\r\n\r\ncontract EvenTheOdds is BNum {\r\n    using SafeMathUint256 for uint256;\r\n\r\n    uint256 private constant MAX_UINT = 2**256 - 1;\r\n\r\n    function bringTokenBalanceToMatchOtherToken(\r\n        AbstractMarketFactoryV3 _marketFactory,\r\n        uint256 _marketId,\r\n        BPool _bPool,\r\n        uint256 _maxOutcome,\r\n        uint256 _maxCollateralIn\r\n    ) public returns (uint256 _collateralOut, uint256[] memory _balancesOut) {\r\n        IERC20 _collateral = _marketFactory.collateral();\r\n\r\n        // Will send remaining back.\r\n        _collateral.transferFrom(msg.sender, address(this), _maxCollateralIn);\r\n        _collateral.approve(address(_marketFactory), _maxCollateralIn);\r\n\r\n        AbstractMarketFactoryV3.Market memory _market = _marketFactory.getMarket(_marketId);\r\n\r\n        uint256 _sets = _marketFactory.calcShares(_maxCollateralIn);\r\n        _marketFactory.mintShares(_marketId, _sets, address(this));\r\n\r\n        uint256 _poolAmountOut = 0;\r\n        uint256 _targetBalance = _bPool.getBalance(address(_market.shareTokens[_maxOutcome]));\r\n        for (uint256 i = 0; i < _market.shareTokens.length; i++) {\r\n            if (i == _maxOutcome) continue;\r\n\r\n            OwnedERC20 _token = _market.shareTokens[i];\r\n            address _tokenAddress = address(_token);\r\n            uint256 _amountToAdd = _targetBalance.sub(_bPool.getBalance(_tokenAddress));\r\n            _token.approve(address(_bPool), _amountToAdd);\r\n\r\n            require(_sets >= _amountToAdd, \"_maxCollateralIn is insufficient\");\r\n\r\n            while (_amountToAdd > 0) {\r\n                // This amount will increase as more of the token is added.\r\n                uint256 _maxAmountAddable = bmul(_bPool.getBalance(_tokenAddress), MAX_IN_RATIO);\r\n                uint256 _amountThisPass = _amountToAdd;\r\n\r\n                if (_amountToAdd >= _maxAmountAddable) {\r\n                    _amountThisPass = _maxAmountAddable;\r\n                }\r\n\r\n                _poolAmountOut += _bPool.joinswapExternAmountIn(_tokenAddress, _amountThisPass, 0);\r\n                _amountToAdd = _amountToAdd.sub(_amountThisPass);\r\n            }\r\n        }\r\n\r\n        uint256[] memory minAmountsOut = new uint256[](_market.shareTokens.length);\r\n        _bPool.exitPool(_poolAmountOut, minAmountsOut);\r\n\r\n        uint256 _setsToSell = MAX_UINT;\r\n        for (uint256 i = 0; i < _market.shareTokens.length; i++) {\r\n            if (_setsToSell > _market.shareTokens[i].balanceOf(address(this))) {\r\n                _setsToSell = _market.shareTokens[i].balanceOf(address(this));\r\n            }\r\n        }\r\n\r\n        // Must be a multiple of share factor.\r\n        _setsToSell = (_setsToSell / _marketFactory.shareFactor()) * _marketFactory.shareFactor();\r\n\r\n        // Send back collateral.\r\n        _collateralOut = _marketFactory.burnShares(_marketId, _setsToSell, msg.sender);\r\n\r\n        // Send back any lingering shares.\r\n        _balancesOut = new uint256[](_market.shareTokens.length);\r\n        for (uint256 i = 0; i < _market.shareTokens.length; i++) {\r\n            _balancesOut[i] = _market.shareTokens[i].balanceOf(address(this));\r\n            _market.shareTokens[i].transfer(msg.sender, _balancesOut[i]);\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/ERC20/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)\r\n\r\npragma solidity 0.7.6;\r\n\r\nimport \"./IERC20.sol\";\r\nimport \"./draft-IERC20Permit.sol\";\r\nimport \"../utils/Address.sol\";\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using Address for address;\r\n\r\n    function safeTransfer(\r\n        IERC20 token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n    function safeApprove(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        require(\r\n            (value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        // unchecked {\r\n        //     uint256 oldAllowance = token.allowance(address(this), spender);\r\n        //     require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\r\n        //     uint256 newAllowance = oldAllowance - value;\r\n        //     _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n        // }\r\n        uint256 oldAllowance = token.allowance(address(this), spender);\r\n        require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\r\n        uint256 newAllowance = oldAllowance - value;\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safePermit(\r\n        IERC20Permit token,\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) internal {\r\n        uint256 nonceBefore = token.nonces(owner);\r\n        token.permit(owner, spender, value, deadline, v, r, s);\r\n        uint256 nonceAfter = token.nonces(owner);\r\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) {\r\n            // Return data is optional\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}"
    },
    "contracts/ERC20/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\r\n\r\npragma solidity 0.7.6;\r\n\r\n/**\r\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\r\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\r\n *\r\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\r\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\r\n * need to send a transaction, and thus is not required to hold Ether at all.\r\n */\r\ninterface IERC20Permit {\r\n    /**\r\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\r\n     * given ``owner``'s signed approval.\r\n     *\r\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\r\n     * ordering also apply here.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `deadline` must be a timestamp in the future.\r\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\r\n     * over the EIP712-formatted function arguments.\r\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\r\n     *\r\n     * For more information on the signature format, see the\r\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\r\n     * section].\r\n     */\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Returns the current nonce for `owner`. This value must be\r\n     * included whenever a signature is generated for {permit}.\r\n     *\r\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\r\n     * prevents a signature from being used multiple times.\r\n     */\r\n    function nonces(address owner) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\r\n     */\r\n    // solhint-disable-next-line func-name-mixedcase\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n}"
    },
    "contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\r\n\r\npragma solidity 0.7.6;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\r\n     *\r\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\r\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\r\n     * constructor.\r\n     * ====\r\n     */\r\n    // function isContract(address account) internal view returns (bool) {\r\n    //     // This method relies on extcodesize/address.code.length, which returns 0\r\n    //     // for contracts in construction, since the code is only stored at the end\r\n    //     // of the constructor execution.\r\n\r\n    //     return account.code.length > 0;\r\n    // }\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain `call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\r\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\r\n     *\r\n     * _Available since v4.8._\r\n     */\r\n    function verifyCallResultFromTarget(\r\n        address target,\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        if (success) {\r\n            if (returndata.length == 0) {\r\n                // only check isContract if the call was successful and the return data is empty\r\n                // otherwise we already know that it was a contract\r\n                require(isContract(target), \"Address: call to non-contract\");\r\n            }\r\n            return returndata;\r\n        } else {\r\n            _revert(returndata, errorMessage);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\r\n     * revert reason or using the provided one.\r\n     *\r\n     * _Available since v4.3._\r\n     */\r\n    function verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            _revert(returndata, errorMessage);\r\n        }\r\n    }\r\n\r\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\r\n        // Look for revert reason and bubble it up if present\r\n        if (returndata.length > 0) {\r\n            // The easiest way to bubble the revert reason is using memory via assembly\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                let returndata_size := mload(returndata)\r\n                revert(add(32, returndata), returndata_size)\r\n            }\r\n        } else {\r\n            revert(errorMessage);\r\n        }\r\n    }\r\n}"
    },
    "contracts/stablecoin/core-storage.sol": {
      "content": "pragma solidity 0.7.6;\r\npragma abicoder v2;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\n\r\ncontract CoreStorage {\r\n    enum LoanTypes {\r\n        AMORTIZED,\r\n        REVOLVING,\r\n        BULLET\r\n    }\r\n\r\n    struct LoanMetadata {\r\n        ERC20 underlyingToken;\r\n        uint256 principal;\r\n        uint256 totalDebt;\r\n        uint256 maturity;\r\n        uint256 amountRepaid;\r\n        uint256 tenor;\r\n        uint256 repaymentDate;\r\n        address recipient;\r\n    }\r\n\r\n    struct LoanData{\r\n        uint256 _total_borrowed_amount; \r\n        uint256 _accrued_interest; \r\n    }\r\n}"
    },
    "contracts/libraries/PlaceholderReputationToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.7.6;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\n\r\n/**\r\n * @title Cash\r\n * @dev Test contract for collateral\r\n */\r\ncontract PlaceholderReputationToken is ERC20 {\r\n    uint8 private _decimals;\r\n\r\n    constructor(\r\n        string memory name_,\r\n        string memory symbol_,\r\n        uint8 decimals_\r\n    ) ERC20(name_, symbol_) {\r\n        _decimals = decimals_;\r\n    }\r\n\r\n    function decimals() public view virtual override(ERC20) returns (uint8) {\r\n        return _decimals;\r\n    }\r\n}\r\n"
    },
    "contracts/libraries/Cash.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.7.6;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\n\r\n/**\r\n * @title Cash\r\n * @dev Test contract for collateral\r\n */\r\ncontract Cash is ERC20 {\r\n    uint8 private _decimals;\r\n\r\n    constructor(\r\n        string memory name_,\r\n        string memory symbol_,\r\n        uint8 decimals_\r\n    ) ERC20(name_, symbol_) {\r\n        _decimals = decimals_;\r\n    }\r\n\r\n    function decimals() public view virtual override(ERC20) returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    function faucet(uint256 _amount) public returns (bool) {\r\n        _mint(msg.sender, _amount);\r\n        return true;\r\n    }\r\n}\r\n"
    },
    "contracts/balancer/BPoolForTesting.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.7.6;\r\n\r\nimport \"./BFactory.sol\";\r\nimport \"../libraries/IERC20Full.sol\";\r\nimport \"../libraries/Cash.sol\";\r\n\r\ncontract BPoolForTesting {\r\n    BFactory private bFactory;\r\n    BPool private bPool;\r\n    uint256 private constant MAX_UINT = 2**256 - 1;\r\n\r\n    constructor(BFactory _bFactory) {\r\n        bFactory = _bFactory;\r\n    }\r\n\r\n    function createBPoolForTesting(\r\n        Cash[] calldata _tokens,\r\n        uint256[] calldata _initialLiquidity,\r\n        uint256[] calldata _weights\r\n    ) external returns (BPool) {\r\n        require(\r\n            _tokens.length == _weights.length && _tokens.length == _initialLiquidity.length,\r\n            \"Tokens, weights and initial liquidity should all have the same length.\"\r\n        );\r\n\r\n        bPool = bFactory.newBPool();\r\n\r\n        for (uint256 i = 0; i < _tokens.length; i++) {\r\n            _tokens[i].approve(address(bPool), MAX_UINT);\r\n            bPool.bind(address(_tokens[i]), _initialLiquidity[i], _weights[i]);\r\n        }\r\n\r\n        bPool.finalize();\r\n\r\n        return bPool;\r\n    }\r\n\r\n    function getBPool() external view returns (BPool) {\r\n        return bPool;\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates",
          "devdoc",
          "userdoc"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}