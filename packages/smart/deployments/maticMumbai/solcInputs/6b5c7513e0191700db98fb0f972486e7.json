{
  "language": "Solidity",
  "sources": {
    "contracts/balancer/BColor.sol": {
      "content": "// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ninterface BColor {\n    function getColor() external view returns (bytes32);\n}\n\ncontract BBronze is BColor {\n    function getColor() external pure override returns (bytes32) {\n        return bytes32(\"BRONZE\");\n    }\n}\n"
    },
    "contracts/balancer/BConst.sol": {
      "content": "// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./BColor.sol\";\n\ncontract BConst is BBronze {\n    uint256 public constant BONE = 10**18;\n\n    uint256 public constant MIN_BOUND_TOKENS = 2;\n    uint256 public constant MAX_BOUND_TOKENS = 8;\n\n    uint256 public constant MIN_FEE = BONE / 10**6;\n    uint256 public constant MAX_FEE = BONE / 10;\n    uint256 public constant EXIT_FEE = 0;\n\n    uint256 public constant MIN_WEIGHT = BONE;\n    uint256 public constant MAX_WEIGHT = BONE * 50;\n    uint256 public constant MAX_TOTAL_WEIGHT = BONE * 50;\n    uint256 public constant MIN_BALANCE = BONE / 10**12;\n\n    uint256 public constant INIT_POOL_SUPPLY = BONE * 100;\n\n    uint256 public constant MIN_BPOW_BASE = 1 wei;\n    uint256 public constant MAX_BPOW_BASE = (2 * BONE) - 1 wei;\n    uint256 public constant BPOW_PRECISION = BONE / 10**10;\n\n    uint256 public constant MAX_IN_RATIO = BONE / 2;\n    uint256 public constant MAX_OUT_RATIO = (BONE / 3) + 1 wei;\n}\n"
    },
    "contracts/balancer/BNum.sol": {
      "content": "// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./BConst.sol\";\n\ncontract BNum is BConst {\n    function btoi(uint256 a) internal pure returns (uint256) {\n        return a / BONE;\n    }\n\n    function bfloor(uint256 a) internal pure returns (uint256) {\n        return btoi(a) * BONE;\n    }\n\n    function badd(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"ERR_ADD_OVERFLOW\");\n        return c;\n    }\n\n    function bsub(uint256 a, uint256 b) internal pure returns (uint256) {\n        (uint256 c, bool flag) = bsubSign(a, b);\n        require(!flag, \"ERR_SUB_UNDERFLOW\");\n        return c;\n    }\n\n    function bsubSign(uint256 a, uint256 b) internal pure returns (uint256, bool) {\n        if (a >= b) {\n            return (a - b, false);\n        } else {\n            return (b - a, true);\n        }\n    }\n\n    function bmul(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c0 = a * b;\n        require(a == 0 || c0 / a == b, \"ERR_MUL_OVERFLOW\");\n        uint256 c1 = c0 + (BONE / 2);\n        require(c1 >= c0, \"ERR_MUL_OVERFLOW\");\n        uint256 c2 = c1 / BONE;\n        return c2;\n    }\n\n    function bdiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"ERR_DIV_ZERO\");\n        uint256 c0 = a * BONE;\n        require(a == 0 || c0 / a == BONE, \"ERR_DIV_INTERNAL\"); // bmul overflow\n        uint256 c1 = c0 + (b / 2);\n        require(c1 >= c0, \"ERR_DIV_INTERNAL\"); //  badd require\n        uint256 c2 = c1 / b;\n        return c2;\n    }\n\n    // DSMath.wpow\n    function bpowi(uint256 a, uint256 n) internal pure returns (uint256) {\n        uint256 z = n % 2 != 0 ? a : BONE;\n\n        for (n /= 2; n != 0; n /= 2) {\n            a = bmul(a, a);\n\n            if (n % 2 != 0) {\n                z = bmul(z, a);\n            }\n        }\n        return z;\n    }\n\n    // Compute b^(e.w) by splitting it into (b^e)*(b^0.w).\n    // Use `bpowi` for `b^e` and `bpowK` for k iterations\n    // of approximation of b^0.w\n    function bpow(uint256 base, uint256 exp) internal pure returns (uint256) {\n        require(base >= MIN_BPOW_BASE, \"ERR_BPOW_BASE_TOO_LOW\");\n        require(base <= MAX_BPOW_BASE, \"ERR_BPOW_BASE_TOO_HIGH\");\n\n        uint256 whole = bfloor(exp);\n        uint256 remain = bsub(exp, whole);\n\n        uint256 wholePow = bpowi(base, btoi(whole));\n\n        if (remain == 0) {\n            return wholePow;\n        }\n\n        uint256 partialResult = bpowApprox(base, remain, BPOW_PRECISION);\n        return bmul(wholePow, partialResult);\n    }\n\n    function bpowApprox(\n        uint256 base,\n        uint256 exp,\n        uint256 precision\n    ) internal pure returns (uint256) {\n        // term 0:\n        uint256 a = exp;\n        (uint256 x, bool xneg) = bsubSign(base, BONE);\n        uint256 term = BONE;\n        uint256 sum = term;\n        bool negative = false;\n\n        // term(k) = numer / denom\n        //         = (product(a - i - 1, i=1-->k) * x^k) / (k!)\n        // each iteration, multiply previous term by (a-(k-1)) * x / k\n        // continue until term is less than precision\n        for (uint256 i = 1; term >= precision; i++) {\n            uint256 bigK = i * BONE;\n            (uint256 c, bool cneg) = bsubSign(a, bsub(bigK, BONE));\n            term = bmul(term, bmul(c, x));\n            term = bdiv(term, bigK);\n            if (term == 0) break;\n\n            if (xneg) negative = !negative;\n            if (cneg) negative = !negative;\n            if (negative) {\n                sum = bsub(sum, term);\n            } else {\n                sum = badd(sum, term);\n            }\n        }\n\n        return sum;\n    }\n}\n"
    },
    "contracts/turbo/AMMFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../balancer/BFactory.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"./AbstractMarketFactoryV3.sol\";\nimport \"../balancer/BNum.sol\";\n\ncontract AMMFactory is BNum {\n    using SafeMath for uint256;\n\n    uint256 private constant MAX_UINT = 2**256 - 1;\n    uint256 private constant MIN_INITIAL_LIQUIDITY = BONE * 100;\n\n    BFactory public bFactory;\n    // MarketFactory => Market => BPool\n    mapping(address => mapping(uint256 => BPool)) public pools;\n    uint256 fee;\n\n    event PoolCreated(\n        address pool,\n        address indexed marketFactory,\n        uint256 indexed marketId,\n        address indexed creator,\n        address lpTokenRecipient\n    );\n    event LiquidityChanged(\n        address indexed marketFactory,\n        uint256 indexed marketId,\n        address indexed user,\n        address recipient,\n        // from the perspective of the user. e.g. collateral is negative when adding liquidity\n        int256 collateral,\n        int256 lpTokens,\n        uint256[] sharesReturned\n    );\n    event SharesSwapped(\n        address indexed marketFactory,\n        uint256 indexed marketId,\n        address indexed user,\n        uint256 outcome,\n        // from the perspective of the user. e.g. collateral is negative when buying\n        int256 collateral,\n        int256 shares,\n        uint256 price\n    );\n\n    constructor(BFactory _bFactory, uint256 _fee) {\n        bFactory = _bFactory;\n        fee = _fee;\n    }\n\n    function createPool(\n        AbstractMarketFactoryV3 _marketFactory,\n        uint256 _marketId,\n        uint256 _initialLiquidity,\n        address _lpTokenRecipient\n    ) public returns (uint256) {\n        require(pools[address(_marketFactory)][_marketId] == BPool(address(0)), \"Pool already created\");\n\n        AbstractMarketFactoryV3.Market memory _market = _marketFactory.getMarket(_marketId);\n\n        uint256 _sets = _marketFactory.calcShares(_initialLiquidity);\n\n        // Comparing to sets because sets are normalized to 10e18.\n        require(_sets >= MIN_INITIAL_LIQUIDITY, \"Initial liquidity must be at least 100 collateral.\");\n\n        //  Turn collateral into shares\n        IERC20Full _collateral = _marketFactory.collateral();\n        require(\n            _collateral.allowance(msg.sender, address(this)) >= _initialLiquidity,\n            \"insufficient collateral allowance for initial liquidity\"\n        );\n\n        _collateral.transferFrom(msg.sender, address(this), _initialLiquidity);\n        _collateral.approve(address(_marketFactory), MAX_UINT);\n\n        _marketFactory.mintShares(_marketId, _sets, address(this));\n\n        // Create pool\n        BPool _pool = bFactory.newBPool();\n\n        // Add each outcome to the pool. Collateral is NOT added.\n        for (uint256 i = 0; i < _market.shareTokens.length; i++) {\n            OwnedERC20 _token = _market.shareTokens[i];\n            _token.approve(address(_pool), MAX_UINT);\n            _pool.bind(address(_token), _sets, _market.initialOdds[i]);\n        }\n\n        // Set the swap fee.\n        _pool.setSwapFee(fee);\n\n        // Finalize pool setup\n        _pool.finalize();\n\n        pools[address(_marketFactory)][_marketId] = _pool;\n\n        // Pass along LP tokens for initial liquidity\n        uint256 _lpTokenBalance = _pool.balanceOf(address(this)) - (BONE / 1000);\n\n        // Burn (BONE / 1000) lp tokens to prevent the bpool from locking up. When all liquidity is removed.\n        _pool.transfer(address(0x0), (BONE / 1000));\n        _pool.transfer(_lpTokenRecipient, _lpTokenBalance);\n\n        uint256[] memory _balances = new uint256[](_market.shareTokens.length);\n        for (uint256 i = 0; i < _market.shareTokens.length; i++) {\n            _balances[i] = 0;\n        }\n\n        emit PoolCreated(address(_pool), address(_marketFactory), _marketId, msg.sender, _lpTokenRecipient);\n        emit LiquidityChanged(\n            address(_marketFactory),\n            _marketId,\n            msg.sender,\n            _lpTokenRecipient,\n            -int256(_initialLiquidity),\n            int256(_lpTokenBalance),\n            _balances\n        );\n\n        return _lpTokenBalance;\n    }\n\n    function addLiquidity(\n        AbstractMarketFactoryV3 _marketFactory,\n        uint256 _marketId,\n        uint256 _collateralIn,\n        uint256 _minLPTokensOut,\n        address _lpTokenRecipient\n    ) public returns (uint256 _poolAmountOut, uint256[] memory _balances) {\n        BPool _pool = pools[address(_marketFactory)][_marketId];\n        require(_pool != BPool(address(0)), \"Pool needs to be created\");\n\n        AbstractMarketFactoryV3.Market memory _market = _marketFactory.getMarket(_marketId);\n\n        //  Turn collateral into shares\n        IERC20Full _collateral = _marketFactory.collateral();\n        _collateral.transferFrom(msg.sender, address(this), _collateralIn);\n        _collateral.approve(address(_marketFactory), MAX_UINT);\n        uint256 _sets = _marketFactory.calcShares(_collateralIn);\n        _marketFactory.mintShares(_marketId, _sets, address(this));\n\n        // Find poolAmountOut\n        _poolAmountOut = MAX_UINT;\n\n        {\n            uint256 _totalSupply = _pool.totalSupply();\n            uint256[] memory _maxAmountsIn = new uint256[](_market.shareTokens.length);\n            for (uint256 i = 0; i < _market.shareTokens.length; i++) {\n                _maxAmountsIn[i] = _sets;\n\n                OwnedERC20 _token = _market.shareTokens[i];\n                uint256 _bPoolTokenBalance = _pool.getBalance(address(_token));\n\n                // This is the result the following when solving for poolAmountOut:\n                // uint256 ratio = bdiv(poolAmountOut, poolTotal);\n                // uint256 tokenAmountIn = bmul(ratio, bal);\n                uint256 _tokenPoolAmountOut =\n                    (((((_sets * BONE) - (BONE / 2)) * _totalSupply) / _bPoolTokenBalance) - (_totalSupply / 2)) / BONE;\n\n                if (_tokenPoolAmountOut < _poolAmountOut) {\n                    _poolAmountOut = _tokenPoolAmountOut;\n                }\n            }\n            _pool.joinPool(_poolAmountOut, _maxAmountsIn);\n        }\n\n        require(_poolAmountOut >= _minLPTokensOut, \"Would not have received enough LP tokens\");\n\n        _pool.transfer(_lpTokenRecipient, _poolAmountOut);\n\n        // Transfer the remaining shares back to _lpTokenRecipient.\n        _balances = new uint256[](_market.shareTokens.length);\n        for (uint256 i = 0; i < _market.shareTokens.length; i++) {\n            OwnedERC20 _token = _market.shareTokens[i];\n            _balances[i] = _token.balanceOf(address(this));\n            if (_balances[i] > 0) {\n                _token.transfer(_lpTokenRecipient, _balances[i]);\n            }\n        }\n\n        emit LiquidityChanged(\n            address(_marketFactory),\n            _marketId,\n            msg.sender,\n            _lpTokenRecipient,\n            -int256(_collateralIn),\n            int256(_poolAmountOut),\n            _balances\n        );\n    }\n\n    function removeLiquidity(\n        AbstractMarketFactoryV3 _marketFactory,\n        uint256 _marketId,\n        uint256 _lpTokensIn,\n        uint256 _minCollateralOut,\n        address _collateralRecipient\n    ) public returns (uint256 _collateralOut, uint256[] memory _balances) {\n        BPool _pool = pools[address(_marketFactory)][_marketId];\n        require(_pool != BPool(address(0)), \"Pool needs to be created\");\n\n        AbstractMarketFactoryV3.Market memory _market = _marketFactory.getMarket(_marketId);\n\n        _pool.transferFrom(msg.sender, address(this), _lpTokensIn);\n\n        uint256[] memory exitPoolEstimate;\n        {\n            uint256[] memory minAmountsOut = new uint256[](_market.shareTokens.length);\n            exitPoolEstimate = _pool.calcExitPool(_lpTokensIn, minAmountsOut);\n            _pool.exitPool(_lpTokensIn, minAmountsOut);\n        }\n\n        // Find the number of sets to sell.\n        uint256 _setsToSell = MAX_UINT;\n        for (uint256 i = 0; i < _market.shareTokens.length; i++) {\n            uint256 _acquiredTokenBalance = exitPoolEstimate[i];\n            if (_acquiredTokenBalance < _setsToSell) _setsToSell = _acquiredTokenBalance;\n        }\n\n        // Must be a multiple of share factor.\n        _setsToSell = (_setsToSell / _marketFactory.shareFactor()) * _marketFactory.shareFactor();\n\n        bool _resolved = _marketFactory.isMarketResolved(_marketId);\n        if (_resolved) {\n            _collateralOut = _marketFactory.claimWinnings(_marketId, _collateralRecipient);\n        } else {\n            _collateralOut = _marketFactory.burnShares(_marketId, _setsToSell, _collateralRecipient);\n        }\n        require(_collateralOut > _minCollateralOut, \"Amount of collateral returned too low.\");\n\n        // Transfer the remaining shares back to _collateralRecipient.\n        _balances = new uint256[](_market.shareTokens.length);\n        for (uint256 i = 0; i < _market.shareTokens.length; i++) {\n            OwnedERC20 _token = _market.shareTokens[i];\n            if (_resolved && _token == _market.winner) continue; // all winning shares claimed when market is resolved\n            _balances[i] = exitPoolEstimate[i] - _setsToSell;\n            if (_balances[i] > 0) {\n                _token.transfer(_collateralRecipient, _balances[i]);\n            }\n        }\n\n        emit LiquidityChanged(\n            address(_marketFactory),\n            _marketId,\n            msg.sender,\n            _collateralRecipient,\n            int256(_collateralOut),\n            -int256(_lpTokensIn),\n            _balances\n        );\n    }\n\n    function buy(\n        AbstractMarketFactoryV3 _marketFactory,\n        uint256 _marketId,\n        uint256 _outcome,\n        uint256 _collateralIn,\n        uint256 _minTokensOut\n    ) external returns (uint256) {\n        BPool _pool = pools[address(_marketFactory)][_marketId];\n        require(_pool != BPool(address(0)), \"Pool needs to be created\");\n\n        AbstractMarketFactoryV3.Market memory _market = _marketFactory.getMarket(_marketId);\n        _marketFactory.logTrade(_marketId, _outcome, _collateralIn); \n\n        IERC20Full _collateral = _marketFactory.collateral();\n        _collateral.transferFrom(msg.sender, address(this), _collateralIn);\n        uint256 _sets = _marketFactory.calcShares(_collateralIn);\n        _marketFactory.mintShares(_marketId, _sets, address(this));\n\n        uint256 _totalDesiredOutcome = _sets;\n        {\n            OwnedERC20 _desiredToken = _market.shareTokens[_outcome];\n\n            for (uint256 i = 0; i < _market.shareTokens.length; i++) {\n                if (i == _outcome) continue;\n                OwnedERC20 _token = _market.shareTokens[i];\n                (uint256 _acquiredToken, ) =\n                    _pool.swapExactAmountIn(address(_token), _sets, address(_desiredToken), 0, MAX_UINT);\n                _totalDesiredOutcome += _acquiredToken;\n            }\n            require(_totalDesiredOutcome >= _minTokensOut, \"Slippage exceeded\");\n\n            _desiredToken.transfer(msg.sender, _totalDesiredOutcome);\n        }\n\n        emit SharesSwapped(\n            address(_marketFactory),\n            _marketId,\n            msg.sender,\n            _outcome,\n            -int256(_collateralIn),\n            int256(_totalDesiredOutcome),\n            bdiv(_sets, _totalDesiredOutcome)\n        );\n\n        return _totalDesiredOutcome;\n    }\n\n    function sellForCollateral(\n        AbstractMarketFactoryV3 _marketFactory,\n        uint256 _marketId,\n        uint256 _outcome,\n        uint256[] memory _shareTokensIn,\n        uint256 _minSetsOut\n    ) external returns (uint256) {\n        BPool _pool = pools[address(_marketFactory)][_marketId];\n        require(_pool != BPool(address(0)), \"Pool needs to be created\");\n        AbstractMarketFactoryV3.Market memory _market = _marketFactory.getMarket(_marketId);\n\n        uint256 _setsOut = MAX_UINT;\n        uint256 _totalUndesiredTokensIn = 0;\n        for (uint256 i = 0; i < _market.shareTokens.length; i++) {\n            _totalUndesiredTokensIn += _shareTokensIn[i];\n        }\n\n        {\n            _market.shareTokens[_outcome].transferFrom(msg.sender, address(this), _totalUndesiredTokensIn);\n            _market.shareTokens[_outcome].approve(address(_pool), MAX_UINT);\n\n            for (uint256 i = 0; i < _market.shareTokens.length; i++) {\n                if (i == _outcome) continue;\n                OwnedERC20 _token = _market.shareTokens[i];\n                (uint256 tokenAmountOut, ) =\n                    _pool.swapExactAmountIn(\n                        address(_market.shareTokens[_outcome]),\n                        _shareTokensIn[i],\n                        address(_token),\n                        0,\n                        MAX_UINT\n                    );\n\n                //Ensure tokenAmountOut is a multiple of shareFactor.\n                tokenAmountOut = (tokenAmountOut / _marketFactory.shareFactor()) * _marketFactory.shareFactor();\n                if (tokenAmountOut < _setsOut) _setsOut = tokenAmountOut;\n            }\n\n            require(_setsOut >= _minSetsOut, \"Minimum sets not available.\");\n            _marketFactory.burnShares(_marketId, _setsOut, msg.sender);\n        }\n\n        // Transfer undesired token balance back.\n        for (uint256 i = 0; i < _market.shareTokens.length; i++) {\n            OwnedERC20 _token = _market.shareTokens[i];\n            uint256 _balance = _token.balanceOf(address(this));\n            if (_balance > 0) {\n                _token.transfer(msg.sender, _balance);\n            }\n        }\n\n        uint256 _collateralOut = _marketFactory.calcCost(_setsOut);\n        emit SharesSwapped(\n            address(_marketFactory),\n            _marketId,\n            msg.sender,\n            _outcome,\n            int256(_collateralOut),\n            -int256(_totalUndesiredTokensIn),\n            bdiv(_setsOut, _totalUndesiredTokensIn)\n        );\n\n        return _collateralOut;\n    }\n\n    // Returns an array of token values for the outcomes of the market, relative to the first outcome.\n    // So the first outcome is 10**18 and all others are higher or lower.\n    // Prices can be derived due to the fact that the total of all outcome shares equals one collateral, possibly with a scaling factor,\n    function tokenRatios(AbstractMarketFactoryV3 _marketFactory, uint256 _marketId)\n        external\n        view\n        returns (uint256[] memory)\n    {\n        BPool _pool = pools[address(_marketFactory)][_marketId];\n        // Pool does not exist. Do not want to revert because multicall.\n        if (_pool == BPool(address(0))) {\n            return new uint256[](0);\n        }\n\n        AbstractMarketFactoryV3.Market memory _market = _marketFactory.getMarket(_marketId);\n        address _basisToken = address(_market.shareTokens[0]);\n        uint256[] memory _ratios = new uint256[](_market.shareTokens.length);\n        _ratios[0] = 10**18;\n        for (uint256 i = 1; i < _market.shareTokens.length; i++) {\n            uint256 _price = _pool.getSpotPrice(_basisToken, address(_market.shareTokens[i]));\n            _ratios[i] = _price;\n        }\n        return _ratios;\n    }\n\n    function getPoolBalances(AbstractMarketFactoryV3 _marketFactory, uint256 _marketId)\n        external\n        view\n        returns (uint256[] memory)\n    {\n        BPool _pool = pools[address(_marketFactory)][_marketId];\n        // Pool does not exist. Do not want to revert because multicall.\n        if (_pool == BPool(address(0))) {\n            return new uint256[](0);\n        }\n\n        address[] memory _tokens = _pool.getCurrentTokens();\n        uint256[] memory _balances = new uint256[](_tokens.length);\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            _balances[i] = _pool.getBalance(_tokens[i]);\n        }\n        return _balances;\n    }\n\n    function getPoolWeights(AbstractMarketFactoryV3 _marketFactory, uint256 _marketId)\n        external\n        view\n        returns (uint256[] memory)\n    {\n        BPool _pool = pools[address(_marketFactory)][_marketId];\n        // Pool does not exist. Do not want to revert because multicall.\n        if (_pool == BPool(address(0))) {\n            return new uint256[](0);\n        }\n\n        address[] memory _tokens = _pool.getCurrentTokens();\n        uint256[] memory _weights = new uint256[](_tokens.length);\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            _weights[i] = _pool.getDenormalizedWeight(_tokens[i]);\n        }\n        return _weights;\n    }\n\n    function getSwapFee(AbstractMarketFactoryV3 _marketFactory, uint256 _marketId) external view returns (uint256) {\n        BPool _pool = pools[address(_marketFactory)][_marketId];\n        return _pool.getSwapFee();\n    }\n\n    function getPoolTokenBalance(\n        AbstractMarketFactoryV3 _marketFactory,\n        uint256 _marketId,\n        address _user\n    ) external view returns (uint256) {\n        BPool _pool = pools[address(_marketFactory)][_marketId];\n        return _pool.balanceOf(_user);\n    }\n\n    function getPool(AbstractMarketFactoryV3 _marketFactory, uint256 _marketId) external view returns (BPool) {\n        return pools[address(_marketFactory)][_marketId];\n    }\n}\n"
    },
    "contracts/balancer/BFactory.sol": {
      "content": "// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is disstributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n// Builds new BPools, logging their addresses and providing `isBPool(address) -> (bool)`\n\nimport \"./BPool.sol\";\n\ncontract BFactory is BBronze {\n    event LOG_NEW_POOL(address indexed caller, address indexed pool);\n\n    event LOG_BLABS(address indexed caller, address indexed blabs);\n\n    mapping(address => bool) private _isBPool;\n\n    function isBPool(address b) external view returns (bool) {\n        return _isBPool[b];\n    }\n\n    function newBPool() external returns (BPool) {\n        BPool bpool = new BPool();\n        _isBPool[address(bpool)] = true;\n        emit LOG_NEW_POOL(msg.sender, address(bpool));\n        bpool.setController(msg.sender);\n        return bpool;\n    }\n\n    address private _blabs;\n\n    constructor() {\n        _blabs = msg.sender;\n    }\n\n    function getBLabs() external view returns (address) {\n        return _blabs;\n    }\n\n    function setBLabs(address b) external {\n        require(msg.sender == _blabs, \"ERR_NOT_BLABS\");\n        emit LOG_BLABS(msg.sender, b);\n        _blabs = b;\n    }\n\n    function collect(BPool pool) external {\n        require(msg.sender == _blabs, \"ERR_NOT_BLABS\");\n        uint256 collected = IERC20Balancer(pool).balanceOf(address(this));\n        bool xfer = pool.transfer(_blabs, collected);\n        require(xfer, \"ERR_ERC20_FAILED\");\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "contracts/turbo/AbstractMarketFactoryV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../libraries/IERC20Full.sol\";\nimport \"../balancer/BPool.sol\";\nimport \"./TurboShareTokenFactory.sol\";\nimport \"./FeePot.sol\";\nimport \"../libraries/Rewardable.sol\";\n\nabstract contract AbstractMarketFactoryV3 is TurboShareTokenFactory, Ownable, Rewardable {\n    using SafeMath for uint256;\n\n    event MarketCreated(uint256 id, string[] names, uint256[] initialOdds);\n    event MarketResolved(uint256 id, address winner, uint256 winnerIndex, string winnerName);\n    event MarketActivated(uint256 id);\n\n    event SharesMinted(uint256 id, uint256 amount, address receiver);\n    event SharesBurned(uint256 id, uint256 amount, address receiver);\n    event WinningsClaimed(\n        uint256 id,\n        address winningOutcome,\n        uint256 winningIndex,\n        string winningName,\n        uint256 amount,\n        uint256 settlementFee,\n        uint256 payout,\n        address indexed receiver\n    );\n\n    IERC20Full public collateral;\n    FeePot public feePot;\n\n    // fees are out of 1e18 and only apply to new markets\n    uint256 public stakerFee;\n    uint256 public settlementFee;\n    uint256 public protocolFee;\n\n    address public protocol; // collects protocol fees\n\n    uint256 public accumulatedProtocolFee = 0;\n    // settlement address => amount of collateral\n    mapping(address => uint256) public accumulatedSettlementFees;\n\n    // How many shares equals one collateral.\n    // Necessary to account for math errors from small numbers in balancer.\n    // shares = collateral / shareFactor\n    // collateral = shares * shareFactor\n    uint256 public shareFactor;\n\n    struct Market {\n        address settlementAddress;\n        OwnedERC20[] shareTokens;\n        OwnedERC20 winner;\n        uint256 winnerIndex;\n        uint256 settlementFee;\n        uint256 protocolFee;\n        uint256 stakerFee;\n        uint256 creationTimestamp;\n        uint256 resolutionTimestamp; // when winner is declared\n        uint256[] initialOdds;\n        bool active; // false if not ready to use or if resolved\n    }\n    Market[] internal markets;\n\n    uint256 private constant MAX_UINT = 2**256 - 1;\n\n    constructor(\n        address _owner,\n        IERC20Full _collateral,\n        uint256 _shareFactor,\n        FeePot _feePot,\n        uint256[3] memory _fees, // staker, settlement, protocol\n        address _protocol\n    ) {\n        owner = _owner; // controls fees for new markets\n        collateral = _collateral;\n        shareFactor = _shareFactor;\n        feePot = _feePot;\n        stakerFee = _fees[0];\n        settlementFee = _fees[1];\n        protocolFee = _fees[2];\n        protocol = _protocol;\n\n        _collateral.approve(address(_feePot), MAX_UINT);\n\n        // First market is always empty so that marketid zero means \"no market\"\n        markets.push(makeEmptyMarket());\n    }\n        \n    mapping(uint256=> mapping(uint256=>uint256)) TradeDetails; //marketid -> (outcome->amount)\n\n    function logTrade(uint256 _marketId, uint256 _outcome, uint256 _collateralIn) external {\n        TradeDetails[_marketId][_outcome] = TradeDetails[_marketId][_outcome] + _collateralIn; \n\n    }\n\n    function getTradeDetails(uint256 _marketId, uint256 _outcome) external view returns(uint256){\n        return TradeDetails[_marketId][_outcome]; \n    }\n    // Returns an empty struct if the market doesn't exist.\n    // Can check market existence before calling this by comparing _id against markets.length.\n    // Can check market existence of the return struct by checking that shareTokens[0] isn't the null address\n    function getMarket(uint256 _id) public view returns (Market memory) {\n        if (_id >= markets.length) {\n            return makeEmptyMarket();\n        } else {\n            return markets[_id];\n        }\n    }\n\n    function marketCount() public view returns (uint256) {\n        return markets.length;\n    }\n\n    // Returns factory-specific details about a market.\n    // function getMarketDetails(uint256 _id) public view returns (MarketDetails memory);\n\n    function mintShares(\n        uint256 _id,\n        uint256 _shareToMint,\n        address _receiver\n    ) public {\n        require(markets.length > _id);\n        require(markets[_id].active);\n\n        uint256 _cost = calcCost(_shareToMint);\n        collateral.transferFrom(msg.sender, address(this), _cost);\n\n        Market memory _market = markets[_id];\n        for (uint256 _i = 0; _i < _market.shareTokens.length; _i++) {\n            _market.shareTokens[_i].trustedMint(_receiver, _shareToMint);\n        }\n\n        emit SharesMinted(_id, _shareToMint, _receiver);\n    }\n\n    function burnShares(\n        uint256 _id,\n        uint256 _sharesToBurn,\n        address _receiver\n    ) public returns (uint256) {\n        require(markets.length > _id);\n        require(markets[_id].active);\n\n        Market memory _market = markets[_id];\n        for (uint256 _i = 0; _i < _market.shareTokens.length; _i++) {\n            // errors if sender doesn't have enough shares\n            _market.shareTokens[_i].trustedBurn(msg.sender, _sharesToBurn);\n        }\n\n        uint256 _payout = calcCost(_sharesToBurn);\n        uint256 _protocolFee = _payout.mul(_market.protocolFee).div(10**18);\n        uint256 _stakerFee = _payout.mul(_market.stakerFee).div(10**18);\n        _payout = _payout.sub(_protocolFee).sub(_stakerFee);\n\n        accumulatedProtocolFee += _protocolFee;\n        collateral.transfer(_receiver, _payout);\n        feePot.depositFees(_stakerFee);\n\n        emit SharesBurned(_id, _sharesToBurn, msg.sender);\n        return _payout;\n    }\n\n    function claimWinnings(uint256 _id, address _receiver) public returns (uint256) {\n        require(isMarketResolved(_id), \"market unresolved\");\n\n        Market memory _market = markets[_id];\n        uint256 _winningShares = _market.winner.trustedBurnAll(msg.sender);\n        _winningShares = (_winningShares / shareFactor) * shareFactor; // remove unusable dust\n\n        uint256 _payout = calcCost(_winningShares); // will fail if there are no winnings to claim\n        uint256 _settlementFee = _payout.mul(_market.settlementFee).div(10**18);\n        _payout = _payout.sub(_settlementFee);\n\n        accumulatedSettlementFees[_market.settlementAddress] += _settlementFee;\n        collateral.transfer(_receiver, _payout);\n\n        uint256 _winningIndex = _market.winnerIndex;\n        string memory _winningName = _market.winner.name();\n\n        emit WinningsClaimed(\n            _id,\n            address(_market.winner),\n            _winningIndex,\n            _winningName,\n            _winningShares,\n            _settlementFee,\n            _payout,\n            _receiver\n        );\n        return _payout;\n    }\n\n    function claimManyWinnings(uint256[] memory _ids, address _receiver) public returns (uint256) {\n        uint256 _totalWinnings = 0;\n        for (uint256 i = 0; i < _ids.length; i++) {\n            _totalWinnings = _totalWinnings.add(claimWinnings(_ids[i], _receiver));\n        }\n        return _totalWinnings;\n    }\n\n    function claimSettlementFees(address _receiver) public returns (uint256) {\n        uint256 _fees = accumulatedSettlementFees[msg.sender];\n        if (_fees > 0) {\n            accumulatedSettlementFees[msg.sender] = 0;\n            collateral.transfer(_receiver, _fees);\n        }\n        return _fees;\n    }\n\n    function claimProtocolFees() public returns (uint256) {\n        require(msg.sender == protocol || msg.sender == address(this));\n        uint256 _fees = accumulatedProtocolFee;\n        if (_fees > 0) {\n            accumulatedProtocolFee = 0;\n            collateral.transfer(protocol, _fees);\n        }\n        return _fees;\n    }\n\n    function setSettlementFee(uint256 _newFee) external onlyOwner {\n        settlementFee = _newFee;\n    }\n\n    function setStakerFee(uint256 _newFee) external onlyOwner {\n        stakerFee = _newFee;\n    }\n\n    function setProtocolFee(uint256 _newFee) external onlyOwner {\n        protocolFee = _newFee;\n    }\n\n    function setProtocol(address _newProtocol, bool _claimFirst) external onlyOwner {\n        if (_claimFirst) {\n            claimProtocolFees();\n        }\n        protocol = _newProtocol;\n    }\n\n    function startMarket(\n        address _settlementAddress,\n        string[] memory _names,\n        uint256[] memory _initialOdds,\n        bool _active\n    ) internal returns (uint256 _marketId) {\n        _marketId = markets.length;\n        markets.push(\n            Market(\n                _settlementAddress,\n                createShareTokens(_names, address(this)),\n                OwnedERC20(address(0)),\n                0,\n                settlementFee,\n                protocolFee,\n                stakerFee,\n                block.timestamp,\n                0,\n                _initialOdds,\n                _active\n            )\n        );\n        emit MarketCreated(_marketId, _names, _initialOdds);\n        if (_active) {\n            emit MarketActivated(_marketId);\n        }\n    }\n\n    function activateMarket(uint256 _marketId) internal {\n        markets[_marketId].active = true;\n        emit MarketActivated(_marketId);\n    }\n\n    function makeEmptyMarket() private pure returns (Market memory) {\n        OwnedERC20[] memory _tokens = new OwnedERC20[](0);\n        uint256[] memory _initialOdds = new uint256[](0);\n        return Market(address(0), _tokens, OwnedERC20(address(0)), 0, 0, 0, 0, 0, 0, _initialOdds, false);\n    }\n\n    function endMarket(uint256 _marketId, uint256 _winningOutcome) internal {\n        Market storage _market = markets[_marketId];\n        OwnedERC20 _winner = _market.shareTokens[_winningOutcome];\n\n        _market.winner = _winner;\n        _market.active = false;\n        _market.winnerIndex = _winningOutcome;\n        _market.resolutionTimestamp = block.timestamp;\n        string memory _outcomeName = _winner.name();\n        emit MarketResolved(_marketId, address(_winner), _winningOutcome, _outcomeName);\n    }\n\n    function isMarketResolved(uint256 _id) public view returns (bool) {\n        Market memory _market = markets[_id];\n        return _market.winner != OwnedERC20(address(0));\n    }\n\n    // shares => collateral\n    // Shares must be both greater than (or equal to) and divisible by shareFactor.\n    function calcCost(uint256 _shares) public view returns (uint256) {\n        require(_shares >= shareFactor && _shares % shareFactor == 0);\n        return _shares / shareFactor;\n    }\n\n    // collateral => shares\n    function calcShares(uint256 _collateralIn) public view returns (uint256) {\n        return _collateralIn * shareFactor;\n    }\n\n    function onTransferOwnership(address, address) internal override {}\n}\n"
    },
    "contracts/balancer/BPool.sol": {
      "content": "// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./BToken.sol\";\nimport \"./BMath.sol\";\n\ncontract BPool is BBronze, BToken, BMath {\n    struct Record {\n        bool bound; // is token bound to pool\n        uint256 index; // private\n        uint256 denorm; // denormalized weight\n        uint256 balance;\n    }\n\n    event LOG_SWAP(\n        address indexed caller,\n        address indexed tokenIn,\n        address indexed tokenOut,\n        uint256 tokenAmountIn,\n        uint256 tokenAmountOut\n    );\n\n    event LOG_JOIN(address indexed caller, address indexed tokenIn, uint256 tokenAmountIn);\n\n    event LOG_EXIT(address indexed caller, address indexed tokenOut, uint256 tokenAmountOut);\n\n    event LOG_CALL(bytes4 indexed sig, address indexed caller, bytes data) anonymous;\n\n    modifier _logs_() {\n        emit LOG_CALL(msg.sig, msg.sender, msg.data);\n        _;\n    }\n\n    modifier _lock_() {\n        require(!_mutex, \"ERR_REENTRY\");\n        _mutex = true;\n        _;\n        _mutex = false;\n    }\n\n    modifier _viewlock_() {\n        require(!_mutex, \"ERR_REENTRY\");\n        _;\n    }\n\n    bool private _mutex;\n\n    address private _factory; // BFactory address to push token exitFee to\n    address private _controller; // has CONTROL role\n    bool private _publicSwap; // true if PUBLIC can call SWAP functions\n\n    // `setSwapFee` and `finalize` require CONTROL\n    // `finalize` sets `PUBLIC can SWAP`, `PUBLIC can JOIN`\n    uint256 private _swapFee;\n    bool private _finalized;\n\n    address[] private _tokens;\n    mapping(address => Record) private _records;\n    uint256 private _totalWeight;\n\n    constructor() {\n        _controller = msg.sender;\n        _factory = msg.sender;\n        _swapFee = MIN_FEE;\n        _publicSwap = false;\n        _finalized = false;\n    }\n\n    function isPublicSwap() external view returns (bool) {\n        return _publicSwap;\n    }\n\n    function isFinalized() external view returns (bool) {\n        return _finalized;\n    }\n\n    function isBound(address t) external view returns (bool) {\n        return _records[t].bound;\n    }\n\n    function getNumTokens() external view returns (uint256) {\n        return _tokens.length;\n    }\n\n    function getCurrentTokens() external view _viewlock_ returns (address[] memory tokens) {\n        return _tokens;\n    }\n\n    function getFinalTokens() external view _viewlock_ returns (address[] memory tokens) {\n        require(_finalized, \"ERR_NOT_FINALIZED\");\n        return _tokens;\n    }\n\n    function getDenormalizedWeight(address token) external view _viewlock_ returns (uint256) {\n        require(_records[token].bound, \"ERR_NOT_BOUND\");\n        return _records[token].denorm;\n    }\n\n    function getTotalDenormalizedWeight() external view _viewlock_ returns (uint256) {\n        return _totalWeight;\n    }\n\n    function getNormalizedWeight(address token) external view _viewlock_ returns (uint256) {\n        require(_records[token].bound, \"ERR_NOT_BOUND\");\n        uint256 denorm = _records[token].denorm;\n        return bdiv(denorm, _totalWeight);\n    }\n\n    function getBalance(address token) external view _viewlock_ returns (uint256) {\n        require(_records[token].bound, \"ERR_NOT_BOUND\");\n        return _records[token].balance;\n    }\n\n    function getSwapFee() external view _viewlock_ returns (uint256) {\n        return _swapFee;\n    }\n\n    function getController() external view _viewlock_ returns (address) {\n        return _controller;\n    }\n\n    function setSwapFee(uint256 swapFee) external _logs_ _lock_ {\n        require(!_finalized, \"ERR_IS_FINALIZED\");\n        require(msg.sender == _controller, \"ERR_NOT_CONTROLLER\");\n        require(swapFee >= MIN_FEE, \"ERR_MIN_FEE\");\n        require(swapFee <= MAX_FEE, \"ERR_MAX_FEE\");\n        _swapFee = swapFee;\n    }\n\n    function setController(address manager) external _logs_ _lock_ {\n        require(msg.sender == _controller, \"ERR_NOT_CONTROLLER\");\n        _controller = manager;\n    }\n\n    function setPublicSwap(bool public_) external _logs_ _lock_ {\n        require(!_finalized, \"ERR_IS_FINALIZED\");\n        require(msg.sender == _controller, \"ERR_NOT_CONTROLLER\");\n        _publicSwap = public_;\n    }\n\n    function finalize() external _logs_ _lock_ {\n        require(msg.sender == _controller, \"ERR_NOT_CONTROLLER\");\n        require(!_finalized, \"ERR_IS_FINALIZED\");\n        require(_tokens.length >= MIN_BOUND_TOKENS, \"ERR_MIN_TOKENS\");\n\n        _finalized = true;\n        _publicSwap = true;\n\n        _mintPoolShare(INIT_POOL_SUPPLY);\n        _pushPoolShare(msg.sender, INIT_POOL_SUPPLY);\n    }\n\n    function bind(\n        address token,\n        uint256 balance,\n        uint256 denorm\n    )\n        external\n        _logs_ // _lock_  Bind does not lock because it jumps to `rebind`, which does\n    {\n        require(msg.sender == _controller, \"ERR_NOT_CONTROLLER\");\n        require(!_records[token].bound, \"ERR_IS_BOUND\");\n        require(!_finalized, \"ERR_IS_FINALIZED\");\n\n        require(_tokens.length < MAX_BOUND_TOKENS, \"ERR_MAX_TOKENS\");\n\n        _records[token] = Record({\n            bound: true,\n            index: _tokens.length,\n            denorm: 0, // balance and denorm will be validated\n            balance: 0 // and set by `rebind`\n        });\n        _tokens.push(token);\n        rebind(token, balance, denorm);\n    }\n\n    function rebind(\n        address token,\n        uint256 balance,\n        uint256 denorm\n    ) public _logs_ _lock_ {\n        require(msg.sender == _controller, \"ERR_NOT_CONTROLLER\");\n        require(_records[token].bound, \"ERR_NOT_BOUND\");\n        require(!_finalized, \"ERR_IS_FINALIZED\");\n\n        require(denorm >= MIN_WEIGHT, \"ERR_MIN_WEIGHT\");\n        require(denorm <= MAX_WEIGHT, \"ERR_MAX_WEIGHT\");\n        require(balance >= MIN_BALANCE, \"ERR_MIN_BALANCE\");\n\n        // Adjust the denorm and totalWeight\n        uint256 oldWeight = _records[token].denorm;\n        if (denorm > oldWeight) {\n            _totalWeight = badd(_totalWeight, bsub(denorm, oldWeight));\n            require(_totalWeight <= MAX_TOTAL_WEIGHT, \"ERR_MAX_TOTAL_WEIGHT\");\n        } else if (denorm < oldWeight) {\n            _totalWeight = bsub(_totalWeight, bsub(oldWeight, denorm));\n        }\n        _records[token].denorm = denorm;\n\n        // Adjust the balance record and actual token balance\n        uint256 oldBalance = _records[token].balance;\n        _records[token].balance = balance;\n        if (balance > oldBalance) {\n            _pullUnderlying(token, msg.sender, bsub(balance, oldBalance));\n        } else if (balance < oldBalance) {\n            // In this case liquidity is being withdrawn, so charge EXIT_FEE\n            uint256 tokenBalanceWithdrawn = bsub(oldBalance, balance);\n            uint256 tokenExitFee = bmul(tokenBalanceWithdrawn, EXIT_FEE);\n            _pushUnderlying(token, msg.sender, bsub(tokenBalanceWithdrawn, tokenExitFee));\n            _pushUnderlying(token, _factory, tokenExitFee);\n        }\n    }\n\n    function unbind(address token) external _logs_ _lock_ {\n        require(msg.sender == _controller, \"ERR_NOT_CONTROLLER\");\n        require(_records[token].bound, \"ERR_NOT_BOUND\");\n        require(!_finalized, \"ERR_IS_FINALIZED\");\n\n        uint256 tokenBalance = _records[token].balance;\n        uint256 tokenExitFee = bmul(tokenBalance, EXIT_FEE);\n\n        _totalWeight = bsub(_totalWeight, _records[token].denorm);\n\n        // Swap the token-to-unbind with the last token,\n        // then delete the last token\n        uint256 index = _records[token].index;\n        uint256 last = _tokens.length - 1;\n        _tokens[index] = _tokens[last];\n        _records[_tokens[index]].index = index;\n        _tokens.pop();\n        _records[token] = Record({bound: false, index: 0, denorm: 0, balance: 0});\n\n        _pushUnderlying(token, msg.sender, bsub(tokenBalance, tokenExitFee));\n        _pushUnderlying(token, _factory, tokenExitFee);\n    }\n\n    // Absorb any tokens that have been sent to this contract into the pool\n    function gulp(address token) external _logs_ _lock_ {\n        require(_records[token].bound, \"ERR_NOT_BOUND\");\n        _records[token].balance = IERC20Balancer(token).balanceOf(address(this));\n    }\n\n    function getSpotPrice(address tokenIn, address tokenOut) external view _viewlock_ returns (uint256 spotPrice) {\n        require(_records[tokenIn].bound, \"ERR_NOT_BOUND\");\n        require(_records[tokenOut].bound, \"ERR_NOT_BOUND\");\n        Record storage inRecord = _records[tokenIn];\n        Record storage outRecord = _records[tokenOut];\n        return calcSpotPrice(inRecord.balance, inRecord.denorm, outRecord.balance, outRecord.denorm, _swapFee);\n    }\n\n    function getSpotPriceSansFee(address tokenIn, address tokenOut)\n        external\n        view\n        _viewlock_\n        returns (uint256 spotPrice)\n    {\n        require(_records[tokenIn].bound, \"ERR_NOT_BOUND\");\n        require(_records[tokenOut].bound, \"ERR_NOT_BOUND\");\n        Record storage inRecord = _records[tokenIn];\n        Record storage outRecord = _records[tokenOut];\n        return calcSpotPrice(inRecord.balance, inRecord.denorm, outRecord.balance, outRecord.denorm, 0);\n    }\n\n    function joinPool(uint256 poolAmountOut, uint256[] calldata maxAmountsIn) external _logs_ _lock_ {\n        require(_finalized, \"ERR_NOT_FINALIZED\");\n\n        uint256 poolTotal = totalSupply();\n        uint256 ratio = bdiv(poolAmountOut, poolTotal);\n        require(ratio != 0, \"ERR_MATH_APPROX\");\n\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            address t = _tokens[i];\n            uint256 bal = _records[t].balance;\n            uint256 tokenAmountIn = bmul(ratio, bal);\n            require(tokenAmountIn != 0, \"ERR_MATH_APPROX\");\n            require(tokenAmountIn <= maxAmountsIn[i], \"ERR_LIMIT_IN\");\n            _records[t].balance = badd(_records[t].balance, tokenAmountIn);\n            emit LOG_JOIN(msg.sender, t, tokenAmountIn);\n            _pullUnderlying(t, msg.sender, tokenAmountIn);\n        }\n        _mintPoolShare(poolAmountOut);\n        _pushPoolShare(msg.sender, poolAmountOut);\n    }\n\n    function exitPool(uint256 poolAmountIn, uint256[] calldata minAmountsOut) external _logs_ _lock_ {\n        require(_finalized, \"ERR_NOT_FINALIZED\");\n\n        uint256 poolTotal = totalSupply();\n        uint256 exitFee = bmul(poolAmountIn, EXIT_FEE);\n        uint256 pAiAfterExitFee = bsub(poolAmountIn, exitFee);\n        uint256 ratio = bdiv(pAiAfterExitFee, poolTotal);\n        require(ratio != 0, \"ERR_MATH_APPROX\");\n\n        _pullPoolShare(msg.sender, poolAmountIn);\n        _pushPoolShare(_factory, exitFee);\n        _burnPoolShare(pAiAfterExitFee);\n\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            address t = _tokens[i];\n            uint256 bal = _records[t].balance;\n            uint256 tokenAmountOut = bmul(ratio, bal);\n            require(tokenAmountOut != 0, \"ERR_MATH_APPROX\");\n            require(tokenAmountOut >= minAmountsOut[i], \"ERR_LIMIT_OUT\");\n            _records[t].balance = bsub(_records[t].balance, tokenAmountOut);\n            emit LOG_EXIT(msg.sender, t, tokenAmountOut);\n            _pushUnderlying(t, msg.sender, tokenAmountOut);\n        }\n    }\n\n    function calcExitPool(uint256 poolAmountIn, uint256[] calldata minAmountsOut)\n        external\n        view\n        returns (uint256[] memory)\n    {\n        require(_finalized, \"ERR_NOT_FINALIZED\");\n\n        uint256 poolTotal = totalSupply();\n        uint256 exitFee = bmul(poolAmountIn, EXIT_FEE);\n        uint256 pAiAfterExitFee = bsub(poolAmountIn, exitFee);\n        uint256 ratio = bdiv(pAiAfterExitFee, poolTotal);\n\n        uint256[] memory _amounts = new uint256[](_tokens.length * 2);\n\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            address t = _tokens[i];\n            uint256 bal = _records[t].balance;\n\n            _amounts[i] = bmul(ratio, bal);\n            _amounts[_tokens.length + i] = minAmountsOut[i];\n            require(_amounts[i] >= minAmountsOut[i], \"ERR_LIMIT_OUT\");\n        }\n\n        return _amounts;\n    }\n\n    function swapExactAmountIn(\n        address tokenIn,\n        uint256 tokenAmountIn,\n        address tokenOut,\n        uint256 minAmountOut,\n        uint256 maxPrice\n    ) external _logs_ _lock_ returns (uint256 tokenAmountOut, uint256 spotPriceAfter) {\n        require(_records[tokenIn].bound, \"ERR_NOT_BOUND\");\n        require(_records[tokenOut].bound, \"ERR_NOT_BOUND\");\n        require(_publicSwap, \"ERR_SWAP_NOT_PUBLIC\");\n\n        Record storage inRecord = _records[address(tokenIn)];\n        Record storage outRecord = _records[address(tokenOut)];\n\n        require(tokenAmountIn <= bmul(inRecord.balance, MAX_IN_RATIO), \"ERR_MAX_IN_RATIO\");\n\n        uint256 spotPriceBefore =\n            calcSpotPrice(inRecord.balance, inRecord.denorm, outRecord.balance, outRecord.denorm, _swapFee);\n        require(spotPriceBefore <= maxPrice, \"ERR_BAD_LIMIT_PRICE\");\n\n        tokenAmountOut = calcOutGivenIn(\n            inRecord.balance,\n            inRecord.denorm,\n            outRecord.balance,\n            outRecord.denorm,\n            tokenAmountIn,\n            _swapFee\n        );\n        require(tokenAmountOut >= minAmountOut, \"ERR_LIMIT_OUT\");\n\n        inRecord.balance = badd(inRecord.balance, tokenAmountIn);\n        outRecord.balance = bsub(outRecord.balance, tokenAmountOut);\n\n        spotPriceAfter = calcSpotPrice(\n            inRecord.balance,\n            inRecord.denorm,\n            outRecord.balance,\n            outRecord.denorm,\n            _swapFee\n        );\n        require(spotPriceAfter >= spotPriceBefore, \"ERR_MATH_APPROX\");\n        require(spotPriceAfter <= maxPrice, \"ERR_LIMIT_PRICE\");\n        require(spotPriceBefore <= bdiv(tokenAmountIn, tokenAmountOut), \"ERR_MATH_APPROX\");\n\n        emit LOG_SWAP(msg.sender, tokenIn, tokenOut, tokenAmountIn, tokenAmountOut);\n\n        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\n        _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\n\n        return (tokenAmountOut, spotPriceAfter);\n    }\n\n    function swapExactAmountOut(\n        address tokenIn,\n        uint256 maxAmountIn,\n        address tokenOut,\n        uint256 tokenAmountOut,\n        uint256 maxPrice\n    ) external _logs_ _lock_ returns (uint256 tokenAmountIn, uint256 spotPriceAfter) {\n        require(_records[tokenIn].bound, \"ERR_NOT_BOUND\");\n        require(_records[tokenOut].bound, \"ERR_NOT_BOUND\");\n        require(_publicSwap, \"ERR_SWAP_NOT_PUBLIC\");\n\n        Record storage inRecord = _records[address(tokenIn)];\n        Record storage outRecord = _records[address(tokenOut)];\n\n        require(tokenAmountOut <= bmul(outRecord.balance, MAX_OUT_RATIO), \"ERR_MAX_OUT_RATIO\");\n\n        uint256 spotPriceBefore =\n            calcSpotPrice(inRecord.balance, inRecord.denorm, outRecord.balance, outRecord.denorm, _swapFee);\n        require(spotPriceBefore <= maxPrice, \"ERR_BAD_LIMIT_PRICE\");\n\n        tokenAmountIn = calcInGivenOut(\n            inRecord.balance,\n            inRecord.denorm,\n            outRecord.balance,\n            outRecord.denorm,\n            tokenAmountOut,\n            _swapFee\n        );\n        require(tokenAmountIn <= maxAmountIn, \"ERR_LIMIT_IN\");\n\n        inRecord.balance = badd(inRecord.balance, tokenAmountIn);\n        outRecord.balance = bsub(outRecord.balance, tokenAmountOut);\n\n        spotPriceAfter = calcSpotPrice(\n            inRecord.balance,\n            inRecord.denorm,\n            outRecord.balance,\n            outRecord.denorm,\n            _swapFee\n        );\n        require(spotPriceAfter >= spotPriceBefore, \"ERR_MATH_APPROX\");\n        require(spotPriceAfter <= maxPrice, \"ERR_LIMIT_PRICE\");\n        require(spotPriceBefore <= bdiv(tokenAmountIn, tokenAmountOut), \"ERR_MATH_APPROX\");\n\n        emit LOG_SWAP(msg.sender, tokenIn, tokenOut, tokenAmountIn, tokenAmountOut);\n\n        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\n        _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\n\n        return (tokenAmountIn, spotPriceAfter);\n    }\n\n    function joinswapExternAmountIn(\n        address tokenIn,\n        uint256 tokenAmountIn,\n        uint256 minPoolAmountOut\n    ) external _logs_ _lock_ returns (uint256 poolAmountOut) {\n        require(_finalized, \"ERR_NOT_FINALIZED\");\n        require(_records[tokenIn].bound, \"ERR_NOT_BOUND\");\n        require(tokenAmountIn <= bmul(_records[tokenIn].balance, MAX_IN_RATIO), \"ERR_MAX_IN_RATIO\");\n\n        Record storage inRecord = _records[tokenIn];\n\n        poolAmountOut = calcPoolOutGivenSingleIn(\n            inRecord.balance,\n            inRecord.denorm,\n            _totalSupply,\n            _totalWeight,\n            tokenAmountIn,\n            _swapFee\n        );\n\n        require(poolAmountOut >= minPoolAmountOut, \"ERR_LIMIT_OUT\");\n\n        inRecord.balance = badd(inRecord.balance, tokenAmountIn);\n\n        emit LOG_JOIN(msg.sender, tokenIn, tokenAmountIn);\n\n        _mintPoolShare(poolAmountOut);\n        _pushPoolShare(msg.sender, poolAmountOut);\n        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\n\n        return poolAmountOut;\n    }\n\n    function joinswapPoolAmountOut(\n        address tokenIn,\n        uint256 poolAmountOut,\n        uint256 maxAmountIn\n    ) external _logs_ _lock_ returns (uint256 tokenAmountIn) {\n        require(_finalized, \"ERR_NOT_FINALIZED\");\n        require(_records[tokenIn].bound, \"ERR_NOT_BOUND\");\n\n        Record storage inRecord = _records[tokenIn];\n\n        tokenAmountIn = calcSingleInGivenPoolOut(\n            inRecord.balance,\n            inRecord.denorm,\n            _totalSupply,\n            _totalWeight,\n            poolAmountOut,\n            _swapFee\n        );\n\n        require(tokenAmountIn != 0, \"ERR_MATH_APPROX\");\n        require(tokenAmountIn <= maxAmountIn, \"ERR_LIMIT_IN\");\n\n        require(tokenAmountIn <= bmul(_records[tokenIn].balance, MAX_IN_RATIO), \"ERR_MAX_IN_RATIO\");\n\n        inRecord.balance = badd(inRecord.balance, tokenAmountIn);\n\n        emit LOG_JOIN(msg.sender, tokenIn, tokenAmountIn);\n\n        _mintPoolShare(poolAmountOut);\n        _pushPoolShare(msg.sender, poolAmountOut);\n        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\n\n        return tokenAmountIn;\n    }\n\n    function exitswapPoolAmountIn(\n        address tokenOut,\n        uint256 poolAmountIn,\n        uint256 minAmountOut\n    ) external _logs_ _lock_ returns (uint256 tokenAmountOut) {\n        require(_finalized, \"ERR_NOT_FINALIZED\");\n        require(_records[tokenOut].bound, \"ERR_NOT_BOUND\");\n\n        Record storage outRecord = _records[tokenOut];\n\n        tokenAmountOut = calcSingleOutGivenPoolIn(\n            outRecord.balance,\n            outRecord.denorm,\n            _totalSupply,\n            _totalWeight,\n            poolAmountIn,\n            _swapFee\n        );\n\n        require(tokenAmountOut >= minAmountOut, \"ERR_LIMIT_OUT\");\n\n        require(tokenAmountOut <= bmul(_records[tokenOut].balance, MAX_OUT_RATIO), \"ERR_MAX_OUT_RATIO\");\n\n        outRecord.balance = bsub(outRecord.balance, tokenAmountOut);\n\n        uint256 exitFee = bmul(poolAmountIn, EXIT_FEE);\n\n        emit LOG_EXIT(msg.sender, tokenOut, tokenAmountOut);\n\n        _pullPoolShare(msg.sender, poolAmountIn);\n        _burnPoolShare(bsub(poolAmountIn, exitFee));\n        _pushPoolShare(_factory, exitFee);\n        _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\n\n        return tokenAmountOut;\n    }\n\n    function exitswapExternAmountOut(\n        address tokenOut,\n        uint256 tokenAmountOut,\n        uint256 maxPoolAmountIn\n    ) external _logs_ _lock_ returns (uint256 poolAmountIn) {\n        require(_finalized, \"ERR_NOT_FINALIZED\");\n        require(_records[tokenOut].bound, \"ERR_NOT_BOUND\");\n        require(tokenAmountOut <= bmul(_records[tokenOut].balance, MAX_OUT_RATIO), \"ERR_MAX_OUT_RATIO\");\n\n        Record storage outRecord = _records[tokenOut];\n\n        poolAmountIn = calcPoolInGivenSingleOut(\n            outRecord.balance,\n            outRecord.denorm,\n            _totalSupply,\n            _totalWeight,\n            tokenAmountOut,\n            _swapFee\n        );\n\n        require(poolAmountIn != 0, \"ERR_MATH_APPROX\");\n        require(poolAmountIn <= maxPoolAmountIn, \"ERR_LIMIT_IN\");\n\n        outRecord.balance = bsub(outRecord.balance, tokenAmountOut);\n\n        uint256 exitFee = bmul(poolAmountIn, EXIT_FEE);\n\n        emit LOG_EXIT(msg.sender, tokenOut, tokenAmountOut);\n\n        _pullPoolShare(msg.sender, poolAmountIn);\n        _burnPoolShare(bsub(poolAmountIn, exitFee));\n        _pushPoolShare(_factory, exitFee);\n        _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\n\n        return poolAmountIn;\n    }\n\n    // ==\n    // 'Underlying' token-manipulation functions make external calls but are NOT locked\n    // You must `_lock_` or otherwise ensure reentry-safety\n\n    function _pullUnderlying(\n        address erc20,\n        address from,\n        uint256 amount\n    ) internal {\n        bool xfer = IERC20Balancer(erc20).transferFrom(from, address(this), amount);\n        require(xfer, \"ERR_ERC20_FALSE\");\n    }\n\n    function _pushUnderlying(\n        address erc20,\n        address to,\n        uint256 amount\n    ) internal {\n        bool xfer = IERC20Balancer(erc20).transfer(to, amount);\n        require(xfer, \"ERR_ERC20_FALSE\");\n    }\n\n    function _pullPoolShare(address from, uint256 amount) internal {\n        _pull(from, amount);\n    }\n\n    function _pushPoolShare(address to, uint256 amount) internal {\n        _push(to, amount);\n    }\n\n    function _mintPoolShare(uint256 amount) internal {\n        _mint(amount);\n    }\n\n    function _burnPoolShare(uint256 amount) internal {\n        _burn(amount);\n    }\n}\n"
    },
    "contracts/balancer/BToken.sol": {
      "content": "// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./BNum.sol\";\n\ninterface IERC20Balancer {\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address whom) external view returns (uint256);\n\n    function allowance(address src, address dst) external view returns (uint256);\n\n    function approve(address dst, uint256 amt) external returns (bool);\n\n    function transfer(address dst, uint256 amt) external returns (bool);\n\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 amt\n    ) external returns (bool);\n}\n\ncontract BTokenBase is BNum {\n    mapping(address => uint256) internal _balance;\n    mapping(address => mapping(address => uint256)) internal _allowance;\n    uint256 internal _totalSupply;\n\n    event Approval(address indexed src, address indexed dst, uint256 amt);\n    event Transfer(address indexed src, address indexed dst, uint256 amt);\n\n    function _mint(uint256 amt) internal {\n        _balance[address(this)] = badd(_balance[address(this)], amt);\n        _totalSupply = badd(_totalSupply, amt);\n        emit Transfer(address(0), address(this), amt);\n    }\n\n    function _burn(uint256 amt) internal {\n        require(_balance[address(this)] >= amt, \"ERR_INSUFFICIENT_BAL\");\n        _balance[address(this)] = bsub(_balance[address(this)], amt);\n        _totalSupply = bsub(_totalSupply, amt);\n        emit Transfer(address(this), address(0), amt);\n    }\n\n    function _move(\n        address src,\n        address dst,\n        uint256 amt\n    ) internal {\n        require(_balance[src] >= amt, \"ERR_INSUFFICIENT_BAL\");\n        _balance[src] = bsub(_balance[src], amt);\n        _balance[dst] = badd(_balance[dst], amt);\n        emit Transfer(src, dst, amt);\n    }\n\n    function _push(address to, uint256 amt) internal {\n        _move(address(this), to, amt);\n    }\n\n    function _pull(address from, uint256 amt) internal {\n        _move(from, address(this), amt);\n    }\n}\n\ncontract BToken is BTokenBase, IERC20Balancer {\n    string private _name = \"Balancer Pool Token\";\n    string private _symbol = \"BPT\";\n    uint8 private _decimals = 18;\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    function allowance(address src, address dst) external view override returns (uint256) {\n        return _allowance[src][dst];\n    }\n\n    function balanceOf(address whom) external view override returns (uint256) {\n        return _balance[whom];\n    }\n\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    function approve(address dst, uint256 amt) external override returns (bool) {\n        _allowance[msg.sender][dst] = amt;\n        emit Approval(msg.sender, dst, amt);\n        return true;\n    }\n\n    function increaseApproval(address dst, uint256 amt) external returns (bool) {\n        _allowance[msg.sender][dst] = badd(_allowance[msg.sender][dst], amt);\n        emit Approval(msg.sender, dst, _allowance[msg.sender][dst]);\n        return true;\n    }\n\n    function decreaseApproval(address dst, uint256 amt) external returns (bool) {\n        uint256 oldValue = _allowance[msg.sender][dst];\n        if (amt > oldValue) {\n            _allowance[msg.sender][dst] = 0;\n        } else {\n            _allowance[msg.sender][dst] = bsub(oldValue, amt);\n        }\n        emit Approval(msg.sender, dst, _allowance[msg.sender][dst]);\n        return true;\n    }\n\n    function transfer(address dst, uint256 amt) external override returns (bool) {\n        _move(msg.sender, dst, amt);\n        return true;\n    }\n\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 amt\n    ) external override returns (bool) {\n        require(msg.sender == src || amt <= _allowance[src][msg.sender], \"ERR_BTOKEN_BAD_CALLER\");\n        _move(src, dst, amt);\n        if (msg.sender != src && _allowance[src][msg.sender] != type(uint256).max) {\n            _allowance[src][msg.sender] = bsub(_allowance[src][msg.sender], amt);\n            emit Approval(msg.sender, dst, _allowance[src][msg.sender]);\n        }\n        return true;\n    }\n}\n"
    },
    "contracts/balancer/BMath.sol": {
      "content": "// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./BNum.sol\";\n\ncontract BMath is BBronze, BConst, BNum {\n    /**********************************************************************************************\n    // calcSpotPrice                                                                             //\n    // sP = spotPrice                                                                            //\n    // bI = tokenBalanceIn                ( bI / wI )         1                                  //\n    // bO = tokenBalanceOut         sP =  -----------  *  ----------                             //\n    // wI = tokenWeightIn                 ( bO / wO )     ( 1 - sF )                             //\n    // wO = tokenWeightOut                                                                       //\n    // sF = swapFee                                                                              //\n    **********************************************************************************************/\n    function calcSpotPrice(\n        uint256 tokenBalanceIn,\n        uint256 tokenWeightIn,\n        uint256 tokenBalanceOut,\n        uint256 tokenWeightOut,\n        uint256 swapFee\n    ) public pure returns (uint256 spotPrice) {\n        uint256 numer = bdiv(tokenBalanceIn, tokenWeightIn);\n        uint256 denom = bdiv(tokenBalanceOut, tokenWeightOut);\n        uint256 ratio = bdiv(numer, denom);\n        uint256 scale = bdiv(BONE, bsub(BONE, swapFee));\n        return (spotPrice = bmul(ratio, scale));\n    }\n\n    /**********************************************************************************************\n    // calcOutGivenIn                                                                            //\n    // aO = tokenAmountOut                                                                       //\n    // bO = tokenBalanceOut                                                                      //\n    // bI = tokenBalanceIn              /      /            bI             \\    (wI / wO) \\      //\n    // aI = tokenAmountIn    aO = bO * |  1 - | --------------------------  | ^            |     //\n    // wI = tokenWeightIn               \\      \\ ( bI + ( aI * ( 1 - sF )) /              /      //\n    // wO = tokenWeightOut                                                                       //\n    // sF = swapFee                                                                              //\n    **********************************************************************************************/\n    function calcOutGivenIn(\n        uint256 tokenBalanceIn,\n        uint256 tokenWeightIn,\n        uint256 tokenBalanceOut,\n        uint256 tokenWeightOut,\n        uint256 tokenAmountIn,\n        uint256 swapFee\n    ) public pure returns (uint256 tokenAmountOut) {\n        uint256 weightRatio = bdiv(tokenWeightIn, tokenWeightOut);\n        uint256 adjustedIn = bsub(BONE, swapFee);\n        adjustedIn = bmul(tokenAmountIn, adjustedIn);\n        uint256 y = bdiv(tokenBalanceIn, badd(tokenBalanceIn, adjustedIn));\n        uint256 foo = bpow(y, weightRatio);\n        uint256 bar = bsub(BONE, foo);\n        tokenAmountOut = bmul(tokenBalanceOut, bar);\n        return tokenAmountOut;\n    }\n\n    /**********************************************************************************************\n    // calcInGivenOut                                                                            //\n    // aI = tokenAmountIn                                                                        //\n    // bO = tokenBalanceOut               /  /     bO      \\    (wO / wI)      \\                 //\n    // bI = tokenBalanceIn          bI * |  | ------------  | ^            - 1  |                //\n    // aO = tokenAmountOut    aI =        \\  \\ ( bO - aO ) /                   /                 //\n    // wI = tokenWeightIn           --------------------------------------------                 //\n    // wO = tokenWeightOut                          ( 1 - sF )                                   //\n    // sF = swapFee                                                                              //\n    **********************************************************************************************/\n    function calcInGivenOut(\n        uint256 tokenBalanceIn,\n        uint256 tokenWeightIn,\n        uint256 tokenBalanceOut,\n        uint256 tokenWeightOut,\n        uint256 tokenAmountOut,\n        uint256 swapFee\n    ) public pure returns (uint256 tokenAmountIn) {\n        uint256 weightRatio = bdiv(tokenWeightOut, tokenWeightIn);\n        uint256 diff = bsub(tokenBalanceOut, tokenAmountOut);\n        uint256 y = bdiv(tokenBalanceOut, diff);\n        uint256 foo = bpow(y, weightRatio);\n        foo = bsub(foo, BONE);\n        tokenAmountIn = bsub(BONE, swapFee);\n        tokenAmountIn = bdiv(bmul(tokenBalanceIn, foo), tokenAmountIn);\n        return tokenAmountIn;\n    }\n\n    /**********************************************************************************************\n    // calcPoolOutGivenSingleIn                                                                  //\n    // pAo = poolAmountOut         /                                              \\              //\n    // tAi = tokenAmountIn        ///      /     //    wI \\      \\\\       \\     wI \\             //\n    // wI = tokenWeightIn        //| tAi *| 1 - || 1 - --  | * sF || + tBi \\    --  \\            //\n    // tW = totalWeight     pAo=||  \\      \\     \\\\    tW /      //         | ^ tW   | * pS - pS //\n    // tBi = tokenBalanceIn      \\\\  ------------------------------------- /        /            //\n    // pS = poolSupply            \\\\                    tBi               /        /             //\n    // sF = swapFee                \\                                              /              //\n    **********************************************************************************************/\n\n    // Charge the trading fee for the proportion of tokenAi\n    ///  which is implicitly traded to the other pool tokens.\n    // That proportion is (1- weightTokenIn)\n    // tokenAiAfterFee = tAi * (1 - (1-weightTi) * poolFee);\n\n    function calcPoolOutGivenSingleIn(\n        uint256 tokenBalanceIn,\n        uint256 tokenWeightIn,\n        uint256 poolSupply,\n        uint256 totalWeight,\n        uint256 tokenAmountIn,\n        uint256 swapFee\n    ) public pure returns (uint256 poolAmountOut) {\n        uint256 normalizedWeight = bdiv(tokenWeightIn, totalWeight);\n        uint256 zaz = bmul(bsub(BONE, normalizedWeight), swapFee);\n        uint256 tokenAmountInAfterFee = bmul(tokenAmountIn, bsub(BONE, zaz));\n\n        uint256 newTokenBalanceIn = badd(tokenBalanceIn, tokenAmountInAfterFee);\n        uint256 tokenInRatio = bdiv(newTokenBalanceIn, tokenBalanceIn);\n\n        // uint newPoolSupply = (ratioTi ^ weightTi) * poolSupply;\n        uint256 poolRatio = bpow(tokenInRatio, normalizedWeight);\n        uint256 newPoolSupply = bmul(poolRatio, poolSupply);\n        poolAmountOut = bsub(newPoolSupply, poolSupply);\n        return poolAmountOut;\n    }\n\n    /**********************************************************************************************\n    // calcSingleInGivenPoolOut                                                                  //\n    // tAi = tokenAmountIn              //(pS + pAo)\\     /    1    \\\\                           //\n    // pS = poolSupply                 || ---------  | ^ | --------- || * bI - bI                //\n    // pAo = poolAmountOut              \\\\    pS    /     \\(wI / tW)//                           //\n    // bI = balanceIn          tAi =  --------------------------------------------               //\n    // wI = weightIn                              /      wI  \\                                   //\n    // tW = totalWeight                          |  1 - ----  |  * sF                            //\n    // sF = swapFee                               \\      tW  /                                   //\n    **********************************************************************************************/\n    function calcSingleInGivenPoolOut(\n        uint256 tokenBalanceIn,\n        uint256 tokenWeightIn,\n        uint256 poolSupply,\n        uint256 totalWeight,\n        uint256 poolAmountOut,\n        uint256 swapFee\n    ) public pure returns (uint256 tokenAmountIn) {\n        uint256 normalizedWeight = bdiv(tokenWeightIn, totalWeight);\n        uint256 newPoolSupply = badd(poolSupply, poolAmountOut);\n        uint256 poolRatio = bdiv(newPoolSupply, poolSupply);\n\n        //uint newBalTi = poolRatio^(1/weightTi) * balTi;\n        uint256 boo = bdiv(BONE, normalizedWeight);\n        uint256 tokenInRatio = bpow(poolRatio, boo);\n        uint256 newTokenBalanceIn = bmul(tokenInRatio, tokenBalanceIn);\n        uint256 tokenAmountInAfterFee = bsub(newTokenBalanceIn, tokenBalanceIn);\n        // Do reverse order of fees charged in joinswap_ExternAmountIn, this way\n        //     ``` pAo == joinswap_ExternAmountIn(Ti, joinswap_PoolAmountOut(pAo, Ti)) ```\n        //uint tAi = tAiAfterFee / (1 - (1-weightTi) * swapFee) ;\n        uint256 zar = bmul(bsub(BONE, normalizedWeight), swapFee);\n        tokenAmountIn = bdiv(tokenAmountInAfterFee, bsub(BONE, zar));\n        return tokenAmountIn;\n    }\n\n    /**********************************************************************************************\n    // calcSingleOutGivenPoolIn                                                                  //\n    // tAo = tokenAmountOut            /      /                                             \\\\   //\n    // bO = tokenBalanceOut           /      // pS - (pAi * (1 - eF)) \\     /    1    \\      \\\\  //\n    // pAi = poolAmountIn            | bO - || ----------------------- | ^ | --------- | * b0 || //\n    // ps = poolSupply                \\      \\\\          pS           /     \\(wO / tW)/      //  //\n    // wI = tokenWeightIn      tAo =   \\      \\                                             //   //\n    // tW = totalWeight                    /     /      wO \\       \\                             //\n    // sF = swapFee                    *  | 1 - |  1 - ---- | * sF  |                            //\n    // eF = exitFee                        \\     \\      tW /       /                             //\n    **********************************************************************************************/\n    function calcSingleOutGivenPoolIn(\n        uint256 tokenBalanceOut,\n        uint256 tokenWeightOut,\n        uint256 poolSupply,\n        uint256 totalWeight,\n        uint256 poolAmountIn,\n        uint256 swapFee\n    ) public pure returns (uint256 tokenAmountOut) {\n        uint256 normalizedWeight = bdiv(tokenWeightOut, totalWeight);\n        // charge exit fee on the pool token side\n        // pAiAfterExitFee = pAi*(1-exitFee)\n        uint256 poolAmountInAfterExitFee = bmul(poolAmountIn, bsub(BONE, EXIT_FEE));\n        uint256 newPoolSupply = bsub(poolSupply, poolAmountInAfterExitFee);\n        uint256 poolRatio = bdiv(newPoolSupply, poolSupply);\n\n        // newBalTo = poolRatio^(1/weightTo) * balTo;\n        uint256 tokenOutRatio = bpow(poolRatio, bdiv(BONE, normalizedWeight));\n        uint256 newTokenBalanceOut = bmul(tokenOutRatio, tokenBalanceOut);\n\n        uint256 tokenAmountOutBeforeSwapFee = bsub(tokenBalanceOut, newTokenBalanceOut);\n\n        // charge swap fee on the output token side\n        //uint tAo = tAoBeforeSwapFee * (1 - (1-weightTo) * swapFee)\n        uint256 zaz = bmul(bsub(BONE, normalizedWeight), swapFee);\n        tokenAmountOut = bmul(tokenAmountOutBeforeSwapFee, bsub(BONE, zaz));\n        return tokenAmountOut;\n    }\n\n    /**********************************************************************************************\n    // calcPoolInGivenSingleOut                                                                  //\n    // pAi = poolAmountIn               // /               tAo             \\\\     / wO \\     \\   //\n    // bO = tokenBalanceOut            // | bO - -------------------------- |\\   | ---- |     \\  //\n    // tAo = tokenAmountOut      pS - ||   \\     1 - ((1 - (tO / tW)) * sF)/  | ^ \\ tW /  * pS | //\n    // ps = poolSupply                 \\\\ -----------------------------------/                /  //\n    // wO = tokenWeightOut  pAi =       \\\\               bO                 /                /   //\n    // tW = totalWeight           -------------------------------------------------------------  //\n    // sF = swapFee                                        ( 1 - eF )                            //\n    // eF = exitFee                                                                              //\n    **********************************************************************************************/\n    function calcPoolInGivenSingleOut(\n        uint256 tokenBalanceOut,\n        uint256 tokenWeightOut,\n        uint256 poolSupply,\n        uint256 totalWeight,\n        uint256 tokenAmountOut,\n        uint256 swapFee\n    ) public pure returns (uint256 poolAmountIn) {\n        // charge swap fee on the output token side\n        uint256 normalizedWeight = bdiv(tokenWeightOut, totalWeight);\n        //uint tAoBeforeSwapFee = tAo / (1 - (1-weightTo) * swapFee) ;\n        uint256 zoo = bsub(BONE, normalizedWeight);\n        uint256 zar = bmul(zoo, swapFee);\n        uint256 tokenAmountOutBeforeSwapFee = bdiv(tokenAmountOut, bsub(BONE, zar));\n\n        uint256 newTokenBalanceOut = bsub(tokenBalanceOut, tokenAmountOutBeforeSwapFee);\n        uint256 tokenOutRatio = bdiv(newTokenBalanceOut, tokenBalanceOut);\n\n        //uint newPoolSupply = (ratioTo ^ weightTo) * poolSupply;\n        uint256 poolRatio = bpow(tokenOutRatio, normalizedWeight);\n        uint256 newPoolSupply = bmul(poolRatio, poolSupply);\n        uint256 poolAmountInAfterExitFee = bsub(poolSupply, newPoolSupply);\n\n        // charge exit fee on the pool token side\n        // pAi = pAiAfterExitFee/(1-exitFee)\n        poolAmountIn = bdiv(poolAmountInAfterExitFee, bsub(BONE, EXIT_FEE));\n        return poolAmountIn;\n    }\n}\n"
    },
    "contracts/libraries/IERC20Full.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IERC20Full is IERC20 {\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/turbo/TurboShareTokenFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./OwnedShareToken.sol\";\n\nabstract contract TurboShareTokenFactory {\n    function createShareTokens(string[] memory _names, address _owner) internal returns (OwnedERC20[] memory) {\n        uint256 _numOutcomes = _names.length;\n        OwnedERC20[] memory _tokens = new OwnedERC20[](_numOutcomes);\n\n        for (uint256 _i = 0; _i < _numOutcomes; _i++) {\n            _tokens[_i] = new OwnedERC20(_names[_i], _names[_i], _owner);\n        }\n        return _tokens;\n    }\n}\n\nabstract contract TurboShareTokenFactoryV1 {\n    function createShareTokens(\n        string[] memory _names,\n        string[] memory _symbols,\n        address _owner\n    ) internal returns (OwnedERC20[] memory) {\n        uint256 _numOutcomes = _names.length;\n        OwnedERC20[] memory _tokens = new OwnedERC20[](_numOutcomes);\n\n        for (uint256 _i = 0; _i < _numOutcomes; _i++) {\n            _tokens[_i] = new OwnedERC20(_names[_i], _symbols[_i], _owner);\n        }\n        return _tokens;\n    }\n}\n"
    },
    "contracts/turbo/FeePot.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"../libraries/IERC20Full.sol\";\n\ncontract FeePot is ERC20 {\n    using SafeMath for uint256;\n\n    uint256 internal constant magnitude = 2**128;\n\n    IERC20Full public collateral;\n    IERC20Full public reputationToken;\n\n    uint256 public magnifiedFeesPerShare;\n\n    mapping(address => uint256) public magnifiedFeesCorrections;\n    mapping(address => uint256) public storedFees;\n\n    uint256 public feeReserve;\n\n    constructor(IERC20Full _collateral, IERC20Full _reputationToken)\n        ERC20(\n            string(abi.encodePacked(\"S_\", _reputationToken.symbol())),\n            string(abi.encodePacked(\"S_\", _reputationToken.symbol()))\n        )\n    {\n        collateral = _collateral;\n        reputationToken = _reputationToken;\n\n        require(_collateral != IERC20Full(address(0)));\n    }\n\n    function depositFees(uint256 _amount) public returns (bool) {\n        collateral.transferFrom(msg.sender, address(this), _amount);\n        uint256 _totalSupply = totalSupply(); // after collateral.transferFrom to prevent reentrancy causing stale totalSupply\n        if (_totalSupply == 0) {\n            feeReserve = feeReserve.add(_amount);\n            return true;\n        }\n        if (feeReserve > 0) {\n            _amount = _amount.add(feeReserve);\n            feeReserve = 0;\n        }\n        magnifiedFeesPerShare = magnifiedFeesPerShare.add((_amount).mul(magnitude) / _totalSupply);\n        return true;\n    }\n\n    function withdrawableFeesOf(address _owner) public view returns (uint256) {\n        return earnedFeesOf(_owner).add(storedFees[_owner]);\n    }\n\n    function earnedFeesOf(address _owner) public view returns (uint256) {\n        uint256 _ownerBalance = balanceOf(_owner);\n        uint256 _magnifiedFees = magnifiedFeesPerShare.mul(_ownerBalance);\n        return _magnifiedFees.sub(magnifiedFeesCorrections[_owner]) / magnitude;\n    }\n\n    function _transfer(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) internal override {\n        storedFees[_from] = storedFees[_from].add(earnedFeesOf(_from));\n        super._transfer(_from, _to, _amount);\n\n        magnifiedFeesCorrections[_from] = magnifiedFeesPerShare.mul(balanceOf(_from));\n        magnifiedFeesCorrections[_to] = magnifiedFeesCorrections[_to].add(magnifiedFeesPerShare.mul(_amount));\n    }\n\n    function stake(uint256 _amount) external returns (bool) {\n        reputationToken.transferFrom(msg.sender, address(this), _amount);\n        _mint(msg.sender, _amount);\n        magnifiedFeesCorrections[msg.sender] = magnifiedFeesCorrections[msg.sender].add(\n            magnifiedFeesPerShare.mul(_amount)\n        );\n        return true;\n    }\n\n    function exit(uint256 _amount) external returns (bool) {\n        redeemInternal(msg.sender);\n        _burn(msg.sender, _amount);\n        reputationToken.transfer(msg.sender, _amount);\n        magnifiedFeesCorrections[msg.sender] = magnifiedFeesPerShare.mul(balanceOf(msg.sender));\n        return true;\n    }\n\n    function redeem() public returns (bool) {\n        redeemInternal(msg.sender);\n        magnifiedFeesCorrections[msg.sender] = magnifiedFeesPerShare.mul(balanceOf(msg.sender));\n        return true;\n    }\n\n    function redeemInternal(address _account) internal {\n        uint256 _withdrawableFees = withdrawableFeesOf(_account);\n        if (_withdrawableFees > 0) {\n            storedFees[_account] = 0;\n            collateral.transfer(_account, _withdrawableFees);\n        }\n    }\n}\n"
    },
    "contracts/libraries/Rewardable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nabstract contract Rewardable {\n    // Rewards will be paid out over the lifetime of an event.\n    // An value of zero will start rewards immediately and proceed based on the values set in master chef.\n\n    // _Id here is the market id passed to the amm factory when creating a pool.\n    function getRewardEndTime(uint256 _marketId) public view virtual returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "contracts/turbo/OwnedShareToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"../libraries/Ownable.sol\";\n\ncontract OwnedERC20 is ERC20, Ownable {\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        address _owner\n    ) ERC20(name_, symbol_) {\n        owner = _owner;\n    }\n\n    function trustedTransfer(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) external onlyOwner {\n        _transfer(_from, _to, _amount);\n    }\n\n    function trustedMint(address _target, uint256 _amount) external onlyOwner {\n        _mint(_target, _amount);\n    }\n\n    function trustedBurn(address _target, uint256 _amount) external onlyOwner {\n        _burn(_target, _amount);\n    }\n\n    function trustedBurnAll(address _target) external onlyOwner returns (uint256) {\n        uint256 _balance = balanceOf(_target);\n        _burn(_target, _balance);\n        return _balance;\n    }\n\n    function onTransferOwnership(address, address) internal override {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "contracts/libraries/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./IOwnable.sol\";\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\nabstract contract Ownable is IOwnable {\n    address internal owner;\n\n    /**\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n     * account.\n     */\n    constructor() {\n        owner = msg.sender;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function getOwner() public view override returns (address) {\n        return owner;\n    }\n\n    /**\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n     * @param _newOwner The address to transfer ownership to.\n     */\n    function transferOwnership(address _newOwner) public override onlyOwner returns (bool) {\n        require(_newOwner != address(0));\n        onTransferOwnership(owner, _newOwner);\n        owner = _newOwner;\n        return true;\n    }\n\n    // Subclasses of this token may want to send additional logs through the centralized Augur log emitter contract\n    function onTransferOwnership(address, address) internal virtual;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/libraries/IOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ninterface IOwnable {\n    function getOwner() external view returns (address);\n\n    function transferOwnership(address _newOwner) external returns (bool);\n}\n"
    },
    "contracts/turbo/random.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n\nimport \"../libraries/IERC20Full.sol\";\nimport \"../balancer/BPool.sol\";\nimport \"./AbstractMarketFactoryV3.sol\";\nimport \"./FeePot.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/SignedSafeMath.sol\";\nimport \"./MMAMarketFactoryV3.sol\";\nimport \"./AMMFactory.sol\";\nimport \"./CryptoMarketFactoryV3.sol\";\nimport \"./NBAMarketFactoryV3.sol\";\nimport \"../rewards/MasterChef.sol\";\nimport \"./CryptoCurrencyMarketFactoryV3.sol\";\nimport \"./TrustedMarketFactoryV3.sol\";\nimport \"./Fetcher.sol\";\n\ncontract TrustedFetcher is Fetcher {\n    constructor() Fetcher(\"Trusted\", \"TBD\") {}\n\n    struct SpecificMarketFactoryBundle {\n        MarketFactoryBundle _super;\n    }\n\n    struct SpecificStaticMarketBundle {\n        StaticMarketBundle _super;\n        // uint256 coinIndex;\n        // uint256 creationValue;\n        // uint256 resolutionTime;\n        // // Dynamics\n        // uint256 resolutionValue;\n        string description;\n    }\n\n    struct SpecificDynamicMarketBundle {\n        DynamicMarketBundle _super;\n        //uint256 resolutionValue;\n        string description;\n\n    }\n\n    function sayHi() public view returns(uint256){\n        return 0; \n    }\n\n    function getMarket( address _marketFactory,\n    AMMFactory _ammFactory,\n    MasterChef _masterChef,\n    uint256 _marketId) public view returns(   SpecificStaticMarketBundle memory _bundle\n){\n    TrustedMarketFactoryV3.MarketDetails memory _details =\n        TrustedMarketFactoryV3(_marketFactory).getMarketDetails(_marketId);\n    _bundle._super = buildStaticMarketBundle(\n        TrustedMarketFactoryV3(_marketFactory),\n        _ammFactory,\n        _masterChef,\n        _marketId\n    );\n    _bundle.description = _details.description;\n    }\n\n\n  function fetchInitial(\n        address _marketFactory,\n        AMMFactory _ammFactory,\n        MasterChef _masterChef,\n        uint256 _offset,\n        uint256 _total\n    )\n        public\n        view\n        returns (\n            SpecificMarketFactoryBundle memory _marketFactoryBundle,\n            SpecificStaticMarketBundle[] memory _marketBundles,\n            uint256 _lowestMarketIndex,\n            uint256 _timestamp\n        )\n    {\n        _marketFactoryBundle = buildSpecificMarketFactoryBundle(_marketFactory);\n\n        uint256[] memory _marketIds;\n\n       (_marketIds, _lowestMarketIndex) = listOfInterestingMarkets(_marketFactory, _offset, _total);\n        // (_marketIds, _lowestMarketIndex) = interestingMarkets(_marketFactory, _offset, _total);\n\n        _total = _marketIds.length;\n        _marketBundles = new SpecificStaticMarketBundle[](_total);\n        for (uint256 i; i < _total; i++) {\n            _marketBundles[i] = buildSpecificStaticMarketBundle(\n                _marketFactory,\n                _ammFactory,\n                _masterChef,\n                 _marketIds[i]\n                \n            );\n        }\n\n        _timestamp = block.timestamp;\n    }\n\n\n    function buildSpecificMarketFactoryBundle(address _marketFactory)\n        internal\n        view\n        returns (SpecificMarketFactoryBundle memory _bundle)\n    {\n        _bundle._super = buildMarketFactoryBundle(TrustedMarketFactoryV3(_marketFactory));\n    }\n\n\n function buildSpecificStaticMarketBundle(\n        address _marketFactory,\n        AMMFactory _ammFactory,\n        MasterChef _masterChef,\n        uint256 _marketId\n    ) internal view returns (SpecificStaticMarketBundle memory _bundle) {\n        TrustedMarketFactoryV3.MarketDetails memory _details =\n            TrustedMarketFactoryV3(_marketFactory).getMarketDetails(_marketId);\n        _bundle._super = buildStaticMarketBundle(\n            TrustedMarketFactoryV3(_marketFactory),\n            _ammFactory,\n            _masterChef,\n            _marketId+1\n        );\n        _bundle.description = _details.description;\n        // _bundle.creationValue = _details.creationValue;\n        // _bundle.coinIndex = _details.coinIndex;\n        // _bundle.resolutionValue = _details.resolutionValue;\n        // _bundle.resolutionTime = _details.resolutionTime;\n    }\n\nfunction listOfInterestingMarkets(\n        address _marketFactory,\n        uint256 _offset,\n        uint256 _total\n    ) internal view returns (uint256[] memory _interestingMarketIds, uint256 _marketId) {\n        _interestingMarketIds = new uint256[](_total);\n        uint256 _max = AbstractMarketFactoryV3(_marketFactory).marketCount() - 1;\n\n        // No markets so return nothing. (needed to prevent integer underflow below)\n        if (_max == 0 || _offset >= _max) {\n            return (new uint256[](0), 0);\n        }\n\n        // Starts at the end, less offset.\n        // Stops before the 0th market since that market is always fake.\n        uint256 _collectedMarkets = 0;\n        _marketId = _max - _offset-1;\n\n        while (true) {\n            if (openOrHasWinningShares(AbstractMarketFactoryV3(_marketFactory), _marketId)) {\n                _interestingMarketIds[_collectedMarkets] = _marketId;\n                _collectedMarkets++;\n            }\n\n            if (_collectedMarkets >= _total) break;\n            if (_marketId == 0) break; // skipping 0th market, which is fake\n            _marketId--; // starts out oone too high, so this works\n        }\n\n        if (_total > _collectedMarkets) {\n            assembly {\n                // shortens array\n                mstore(_interestingMarketIds, _collectedMarkets)\n            }\n        }\n    }\n\n    function fetchDynamic(\n        address _marketFactory,\n        AMMFactory _ammFactory,\n        uint256 _offset,\n        uint256 _total\n    )\n        public\n        view\n        returns (\n            SpecificDynamicMarketBundle[] memory _bundles,\n            uint256 _lowestMarketIndex,\n            uint256 _timestamp\n        )\n    {\n        uint256[] memory _marketIds;\n        (_marketIds, _lowestMarketIndex) = listOfInterestingMarkets(_marketFactory, _offset, _total);\n\n        _total = _marketIds.length;\n        _bundles = new SpecificDynamicMarketBundle[](_total);\n        for (uint256 i; i < _total; i++) {\n            _bundles[i] = buildSpecificDynamicMarketBundle(_marketFactory, _ammFactory, _marketIds[i]);\n        }\n\n        _timestamp = block.timestamp;\n    }\n \n\n\n    function buildSpecificDynamicMarketBundle(\n        address _marketFactory,\n        AMMFactory _ammFactory,\n        uint256 _marketId\n    ) internal view returns (SpecificDynamicMarketBundle memory _bundle) {\n        TrustedMarketFactoryV3.MarketDetails memory _details =\n            TrustedMarketFactoryV3(_marketFactory).getMarketDetails(_marketId);\n        _bundle._super = buildDynamicMarketBundle(TrustedMarketFactoryV3(_marketFactory), _ammFactory, _marketId+1);\n        _bundle.description = _details.description;\n    }\n\n\n    }\n\n\n\n\n\n\n// contract TrustedFetcher is Fetcher {\n//     constructor() Fetcher(\"Trusted\", \"TBD\") {}\n\n//     struct SpecificMarketFactoryBundle {\n//         MarketFactoryBundle _super;\n//     }\n\n//     struct SpecificStaticMarketBundle {\n//         StaticMarketBundle _super;\n//         // uint256 coinIndex;\n//         // uint256 creationValue;\n//         // uint256 resolutionTime;\n//         // // Dynamics\n//         // uint256 resolutionValue;\n//         string description;\n//     }\n\n//     struct SpecificDynamicMarketBundle {\n//         DynamicMarketBundle _super;\n//         //uint256 resolutionValue;\n//         string description;\n\n//     }\n\n//     function getMarket(    address _marketFactory,\n//         AMMFactory _ammFactory,\n//         MasterChef _masterChef,\n//         uint256 _marketId) public view returns(   SpecificStaticMarketBundle memory _bundle\n// ){\n//         TrustedMarketFactoryV3.MarketDetails memory _details =\n//             TrustedMarketFactoryV3(_marketFactory).getMarketDetails(_marketId);\n//         _bundle._super = buildStaticMarketBundle(\n//             TrustedMarketFactoryV3(_marketFactory),\n//             _ammFactory,\n//             _masterChef,\n//             _marketId\n//         );\n//         _bundle.description = _details.description;\n//     }\n\n//     function buildSpecificMarketFactoryBundle(address _marketFactory)\n//         internal\n//         view\n//         returns (SpecificMarketFactoryBundle memory _bundle)\n//     {\n//         _bundle._super = buildMarketFactoryBundle(TrustedMarketFactoryV3(_marketFactory));\n//     }\n\n//     function buildSpecificStaticMarketBundle(\n//         address _marketFactory,\n//         AMMFactory _ammFactory,\n//         MasterChef _masterChef,\n//         uint256 _marketId\n//     ) internal view returns (SpecificStaticMarketBundle memory _bundle) {\n//         TrustedMarketFactoryV3.MarketDetails memory _details =\n//             TrustedMarketFactoryV3(_marketFactory).getMarketDetails(_marketId);\n//         _bundle._super = buildStaticMarketBundle(\n//             TrustedMarketFactoryV3(_marketFactory),\n//             _ammFactory,\n//             _masterChef,\n//             _marketId\n//         );\n//         _bundle.description = _details.description;\n//         // _bundle.creationValue = _details.creationValue;\n//         // _bundle.coinIndex = _details.coinIndex;\n//         // _bundle.resolutionValue = _details.resolutionValue;\n//         // _bundle.resolutionTime = _details.resolutionTime;\n//     }\n\n//     function buildSpecificDynamicMarketBundle(\n//         address _marketFactory,\n//         AMMFactory _ammFactory,\n//         uint256 _marketId\n//     ) internal view returns (SpecificDynamicMarketBundle memory _bundle) {\n//         TrustedMarketFactoryV3.MarketDetails memory _details =\n//             TrustedMarketFactoryV3(_marketFactory).getMarketDetails(_marketId);\n//         _bundle._super = buildDynamicMarketBundle(TrustedMarketFactoryV3(_marketFactory), _ammFactory, _marketId);\n//         _bundle.description = _details.description;\n//     }\n\n//     function fetchInitial(\n//         address _marketFactory,\n//         AMMFactory _ammFactory,\n//         MasterChef _masterChef,\n//         uint256 _offset,\n//         uint256 _total\n//     )\n//         public\n//         view\n//         returns (\n//             SpecificMarketFactoryBundle memory _marketFactoryBundle,\n//             SpecificStaticMarketBundle[] memory _marketBundles,\n//             uint256 _lowestMarketIndex,\n//             uint256 _timestamp\n//         )\n//     {\n//         _marketFactoryBundle = buildSpecificMarketFactoryBundle(_marketFactory);\n\n//         uint256[] memory _marketIds;\n//         (_marketIds, _lowestMarketIndex) = listOfInterestingMarkets(_marketFactory, _offset, _total);\n\n//         _total = _marketIds.length;\n//         _marketBundles = new SpecificStaticMarketBundle[](_total);\n//         for (uint256 i; i < _total; i++) {\n//             _marketBundles[i] = buildSpecificStaticMarketBundle(\n//                 _marketFactory,\n//                 _ammFactory,\n//                 _masterChef,\n//                 _marketIds[i]\n//             );\n//         }\n\n//         _timestamp = block.timestamp;\n//     }\n\n//     function fetchDynamic(\n//         address _marketFactory,\n//         AMMFactory _ammFactory,\n//         uint256 _offset,\n//         uint256 _total\n//     )\n//         public\n//         view\n//         returns (\n//             SpecificDynamicMarketBundle[] memory _bundles,\n//             uint256 _lowestMarketIndex,\n//             uint256 _timestamp\n//         )\n//     {\n//         uint256[] memory _marketIds;\n//         (_marketIds, _lowestMarketIndex) = listOfInterestingMarkets(_marketFactory, _offset, _total);\n\n//         _total = _marketIds.length;\n//         _bundles = new SpecificDynamicMarketBundle[](_total);\n//         for (uint256 i; i < _total; i++) {\n//             _bundles[i] = buildSpecificDynamicMarketBundle(_marketFactory, _ammFactory, _marketIds[i]);\n//         }\n\n//         _timestamp = block.timestamp;\n//     }\n\n//     // Starts from the end of the markets list because newer markets are more interesting.\n//     // _offset is skipping all markets, not just interesting markets\n//     function listOfInterestingMarkets(\n//         address _marketFactory,\n//         uint256 _offset,\n//         uint256 _total\n//     ) internal view returns (uint256[] memory _interestingMarketIds, uint256 _marketId) {\n//         _interestingMarketIds = new uint256[](_total);\n//         uint256 _max = AbstractMarketFactoryV3(_marketFactory).marketCount() - 1;\n\n//         // No markets so return nothing. (needed to prevent integer underflow below)\n//         if (_max == 0 || _offset >= _max) {\n//             return (new uint256[](0), 0);\n//         }\n\n//         // Starts at the end, less offset.\n//         // Stops before the 0th market since that market is always fake.\n//         uint256 _collectedMarkets = 0;\n//         _marketId = _max - _offset;\n\n//         while (true) {\n//             if (openOrHasWinningShares(AbstractMarketFactoryV3(_marketFactory), _marketId)) {\n//                 _interestingMarketIds[_collectedMarkets] = _marketId;\n//                 _collectedMarkets++;\n//             }\n\n//             if (_collectedMarkets >= _total) break;\n//             if (_marketId == 1) break; // skipping 0th market, which is fake\n//             _marketId--; // starts out oone too high, so this works\n//         }\n\n//         if (_total > _collectedMarkets) {\n//             assembly {\n//                 // shortens array\n//                 mstore(_interestingMarketIds, _collectedMarkets)\n//             }\n//         }\n//     }"
    },
    "@openzeppelin/contracts/utils/math/SignedSafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/SignedSafeMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SignedSafeMath` is no longer needed starting with Solidity 0.8. The compiler\n * now has built in overflow checking.\n */\nlibrary SignedSafeMath {\n    /**\n     * @dev Returns the multiplication of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(int256 a, int256 b) internal pure returns (int256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two signed integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(int256 a, int256 b) internal pure returns (int256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(int256 a, int256 b) internal pure returns (int256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the addition of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(int256 a, int256 b) internal pure returns (int256) {\n        return a + b;\n    }\n}\n"
    },
    "contracts/turbo/MMAMarketFactoryV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./AbstractMarketFactoryV3.sol\";\nimport \"./FeePot.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/SignedSafeMath.sol\";\nimport \"../libraries/Sport.sol\";\nimport \"../libraries/ResolveByFiat.sol\";\nimport \"../libraries/HasHeadToHeadMarket.sol\";\nimport \"../libraries/Versioned.sol\";\n\ncontract MMAMarketFactoryV3 is AbstractMarketFactoryV3, SportView, ResolvesByFiat, HasHeadToHeadMarket, Versioned {\n    using SafeMath for uint256;\n    using SignedSafeMath for int256;\n\n    uint256 constant HeadToHead = 0;\n    string constant InvalidName = \"No Contest / Draw\";\n\n    constructor(\n        address _owner,\n        IERC20Full _collateral,\n        uint256 _shareFactor,\n        FeePot _feePot,\n        uint256[3] memory _fees,\n        address _protocol,\n        address _linkNode\n    )\n        AbstractMarketFactoryV3(_owner, _collateral, _shareFactor, _feePot, _fees, _protocol)\n        Versioned(\"v1.2.0\")\n        ManagedByLink(_linkNode)\n        HasHeadToHeadMarket(HeadToHead, InvalidName)\n    {}\n\n    function createEvent(\n        uint256 _eventId,\n        string memory _homeTeamName,\n        uint256 _homeTeamId,\n        string memory _awayTeamName,\n        uint256 _awayTeamId,\n        uint256 _startTimestamp,\n        int256[2] memory _moneylines // [home,away]\n    ) public onlyLinkNode returns (uint256[] memory _marketIds) {\n        _marketIds = makeMarkets(_moneylines, _homeTeamName, _awayTeamName);\n        makeSportsEvent(\n            _eventId,\n            _marketIds,\n            build1Line(),\n            _startTimestamp,\n            _homeTeamId,\n            _awayTeamId,\n            _homeTeamName,\n            _awayTeamName\n        );\n    }\n\n    function makeMarkets(\n        int256[2] memory _moneylines,\n        string memory _homeTeamName,\n        string memory _awayTeamName\n    ) internal returns (uint256[] memory _marketIds) {\n        _marketIds = new uint256[](1);\n        _marketIds[HeadToHead] = makeHeadToHeadMarket(_moneylines, _homeTeamName, _awayTeamName);\n    }\n\n    function resolveValidEvent(SportsEvent memory _event, uint256 _whoWon) internal override {\n        resolveHeadToHeadMarket(_event.markets[HeadToHead], _whoWon);\n    }\n\n    function resolveHeadToHeadMarket(uint256 _marketId, uint256 _whoWon) internal {\n        uint256 _shareTokenIndex = calcHeadToHeadWinner(_whoWon);\n        endMarket(_marketId, _shareTokenIndex);\n    }\n\n    function calcHeadToHeadWinner(uint256 _whoWon) internal pure returns (uint256) {\n        if (WhoWonHome == _whoWon) {\n            return HeadToHeadHome;\n        } else if (WhoWonAway == _whoWon) {\n            return HeadToHeadAway;\n        } else {\n            return NoContest; // shouldn't happen here\n        }\n    }\n}\n"
    },
    "contracts/turbo/CryptoMarketFactoryV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../libraries/IERC20Full.sol\";\nimport \"../balancer/BPool.sol\";\nimport \"./AbstractMarketFactoryV3.sol\";\nimport \"./FeePot.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/SignedSafeMath.sol\";\nimport \"../utils/AggregatorV3Interface.sol\";\nimport \"../libraries/CalculateLinesToBPoolOdds.sol\";\nimport \"../libraries/Versioned.sol\";\nimport \"../libraries/ManagedByLink.sol\";\nimport \"../libraries/Rewardable.sol\";\n\ncontract CryptoMarketFactoryV3 is AbstractMarketFactoryV3, CalculateLinesToBPoolOdds, Versioned, ManagedByLink {\n    using SafeMath for uint256;\n    using SignedSafeMath for int256;\n\n    event CoinAdded(uint256 indexed id, string name);\n\n    event NewPrices(uint256 indexed nextResolutionTime, uint256[] markets, uint256[] prices);\n\n    struct Coin {\n        string name;\n        AggregatorV3Interface priceFeed;\n        uint256 price;\n        uint8 imprecision; // how many decimals to truncate\n        uint256[1] currentMarkets;\n    }\n    Coin[] public coins;\n\n    enum MarketType {\n        PriceUpDown // 0\n    }\n    enum PriceUpDownOutcome {\n        Above, // 0\n        NotAbove // 1\n    }\n    struct MarketDetails {\n        MarketType marketType;\n        uint256 coinIndex;\n        uint256 creationPrice;\n        uint256 resolutionPrice;\n        uint256 resolutionTime; // price at given time; this is that time\n    }\n    // MarketId => MarketDetails\n    mapping(uint256 => MarketDetails) internal marketDetails;\n\n    uint256 public nextResolutionTime;\n\n    constructor(\n        address _owner,\n        IERC20Full _collateral,\n        uint256 _shareFactor,\n        FeePot _feePot,\n        uint256[3] memory _fees,\n        address _protocol,\n        address _linkNode\n    )\n        AbstractMarketFactoryV3(_owner, _collateral, _shareFactor, _feePot, _fees, _protocol)\n        Versioned(\"v1.2.0\")\n        ManagedByLink(_linkNode)\n    {\n        string memory _name = \"\";\n        coins.push(makeCoin(_name, AggregatorV3Interface(address(0)), 0));\n    }\n\n    function getMarketDetails(uint256 _marketId) public view returns (MarketDetails memory) {\n        return marketDetails[_marketId];\n    }\n\n    // NOTE: Trusts the owner not to add a coin twice.\n    // Returns the coin index.\n    function addCoin(\n        string calldata _name,\n        AggregatorV3Interface _priceFeed,\n        uint8 _imprecision\n    ) external onlyOwner returns (uint256 _coinIndex) {\n        Coin memory _coin = makeCoin(_name, _priceFeed, _imprecision);\n        _coinIndex = coins.length;\n        coins.push(_coin);\n        emit CoinAdded(_coinIndex, _name);\n    }\n\n    function getCoin(uint256 _coinIndex) public view returns (Coin memory _coin) {\n        _coin = coins[_coinIndex];\n    }\n\n    function getCoins() public view returns (Coin[] memory _coins) {\n        _coins = new Coin[](coins.length);\n        // Skip first coin because it's always the zeroed-out fake coin.\n        for (uint256 i = 1; i < coins.length; i++) {\n            _coins[i] = coins[i];\n        }\n    }\n\n    // Iterates over all coins.\n    // If markets do not exist for coin, create them.\n    // Unless _nextResolutionTime is zero; then do not create new markets.\n    // If markets for coin exist and are ready to resolve, resolve them and create new markets.\n    // Else, error.\n    //\n    // Assume that _roundIds has a dummy value at index 0, and is 1 indexed like the\n    // coins array.\n    function createAndResolveMarkets(uint80[] calldata _roundIds, uint256 _nextResolutionTime) public onlyLinkNode {\n        // If market creation was stopped then it can be started again.\n        // If market creation wasn't stopped then you must wait for market end time to resolve.\n        require(block.timestamp >= nextResolutionTime, \"Must wait for market resolution\");\n        require(_roundIds.length == coins.length, \"Must specify one roundId for each coin\");\n\n        uint256 _resolutionTime = nextResolutionTime;\n        nextResolutionTime = _nextResolutionTime;\n\n        uint256[] memory _prices = new uint256[](coins.length - 1);\n        uint256[] memory _newMarketIds = new uint256[](coins.length - 1);\n        // Start at 1 to skip the fake Coin in the 0 index\n        for (uint256 i = 1; i < coins.length; i++) {\n            (_prices[i - 1], _newMarketIds[i - 1]) = createAndResolveMarketsForCoin(i, _resolutionTime, _roundIds[i]);\n        }\n\n        emit NewPrices(nextResolutionTime, _newMarketIds, _prices);\n    }\n\n    function createAndResolveMarketsForCoin(\n        uint256 _coinIndex,\n        uint256 _resolutionTime,\n        uint80 _roundId\n    ) internal returns (uint256 _price, uint256 _newMarketId) {\n        Coin memory _coin = coins[_coinIndex];\n        (uint256 _fullPrice, uint256 _newPrice) = getPrice(_coin, _roundId, _resolutionTime);\n\n        // resolve markets\n        if (_coin.currentMarkets[uint256(MarketType.PriceUpDown)] != 0) {\n            resolvePriceUpDownMarket(_coin, _newPrice, _fullPrice);\n        }\n\n        // update price only AFTER resolution\n        coins[_coinIndex].price = _newPrice;\n\n        // link node sets nextResolutionTime to zero to signify \"do not create markets after resolution\"\n        if (nextResolutionTime == 0) {\n            return (0, 0);\n        }\n\n        // create markets\n        _newMarketId = createPriceUpDownMarket(_coinIndex, linkNode, _newPrice);\n        coins[_coinIndex].currentMarkets[uint256(MarketType.PriceUpDown)] = _newMarketId;\n\n        return (_newPrice, _newMarketId);\n    }\n\n    function resolvePriceUpDownMarket(\n        Coin memory _coin,\n        uint256 _newPrice,\n        uint256 _fullPrice\n    ) internal {\n        uint256 _marketId = _coin.currentMarkets[uint256(MarketType.PriceUpDown)];\n\n        uint256 _winningOutcome;\n        if (_newPrice > _coin.price) {\n            _winningOutcome = uint256(PriceUpDownOutcome.Above);\n        } else {\n            _winningOutcome = uint256(PriceUpDownOutcome.NotAbove);\n        }\n\n        endMarket(_marketId, _winningOutcome);\n        marketDetails[_marketId].resolutionPrice = _fullPrice;\n    }\n\n    function createPriceUpDownMarket(\n        uint256 _coinIndex,\n        address _creator,\n        uint256 _newPrice\n    ) internal returns (uint256 _id) {\n        string[] memory _outcomes = new string[](2);\n        _outcomes[uint256(PriceUpDownOutcome.Above)] = \"Above\";\n        _outcomes[uint256(PriceUpDownOutcome.NotAbove)] = \"Not Above\";\n\n        _id = startMarket(_creator, _outcomes, evenOdds(false, 2), true);\n        marketDetails[_id] = MarketDetails(MarketType.PriceUpDown, _coinIndex, _newPrice, 0, nextResolutionTime);\n    }\n\n    // Returns the price based on a few factors.\n    // If _roundId is zero then it returns the latest price.\n    // Else, it returns the price for that round,\n    //       but errors if that isn't the first round after the resolution time.\n    // The price is then altered to match the desired precision.\n    function getPrice(\n        Coin memory _coin,\n        uint80 _roundId,\n        uint256 _resolutionTime\n    ) internal view returns (uint256 _fullPrice, uint256 _truncatedPrice) {\n        if (_roundId == 0) {\n            (, int256 _rawPrice, , , ) = _coin.priceFeed.latestRoundData();\n            require(_rawPrice >= 0, \"Price from feed is negative\");\n            _fullPrice = uint256(_rawPrice);\n        } else {\n            (, int256 _rawPrice, , uint256 updatedAt, ) = _coin.priceFeed.getRoundData(_roundId);\n            require(_rawPrice >= 0, \"Price from feed is negative\");\n            require(updatedAt >= _resolutionTime, \"Price hasn't been updated yet\");\n\n            // if resolution time is zero then market creation was stopped, so the previous round doesn't matter\n            if (_resolutionTime != 0) {\n                (, , , uint256 _previousRoundTime, ) = _coin.priceFeed.getRoundData(previousRound(_roundId));\n                require(_previousRoundTime < _resolutionTime, \"Must use first round after resolution time\");\n            }\n\n            _fullPrice = uint256(_rawPrice);\n        }\n\n        // The precision is how many decimals the price has. Zero is dollars, 2 includes cents, 3 is tenths of a cent, etc.\n        // Our resolution rules want a certain precision. Like BTC is to the dollar and MATIC is to the cent.\n        // If somehow the decimals are larger than the desired precision then add zeroes to the end to meet the precision.\n        // This does not change the resolution outcome but does guard against decimals() changing and therefore altering the basis.\n\n        uint8 _precision = _coin.priceFeed.decimals(); // probably constant but that isn't guaranteed, so query each time\n        if (_precision > _coin.imprecision) {\n            uint8 _truncate = _precision - _coin.imprecision;\n            _truncatedPrice = _fullPrice / (10**_truncate);\n        } else if (_precision < _coin.imprecision) {\n            uint8 _greaten = _coin.imprecision - _precision;\n            _truncatedPrice = _fullPrice * (10**_greaten);\n        } else {\n            _truncatedPrice = _fullPrice;\n        }\n\n        // Round up because that cleanly fits Above/Not-Above.\n        if (_truncatedPrice != _fullPrice) {\n            _truncatedPrice += 1;\n        }\n    }\n\n    function makeCoin(\n        string memory _name,\n        AggregatorV3Interface _priceFeed,\n        uint8 _imprecision\n    ) internal pure returns (Coin memory _coin) {\n        uint256[1] memory _currentMarkets = [uint256(0)];\n        _coin = Coin(_name, _priceFeed, 0, _imprecision, _currentMarkets);\n    }\n\n    // The roundId is the encoding of two parts: the phase and the phase-specific round id.\n    // To find the previous roundId:\n    // 1. extract the phase and phase-specific round (I call these _phaseId and _roundId)\n    // 2. decrement the phase-specific round\n    // 3. re-encode the phase and phase-specific round.\n    uint256 private constant PHASE_OFFSET = 64;\n\n    function previousRound(uint80 _fullRoundId) internal pure returns (uint80) {\n        uint256 _phaseId = uint256(uint16(_fullRoundId >> PHASE_OFFSET));\n        uint64 _roundId = uint64(_fullRoundId) - 1;\n        return uint80((_phaseId << PHASE_OFFSET) | _roundId);\n    }\n\n    function getRewardEndTime(uint256 _marketId) public view override returns (uint256) {\n        return getMarketDetails(_marketId).resolutionTime;\n    }\n}\n"
    },
    "contracts/turbo/NBAMarketFactoryV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../libraries/IERC20Full.sol\";\nimport \"../balancer/BPool.sol\";\nimport \"./AbstractMarketFactoryV3.sol\";\nimport \"./FeePot.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/SignedSafeMath.sol\";\nimport \"../libraries/Sport.sol\";\nimport \"../libraries/HasSpreadMarket.sol\";\nimport \"../libraries/ResolveByScore.sol\";\nimport \"../libraries/Versioned.sol\";\n\ncontract NBAMarketFactoryV3 is AbstractMarketFactoryV3, SportView, HasSpreadMarket, ResolvesByScore, Versioned {\n    using SafeMath for uint256;\n    using SignedSafeMath for int256;\n\n    uint256 constant Spread = 0;\n    string constant InvalidName = \"No Contest\";\n\n    constructor(\n        address _owner,\n        IERC20Full _collateral,\n        uint256 _shareFactor,\n        FeePot _feePot,\n        uint256[3] memory _fees,\n        address _protocol,\n        address _linkNode\n    )\n        AbstractMarketFactoryV3(_owner, _collateral, _shareFactor, _feePot, _fees, _protocol)\n        Versioned(\"1.5.0\")\n        ManagedByLink(_linkNode)\n        HasSpreadMarket(Spread, InvalidName)\n    {}\n\n    function createEvent(\n        uint256 _eventId,\n        string memory _homeTeamName,\n        uint256 _homeTeamId,\n        string memory _awayTeamName,\n        uint256 _awayTeamId,\n        uint256 _startTimestamp,\n        int256 _homeSpread\n    ) public onlyLinkNode returns (uint256[] memory _marketIds) {\n        _marketIds = makeMarkets(_homeTeamName, _awayTeamName);\n        makeSportsEvent(\n            _eventId,\n            _marketIds,\n            makeLine(_homeSpread),\n            _startTimestamp,\n            _homeTeamId,\n            _awayTeamId,\n            _homeTeamName,\n            _awayTeamName\n        );\n    }\n\n    function makeMarkets(string memory _homeTeamName, string memory _awayTeamName)\n        internal\n        returns (uint256[] memory _marketIds)\n    {\n        _marketIds = new uint256[](1);\n        _marketIds[Spread] = makeSpreadMarket(_homeTeamName, _awayTeamName);\n    }\n\n    function makeLine(int256 _homeSpread) internal pure returns (int256[] memory _line) {\n        _line = build1Line();\n        _line[0] = addHalfPoint(_homeSpread);\n    }\n\n    function resolveValidEvent(\n        SportsEvent memory _event,\n        uint256 _homeScore,\n        uint256 _awayScore\n    ) internal override {\n        resolveSpreadMarket(_event.markets[Spread], _event.lines[Spread], _homeScore, _awayScore);\n    }\n}\n"
    },
    "contracts/rewards/MasterChef.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\" as OpenZeppelinOwnable;\nimport \"../turbo/AbstractMarketFactoryV3.sol\";\nimport \"../turbo/AMMFactory.sol\";\n\n// MasterChef is the master of Reward. He can make Reward and he is a fair guy.\ncontract MasterChef is OpenZeppelinOwnable.Ownable {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    uint256 public constant BONE = 10**18;\n\n    // The percentage of the rewards period that early deposit bonus will payout.\n    // e.g. Early deposit bonus hits if LP is done in the first x percent of the period.\n    uint256 public constant EARLY_DEPOSIT_BONUS_REWARDS_PERCENTAGE = BONE / 10; // 10% of reward period.\n\n    // Info of each user.\n    struct UserInfo {\n        uint256 amount; // How many LP tokens the user has provided.\n        uint256 rewardDebt; // Reward debt. See explanation below.\n        uint256 lastActionTimestamp; // Timestamp of the withdrawal or deposit from this user.\n        //\n        // We do some fancy math here. Basically, any point in time, the amount of REWARDs\n        // entitled to a user but is pending to be distributed is:\n        //\n        //   pending reward = (user.amount * pool.accRewardsPerShare) - user.rewardDebt\n        //\n        // Whenever a user deposits or withdraws LP tokens to a pool. Here's what happens:\n        //   1. The pool's `accRewardsPerShare` (and `lastRewardBlock`) gets updated.\n        //   2. User receives the pending reward sent to his/her address.\n        //   3. User's `amount` gets updated.\n        //   4. User's `rewardDebt` gets updated.\n    }\n    // Info of each user that deposits LP tokens.\n    mapping(uint256 => mapping(address => UserInfo)) public userInfo;\n\n    // Info of each pool.\n    struct PoolInfo {\n        IERC20 lpToken; // Address of LP token contract.\n        uint256 accRewardsPerShare; // Accumulated REWARDs per share, times BONE. See below.\n        uint256 totalEarlyDepositBonusRewardShares; // The total number of share currently qualifying bonus REWARDs.\n        uint256 beginTimestamp; // The timestamp to begin calculating rewards at.\n        uint256 endTimestamp; // Timestamp of the end of the rewards period.\n        uint256 earlyDepositBonusRewards; // Amount of REWARDs to distribute to early depositors.\n        uint256 lastRewardTimestamp; // Last timestamp REWARDs distribution occurred.\n        uint256 rewardsPerSecond; // Number of rewards paid out per second.\n    }\n    // Info of each pool.\n    PoolInfo[] public poolInfo;\n\n    // This is a snapshot of the current state of a market.\n    struct PoolStatusInfo {\n        uint256 beginTimestamp;\n        uint256 endTimestamp;\n        uint256 earlyDepositEndTimestamp;\n        uint256 totalRewardsAccrued;\n        bool created;\n    }\n\n    struct PendingRewardInfo {\n        uint256 beginTimestamp;\n        uint256 endTimestamp;\n        uint256 earlyDepositEndTimestamp;\n        uint256 accruedStandardRewards;\n        uint256 accruedEarlyDepositBonusRewards;\n        uint256 pendingEarlyDepositBonusRewards;\n        bool created;\n    }\n\n    struct MarketFactoryInfo {\n        uint256 earlyDepositBonusRewards; // Amount of REWARDs per day to distribute to early depositors.\n        uint256 rewardsPeriods; // Number of days the rewards for this pool will payout.\n        uint256 rewardsPerPeriod; // Amount of rewards to be given out for a given period.\n    }\n    mapping(address => MarketFactoryInfo) marketFactoryRewardInfo;\n\n    struct RewardPoolLookupInfo {\n        uint256 pid;\n        bool created;\n    }\n\n    // AMMFactory => MarketFactory => MarketId\n    mapping(address => mapping(address => mapping(uint256 => RewardPoolLookupInfo))) public rewardPoolLookup;\n\n    // The REWARD TOKEN!\n    IERC20 private rewardsToken;\n\n    mapping(address => bool) private approvedAMMFactories;\n\n    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);\n    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount, address recipient);\n    event TrustMarketFactory(\n        address indexed MarketFactory,\n        uint256 OriginEarlyDepositBonusRewards,\n        uint256 OriginrewardsPeriods,\n        uint256 OriginRewardsPerPeriod,\n        uint256 EarlyDepositBonusRewards,\n        uint256 rewardsPeriods,\n        uint256 RewardsPerPeriod\n    );\n\n    event PoolCreated(\n        address indexed ammFactory,\n        address indexed marketFactory,\n        uint256 indexed marketId,\n        address creator,\n        address lpTokenRecipient\n    );\n    event LiquidityChanged(\n        address indexed ammFactory,\n        address indexed marketFactory,\n        uint256 indexed marketId,\n        address user,\n        address recipient,\n        // from the perspective of the user. e.g. collateral is negative when adding liquidity\n        int256 collateral,\n        int256 lpTokens,\n        uint256[] sharesReturned\n    );\n\n    event EmergencyWithdraw(address indexed user, uint256 indexed pid, uint256 amount);\n\n    constructor(IERC20 _rewardsToken) {\n        rewardsToken = _rewardsToken;\n    }\n\n    function trustAMMFactory(address _ammFactory) public onlyOwner {\n        approvedAMMFactories[_ammFactory] = true;\n    }\n\n    function untrustAMMFactory(address _ammFactory) public onlyOwner {\n        delete approvedAMMFactories[_ammFactory];\n    }\n\n    // This method can also be used to update rewards\n    function addRewards(\n        address _marketFactory,\n        uint256 _rewardsPerMarket,\n        uint256 _rewardDaysPerMarket,\n        uint256 _earlyDepositBonusRewards\n    ) public onlyOwner {\n        MarketFactoryInfo memory _oldMarketFactoryInfo = marketFactoryRewardInfo[_marketFactory];\n\n        marketFactoryRewardInfo[_marketFactory] = MarketFactoryInfo({\n            rewardsPeriods: _rewardDaysPerMarket,\n            rewardsPerPeriod: _rewardsPerMarket,\n            earlyDepositBonusRewards: _earlyDepositBonusRewards\n        });\n\n        emit TrustMarketFactory(\n            _marketFactory,\n            _oldMarketFactoryInfo.earlyDepositBonusRewards,\n            _oldMarketFactoryInfo.rewardsPeriods,\n            _oldMarketFactoryInfo.rewardsPerPeriod,\n            _earlyDepositBonusRewards,\n            _rewardDaysPerMarket,\n            _rewardsPerMarket\n        );\n    }\n\n    function poolLength() external view returns (uint256) {\n        return poolInfo.length;\n    }\n\n    // Add a new lp to the pool. Can only be called by the owner.\n    // XXX DO NOT add the same LP token more than once. Rewards will be messed up if you do.\n    // An _endTimestamp of zero means the rewards start immediately.\n    function add(\n        address _ammFactory,\n        address _marketFactory,\n        uint256 _marketId,\n        IERC20 _lpToken,\n        uint256 _endTimestamp\n    ) public onlyOwner returns (uint256 _nextPID) {\n        return addInternal(_ammFactory, _marketFactory, _marketId, _lpToken, _endTimestamp);\n    }\n\n    function addInternal(\n        address _ammFactory,\n        address _marketFactory,\n        uint256 _marketId,\n        IERC20 _lpToken,\n        uint256 _endTimestamp\n    ) internal returns (uint256 _nextPID) {\n        require(\n            !rewardPoolLookup[_ammFactory][_marketFactory][_marketId].created,\n            \"Reward pool has already been created.\"\n        );\n\n        require(approvedAMMFactories[address(_ammFactory)], \"AMMFactory must be approved to create pool\");\n\n        _nextPID = poolInfo.length;\n\n        rewardPoolLookup[_ammFactory][_marketFactory][_marketId] = RewardPoolLookupInfo({pid: _nextPID, created: true});\n\n        MarketFactoryInfo memory _marketFactoryInfo = marketFactoryRewardInfo[_marketFactory];\n\n        // Need to figure out the beginning/end of the reward period.\n        uint256 _rewardsPeriodsInSeconds = _marketFactoryInfo.rewardsPeriods * 1 days;\n        uint256 _beginTimestamp = block.timestamp;\n\n        // Add one hour buffer for LPs to withdraw before event start.\n        if (_endTimestamp != 0) {\n            _endTimestamp = _endTimestamp - 1 hours;\n        }\n\n        if (_endTimestamp == 0) {\n            _endTimestamp = _beginTimestamp + _rewardsPeriodsInSeconds;\n        } else if ((_endTimestamp - _rewardsPeriodsInSeconds) > block.timestamp) {\n            _beginTimestamp = _endTimestamp - _rewardsPeriodsInSeconds;\n        } else if (block.timestamp >= _endTimestamp) {\n            // reward period already over.\n            _beginTimestamp = _endTimestamp;\n        }\n        poolInfo.push(\n            PoolInfo({\n                accRewardsPerShare: 0,\n                beginTimestamp: _beginTimestamp,\n                endTimestamp: _endTimestamp,\n                totalEarlyDepositBonusRewardShares: 0,\n                earlyDepositBonusRewards: (_marketFactoryInfo.earlyDepositBonusRewards / 1 days) *\n                    (_endTimestamp - _beginTimestamp),\n                lpToken: _lpToken,\n                rewardsPerSecond: (_marketFactoryInfo.rewardsPerPeriod / 1 days),\n                lastRewardTimestamp: _beginTimestamp\n            })\n        );\n    }\n\n    // Return number of seconds elapsed in terms of BONEs.\n    function getTimeElapsed(uint256 _pid) public view returns (uint256) {\n        PoolInfo storage _pool = poolInfo[_pid];\n        uint256 _fromTimestamp = block.timestamp;\n\n        if (\n            // Rewards have not started yet.\n            _pool.beginTimestamp > _fromTimestamp ||\n            // Not sure how this happens but it is accounted for in the original master chef contract.\n            _pool.lastRewardTimestamp > _fromTimestamp ||\n            // No rewards to be distributed\n            _pool.rewardsPerSecond == 0\n        ) {\n            return 0;\n        }\n\n        // Rewards are over for this pool. No more rewards have accrued.\n        if (_pool.lastRewardTimestamp >= _pool.endTimestamp) {\n            return 0;\n        }\n\n        return min(_fromTimestamp, _pool.endTimestamp).sub(_pool.lastRewardTimestamp).add(1).mul(BONE);\n        // return (min(_fromTimestamp, _pool.endTimestamp) - _pool.lastRewardTimestamp + 1) * BONE;\n    }\n\n    function getPoolTokenBalance(\n        AMMFactory _ammFactory,\n        AbstractMarketFactoryV3 _marketFactory,\n        uint256 _marketId,\n        address _user\n    ) external view returns (uint256) {\n        RewardPoolLookupInfo memory _rewardPoolLookupInfo =\n            rewardPoolLookup[address(_ammFactory)][address(_marketFactory)][_marketId];\n\n        if (_rewardPoolLookupInfo.created) {\n            return userInfo[_rewardPoolLookupInfo.pid][_user].amount;\n        } else {\n            return 0;\n        }\n    }\n\n    function getUserAmount(uint256 _pid, address _user) external view returns (uint256) {\n        return userInfo[_pid][_user].amount;\n    }\n\n    function getPoolRewardEndTimestamp(uint256 _pid) public view returns (uint256) {\n        PoolInfo storage _pool = poolInfo[_pid];\n        return _pool.endTimestamp;\n    }\n\n    function getEarlyDepositEndTimestamp(uint256 _pid) public view returns (uint256) {\n        PoolInfo storage _pool = poolInfo[_pid];\n        uint256 _duration = _pool.endTimestamp - _pool.beginTimestamp;\n\n        return ((_duration * EARLY_DEPOSIT_BONUS_REWARDS_PERCENTAGE) / BONE) + _pool.beginTimestamp + 1;\n    }\n\n    function getPoolLPTokenTotalSupply(\n        AMMFactory _ammFactory,\n        AbstractMarketFactoryV3 _marketFactory,\n        uint256 _marketId\n    ) public view returns (uint256) {\n        RewardPoolLookupInfo memory _rewardPoolLookupInfo =\n            rewardPoolLookup[address(_ammFactory)][address(_marketFactory)][_marketId];\n\n        return poolInfo[_rewardPoolLookupInfo.pid].lpToken.totalSupply();\n    }\n\n    function getPoolLPToken(\n        AMMFactory _ammFactory,\n        AbstractMarketFactoryV3 _marketFactory,\n        uint256 _marketId\n    ) public view returns (IERC20) {\n        RewardPoolLookupInfo memory _rewardPoolLookupInfo =\n            rewardPoolLookup[address(_ammFactory)][address(_marketFactory)][_marketId];\n\n        return poolInfo[_rewardPoolLookupInfo.pid].lpToken;\n    }\n\n    function getPoolInfo(\n        AMMFactory _ammFactory,\n        AbstractMarketFactoryV3 _marketFactory,\n        uint256 _marketId\n    ) public view returns (PoolStatusInfo memory _poolStatusInfo) {\n        RewardPoolLookupInfo memory _rewardPoolLookupInfo =\n            rewardPoolLookup[address(_ammFactory)][address(_marketFactory)][_marketId];\n\n        // This cannot revert as it will be used in a multicall.\n        if (_rewardPoolLookupInfo.created) {\n            PoolInfo storage _pool = poolInfo[_rewardPoolLookupInfo.pid];\n\n            _poolStatusInfo.beginTimestamp = _pool.beginTimestamp;\n            _poolStatusInfo.endTimestamp = _pool.endTimestamp;\n            _poolStatusInfo.earlyDepositEndTimestamp = getEarlyDepositEndTimestamp(_rewardPoolLookupInfo.pid);\n\n            _poolStatusInfo.totalRewardsAccrued =\n                (min(block.timestamp, _pool.endTimestamp) - _pool.beginTimestamp) *\n                _pool.rewardsPerSecond;\n            _poolStatusInfo.created = true;\n        }\n    }\n\n    // View function to see pending REWARDs on frontend.\n    function getUserPendingRewardInfo(\n        AMMFactory _ammFactory,\n        AbstractMarketFactoryV3 _marketFactory,\n        uint256 _marketId,\n        address _userAddress\n    ) external view returns (PendingRewardInfo memory _pendingRewardInfo) {\n        RewardPoolLookupInfo memory _rewardPoolLookupInfo =\n            rewardPoolLookup[address(_ammFactory)][address(_marketFactory)][_marketId];\n\n        if (_rewardPoolLookupInfo.created) {\n            PoolInfo storage _pool = poolInfo[_rewardPoolLookupInfo.pid];\n            UserInfo storage _user = userInfo[_rewardPoolLookupInfo.pid][_userAddress];\n            uint256 accRewardsPerShare = _pool.accRewardsPerShare;\n            uint256 lpSupply = _pool.lpToken.balanceOf(address(this));\n\n            uint256 _duration = _pool.endTimestamp - _pool.beginTimestamp;\n\n            _pendingRewardInfo.created = true;\n            _pendingRewardInfo.beginTimestamp = _pool.beginTimestamp;\n            _pendingRewardInfo.endTimestamp = _pool.endTimestamp;\n            _pendingRewardInfo.earlyDepositEndTimestamp = getEarlyDepositEndTimestamp(_rewardPoolLookupInfo.pid);\n\n            if (_user.lastActionTimestamp <= _pendingRewardInfo.earlyDepositEndTimestamp) {\n                if (_pool.totalEarlyDepositBonusRewardShares > 0 && block.timestamp > _pendingRewardInfo.endTimestamp) {\n                    _pendingRewardInfo.accruedEarlyDepositBonusRewards = _pool\n                        .earlyDepositBonusRewards\n                        .mul(_user.amount)\n                        .div(_pool.totalEarlyDepositBonusRewardShares);\n                } else if (_pool.totalEarlyDepositBonusRewardShares > 0) {\n                    _pendingRewardInfo.pendingEarlyDepositBonusRewards = _pool\n                        .earlyDepositBonusRewards\n                        .mul(_user.amount)\n                        .div(_pool.totalEarlyDepositBonusRewardShares);\n                }\n            }\n\n            if (block.timestamp > _pool.lastRewardTimestamp && lpSupply != 0) {\n                uint256 multiplier = getTimeElapsed(_rewardPoolLookupInfo.pid);\n                accRewardsPerShare = accRewardsPerShare.add(multiplier.mul(_pool.rewardsPerSecond).div(lpSupply));\n            }\n\n            _pendingRewardInfo.accruedStandardRewards = _user.amount.mul(accRewardsPerShare).div(BONE).sub(\n                _user.rewardDebt\n            );\n        }\n    }\n\n    // Update reward variables for all pools. Be careful of gas spending!\n    function massUpdatePools() public {\n        uint256 length = poolInfo.length;\n        for (uint256 pid = 0; pid < length; ++pid) {\n            updatePool(pid);\n        }\n    }\n\n    // Update reward variables of the given pool to be up-to-date.\n    function updatePool(uint256 _pid) public {\n        PoolInfo storage pool = poolInfo[_pid];\n        if (block.timestamp <= pool.lastRewardTimestamp) {\n            return;\n        }\n        uint256 lpSupply = pool.lpToken.balanceOf(address(this));\n        if (lpSupply == 0) {\n            pool.lastRewardTimestamp = block.timestamp;\n            return;\n        }\n        uint256 multiplier = getTimeElapsed(_pid);\n        pool.accRewardsPerShare = pool.accRewardsPerShare.add(multiplier.mul(pool.rewardsPerSecond).div(lpSupply));\n        pool.lastRewardTimestamp = block.timestamp;\n    }\n\n    // Deposit LP tokens to MasterChef for REWARD allocation.\n    // Assumes the staked tokens are already on contract.\n    function depositInternal(\n        address _userAddress,\n        uint256 _pid,\n        uint256 _amount\n    ) internal {\n        PoolInfo storage _pool = poolInfo[_pid];\n        UserInfo storage _user = userInfo[_pid][_userAddress];\n\n        updatePool(_pid);\n\n        if (_user.amount > 0) {\n            uint256 pending = _user.amount.mul(_pool.accRewardsPerShare).div(BONE).sub(_user.rewardDebt);\n            safeRewardsTransfer(_userAddress, pending);\n        }\n\n        uint256 _rewardsPeriodsInSeconds = _pool.endTimestamp - _pool.beginTimestamp;\n        uint256 _bonusrewardsPeriodsEndTimestamp =\n            ((_rewardsPeriodsInSeconds * EARLY_DEPOSIT_BONUS_REWARDS_PERCENTAGE) / BONE) + _pool.beginTimestamp + 1;\n\n        // If the user was an early deposit, remove user amount from the pool.\n        // Even if the pools reward period has elapsed. They must withdraw first.\n        if (\n            block.timestamp > _bonusrewardsPeriodsEndTimestamp &&\n            _user.lastActionTimestamp <= _bonusrewardsPeriodsEndTimestamp\n        ) {\n            _pool.totalEarlyDepositBonusRewardShares = _pool.totalEarlyDepositBonusRewardShares.sub(_user.amount);\n        }\n\n        // Still in the early deposit bonus period.\n        if (_bonusrewardsPeriodsEndTimestamp > block.timestamp) {\n            _pool.totalEarlyDepositBonusRewardShares = _pool.totalEarlyDepositBonusRewardShares.add(_amount);\n        }\n\n        _user.amount = _user.amount.add(_amount);\n\n        _user.rewardDebt = _user.amount.mul(_pool.accRewardsPerShare).div(BONE);\n        _user.lastActionTimestamp = block.timestamp;\n        emit Deposit(_userAddress, _pid, _amount);\n    }\n\n    function depositByMarket(\n        AMMFactory _ammFactory,\n        AbstractMarketFactoryV3 _marketFactory,\n        uint256 _marketId,\n        uint256 _amount\n    ) public {\n        RewardPoolLookupInfo memory _rewardPoolLookupInfo =\n            rewardPoolLookup[address(_ammFactory)][address(_marketFactory)][_marketId];\n\n        require(_rewardPoolLookupInfo.created, \"Reward pool has not been created.\");\n\n        deposit(_rewardPoolLookupInfo.pid, _amount);\n    }\n\n    function deposit(uint256 _pid, uint256 _amount) public {\n        depositInternal(msg.sender, _pid, _amount);\n        poolInfo[_pid].lpToken.safeTransferFrom(msg.sender, address(this), _amount);\n    }\n\n    // Withdraw LP tokens from MasterChef.\n    // Assumes caller is handling distribution of LP tokens.\n    function withdrawInternal(\n        address _userAddress,\n        uint256 _pid,\n        uint256 _amount,\n        address _tokenRecipientAddress\n    ) internal {\n        PoolInfo storage _pool = poolInfo[_pid];\n        UserInfo storage _user = userInfo[_pid][_userAddress];\n        require(_user.amount >= _amount, \"withdraw: not good\");\n\n        updatePool(_pid);\n\n        uint256 _rewardsPeriodsInSeconds = _pool.endTimestamp - _pool.beginTimestamp;\n        uint256 _bonusrewardsPeriodsEndTimestamp =\n            ((_rewardsPeriodsInSeconds * EARLY_DEPOSIT_BONUS_REWARDS_PERCENTAGE) / BONE) + _pool.beginTimestamp + 1;\n        uint256 _rewardPeriodEndTimestamp = _rewardsPeriodsInSeconds + _pool.beginTimestamp + 1;\n\n        if (_rewardPeriodEndTimestamp <= block.timestamp) {\n            if (\n                _pool.totalEarlyDepositBonusRewardShares > 0 &&\n                _user.lastActionTimestamp <= _bonusrewardsPeriodsEndTimestamp\n            ) {\n                uint256 _rewardsToUser =\n                    _pool.earlyDepositBonusRewards.mul(_user.amount).div(_pool.totalEarlyDepositBonusRewardShares);\n                safeRewardsTransfer(_userAddress, _rewardsToUser);\n            }\n        } else if (_bonusrewardsPeriodsEndTimestamp >= block.timestamp) {\n            // Still in the early deposit bonus period.\n            _pool.totalEarlyDepositBonusRewardShares = _pool.totalEarlyDepositBonusRewardShares.sub(_amount);\n        } else if (\n            // If the user was an early deposit, remove user amount from the pool.\n            _bonusrewardsPeriodsEndTimestamp >= _user.lastActionTimestamp\n        ) {\n            _pool.totalEarlyDepositBonusRewardShares = _pool.totalEarlyDepositBonusRewardShares.sub(_user.amount);\n        }\n\n        uint256 pending = _user.amount.mul(_pool.accRewardsPerShare).div(BONE).sub(_user.rewardDebt);\n\n        safeRewardsTransfer(_tokenRecipientAddress, pending);\n        _user.amount = _user.amount.sub(_amount);\n        _user.rewardDebt = _user.amount.mul(_pool.accRewardsPerShare).div(BONE);\n        _user.lastActionTimestamp = block.timestamp;\n\n        emit Withdraw(msg.sender, _pid, _amount, _tokenRecipientAddress);\n    }\n\n    function withdrawByMarket(\n        AMMFactory _ammFactory,\n        AbstractMarketFactoryV3 _marketFactory,\n        uint256 _marketId,\n        uint256 _amount\n    ) public {\n        RewardPoolLookupInfo memory _rewardPoolLookupInfo =\n            rewardPoolLookup[address(_ammFactory)][address(_marketFactory)][_marketId];\n\n        require(_rewardPoolLookupInfo.created, \"Reward pool has not been created.\");\n\n        withdraw(_rewardPoolLookupInfo.pid, _amount);\n    }\n\n    function withdraw(uint256 _pid, uint256 _amount) public {\n        withdrawInternal(msg.sender, _pid, _amount, msg.sender);\n        poolInfo[_pid].lpToken.safeTransfer(msg.sender, _amount);\n    }\n\n    function createPool(\n        AMMFactory _ammFactory,\n        AbstractMarketFactoryV3 _marketFactory,\n        uint256 _marketId,\n        uint256 _initialLiquidity,\n        address _lpTokenRecipient\n    ) public returns (uint256) {\n        _marketFactory.collateral().transferFrom(msg.sender, address(this), _initialLiquidity);\n        _marketFactory.collateral().approve(address(_ammFactory), _initialLiquidity);\n\n        uint256 _lpTokensIn = _ammFactory.createPool(_marketFactory, _marketId, _initialLiquidity, address(this));\n        IERC20 _lpToken = IERC20(address(_ammFactory.getPool(_marketFactory, _marketId)));\n\n        uint256 _nextPID =\n            addInternal(\n                address(_ammFactory),\n                address(_marketFactory),\n                _marketId,\n                _lpToken,\n                _marketFactory.getRewardEndTime(_marketId)\n            );\n\n        depositInternal(_lpTokenRecipient, _nextPID, _lpTokensIn);\n\n        AbstractMarketFactoryV3.Market memory _market = _marketFactory.getMarket(_marketId);\n        uint256[] memory _balances = new uint256[](_market.shareTokens.length);\n        for (uint256 i = 0; i < _market.shareTokens.length; i++) {\n            _balances[i] = 0;\n        }\n\n        emit PoolCreated(address(_ammFactory), address(_marketFactory), _marketId, msg.sender, _lpTokenRecipient);\n        emit LiquidityChanged(\n            address(_ammFactory),\n            address(_marketFactory),\n            _marketId,\n            msg.sender,\n            _lpTokenRecipient,\n            -int256(_initialLiquidity),\n            int256(_lpTokensIn),\n            _balances\n        );\n\n        return _lpTokensIn;\n    }\n\n    function addLiquidity(\n        AMMFactory _ammFactory,\n        AbstractMarketFactoryV3 _marketFactory,\n        uint256 _marketId,\n        uint256 _collateralIn,\n        uint256 _minLPTokensOut,\n        address _lpTokenRecipient\n    ) public returns (uint256 _poolAmountOut, uint256[] memory _balances) {\n        RewardPoolLookupInfo memory _rewardPoolLookupInfo =\n            rewardPoolLookup[address(_ammFactory)][address(_marketFactory)][_marketId];\n\n        uint256 _pid = _rewardPoolLookupInfo.pid;\n\n        // If not created should attempt to create it.\n        if (!_rewardPoolLookupInfo.created) {\n            BPool _bPool = _ammFactory.getPool(_marketFactory, _marketId);\n            require(_bPool != BPool(address(0)), \"Pool not created.\");\n\n            _pid = addInternal(\n                address(_ammFactory),\n                address(_marketFactory),\n                _marketId,\n                IERC20(address(_bPool)),\n                _marketFactory.getRewardEndTime(_marketId)\n            );\n        }\n\n        _marketFactory.collateral().transferFrom(msg.sender, address(this), _collateralIn);\n        _marketFactory.collateral().approve(address(_ammFactory), _collateralIn);\n\n        (_poolAmountOut, _balances) = _ammFactory.addLiquidity(\n            _marketFactory,\n            _marketId,\n            _collateralIn,\n            _minLPTokensOut,\n            address(this)\n        );\n\n        AbstractMarketFactoryV3.Market memory _market = _marketFactory.getMarket(_marketId);\n        for (uint256 i = 0; i < _balances.length; i++) {\n            if (_balances[i] > 0) {\n                _market.shareTokens[i].transfer(_lpTokenRecipient, _balances[i]);\n            }\n        }\n\n        depositInternal(_lpTokenRecipient, _pid, _poolAmountOut);\n\n        emit LiquidityChanged(\n            address(_ammFactory),\n            address(_marketFactory),\n            _marketId,\n            msg.sender,\n            _lpTokenRecipient,\n            -int256(_collateralIn),\n            int256(_poolAmountOut),\n            _balances\n        );\n    }\n\n    function removeLiquidity(\n        AMMFactory _ammFactory,\n        AbstractMarketFactoryV3 _marketFactory,\n        uint256 _marketId,\n        uint256 _lpTokensIn,\n        uint256 _minCollateralOut,\n        address _collateralRecipient\n    ) public returns (uint256 _collateralOut, uint256[] memory _balances) {\n        RewardPoolLookupInfo memory _rewardPoolLookupInfo =\n            rewardPoolLookup[address(_ammFactory)][address(_marketFactory)][_marketId];\n\n        require(_rewardPoolLookupInfo.created, \"Reward pool has not been created.\");\n\n        withdrawInternal(msg.sender, _rewardPoolLookupInfo.pid, _lpTokensIn, _collateralRecipient);\n\n        PoolInfo storage _pool = poolInfo[_rewardPoolLookupInfo.pid];\n\n        _pool.lpToken.approve(address(_ammFactory), _lpTokensIn);\n\n        (_collateralOut, _balances) = _ammFactory.removeLiquidity(\n            _marketFactory,\n            _marketId,\n            _lpTokensIn,\n            _minCollateralOut,\n            _collateralRecipient\n        );\n\n        emit LiquidityChanged(\n            address(_ammFactory),\n            address(_marketFactory),\n            _marketId,\n            msg.sender,\n            _collateralRecipient,\n            int256(_collateralOut),\n            -int256(_lpTokensIn),\n            _balances\n        );\n    }\n\n    function withdrawRewards(uint256 _amount) external onlyOwner {\n        rewardsToken.transfer(msg.sender, _amount);\n    }\n\n    // Withdraw without caring about rewards. EMERGENCY ONLY.\n    function emergencyWithdraw(uint256 _pid) public {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        pool.lpToken.safeTransfer(address(msg.sender), user.amount);\n        emit EmergencyWithdraw(msg.sender, _pid, user.amount);\n        user.amount = 0;\n        user.rewardDebt = 0;\n        user.lastActionTimestamp = 0;\n    }\n\n    function safeRewardsTransfer(address _to, uint256 _amount) internal {\n        uint256 _rewardsBal = rewardsToken.balanceOf(address(this));\n        if (_amount > _rewardsBal) {\n            rewardsToken.transfer(_to, _rewardsBal);\n        } else {\n            rewardsToken.transfer(_to, _amount);\n        }\n    }\n\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a <= b) {\n            return a;\n        } else {\n            return b;\n        }\n    }\n}\n"
    },
    "contracts/turbo/CryptoCurrencyMarketFactoryV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../libraries/IERC20Full.sol\";\nimport \"../balancer/BPool.sol\";\nimport \"./AbstractMarketFactoryV3.sol\";\nimport \"./FeePot.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/SignedSafeMath.sol\";\nimport \"../utils/AggregatorV3Interface.sol\";\nimport \"../libraries/CalculateLinesToBPoolOdds.sol\";\nimport \"../libraries/Versioned.sol\";\nimport \"../libraries/ManagedByLink.sol\";\n\ncontract CryptoCurrencyMarketFactoryV3 is AbstractMarketFactoryV3, CalculateLinesToBPoolOdds, Versioned, ManagedByLink {\n    using SafeMath for uint256;\n    using SignedSafeMath for int256;\n\n    event CoinAdded(uint256 indexed id, string name);\n    event ValueUpdate(uint256 indexed coinIndex, uint256 indexed resolutionTime, uint256 market, uint256 value);\n\n    enum Outcome {\n        Above, // 0\n        NotAbove // 1\n    }\n    string constant Above = \"Above\";\n    string constant NotAbove = \"Not Above\";\n\n    struct Coin {\n        string name;\n        AggregatorV3Interface feed;\n        uint256 value;\n        uint8 imprecision; // how many decimals to truncate\n        uint256 currentMarket; // 0 indicates no current market\n    }\n    Coin[] public coins;\n\n    struct MarketDetails {\n        uint256 coinIndex;\n        uint256 creationValue;\n        uint256 resolutionValue;\n        uint256 resolutionTime; // value at given time; this is that time\n    }\n    // MarketId => MarketDetails\n    mapping(uint256 => MarketDetails) internal marketDetails;\n\n    constructor(\n        address _owner,\n        IERC20Full _collateral,\n        uint256 _shareFactor,\n        FeePot _feePot,\n        uint256[3] memory _fees,\n        address _protocol,\n        address _linkNode\n    )\n        AbstractMarketFactoryV3(_owner, _collateral, _shareFactor, _feePot, _fees, _protocol)\n        Versioned(\"v1.3.3\")\n        ManagedByLink(_linkNode)\n    {\n        string memory _name = \"\";\n        coins.push(makeCoin(_name, AggregatorV3Interface(address(0)), 0));\n    }\n\n    function getMarketDetails(uint256 _marketId) public view returns (MarketDetails memory) {\n        return marketDetails[_marketId];\n    }\n\n    // NOTE: Trusts the owner not to add a coin twice.\n    function addCoin(\n        string calldata _name,\n        AggregatorV3Interface _feed,\n        uint8 _imprecision\n    ) external onlyOwner returns (uint256 _coinIndex) {\n        Coin memory _coin = makeCoin(_name, _feed, _imprecision);\n        _coinIndex = coins.length;\n        coins.push(_coin);\n        emit CoinAdded(_coinIndex, _name);\n    }\n\n    function getCoin(uint256 _coinIndex) public view returns (Coin memory _coin) {\n        _coin = coins[_coinIndex];\n    }\n\n    function getCoins() public view returns (Coin[] memory _coins) {\n        _coins = new Coin[](coins.length);\n        // Skip first coin because it's always the zeroed-out fake coin.\n        for (uint256 i = 1; i < coins.length; i++) {\n            _coins[i] = coins[i];\n        }\n    }\n\n    // If _resolutionTime is 0 then do NOT create.\n    // If _roundId is 0 then do NOT resolve.\n    function pokeCoin(\n        uint256 _coinIndex,\n        uint256 _resolutionTime,\n        uint80 _roundId\n    ) public onlyLinkNode {\n        Coin storage _coin = coins[_coinIndex];\n\n        // There's a market to resolve.\n        if (_roundId != 0 && _coin.currentMarket != 0) {\n            resolveMarket(_coin, _roundId);\n        }\n\n        // Create a market\n        if (_resolutionTime != 0 && _coin.currentMarket == 0) {\n            createMarket(_coinIndex, _coin, _resolutionTime);\n        }\n    }\n\n    function createMarket(\n        uint256 _coinIndex,\n        Coin storage _coin,\n        uint256 _resolutionTime\n    ) internal returns (uint256 _marketId) {\n        (, uint256 _newValue) = getLatestValue(_coin);\n\n        string[] memory _outcomes = new string[](2);\n        _outcomes[uint256(Outcome.Above)] = Above;\n        _outcomes[uint256(Outcome.NotAbove)] = NotAbove;\n\n        _marketId = startMarket(linkNode, _outcomes, evenOdds(false, 2), true);\n        marketDetails[_marketId] = MarketDetails(_coinIndex, _newValue, 0, _resolutionTime);\n        _coin.currentMarket = _marketId;\n        _coin.value = _newValue;\n        emit ValueUpdate(_coinIndex, _resolutionTime, _marketId, _newValue);\n    }\n\n    function resolveMarket(Coin storage _coin, uint80 _roundId) internal {\n        uint256 _resolutionTime = marketDetails[_coin.currentMarket].resolutionTime;\n        (uint256 _fullValue, uint256 _newValue) = getSpecificValue(_coin, _roundId, _resolutionTime);\n\n        uint256 _winningOutcome;\n        if (_newValue > _coin.value) {\n            _winningOutcome = uint256(Outcome.Above);\n        } else {\n            _winningOutcome = uint256(Outcome.NotAbove);\n        }\n\n        endMarket(_coin.currentMarket, _winningOutcome);\n        marketDetails[_coin.currentMarket].resolutionValue = _fullValue;\n        _coin.currentMarket = 0;\n        _coin.value = 0;\n    }\n\n    function getLatestValue(Coin storage _coin) internal view returns (uint256 _fullValue, uint256 _truncatedValue) {\n        (, int256 _rawValue, , , ) = _coin.feed.latestRoundData();\n        require(_rawValue >= 0, \"Value from feed is negative\");\n        _fullValue = uint256(_rawValue);\n        _truncatedValue = calcTruncatedValue(_coin, _fullValue);\n    }\n\n    // Get value at a specific round, but fail if it isn't after a specific time.\n    function getSpecificValue(\n        Coin storage _coin,\n        uint80 _roundId,\n        uint256 _resolutionTime\n    ) internal view returns (uint256 _fullValue, uint256 _truncatedValue) {\n        (, int256 _rawValue, , uint256 _updatedAt, ) = _coin.feed.getRoundData(_roundId);\n        require(_rawValue >= 0, \"Value from feed is negative\");\n        require(_updatedAt >= _resolutionTime, \"Value hasn't been updated yet\");\n\n        (, , , uint256 _previousRoundTime, ) = _coin.feed.getRoundData(previousRound(_roundId));\n        require(_previousRoundTime < _resolutionTime, \"Must use first round after resolution time\");\n\n        _fullValue = uint256(_rawValue);\n        _truncatedValue = calcTruncatedValue(_coin, _fullValue);\n    }\n\n    // The precision is how many decimals the value has. Zero is dollars, 2 includes cents, 3 is tenths of a cent, etc.\n    // Our resolution rules want a certain precision. Like BTC is to the dollar and MATIC is to the cent.\n    // If somehow the decimals are larger than the desired precision then add zeroes to the end to meet the precision.\n    // This does not change the resolution outcome but does guard against decimals() changing and therefore altering the basis.\n    function calcTruncatedValue(Coin storage _coin, uint256 _fullValue)\n        internal\n        view\n        returns (uint256 _truncatedValue)\n    {\n        uint8 _precision = _coin.feed.decimals(); // probably constant but that isn't guaranteed, so query each time\n        if (_precision > _coin.imprecision) {\n            uint8 _truncate = _precision - _coin.imprecision;\n            _truncatedValue = _fullValue / (10**_truncate);\n        } else if (_precision < _coin.imprecision) {\n            uint8 _greaten = _coin.imprecision - _precision;\n            _truncatedValue = _fullValue * (10**_greaten);\n        } else {\n            _truncatedValue = _fullValue;\n        }\n\n        // Round up because that cleanly fits Above/Not-Above.\n        if (_truncatedValue != _fullValue) {\n            _truncatedValue += 1;\n        }\n    }\n\n    function makeCoin(\n        string memory _name,\n        AggregatorV3Interface _feed,\n        uint8 _imprecision\n    ) internal pure returns (Coin memory _coin) {\n        _coin = Coin(_name, _feed, 0, _imprecision, 0);\n    }\n\n    // The roundId is the encoding of two parts: the phase and the phase-specific round id.\n    // To find the previous roundId:\n    // 1. extract the phase and phase-specific round (I call these _phaseId and _roundId)\n    // 2. decrement the phase-specific round\n    // 3. re-encode the phase and phase-specific round.\n    uint256 private constant PHASE_OFFSET = 64;\n\n    function previousRound(uint80 _fullRoundId) internal pure returns (uint80) {\n        uint256 _phaseId = uint256(uint16(_fullRoundId >> PHASE_OFFSET));\n        uint64 _roundId = uint64(_fullRoundId) - 1;\n        return uint80((_phaseId << PHASE_OFFSET) | _roundId);\n    }\n\n    function getRewardEndTime(uint256 _marketId) public view override returns (uint256) {\n        return getMarketDetails(_marketId).resolutionTime;\n    }\n}\n"
    },
    "contracts/turbo/TrustedMarketFactoryV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./AbstractMarketFactoryV3.sol\";\nimport \"../libraries/CalculateLinesToBPoolOdds.sol\";\nimport \"../libraries/Versioned.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/SignedSafeMath.sol\";\n\ncontract TrustedMarketFactoryV3 is AbstractMarketFactoryV3, CalculateLinesToBPoolOdds, Versioned {\n    using SafeMath for uint256;\n\n    struct MarketDetails {\n        string description;\n    }\n    MarketDetails[] internal marketDetails;\n    // mapping(uint256=> mapping(uint256=>uint256)) TradeDetails; //marketid -> (outcome->amount)\n\n    modifier onlyOwnerManager() {\n        require(msg.sender == owner || managers[msg.sender] , \"Only Validators can call this function\");\n        _;\n    }\n\n    mapping(address=>bool) managers; \n\n    constructor(\n        address _owner,\n        IERC20Full _collateral,\n        uint256 _shareFactor,\n        FeePot _feePot,\n        uint256[3] memory _fees,\n        address _protocol\n    ) AbstractMarketFactoryV3(_owner, _collateral, _shareFactor, _feePot, _fees, _protocol) Versioned(\"v1.1.0\") {}\n\n    //TODO add managers \n    function createMarket(\n        address _creator,\n        string calldata _description,\n        string[] calldata _names,\n        uint256[] calldata _odds\n    ) public  returns (uint256) {\n        marketDetails.push(MarketDetails(_description));\n        return startMarket(_creator, _names, _odds, true);\n    }\n\n    //TODO add managers \n    function trustedResolveMarket(uint256 _id, uint256 _winningOutcome) public {\n        endMarket(_id, _winningOutcome);\n    }\n\n    function getMarketDetails(uint256 _id) public view returns (MarketDetails memory) {\n        return marketDetails[_id];\n    }\n\n    function getRewardEndTime(uint256 _marketId) public view override returns (uint256) {\n        return 0;\n    }\n    \n   // function logTrade(uint256 _marketId, uint256 _outcome, uint256 _collateralIn) external {\n   //      TradeDetails[_marketId][_outcome] = TradeDetails[_marketId][_outcome] + _collateralIn; \n\n   //  }\n\n   //  function getTradeDetails(uint256 _marketId, uint256 _outcome) external view returns(uint256){\n   //      return TradeDetails[_marketId][_outcome]; \n   //  }\n}\n"
    },
    "contracts/turbo/Fetcher.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../libraries/IERC20Full.sol\";\nimport \"../balancer/BPool.sol\";\nimport \"./AbstractMarketFactoryV3.sol\";\nimport \"./FeePot.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/SignedSafeMath.sol\";\nimport \"./MMAMarketFactoryV3.sol\";\nimport \"./AMMFactory.sol\";\nimport \"./CryptoMarketFactoryV3.sol\";\nimport \"./NBAMarketFactoryV3.sol\";\nimport \"../rewards/MasterChef.sol\";\nimport \"./CryptoCurrencyMarketFactoryV3.sol\";\nimport \"./TrustedMarketFactoryV3.sol\";\n\n// Helper contract for grabbing huge amounts of data without overloading multicall.\nabstract contract Fetcher {\n    using SafeMath for uint256;\n    using SignedSafeMath for int256;\n\n    struct CollateralBundle {\n        address addr;\n        string symbol;\n        uint256 decimals;\n    }\n\n    struct MarketFactoryBundle {\n        uint256 shareFactor;\n        uint256 stakerFee;\n        uint256 settlementFee;\n        uint256 protocolFee;\n        FeePot feePot;\n        CollateralBundle collateral;\n        uint256 marketCount;\n    }\n\n    struct PoolBundle {\n        address addr;\n        uint256[] tokenRatios;\n        uint256[] balances;\n        uint256[] weights;\n        uint256 swapFee;\n        uint256 totalSupply;\n    }\n\n    struct StaticMarketBundle {\n        AbstractMarketFactoryV3 factory;\n        uint256 marketId;\n        PoolBundle pool;\n        MasterChef.PoolStatusInfo rewards;\n        OwnedERC20[] shareTokens;\n        uint256 creationTimestamp;\n        OwnedERC20 winner;\n        uint256[] initialOdds;\n    }\n\n    struct DynamicMarketBundle {\n        AbstractMarketFactoryV3 factory;\n        uint256 marketId;\n        PoolBundle pool;\n        OwnedERC20 winner;\n    }\n\n    string public marketType;\n    string public version;\n\n    constructor(string memory _type, string memory _version) {\n        marketType = _type;\n        version = _version;\n    }\n\n    function buildCollateralBundle(IERC20Full _collateral) internal view returns (CollateralBundle memory _bundle) {\n        _bundle.addr = address(_collateral);\n        _bundle.symbol = _collateral.symbol();\n        _bundle.decimals = _collateral.decimals();\n    }\n\n    function buildMarketFactoryBundle(AbstractMarketFactoryV3 _marketFactory)\n        internal\n        view\n        returns (MarketFactoryBundle memory _bundle)\n    {\n        _bundle.shareFactor = _marketFactory.shareFactor();\n        _bundle.stakerFee = _marketFactory.stakerFee();\n        _bundle.settlementFee = _marketFactory.settlementFee();\n        _bundle.protocolFee = _marketFactory.protocolFee();\n        _bundle.feePot = _marketFactory.feePot();\n        _bundle.collateral = buildCollateralBundle(_marketFactory.collateral());\n        _bundle.marketCount = _marketFactory.marketCount();\n    }\n\n    function buildStaticMarketBundle(\n        AbstractMarketFactoryV3 _marketFactory,\n        AMMFactory _ammFactory,\n        MasterChef _masterChef,\n        uint256 _marketId\n    ) internal view returns (StaticMarketBundle memory _bundle) {\n        AbstractMarketFactoryV3.Market memory _market = _marketFactory.getMarket(_marketId);\n        _bundle.factory = _marketFactory;\n        _bundle.marketId = _marketId;\n        _bundle.pool = buildPoolBundle(_marketFactory, _ammFactory, _marketId);\n        _bundle.rewards = _masterChef.getPoolInfo(_ammFactory, _marketFactory, _marketId);\n        _bundle.shareTokens = _market.shareTokens;\n        _bundle.creationTimestamp = _market.creationTimestamp;\n        _bundle.winner = _market.winner;\n        _bundle.initialOdds = _market.initialOdds;\n    }\n\n    function buildDynamicMarketBundle(\n        AbstractMarketFactoryV3 _marketFactory,\n        AMMFactory _ammFactory,\n        uint256 _marketId\n    ) internal view returns (DynamicMarketBundle memory _bundle) {\n        AbstractMarketFactoryV3.Market memory _market = _marketFactory.getMarket(_marketId);\n\n        _bundle.factory = _marketFactory;\n        _bundle.marketId = _marketId;\n        _bundle.winner = _market.winner;\n        _bundle.pool = buildPoolBundle(_marketFactory, _ammFactory, _marketId);\n    }\n\n    function buildPoolBundle(\n        AbstractMarketFactoryV3 _marketFactory,\n        AMMFactory _ammFactory,\n        uint256 _marketId\n    ) internal view returns (PoolBundle memory _bundle) {\n        BPool _pool = _ammFactory.getPool(_marketFactory, _marketId);\n        if (_pool == BPool(address(0))) return _bundle;\n\n        _bundle.addr = address(_pool);\n        _bundle.totalSupply = _pool.totalSupply();\n        _bundle.swapFee = _ammFactory.getSwapFee(_marketFactory, _marketId);\n        _bundle.balances = _ammFactory.getPoolBalances(_marketFactory, _marketId);\n        _bundle.tokenRatios = _ammFactory.tokenRatios(_marketFactory, _marketId);\n        _bundle.weights = _ammFactory.getPoolWeights(_marketFactory, _marketId);\n    }\n\n    function openOrHasWinningShares(AbstractMarketFactoryV3 _marketFactory, uint256 _marketId)\n        internal\n        view\n        returns (bool)\n    {\n        AbstractMarketFactoryV3.Market memory _market = _marketFactory.getMarket(_marketId);\n        if (_market.winner == OwnedERC20(address(0))) return true; // open\n        return _market.winner.totalSupply() > 0; // has winning shares\n    }\n}\n\nabstract contract SportsFetcher is Fetcher {\n    struct SpecificMarketFactoryBundle {\n        MarketFactoryBundle _super;\n    }\n\n    struct StaticEventBundle {\n        uint256 id;\n        StaticMarketBundle[] markets;\n        int256[] lines;\n        uint256 estimatedStartTime;\n        uint256 homeTeamId;\n        uint256 awayTeamId;\n        string homeTeamName;\n        string awayTeamName;\n        // Dynamics\n        Sport.SportsEventStatus status;\n        uint256 homeScore;\n        uint256 awayScore;\n    }\n\n    struct DynamicEventBundle {\n        uint256 id;\n        Sport.SportsEventStatus status;\n        DynamicMarketBundle[] markets;\n        uint256 homeScore;\n        uint256 awayScore;\n    }\n\n    function buildSpecificMarketFactoryBundle(address _marketFactory)\n        internal\n        view\n        returns (SpecificMarketFactoryBundle memory _bundle)\n    {\n        _bundle._super = buildMarketFactoryBundle(AbstractMarketFactoryV3(_marketFactory));\n    }\n\n    function fetchInitial(\n        address _marketFactory,\n        AMMFactory _ammFactory,\n        MasterChef _masterChef,\n        uint256 _offset,\n        uint256 _total\n    )\n        public\n        view\n        returns (\n            SpecificMarketFactoryBundle memory _marketFactoryBundle,\n            StaticEventBundle[] memory _eventBundles,\n            uint256 _lowestEventIndex,\n            uint256 _timestamp\n        )\n    {\n        _marketFactoryBundle = buildSpecificMarketFactoryBundle(_marketFactory);\n        (_eventBundles, _lowestEventIndex) = buildStaticEventBundles(\n            _marketFactory,\n            _ammFactory,\n            _masterChef,\n            _offset,\n            _total\n        );\n        _timestamp = block.timestamp;\n    }\n\n    function fetchDynamic(\n        address _marketFactory,\n        AMMFactory _ammFactory,\n        uint256 _offset,\n        uint256 _total\n    )\n        public\n        view\n        returns (\n            DynamicEventBundle[] memory _bundles,\n            uint256 _lowestEventIndex,\n            uint256 _timestamp\n        )\n    {\n        (_bundles, _lowestEventIndex) = buildDynamicEventBundles(_marketFactory, _ammFactory, _offset, _total);\n        _timestamp = block.timestamp;\n    }\n\n    function buildStaticEventBundles(\n        address _marketFactory,\n        AMMFactory _ammFactory,\n        MasterChef _masterChef,\n        uint256 _offset,\n        uint256 _total\n    ) internal view returns (StaticEventBundle[] memory _bundles, uint256 _lowestEventIndex) {\n        uint256[] memory _eventIds;\n        (_eventIds, _lowestEventIndex) = listOfInterestingEvents(_marketFactory, _offset, _total);\n\n        _total = _eventIds.length;\n        _bundles = new StaticEventBundle[](_total);\n        for (uint256 i; i < _total; i++) {\n            _bundles[i] = buildStaticEventBundle(_marketFactory, _ammFactory, _masterChef, _eventIds[i]);\n        }\n    }\n\n    function buildDynamicEventBundles(\n        address _marketFactory,\n        AMMFactory _ammFactory,\n        uint256 _offset,\n        uint256 _total\n    ) internal view returns (DynamicEventBundle[] memory _bundles, uint256 _lowestEventIndex) {\n        uint256[] memory _eventIds;\n        (_eventIds, _lowestEventIndex) = listOfInterestingEvents(_marketFactory, _offset, _total);\n\n        _total = _eventIds.length;\n        _bundles = new DynamicEventBundle[](_total);\n        for (uint256 i; i < _total; i++) {\n            _bundles[i] = buildDynamicEventBundle(_marketFactory, _ammFactory, _eventIds[i]);\n        }\n    }\n\n    function buildStaticEventBundle(\n        address _marketFactory,\n        AMMFactory _ammFactory,\n        MasterChef _masterChef,\n        uint256 _eventId\n    ) internal view returns (StaticEventBundle memory _bundle) {\n        Sport.SportsEvent memory _event = Sport(_marketFactory).getSportsEvent(_eventId);\n\n        StaticMarketBundle[] memory _markets = new StaticMarketBundle[](_event.markets.length);\n        for (uint256 i = 0; i < _markets.length; i++) {\n            _markets[i] = buildStaticMarketBundle(\n                AbstractMarketFactoryV3(_marketFactory),\n                _ammFactory,\n                _masterChef,\n                _event.markets[i]\n            );\n        }\n\n        _bundle.id = _eventId;\n        _bundle.status = _event.status;\n        _bundle.markets = _markets;\n        _bundle.lines = _event.lines;\n        _bundle.estimatedStartTime = _event.estimatedStartTime;\n        _bundle.homeTeamId = _event.homeTeamId;\n        _bundle.awayTeamId = _event.awayTeamId;\n        _bundle.homeTeamName = _event.homeTeamName;\n        _bundle.awayTeamName = _event.awayTeamName;\n        _bundle.homeScore = _event.homeScore;\n        _bundle.awayScore = _event.awayScore;\n    }\n\n    function buildDynamicEventBundle(\n        address _marketFactory,\n        AMMFactory _ammFactory,\n        uint256 _eventId\n    ) internal view returns (DynamicEventBundle memory _bundle) {\n        Sport.SportsEvent memory _event = Sport(_marketFactory).getSportsEvent(_eventId);\n\n        DynamicMarketBundle[] memory _markets = new DynamicMarketBundle[](_event.markets.length);\n        for (uint256 i = 0; i < _markets.length; i++) {\n            _markets[i] = buildDynamicMarketBundle(\n                AbstractMarketFactoryV3(_marketFactory),\n                _ammFactory,\n                _event.markets[i]\n            );\n        }\n\n        _bundle.id = _eventId;\n        _bundle.markets = _markets;\n        _bundle.status = _event.status;\n        _bundle.homeScore = _event.homeScore;\n        _bundle.awayScore = _event.awayScore;\n    }\n\n    // Starts from the end of the events list because newer events are more interesting.\n    // _offset is skipping all events, not just interesting events\n    function listOfInterestingEvents(\n        address _marketFactory,\n        uint256 _offset,\n        uint256 _total\n    ) internal view returns (uint256[] memory _interestingEventIds, uint256 _eventIndex) {\n        _interestingEventIds = new uint256[](_total);\n\n        uint256 _eventCount = Sport(_marketFactory).eventCount();\n\n        // No events so return nothing. (needed to avoid integer underflow below)\n        if (_eventCount == 0) {\n            return (new uint256[](0), 0);\n        }\n\n        uint256 _max = _eventCount;\n\n        // No remaining events so return nothing. (needed to avoid integer underflow below)\n        if (_offset > _max) {\n            return (new uint256[](0), 0);\n        }\n\n        uint256 _collectedEvents = 0;\n        _eventIndex = _max - _offset;\n        while (true) {\n            if (_collectedEvents >= _total) break;\n            if (_eventIndex == 0) break;\n\n            _eventIndex--; // starts out one too high, so this works\n\n            (Sport.SportsEvent memory _event, uint256 _eventId) =\n                Sport(_marketFactory).getSportsEventByIndex(_eventIndex);\n\n            if (isEventInteresting(_event, AbstractMarketFactoryV3(_marketFactory))) {\n                _interestingEventIds[_collectedEvents] = _eventId;\n                _collectedEvents++;\n            }\n        }\n\n        if (_total > _collectedEvents) {\n            assembly {\n                // shortens array\n                mstore(_interestingEventIds, _collectedEvents)\n            }\n        }\n    }\n\n    function isEventInteresting(Sport.SportsEvent memory _event, AbstractMarketFactoryV3 _marketFactory)\n        private\n        view\n        returns (bool)\n    {\n        for (uint256 i = 0; i < _event.markets.length; i++) {\n            uint256 _marketId = _event.markets[i];\n            if (openOrHasWinningShares(_marketFactory, _marketId)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n\ncontract NBAFetcher is SportsFetcher {\n    constructor() Fetcher(\"NBA\", \"TBD\") {}\n}\n\ncontract MLBFetcher is SportsFetcher {\n    constructor() Fetcher(\"MLB\", \"TBD\") {}\n}\n\ncontract MMAFetcher is SportsFetcher {\n    constructor() Fetcher(\"MMA\", \"TBD\") {}\n}\n\ncontract NFLFetcher is SportsFetcher {\n    constructor() Fetcher(\"NFL\", \"TBD\") {}\n}\n\ncontract CryptoFetcher is Fetcher {\n    constructor() Fetcher(\"Crypto\", \"TBD\") {}\n\n    struct SpecificMarketFactoryBundle {\n        MarketFactoryBundle _super;\n    }\n\n    struct SpecificStaticMarketBundle {\n        StaticMarketBundle _super;\n        uint8 marketType;\n        uint256 coinIndex;\n        uint256 creationPrice;\n        uint256 resolutionTime;\n        // Dynamics\n        uint256 resolutionPrice;\n    }\n\n    struct SpecificDynamicMarketBundle {\n        DynamicMarketBundle _super;\n        uint256 resolutionPrice;\n    }\n\n    function buildSpecificMarketFactoryBundle(address _marketFactory)\n        internal\n        view\n        returns (SpecificMarketFactoryBundle memory _bundle)\n    {\n        _bundle._super = buildMarketFactoryBundle(CryptoMarketFactoryV3(_marketFactory));\n    }\n\n    function buildSpecificStaticMarketBundle(\n        address _marketFactory,\n        AMMFactory _ammFactory,\n        MasterChef _masterChef,\n        uint256 _marketId\n    ) internal view returns (SpecificStaticMarketBundle memory _bundle) {\n        CryptoMarketFactoryV3.MarketDetails memory _details =\n            CryptoMarketFactoryV3(_marketFactory).getMarketDetails(_marketId);\n        _bundle._super = buildStaticMarketBundle(\n            CryptoMarketFactoryV3(_marketFactory),\n            _ammFactory,\n            _masterChef,\n            _marketId\n        );\n        _bundle.marketType = uint8(_details.marketType);\n        _bundle.creationPrice = _details.creationPrice;\n        _bundle.coinIndex = _details.coinIndex;\n        _bundle.resolutionPrice = _details.resolutionPrice;\n        _bundle.resolutionTime = _details.resolutionTime;\n    }\n\n    function buildSpecificDynamicMarketBundle(\n        address _marketFactory,\n        AMMFactory _ammFactory,\n        uint256 _marketId\n    ) internal view returns (SpecificDynamicMarketBundle memory _bundle) {\n        CryptoMarketFactoryV3.MarketDetails memory _details =\n            CryptoMarketFactoryV3(_marketFactory).getMarketDetails(_marketId);\n        _bundle._super = buildDynamicMarketBundle(CryptoMarketFactoryV3(_marketFactory), _ammFactory, _marketId);\n        _bundle.resolutionPrice = _details.resolutionPrice;\n    }\n\n    function fetchInitial(\n        address _marketFactory,\n        AMMFactory _ammFactory,\n        MasterChef _masterChef,\n        uint256 _offset,\n        uint256 _total\n    )\n        public\n        view\n        returns (\n            SpecificMarketFactoryBundle memory _marketFactoryBundle,\n            SpecificStaticMarketBundle[] memory _marketBundles,\n            uint256 _lowestMarketIndex,\n            uint256 _timestamp\n        )\n    {\n        _marketFactoryBundle = buildSpecificMarketFactoryBundle(_marketFactory);\n\n        uint256[] memory _marketIds;\n        (_marketIds, _lowestMarketIndex) = listOfInterestingMarkets(_marketFactory, _offset, _total);\n\n        _total = _marketIds.length;\n        _marketBundles = new SpecificStaticMarketBundle[](_total);\n        for (uint256 i; i < _total; i++) {\n            _marketBundles[i] = buildSpecificStaticMarketBundle(\n                _marketFactory,\n                _ammFactory,\n                _masterChef,\n                _marketIds[i]\n            );\n        }\n\n        _timestamp = block.timestamp;\n    }\n\n    function fetchDynamic(\n        address _marketFactory,\n        AMMFactory _ammFactory,\n        uint256 _offset,\n        uint256 _total\n    )\n        public\n        view\n        returns (\n            SpecificDynamicMarketBundle[] memory _bundles,\n            uint256 _lowestMarketIndex,\n            uint256 _timestamp\n        )\n    {\n        uint256[] memory _marketIds;\n        (_marketIds, _lowestMarketIndex) = listOfInterestingMarkets(_marketFactory, _offset, _total);\n\n        _total = _marketIds.length;\n        _bundles = new SpecificDynamicMarketBundle[](_total);\n        for (uint256 i; i < _total; i++) {\n            _bundles[i] = buildSpecificDynamicMarketBundle(_marketFactory, _ammFactory, _marketIds[i]);\n        }\n\n        _timestamp = block.timestamp;\n    }\n\n    // Starts from the end of the markets list because newer markets are more interesting.\n    // _offset is skipping all markets, not just interesting markets\n    function listOfInterestingMarkets(\n        address _marketFactory,\n        uint256 _offset,\n        uint256 _total\n    ) internal view returns (uint256[] memory _interestingMarketIds, uint256 _marketId) {\n        _interestingMarketIds = new uint256[](_total);\n        uint256 _max = AbstractMarketFactoryV3(_marketFactory).marketCount() - 1;\n\n        // No markets so return nothing. (needed to prevent integer underflow below)\n        if (_max == 0 || _offset >= _max) {\n            return (new uint256[](0), 0);\n        }\n\n        // Starts at the end, less offset.\n        // Stops before the 0th market since that market is always fake.\n        uint256 _collectedMarkets = 0;\n        _marketId = _max - _offset;\n\n        while (true) {\n            if (openOrHasWinningShares(AbstractMarketFactoryV3(_marketFactory), _marketId)) {\n                _interestingMarketIds[_collectedMarkets] = _marketId;\n                _collectedMarkets++;\n            }\n\n            if (_collectedMarkets >= _total) break;\n            if (_marketId == 1) break; // skipping 0th market, which is fake\n            _marketId--; // starts out oone too high, so this works\n        }\n\n        if (_total > _collectedMarkets) {\n            assembly {\n                // shortens array\n                mstore(_interestingMarketIds, _collectedMarkets)\n            }\n        }\n    }\n}\n\ncontract CryptoCurrencyFetcher is Fetcher {\n    constructor() Fetcher(\"CryptoCurrency\", \"TBD\") {}\n\n    struct SpecificMarketFactoryBundle {\n        MarketFactoryBundle _super;\n    }\n\n    struct SpecificStaticMarketBundle {\n        StaticMarketBundle _super;\n        uint256 coinIndex;\n        uint256 creationValue;\n        uint256 resolutionTime;\n        // Dynamics\n        uint256 resolutionValue;\n    }\n\n    struct SpecificDynamicMarketBundle {\n        DynamicMarketBundle _super;\n        uint256 resolutionValue;\n    }\n\n    function buildSpecificMarketFactoryBundle(address _marketFactory)\n        internal\n        view\n        returns (SpecificMarketFactoryBundle memory _bundle)\n    {\n        _bundle._super = buildMarketFactoryBundle(CryptoCurrencyMarketFactoryV3(_marketFactory));\n    }\n\n    function buildSpecificStaticMarketBundle(\n        address _marketFactory,\n        AMMFactory _ammFactory,\n        MasterChef _masterChef,\n        uint256 _marketId\n    ) internal view returns (SpecificStaticMarketBundle memory _bundle) {\n        CryptoCurrencyMarketFactoryV3.MarketDetails memory _details =\n            CryptoCurrencyMarketFactoryV3(_marketFactory).getMarketDetails(_marketId);\n        _bundle._super = buildStaticMarketBundle(\n            CryptoCurrencyMarketFactoryV3(_marketFactory),\n            _ammFactory,\n            _masterChef,\n            _marketId\n        );\n        _bundle.creationValue = _details.creationValue;\n        _bundle.coinIndex = _details.coinIndex;\n        _bundle.resolutionValue = _details.resolutionValue;\n        _bundle.resolutionTime = _details.resolutionTime;\n    }\n\n    function buildSpecificDynamicMarketBundle(\n        address _marketFactory,\n        AMMFactory _ammFactory,\n        uint256 _marketId\n    ) internal view returns (SpecificDynamicMarketBundle memory _bundle) {\n        CryptoCurrencyMarketFactoryV3.MarketDetails memory _details =\n            CryptoCurrencyMarketFactoryV3(_marketFactory).getMarketDetails(_marketId);\n        _bundle._super = buildDynamicMarketBundle(CryptoCurrencyMarketFactoryV3(_marketFactory), _ammFactory, _marketId);\n        _bundle.resolutionValue = _details.resolutionValue;\n    }\n\n    function fetchInitial(\n        address _marketFactory,\n        AMMFactory _ammFactory,\n        MasterChef _masterChef,\n        uint256 _offset,\n        uint256 _total\n    )\n        public\n        view\n        returns (\n            SpecificMarketFactoryBundle memory _marketFactoryBundle,\n            SpecificStaticMarketBundle[] memory _marketBundles,\n            uint256 _lowestMarketIndex,\n            uint256 _timestamp\n        )\n    {\n        _marketFactoryBundle = buildSpecificMarketFactoryBundle(_marketFactory);\n\n        uint256[] memory _marketIds;\n        (_marketIds, _lowestMarketIndex) = listOfInterestingMarkets(_marketFactory, _offset, _total);\n\n        _total = _marketIds.length;\n        _marketBundles = new SpecificStaticMarketBundle[](_total);\n        for (uint256 i; i < _total; i++) {\n            _marketBundles[i] = buildSpecificStaticMarketBundle(\n                _marketFactory,\n                _ammFactory,\n                _masterChef,\n                _marketIds[i]\n            );\n        }\n\n        _timestamp = block.timestamp;\n    }\n\n    function fetchDynamic(\n        address _marketFactory,\n        AMMFactory _ammFactory,\n        uint256 _offset,\n        uint256 _total\n    )\n        public\n        view\n        returns (\n            SpecificDynamicMarketBundle[] memory _bundles,\n            uint256 _lowestMarketIndex,\n            uint256 _timestamp\n        )\n    {\n        uint256[] memory _marketIds;\n        (_marketIds, _lowestMarketIndex) = listOfInterestingMarkets(_marketFactory, _offset, _total);\n\n        _total = _marketIds.length;\n        _bundles = new SpecificDynamicMarketBundle[](_total);\n        for (uint256 i; i < _total; i++) {\n            _bundles[i] = buildSpecificDynamicMarketBundle(_marketFactory, _ammFactory, _marketIds[i]);\n        }\n\n        _timestamp = block.timestamp;\n    }\n\n    // Starts from the end of the markets list because newer markets are more interesting.\n    // _offset is skipping all markets, not just interesting markets\n    function listOfInterestingMarkets(\n        address _marketFactory,\n        uint256 _offset,\n        uint256 _total\n    ) internal view returns (uint256[] memory _interestingMarketIds, uint256 _marketId) {\n        _interestingMarketIds = new uint256[](_total);\n        uint256 _max = AbstractMarketFactoryV3(_marketFactory).marketCount() - 1;\n\n        // No markets so return nothing. (needed to prevent integer underflow below)\n        if (_max == 0 || _offset >= _max) {\n            return (new uint256[](0), 0);\n        }\n\n        // Starts at the end, less offset.\n        // Stops before the 0th market since that market is always fake.\n        uint256 _collectedMarkets = 0;\n        _marketId = _max - _offset;\n\n        while (true) {\n            if (openOrHasWinningShares(AbstractMarketFactoryV3(_marketFactory), _marketId)) {\n                _interestingMarketIds[_collectedMarkets] = _marketId;\n                _collectedMarkets++;\n            }\n\n            if (_collectedMarkets >= _total) break;\n            if (_marketId == 1) break; // skipping 0th market, which is fake\n            _marketId--; // starts out oone too high, so this works\n        }\n\n        if (_total > _collectedMarkets) {\n            assembly {\n                // shortens array\n                mstore(_interestingMarketIds, _collectedMarkets)\n            }\n        }\n    }\n}\n\n\n// contract TrustedFetcher is Fetcher {\n//     constructor() Fetcher(\"Trusted\", \"TBD\") {}\n\n//     struct SpecificMarketFactoryBundle {\n//         MarketFactoryBundle _super;\n//     }\n\n//     struct SpecificStaticMarketBundle {\n//         StaticMarketBundle _super;\n//         // uint256 coinIndex;\n//         // uint256 creationValue;\n//         // uint256 resolutionTime;\n//         // // Dynamics\n//         // uint256 resolutionValue;\n//         string description;\n//     }\n\n//     struct SpecificDynamicMarketBundle {\n//         DynamicMarketBundle _super;\n//         //uint256 resolutionValue;\n//         string description;\n\n//     }\n\n//     function getMarket(    address _marketFactory,\n//         AMMFactory _ammFactory,\n//         MasterChef _masterChef,\n//         uint256 _marketId) public view returns(   SpecificStaticMarketBundle memory _bundle\n// ){\n//         TrustedMarketFactoryV3.MarketDetails memory _details =\n//             TrustedMarketFactoryV3(_marketFactory).getMarketDetails(_marketId);\n//         _bundle._super = buildStaticMarketBundle(\n//             TrustedMarketFactoryV3(_marketFactory),\n//             _ammFactory,\n//             _masterChef,\n//             _marketId\n//         );\n//         _bundle.description = _details.description;\n//     }\n\n//     function buildSpecificMarketFactoryBundle(address _marketFactory)\n//         internal\n//         view\n//         returns (SpecificMarketFactoryBundle memory _bundle)\n//     {\n//         _bundle._super = buildMarketFactoryBundle(TrustedMarketFactoryV3(_marketFactory));\n//     }\n\n//     function buildSpecificStaticMarketBundle(\n//         address _marketFactory,\n//         AMMFactory _ammFactory,\n//         MasterChef _masterChef,\n//         uint256 _marketId\n//     ) internal view returns (SpecificStaticMarketBundle memory _bundle) {\n//         TrustedMarketFactoryV3.MarketDetails memory _details =\n//             TrustedMarketFactoryV3(_marketFactory).getMarketDetails(_marketId);\n//         _bundle._super = buildStaticMarketBundle(\n//             TrustedMarketFactoryV3(_marketFactory),\n//             _ammFactory,\n//             _masterChef,\n//             _marketId\n//         );\n//         _bundle.description = _details.description;\n//         // _bundle.creationValue = _details.creationValue;\n//         // _bundle.coinIndex = _details.coinIndex;\n//         // _bundle.resolutionValue = _details.resolutionValue;\n//         // _bundle.resolutionTime = _details.resolutionTime;\n//     }\n\n//     function buildSpecificDynamicMarketBundle(\n//         address _marketFactory,\n//         AMMFactory _ammFactory,\n//         uint256 _marketId\n//     ) internal view returns (SpecificDynamicMarketBundle memory _bundle) {\n//         TrustedMarketFactoryV3.MarketDetails memory _details =\n//             TrustedMarketFactoryV3(_marketFactory).getMarketDetails(_marketId);\n//         _bundle._super = buildDynamicMarketBundle(TrustedMarketFactoryV3(_marketFactory), _ammFactory, _marketId);\n//         _bundle.description = _details.description;\n//     }\n\n//     function fetchInitial(\n//         address _marketFactory,\n//         AMMFactory _ammFactory,\n//         MasterChef _masterChef,\n//         uint256 _offset,\n//         uint256 _total\n//     )\n//         public\n//         view\n//         returns (\n//             SpecificMarketFactoryBundle memory _marketFactoryBundle,\n//             SpecificStaticMarketBundle[] memory _marketBundles,\n//             uint256 _lowestMarketIndex,\n//             uint256 _timestamp\n//         )\n//     {\n//         _marketFactoryBundle = buildSpecificMarketFactoryBundle(_marketFactory);\n\n//         uint256[] memory _marketIds;\n//         (_marketIds, _lowestMarketIndex) = listOfInterestingMarkets(_marketFactory, _offset, _total);\n\n//         _total = _marketIds.length;\n//         _marketBundles = new SpecificStaticMarketBundle[](_total);\n//         for (uint256 i; i < _total; i++) {\n//             _marketBundles[i] = buildSpecificStaticMarketBundle(\n//                 _marketFactory,\n//                 _ammFactory,\n//                 _masterChef,\n//                 _marketIds[i]\n//             );\n//         }\n\n//         _timestamp = block.timestamp;\n//     }\n\n//     function fetchDynamic(\n//         address _marketFactory,\n//         AMMFactory _ammFactory,\n//         uint256 _offset,\n//         uint256 _total\n//     )\n//         public\n//         view\n//         returns (\n//             SpecificDynamicMarketBundle[] memory _bundles,\n//             uint256 _lowestMarketIndex,\n//             uint256 _timestamp\n//         )\n//     {\n//         uint256[] memory _marketIds;\n//         (_marketIds, _lowestMarketIndex) = listOfInterestingMarkets(_marketFactory, _offset, _total);\n\n//         _total = _marketIds.length;\n//         _bundles = new SpecificDynamicMarketBundle[](_total);\n//         for (uint256 i; i < _total; i++) {\n//             _bundles[i] = buildSpecificDynamicMarketBundle(_marketFactory, _ammFactory, _marketIds[i]);\n//         }\n\n//         _timestamp = block.timestamp;\n//     }\n\n//     // Starts from the end of the markets list because newer markets are more interesting.\n//     // _offset is skipping all markets, not just interesting markets\n//     function listOfInterestingMarkets(\n//         address _marketFactory,\n//         uint256 _offset,\n//         uint256 _total\n//     ) internal view returns (uint256[] memory _interestingMarketIds, uint256 _marketId) {\n//         _interestingMarketIds = new uint256[](_total);\n//         uint256 _max = AbstractMarketFactoryV3(_marketFactory).marketCount() - 1;\n\n//         // No markets so return nothing. (needed to prevent integer underflow below)\n//         if (_max == 0 || _offset >= _max) {\n//             return (new uint256[](0), 0);\n//         }\n\n//         // Starts at the end, less offset.\n//         // Stops before the 0th market since that market is always fake.\n//         uint256 _collectedMarkets = 0;\n//         _marketId = _max - _offset;\n\n//         while (true) {\n//             if (openOrHasWinningShares(AbstractMarketFactoryV3(_marketFactory), _marketId)) {\n//                 _interestingMarketIds[_collectedMarkets] = _marketId;\n//                 _collectedMarkets++;\n//             }\n\n//             if (_collectedMarkets >= _total) break;\n//             if (_marketId == 1) break; // skipping 0th market, which is fake\n//             _marketId--; // starts out oone too high, so this works\n//         }\n\n//         if (_total > _collectedMarkets) {\n//             assembly {\n//                 // shortens array\n//                 mstore(_interestingMarketIds, _collectedMarkets)\n//             }\n//         }\n//     }\n// }\n"
    },
    "contracts/libraries/Sport.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../turbo/AbstractMarketFactoryV3.sol\";\nimport \"./LineHelper.sol\";\n\nabstract contract Sport is AbstractMarketFactoryV3, LineHelper {\n    event SportsEventCreated(\n        uint256 id,\n        uint256[] markets,\n        int256[] lines,\n        uint256 homeTeamId,\n        uint256 awayTeamId,\n        string homeTeamName,\n        string awayTeamName,\n        uint256 estimatedStartTime\n    );\n\n    enum SportsEventStatus {Unknown, Scheduled, Final, Postponed, Canceled}\n    struct SportsEvent {\n        SportsEventStatus status;\n        uint256[] markets;\n        int256[] lines;\n        uint256 estimatedStartTime;\n        uint256 homeTeamId;\n        uint256 awayTeamId;\n        string homeTeamName;\n        string awayTeamName;\n        uint256 homeScore;\n        uint256 awayScore;\n    }\n    // EventId => EventDetails\n    mapping(uint256 => SportsEvent) public sportsEvents;\n    uint256[] public listOfSportsEvents;\n    mapping(uint256 => uint256) public marketIdToEventIdMapping;\n    uint256 constant NoContest = 0;\n\n    function eventCount() public view returns (uint256) {\n        return listOfSportsEvents.length;\n    }\n\n    function getSportsEvent(uint256 _eventId) public view returns (SportsEvent memory) {\n        return sportsEvents[_eventId];\n    }\n\n    function getSportsEventByIndex(uint256 _index) public view returns (SportsEvent memory _event, uint256 _eventId) {\n        _eventId = listOfSportsEvents[_index];\n        _event = getSportsEvent(_eventId);\n    }\n\n    function makeSportsEvent(\n        uint256 _eventId,\n        uint256[] memory _markets,\n        int256[] memory _lines,\n        uint256 _estimatedStartTime,\n        uint256 _homeTeamId,\n        uint256 _awayTeamId,\n        string memory _homeTeamName,\n        string memory _awayTeamName\n    ) internal {\n        // Cannot create markets for an event twice.\n        require(sportsEvents[_eventId].status == SportsEventStatus.Unknown, \"event exists\");\n\n        for (uint256 i = 0; i < _markets.length; i++) {\n            marketIdToEventIdMapping[_markets[i]] = _eventId;\n        }\n\n        listOfSportsEvents.push(_eventId);\n        sportsEvents[_eventId].status = SportsEventStatus.Scheduled; // new events must be Scheduled\n        sportsEvents[_eventId].markets = _markets;\n        sportsEvents[_eventId].lines = _lines;\n        sportsEvents[_eventId].estimatedStartTime = _estimatedStartTime;\n        sportsEvents[_eventId].homeTeamId = _homeTeamId;\n        sportsEvents[_eventId].awayTeamId = _awayTeamId;\n        sportsEvents[_eventId].homeTeamName = _homeTeamName;\n        sportsEvents[_eventId].awayTeamName = _awayTeamName;\n        // homeScore and awayScore default to zero, which is correct for new events\n\n        emit SportsEventCreated(\n            _eventId,\n            _markets,\n            _lines,\n            _homeTeamId,\n            _awayTeamId,\n            _homeTeamName,\n            _awayTeamName,\n            _estimatedStartTime\n        );\n    }\n\n    uint256 constant WhoWonUnknown = 0;\n    uint256 constant WhoWonHome = 1;\n    uint256 constant WhoWonAway = 2;\n    uint256 constant WhoWonDraw = 3;\n\n    function eventIsNoContest(\n        SportsEvent memory _event,\n        SportsEventStatus _eventStatus,\n        uint256 _homeTeamId,\n        uint256 _awayTeamId,\n        uint256 _whoWon // pass in WhoWonUnknown if using a scoring sport\n    ) internal pure returns (bool) {\n        bool _draw = _whoWon == WhoWonDraw;\n        bool _notFinal = _eventStatus != SportsEventStatus.Final;\n        bool _unstableHomeTeamId = _event.homeTeamId != _homeTeamId;\n        bool _unstableAwayTeamId = _event.awayTeamId != _awayTeamId;\n        return _draw || _notFinal || _unstableHomeTeamId || _unstableAwayTeamId;\n    }\n\n    function resolveInvalidEvent(uint256 _eventId) internal {\n        uint256[] memory _marketIds = sportsEvents[_eventId].markets;\n        for (uint256 i = 0; i < _marketIds.length; i++) {\n            uint256 _marketId = _marketIds[i];\n            if (_marketId == 0) continue; // skip non-created markets\n            endMarket(_marketId, NoContest);\n        }\n    }\n\n    // TODO is this needed? getSportsEvent should do the same\n    function getEventMarkets(uint256 _eventId) public view returns (uint256[] memory _markets) {\n        uint256[] storage _original = sportsEvents[_eventId].markets;\n        uint256 _len = _original.length;\n        _markets = new uint256[](_len);\n        for (uint256 i = 0; i < _len; i++) {\n            _markets[i] = _original[i];\n        }\n    }\n\n    function getRewardEndTime(uint256 _marketId) public view override returns (uint256) {\n        uint256 _eventId = marketIdToEventIdMapping[_marketId];\n        return getSportsEvent(_eventId).estimatedStartTime;\n    }\n}\n\n// TODO change this to work with the Fetcher contracts and use it there, since it's offchain-read-only.\nabstract contract SportView is Sport {\n    // Only usable off-chain. Gas cost can easily eclipse block limit.\n    // Lists all events that could be resolved with a call to resolveEvent.\n    // Not all will be resolvable because this does not ensure the game ended.\n    function listResolvableEvents() external view returns (uint256[] memory) {\n        uint256 _totalResolvable = countResolvableEvents();\n        uint256[] memory _resolvableEvents = new uint256[](_totalResolvable);\n\n        uint256 n = 0;\n        for (uint256 i = 0; i < listOfSportsEvents.length; i++) {\n            if (n > _totalResolvable) break;\n            uint256 _eventId = listOfSportsEvents[i];\n            if (isEventResolvable(_eventId)) {\n                _resolvableEvents[n] = _eventId;\n                n++;\n            }\n        }\n\n        return _resolvableEvents;\n    }\n\n    function countResolvableEvents() internal view returns (uint256) {\n        uint256 _totalResolvable = 0;\n        for (uint256 i = 0; i < listOfSportsEvents.length; i++) {\n            uint256 _eventId = listOfSportsEvents[i];\n            if (isEventResolvable(_eventId)) {\n                _totalResolvable++;\n            }\n        }\n        return _totalResolvable;\n    }\n\n    // Returns true if a call to resolveEvent is potentially useful.\n    function isEventResolvable(uint256 _eventId) internal view returns (bool) {\n        uint256[] memory _markets = getEventMarkets(_eventId);\n\n        bool _unresolved = false; // default because non-existing markets aren't resolvable\n        for (uint256 i = 0; i < _markets.length; i++) {\n            uint256 _marketId = _markets[i];\n            if (_marketId != 0 && !isMarketResolved(_marketId)) {\n                _unresolved = true;\n                break;\n            }\n        }\n\n        return _unresolved;\n    }\n}\n"
    },
    "contracts/libraries/ResolveByFiat.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./Sport.sol\";\nimport \"./ManagedByLink.sol\";\n\nabstract contract ResolvesByFiat is Sport, ManagedByLink {\n    function resolveEvent(\n        uint256 _eventId,\n        SportsEventStatus _eventStatus,\n        uint256 _homeTeamId, // for verifying team stability\n        uint256 _awayTeamId, // for verifying team stability\n        uint256 _whoWon\n    ) public onlyLinkNode {\n        SportsEvent storage _event = sportsEvents[_eventId];\n\n        require(_event.status == SportsEventStatus.Scheduled);\n        require(SportsEventStatus(_eventStatus) != SportsEventStatus.Scheduled);\n\n        if (eventIsNoContest(_event, _eventStatus, _homeTeamId, _awayTeamId, _whoWon)) {\n            resolveInvalidEvent(_eventId);\n        } else {\n            resolveValidEvent(_event, _whoWon);\n        }\n\n        sportsEvents[_eventId].status = _eventStatus;\n    }\n\n    function resolveValidEvent(SportsEvent memory _event, uint256 _whoWon) internal virtual;\n}\n"
    },
    "contracts/libraries/HasHeadToHeadMarket.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../turbo/AbstractMarketFactoryV3.sol\";\nimport \"./Sport.sol\";\nimport \"./CalculateLinesToBPoolOdds.sol\";\nimport \"./TokenNamesFromTeams.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/SignedSafeMath.sol\";\n\nabstract contract HasHeadToHeadMarket is\n    AbstractMarketFactoryV3,\n    Sport,\n    CalculateLinesToBPoolOdds,\n    TokenNamesFromTeams\n{\n    using SafeMath for uint256;\n    using SignedSafeMath for int256;\n\n    uint256 private headToHeadMarketType;\n    string private noContestName;\n\n    uint256 constant HeadToHeadAway = 1;\n    uint256 constant HeadToHeadHome = 2;\n\n    constructor(uint256 _marketType, string memory _noContestName) {\n        headToHeadMarketType = _marketType;\n        noContestName = _noContestName;\n    }\n\n    function makeHeadToHeadMarket(\n        int256[2] memory _moneylines,\n        string memory _homeTeamName,\n        string memory _awayTeamName\n    ) internal returns (uint256) {\n        // moneylines is [home,away] but the outcomes are listed [NC,away,home] so they must be reversed\n        return\n            makeSportsMarket(\n                noContestName,\n                _homeTeamName,\n                _awayTeamName,\n                oddsFromLines(_moneylines[1], _moneylines[0])\n            );\n    }\n\n    function resolveHeadToHeadMarket(\n        uint256 _marketId,\n        uint256 _homeScore,\n        uint256 _awayScore\n    ) internal {\n        uint256 _shareTokenIndex = calcHeadToHeadWinner(_homeScore, _awayScore);\n        endMarket(_marketId, _shareTokenIndex);\n    }\n\n    function calcHeadToHeadWinner(uint256 _homeScore, uint256 _awayScore) private pure returns (uint256) {\n        if (_homeScore > _awayScore) {\n            return HeadToHeadHome;\n        } else if (_homeScore < _awayScore) {\n            return HeadToHeadAway;\n        } else {\n            return NoContest;\n        }\n    }\n}\n"
    },
    "contracts/libraries/Versioned.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nabstract contract Versioned {\n    string internal version;\n\n    constructor(string memory _version) {\n        version = _version;\n    }\n\n    function getVersion() public view returns (string memory) {\n        return version;\n    }\n}\n"
    },
    "contracts/libraries/LineHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nabstract contract LineHelper {\n    function build1Line() internal pure returns (int256[] memory _lines) {\n        _lines = new int256[](1);\n    }\n\n    function build3Lines(int256 _homeSpread, int256 _totalScore) internal pure returns (int256[] memory _lines) {\n        _lines = new int256[](3);\n        // 0 is the Head-to-Head market, which has no lines\n        _lines[1] = addHalfPoint(_homeSpread);\n        _lines[2] = addHalfPoint(_totalScore);\n    }\n\n    function addHalfPoint(int256 _line) internal pure returns (int256) {\n        // The line is a quantity of tenths. So 55 is 5.5 and -6 is -60.\n        // If the line is a whole number then make it a half point more extreme, to eliminate ties.\n        // So 50 becomes 55, -60 becomes -65, and 0 becomes 5.\n        if (_line >= 0 && _line % 10 == 0) {\n            return _line + 5;\n        } else if (_line < 0 && (-_line) % 10 == 0) {\n            return _line - 5;\n        } else {\n            return _line;\n        }\n    }\n}\n"
    },
    "contracts/libraries/ManagedByLink.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./Ownable.sol\";\n\nabstract contract ManagedByLink is Ownable {\n    event LinkNodeChanged(address newLinkNode);\n\n    address public linkNode;\n\n    constructor(address _linkNode) {\n        linkNode = _linkNode;\n    }\n\n    function setLinkNode(address _newLinkNode) external onlyOwner {\n        linkNode = _newLinkNode;\n        emit LinkNodeChanged(_newLinkNode);\n    }\n\n    modifier onlyLinkNode() {\n        require(msg.sender == linkNode);\n        _;\n    }\n}\n"
    },
    "contracts/libraries/CalculateLinesToBPoolOdds.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/SignedSafeMath.sol\";\n\nabstract contract CalculateLinesToBPoolOdds {\n    using SafeMath for uint256;\n    using SignedSafeMath for int256;\n\n    uint256 constant MAX_BPOOL_WEIGHT = 50e18;\n\n    function ratioOdds(uint256[] memory _proportions) internal pure returns (uint256[] memory _odds) {\n        uint256 _total = sum(_proportions);\n\n        _odds = new uint256[](_proportions.length);\n        for (uint256 i = 0; i < _proportions.length; i++) {\n            _odds[i] = (MAX_BPOOL_WEIGHT).mul(_proportions[i]).div(_total);\n            require(_odds[i] >= 1e18, \"min outcome weight is 2%\");\n        }\n    }\n\n    function sum(uint256[] memory _numbers) private pure returns (uint256 _sum) {\n        for (uint256 i = 0; i < _numbers.length; i++) {\n            _sum += _numbers[i];\n        }\n    }\n\n    function evenOdds(bool _invalid, uint256 _outcomes) internal pure returns (uint256[] memory _odds) {\n        uint256 _size = _outcomes + (_invalid ? 1 : 0);\n        _odds = new uint256[](_size);\n\n        if (_invalid) _odds[0] = 1e18; // 2%\n\n        uint256 _each = (_invalid ? 49e18 : 50e18) / _outcomes;\n        for (uint256 i = _invalid ? 1 : 0; i < _size; i++) {\n            _odds[i] = _each;\n        }\n    }\n\n    function oddsFromLines(int256 _moneyline1, int256 _moneyline2) internal pure returns (uint256[] memory _odds) {\n        uint256 _odds1 = __calcLineToOdds(_moneyline1);\n        uint256 _odds2 = __calcLineToOdds(_moneyline2);\n\n        uint256 _total = _odds1 + _odds2;\n\n        _odds1 = uint256(49e18).mul(_odds1).div(_total);\n        _odds2 = uint256(49e18).mul(_odds2).div(_total);\n\n        // Moneyline odds are too skewed: would have under 2% odds.\n        require(_odds1 >= 1e18);\n        require(_odds2 >= 1e18);\n\n        _odds = new uint256[](3);\n        _odds[0] = 1e18; // Invalid, 2%\n        _odds[1] = _odds1;\n        _odds[2] = _odds2;\n    }\n\n    function __calcLineToOdds(int256 _line) internal pure returns (uint256) {\n        if (_line < 0) {\n            // favored\n            uint256 _posLine = uint256(-_line);\n            return _posLine.mul(49e18).div(_posLine.add(100)); // 49e18 * _line / (_line + 100)\n        } else {\n            // underdog\n            return uint256(4900e18).div(uint256(_line).add(100)); // 49e18 * 100 / (_line + 100)\n        }\n    }\n}\n"
    },
    "contracts/libraries/TokenNamesFromTeams.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./Sport.sol\";\n\nabstract contract TokenNamesFromTeams is Sport {\n    uint256 constant Away = 1;\n    uint256 constant Home = 2;\n\n    function makeSportsMarket(\n        string memory _noContestName,\n        string memory _homeTeamName,\n        string memory _awayTeamName,\n        uint256[] memory _odds\n    ) internal returns (uint256) {\n        string[] memory _outcomeNames = makeOutcomeNames(_noContestName, _homeTeamName, _awayTeamName);\n        return startMarket(msg.sender, _outcomeNames, _odds, true);\n    }\n\n    function makeOutcomeNames(\n        string memory _noContestName,\n        string memory _homeTeamName,\n        string memory _awayTeamName\n    ) private pure returns (string[] memory _names) {\n        _names = new string[](3);\n        _names[NoContest] = _noContestName;\n        _names[Away] = _awayTeamName;\n        _names[Home] = _homeTeamName;\n    }\n}\n"
    },
    "contracts/utils/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}"
    },
    "contracts/libraries/HasSpreadMarket.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../turbo/AbstractMarketFactoryV3.sol\";\nimport \"./Sport.sol\";\nimport \"./CalculateLinesToBPoolOdds.sol\";\nimport \"./TokenNamesFromTeams.sol\";\n\nabstract contract HasSpreadMarket is AbstractMarketFactoryV3, Sport, CalculateLinesToBPoolOdds, TokenNamesFromTeams {\n    using SafeMath for uint256;\n    using SignedSafeMath for int256;\n\n    uint256 private spreadMarketType;\n    string private noContestName;\n\n    uint256 constant SpreadAway = 1;\n    uint256 constant SpreadHome = 2;\n\n    constructor(uint256 _marketType, string memory _noContestName) {\n        spreadMarketType = _marketType;\n        noContestName = _noContestName;\n    }\n\n    function makeSpreadMarket(string memory _homeTeamName, string memory _awayTeamName) internal returns (uint256) {\n        return makeSportsMarket(noContestName, _homeTeamName, _awayTeamName, evenOdds(true, 2));\n    }\n\n    function resolveSpreadMarket(\n        uint256 _marketId,\n        int256 _line,\n        uint256 _homeScore,\n        uint256 _awayScore\n    ) internal {\n        uint256 _shareTokenIndex = calcSpreadWinner(_homeScore, _awayScore, _line);\n        endMarket(_marketId, _shareTokenIndex);\n    }\n\n    function calcSpreadWinner(\n        uint256 _homeScore,\n        uint256 _awayScore,\n        int256 _targetSpread\n    ) internal pure returns (uint256) {\n        int256 _adjustedHomeScore = int256(_homeScore) + int256(_targetSpread);\n\n        if (_adjustedHomeScore > int256(_awayScore)) {\n            return SpreadHome; // home spread greater\n        } else if (_adjustedHomeScore < int256(_awayScore)) {\n            return SpreadAway; // away spread lesser\n        } else {\n            // draw / tie; some sports eliminate this with half-points\n            return NoContest;\n        }\n    }\n}\n"
    },
    "contracts/libraries/ResolveByScore.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./Sport.sol\";\nimport \"./ManagedByLink.sol\";\n\nabstract contract ResolvesByScore is Sport, ManagedByLink {\n    function resolveEvent(\n        uint256 _eventId,\n        SportsEventStatus _eventStatus,\n        uint256 _homeTeamId, // for verifying team stability\n        uint256 _awayTeamId, // for verifying team stability\n        uint256 _homeScore,\n        uint256 _awayScore\n    ) public onlyLinkNode {\n        SportsEvent storage _event = sportsEvents[_eventId];\n\n        require(_event.status == SportsEventStatus.Scheduled);\n        require(uint8(_eventStatus) >= uint8(SportsEventStatus.Final));\n\n        if (eventIsNoContest(_event, _eventStatus, _homeTeamId, _awayTeamId, WhoWonUnknown)) {\n            resolveInvalidEvent(_eventId);\n        } else {\n            resolveValidEvent(_event, _homeScore, _awayScore);\n        }\n\n        _event.status = _eventStatus;\n        _event.homeScore = _homeScore;\n        _event.awayScore = _awayScore;\n    }\n\n    function resolveValidEvent(\n        SportsEvent memory _event,\n        uint256 _homeScore,\n        uint256 _awayScore\n    ) internal virtual;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/draft-IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/structs/EnumerableSet.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n *  Trying to delete such a structure from storage will likely result in data corruption, rendering the structure unusable.\n *  See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n *  In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/turbo/GroupFetcher.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./Fetcher.sol\";\nimport \"./Grouped.sol\";\n\nabstract contract GroupFetcher is Fetcher {\n    struct SpecificMarketFactoryBundle {\n        MarketFactoryBundle _super;\n    }\n\n    struct StaticGroupBundle {\n        uint256 id;\n        string name;\n        StaticMarketBundle[] markets;\n        string[] marketNames;\n        StaticMarketBundle invalidMarket;\n        string invalidMarketName;\n        uint256 endTime;\n        string category;\n        // Dynamics\n        Grouped.GroupStatus status;\n    }\n\n    struct DynamicGroupBundle {\n        uint256 id;\n        Grouped.GroupStatus status;\n        DynamicMarketBundle[] markets;\n        DynamicMarketBundle invalidMarket;\n    }\n\n    function buildSpecificMarketFactoryBundle(address _marketFactory)\n        internal\n        view\n        returns (SpecificMarketFactoryBundle memory _bundle)\n    {\n        _bundle._super = buildMarketFactoryBundle(AbstractMarketFactoryV3(_marketFactory));\n    }\n\n    function fetchInitial(\n        address _marketFactory,\n        AMMFactory _ammFactory,\n        MasterChef _masterChef,\n        uint256 _offset,\n        uint256 _total\n    )\n        public\n        view\n        returns (\n            SpecificMarketFactoryBundle memory _marketFactoryBundle,\n            StaticGroupBundle[] memory _groupBundles,\n            uint256 _lowestGroupIndex,\n            uint256 _timestamp\n        )\n    {\n        _marketFactoryBundle = buildSpecificMarketFactoryBundle(_marketFactory);\n        (_groupBundles, _lowestGroupIndex) = buildStaticGroupBundles(\n            _marketFactory,\n            _ammFactory,\n            _masterChef,\n            _offset,\n            _total\n        );\n        _timestamp = block.timestamp;\n    }\n\n    function fetchDynamic(\n        address _marketFactory,\n        AMMFactory _ammFactory,\n        uint256 _offset,\n        uint256 _total\n    )\n        public\n        view\n        returns (\n            DynamicGroupBundle[] memory _bundles,\n            uint256 _lowestGroupIndex,\n            uint256 _timestamp\n        )\n    {\n        (_bundles, _lowestGroupIndex) = buildDynamicGroupBundles(_marketFactory, _ammFactory, _offset, _total);\n        _timestamp = block.timestamp;\n    }\n\n    function buildStaticGroupBundles(\n        address _marketFactory,\n        AMMFactory _ammFactory,\n        MasterChef _masterChef,\n        uint256 _offset,\n        uint256 _total\n    ) internal view returns (StaticGroupBundle[] memory _bundles, uint256 _lowestGroupIndex) {\n        uint256[] memory _groupIds;\n        (_groupIds, _lowestGroupIndex) = listOfInterestingGroups(_marketFactory, _offset, _total);\n\n        _total = _groupIds.length;\n        _bundles = new StaticGroupBundle[](_total);\n        for (uint256 i; i < _total; i++) {\n            _bundles[i] = buildStaticGroupBundle(_marketFactory, _ammFactory, _masterChef, _groupIds[i]);\n        }\n    }\n\n    function buildDynamicGroupBundles(\n        address _marketFactory,\n        AMMFactory _ammFactory,\n        uint256 _offset,\n        uint256 _total\n    ) internal view returns (DynamicGroupBundle[] memory _bundles, uint256 _lowestGroupIndex) {\n        uint256[] memory _groupIds;\n        (_groupIds, _lowestGroupIndex) = listOfInterestingGroups(_marketFactory, _offset, _total);\n\n        _total = _groupIds.length;\n        _bundles = new DynamicGroupBundle[](_total);\n        for (uint256 i; i < _total; i++) {\n            _bundles[i] = buildDynamicGroupBundle(_marketFactory, _ammFactory, _groupIds[i]);\n        }\n    }\n\n    function buildStaticGroupBundle(\n        address _marketFactory,\n        AMMFactory _ammFactory,\n        MasterChef _masterChef,\n        uint256 _groupId\n    ) internal view returns (StaticGroupBundle memory _bundle) {\n        Grouped.MarketGroup memory _group = Grouped(_marketFactory).getGroup(_groupId);\n\n        StaticMarketBundle[] memory _markets = new StaticMarketBundle[](_group.markets.length);\n        for (uint256 i = 0; i < _markets.length; i++) {\n            _markets[i] = buildStaticMarketBundle(\n                AbstractMarketFactoryV3(_marketFactory),\n                _ammFactory,\n                _masterChef,\n                _group.markets[i]\n            );\n        }\n\n        _bundle.id = _groupId;\n        _bundle.name = _group.name;\n        _bundle.status = _group.status;\n        _bundle.markets = _markets;\n        _bundle.endTime = _group.endTime;\n        _bundle.invalidMarket = buildStaticMarketBundle(\n            AbstractMarketFactoryV3(_marketFactory),\n            _ammFactory,\n            _masterChef,\n            _group.invalidMarket\n        );\n        _bundle.invalidMarketName = _group.invalidMarketName;\n        _bundle.marketNames = _group.marketNames;\n        _bundle.category = _group.category;\n    }\n\n    function buildDynamicGroupBundle(\n        address _marketFactory,\n        AMMFactory _ammFactory,\n        uint256 _groupId\n    ) internal view returns (DynamicGroupBundle memory _bundle) {\n        Grouped.MarketGroup memory _group = Grouped(_marketFactory).getGroup(_groupId);\n\n        DynamicMarketBundle[] memory _markets = new DynamicMarketBundle[](_group.markets.length);\n        for (uint256 i = 0; i < _markets.length; i++) {\n            _markets[i] = buildDynamicMarketBundle(\n                AbstractMarketFactoryV3(_marketFactory),\n                _ammFactory,\n                _group.markets[i]\n            );\n        }\n\n        _bundle.id = _groupId;\n        _bundle.markets = _markets;\n        _bundle.invalidMarket = buildDynamicMarketBundle(\n            AbstractMarketFactoryV3(_marketFactory),\n            _ammFactory,\n            _group.invalidMarket\n        );\n        _bundle.status = _group.status;\n    }\n\n    // Starts from the end of the groups list because newer groups are more interesting.\n    // _offset is skipping all groups, not just interesting groups\n    function listOfInterestingGroups(\n        address _marketFactory,\n        uint256 _offset,\n        uint256 _total\n    ) internal view returns (uint256[] memory _interestingGroupIds, uint256 _groupIndex) {\n        _interestingGroupIds = new uint256[](_total);\n\n        uint256 _groupCount = Grouped(_marketFactory).groupCount();\n\n        // No groups so return nothing. (needed to avoid integer underflow below)\n        if (_groupCount == 0) {\n            return (new uint256[](0), 0);\n        }\n\n        uint256 _max = _groupCount;\n\n        // No remaining groups so return nothing. (needed to avoid integer underflow below)\n        if (_offset > _max) {\n            return (new uint256[](0), 0);\n        }\n\n        uint256 _collectedGroups = 0;\n        _groupIndex = _max - _offset;\n        while (true) {\n            if (_collectedGroups >= _total) break;\n            if (_groupIndex == 0) break;\n\n            _groupIndex--; // starts out one too high, so this works\n\n            (Grouped.MarketGroup memory _group, uint256 _groupId) =\n                Grouped(_marketFactory).getGroupByIndex(_groupIndex);\n\n            if (isGroupInteresting(_group, AbstractMarketFactoryV3(_marketFactory))) {\n                _interestingGroupIds[_collectedGroups] = _groupId;\n                _collectedGroups++;\n            }\n        }\n\n        if (_total > _collectedGroups) {\n            assembly {\n                // shortens array\n                mstore(_interestingGroupIds, _collectedGroups)\n            }\n        }\n    }\n\n    function isGroupInteresting(Grouped.MarketGroup memory _group, AbstractMarketFactoryV3 _marketFactory)\n        private\n        view\n        returns (bool)\n    {\n        for (uint256 i = 0; i < _group.markets.length; i++) {\n            uint256 _marketId = _group.markets[i];\n            if (openOrHasWinningShares(_marketFactory, _marketId)) {\n                return true;\n            }\n        }\n        if (openOrHasWinningShares(_marketFactory, _group.invalidMarket)) {\n            return true;\n        }\n\n        return false;\n    }\n}\n\ncontract GroupedFetcher is GroupFetcher {\n    constructor() Fetcher(\"Grouped\", \"TBD\") {}\n}\n"
    },
    "contracts/turbo/Grouped.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./AbstractMarketFactoryV3.sol\";\nimport \"../libraries/CalculateLinesToBPoolOdds.sol\";\nimport \"./GroupFetcher.sol\";\n\nabstract contract Grouped is AbstractMarketFactoryV3, CalculateLinesToBPoolOdds {\n    event GroupCreated(uint256 indexed id, uint256 endTime, uint256 invalidMarketId, string invalidMarketName);\n    event GroupMarketAdded(uint256 indexed groupId, uint256 marketId, string marketName);\n    event GroupFinalizing(uint256 indexed groupId, uint256 winningMarketIndex);\n    event GroupResolved(uint256 indexed id, bool valid);\n\n    enum GroupStatus {Unknown, Scheduled, Finalizing, Final, Invalid}\n\n    struct MarketGroup {\n        GroupStatus status;\n        string name;\n        uint256[] markets;\n        string[] marketNames;\n        uint256 invalidMarket;\n        string invalidMarketName;\n        uint256 endTime;\n        string category;\n        uint256 winningMarketIndex; // ignore when status is Scheduled. MAX_UINT is invalid\n    }\n    // GroupId => MarketGroup\n    mapping(uint256 => MarketGroup) public marketGroups;\n    uint256[] public listOfMarketGroups;\n\n    // For regular markets, YES means the team won and NO means the team did not win.\n    // For the invalid market, YES means none of the teams won and NO means a team won.\n    uint256 constant OUTCOME_NO = 0;\n    uint256 constant OUTCOME_YES = 1;\n\n    uint256 constant MAX_UINT = 2**256 - 1;\n\n    function groupCount() public view returns (uint256) {\n        return listOfMarketGroups.length;\n    }\n\n    function getGroup(uint256 _groupId) public view returns (MarketGroup memory) {\n        return marketGroups[_groupId];\n    }\n\n    function getGroupByIndex(uint256 _index) public view returns (MarketGroup memory _group, uint256 _groupId) {\n        _groupId = listOfMarketGroups[_index];\n        _group = getGroup(_groupId);\n    }\n\n    function startCreatingMarketGroup(\n        uint256 _groupId,\n        string memory _groupName,\n        uint256 _endTime,\n        string memory _invalidMarketName,\n        string memory _category\n    ) internal {\n        require(marketGroups[_groupId].status == GroupStatus.Unknown, \"group exists\");\n\n        listOfMarketGroups.push(_groupId);\n        marketGroups[_groupId].status = GroupStatus.Scheduled;\n        marketGroups[_groupId].name = _groupName;\n        marketGroups[_groupId].endTime = _endTime;\n        marketGroups[_groupId].category = _category;\n\n        uint256 _invalidMarket = startMarket(msg.sender, buildOutcomesNames(_invalidMarketName), invalidOdds(), true);\n        marketGroups[_groupId].invalidMarket = _invalidMarket;\n        marketGroups[_groupId].invalidMarketName = _invalidMarketName;\n\n        emit GroupCreated(_groupId, _endTime, _invalidMarket, _invalidMarketName);\n        emit GroupMarketAdded(_groupId, _invalidMarket, _invalidMarketName);\n    }\n\n    function addMarketToMarketGroup(\n        uint256 _groupId,\n        string memory _marketName,\n        uint256[] memory _odds\n    ) internal {\n        require(marketGroups[_groupId].status == GroupStatus.Scheduled, \"group must be Scheduled\");\n\n        uint256 _marketId = startMarket(msg.sender, buildOutcomesNames(_marketName), _odds, true);\n        marketGroups[_groupId].markets.push(_marketId);\n        marketGroups[_groupId].marketNames.push(_marketName);\n        emit GroupMarketAdded(_groupId, _marketId, _marketName);\n    }\n\n    // Use MAX_UINT for _winningMarketIndex to indicate INVALID\n    function startResolvingMarketGroup(uint256 _groupId, uint256 _winningMarketIndex) internal {\n        bool _isInvalid = _winningMarketIndex == MAX_UINT;\n        MarketGroup memory _group = marketGroups[_groupId];\n\n        require(_group.status == GroupStatus.Scheduled, \"group not Scheduled\");\n\n        resolveInvalidMarket(_group, _isInvalid);\n        marketGroups[_groupId].status = GroupStatus.Finalizing;\n        marketGroups[_groupId].winningMarketIndex = _winningMarketIndex;\n        emit GroupFinalizing(_groupId, _winningMarketIndex);\n    }\n\n    function resolveFinalizingGroupMarket(uint256 _groupId, uint256 _marketIndex) internal {\n        MarketGroup memory _group = marketGroups[_groupId];\n        require(_group.status == GroupStatus.Finalizing, \"must be finalizing\");\n\n        uint256 _marketId = _group.markets[_marketIndex];\n        bool _wins = _marketIndex == _group.winningMarketIndex;\n        resolveGroupMarket(_marketId, _wins);\n    }\n\n    function finalizeMarketGroup(uint256 _groupId) internal {\n        MarketGroup storage _group = marketGroups[_groupId];\n        require(_group.status == GroupStatus.Finalizing);\n\n        bool _valid = _group.winningMarketIndex != MAX_UINT;\n\n        _group.status = _valid ? GroupStatus.Final : GroupStatus.Invalid;\n\n        emit GroupResolved(_groupId, _valid);\n    }\n\n    function resolveGroupMarket(uint256 _marketId, bool _wins) internal {\n        uint256 _winningOutcome = _wins ? OUTCOME_YES : OUTCOME_NO;\n        endMarket(_marketId, _winningOutcome);\n    }\n\n    function resolveInvalidMarket(MarketGroup memory _group, bool _invalid) private {\n        uint256 _outcomeIndex = _invalid ? OUTCOME_YES : OUTCOME_NO;\n        endMarket(_group.invalidMarket, _outcomeIndex);\n    }\n\n    function buildOutcomesNames(string memory _marketName) internal pure returns (string[] memory _names) {\n        _names = new string[](2);\n        _names[OUTCOME_NO] = string(abi.encodePacked(\"NO - \", _marketName));\n        _names[OUTCOME_YES] = string(abi.encodePacked(\"YES - \", _marketName));\n    }\n\n    function invalidOdds() private pure returns (uint256[] memory _odds) {\n        _odds = new uint256[](2);\n        _odds[OUTCOME_YES] = 1e18;\n        _odds[OUTCOME_NO] = 49e18;\n    }\n}\n"
    },
    "contracts/turbo/GroupedMarketFactoryV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./AbstractMarketFactoryV3.sol\";\nimport \"./FeePot.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/SignedSafeMath.sol\";\nimport \"./Grouped.sol\";\nimport \"../libraries/ManagedByLink.sol\";\nimport \"../libraries/Versioned.sol\";\n\ncontract GroupedMarketFactoryV3 is AbstractMarketFactoryV3, Grouped, ManagedByLink, Versioned {\n    using SafeMath for uint256;\n    using SignedSafeMath for int256;\n\n    constructor(\n        address _owner,\n        IERC20Full _collateral,\n        uint256 _shareFactor,\n        FeePot _feePot,\n        uint256[3] memory _fees,\n        address _protocol,\n        address _linkNode\n    )\n        AbstractMarketFactoryV3(_owner, _collateral, _shareFactor, _feePot, _fees, _protocol)\n        Versioned(\"v1.2.0\")\n        ManagedByLink(_linkNode)\n    {}\n\n    function initializeGroup(\n        uint256 _groupId,\n        string memory _groupName,\n        string memory _invalidMarketName,\n        uint256 _endTime,\n        string memory _category\n    ) public onlyLinkNode {\n        startCreatingMarketGroup(_groupId, _groupName, _endTime, _invalidMarketName, _category);\n    }\n\n    function addOutcomesToGroup(\n        uint256 _groupId,\n        string[] memory _marketNames,\n        uint256[][] memory _odds\n    ) public onlyLinkNode {\n        require(_marketNames.length == _odds.length);\n\n        for (uint256 i = 0; i < _marketNames.length; i++) {\n            addMarketToMarketGroup(_groupId, _marketNames[i], _odds[i]);\n        }\n    }\n\n    // Set _winner to MAX_UINT (2*256 - 1) to indicate invalid\n    function beginResolvingGroup(uint256 _groupId, uint256 _winningMarketIndex) public onlyLinkNode {\n        startResolvingMarketGroup(_groupId, _winningMarketIndex);\n    }\n\n    function resolveMarkets(uint256 _groupId, uint256[] memory _marketIndexes) public onlyLinkNode {\n        MarketGroup memory _group = marketGroups[_groupId];\n        require(_group.status == GroupStatus.Finalizing);\n\n        for (uint256 i = 0; i < _marketIndexes.length; i++) {\n            uint256 _marketIndex = _marketIndexes[i];\n            uint256 _marketId = _group.markets[_marketIndex];\n            if (isMarketResolved(_marketId)) continue; // skip resolved markets\n            resolveFinalizingGroupMarket(_groupId, _marketIndex);\n        }\n    }\n\n    function finalizeGroup(uint256 _groupId) public onlyLinkNode {\n        finalizeMarketGroup(_groupId);\n    }\n\n    // Used when some markets in a group can resolve early as NO.\n    // ex: Teams eliminated early from a tournament cannot win the overall tournament.\n    function resolveMarketAsNo(uint256 _marketId) public onlyLinkNode {\n        require(markets[_marketId].active, \"market inactive\");\n        resolveGroupMarket(_marketId, false);\n    }\n\n    function getRewardEndTime(uint256 _eventId) public view override returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "contracts/turbo/NFLMarketFactoryV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../libraries/IERC20Full.sol\";\nimport \"../balancer/BPool.sol\";\nimport \"./AbstractMarketFactoryV3.sol\";\nimport \"./FeePot.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/SignedSafeMath.sol\";\nimport \"../libraries/Sport.sol\";\nimport \"../libraries/HasHeadToHeadMarket.sol\";\nimport \"../libraries/HasSpreadMarket.sol\";\nimport \"../libraries/HasOverUnderMarket.sol\";\nimport \"../libraries/ResolveByScore.sol\";\nimport \"../libraries/Versioned.sol\";\n\n// NFL is standard except ties are fine: they become NoContestOrDraw.\n// As a consequence, half points are not added to the lines.\ncontract NFLMarketFactoryV3 is\n    AbstractMarketFactoryV3,\n    SportView,\n    HasHeadToHeadMarket,\n    HasSpreadMarket,\n    HasOverUnderMarket,\n    ResolvesByScore,\n    Versioned\n{\n    using SafeMath for uint256;\n    using SignedSafeMath for int256;\n\n    uint256 constant HeadToHead = 0;\n    uint256 constant Spread = 1;\n    uint256 constant OverUnder = 2;\n\n    constructor(\n        address _owner,\n        IERC20Full _collateral,\n        uint256 _shareFactor,\n        FeePot _feePot,\n        uint256[3] memory _fees,\n        address _protocol,\n        address _linkNode\n    )\n        AbstractMarketFactoryV3(_owner, _collateral, _shareFactor, _feePot, _fees, _protocol)\n        Versioned(\"v1.2.0\")\n        ManagedByLink(_linkNode)\n        HasHeadToHeadMarket(HeadToHead, \"No Contest / Draw\")\n        HasSpreadMarket(Spread, \"No Contest\")\n        HasOverUnderMarket(OverUnder, \"No Contest\")\n    {}\n\n    function createEvent(\n        uint256 _eventId,\n        string memory _homeTeamName,\n        uint256 _homeTeamId,\n        string memory _awayTeamName,\n        uint256 _awayTeamId,\n        uint256 _startTimestamp,\n        int256 _homeSpread,\n        int256 _totalScore,\n        int256[2] memory _moneylines // [home,away]\n    ) public onlyLinkNode returns (uint256[] memory _marketIds) {\n        _marketIds = makeMarkets(_moneylines, _homeTeamName, _awayTeamName);\n        makeSportsEvent(\n            _eventId,\n            _marketIds,\n            build3Lines(_homeSpread, _totalScore),\n            _startTimestamp,\n            _homeTeamId,\n            _awayTeamId,\n            _homeTeamName,\n            _awayTeamName\n        );\n    }\n\n    function makeMarkets(\n        int256[2] memory _moneylines,\n        string memory _homeTeamName,\n        string memory _awayTeamName\n    ) internal returns (uint256[] memory _marketIds) {\n        _marketIds = new uint256[](3);\n\n        _marketIds[HeadToHead] = makeHeadToHeadMarket(_moneylines, _homeTeamName, _awayTeamName);\n        _marketIds[Spread] = makeSpreadMarket(_homeTeamName, _awayTeamName);\n        _marketIds[OverUnder] = makeOverUnderMarket();\n    }\n\n    function resolveValidEvent(\n        SportsEvent memory _event,\n        uint256 _homeScore,\n        uint256 _awayScore\n    ) internal override {\n        resolveHeadToHeadMarket(_event.markets[HeadToHead], _homeScore, _awayScore);\n        resolveSpreadMarket(_event.markets[Spread], _event.lines[Spread], _homeScore, _awayScore);\n        resolveOverUnderMarket(_event.markets[OverUnder], _event.lines[OverUnder], _homeScore, _awayScore);\n    }\n}\n"
    },
    "contracts/libraries/HasOverUnderMarket.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../turbo/AbstractMarketFactoryV3.sol\";\nimport \"./Sport.sol\";\nimport \"./CalculateLinesToBPoolOdds.sol\";\n\nabstract contract HasOverUnderMarket is AbstractMarketFactoryV3, Sport, CalculateLinesToBPoolOdds {\n    using SafeMath for uint256;\n    using SignedSafeMath for int256;\n\n    uint256 private overUnderMarketType;\n    string private noContestName;\n\n    uint256 constant Over = 1;\n    uint256 constant Under = 2;\n\n    constructor(uint256 _marketType, string memory _noContestName) {\n        overUnderMarketType = _marketType;\n        noContestName = _noContestName;\n    }\n\n    function makeOverUnderMarket() internal returns (uint256) {\n        string[] memory _outcomeNames = makeOutcomeNames(noContestName);\n        return startMarket(msg.sender, _outcomeNames, evenOdds(true, 2), true);\n    }\n\n    function resolveOverUnderMarket(\n        uint256 _marketId,\n        int256 _line,\n        uint256 _homeScore,\n        uint256 _awayScore\n    ) internal {\n        uint256 _shareTokenIndex = calcOverUnderWinner(_homeScore, _awayScore, _line);\n        endMarket(_marketId, _shareTokenIndex);\n    }\n\n    function calcOverUnderWinner(\n        uint256 _homeScore,\n        uint256 _awayScore,\n        int256 _targetTotal\n    ) internal pure returns (uint256) {\n        int256 _actualTotal = int256(_homeScore).add(int256(_awayScore));\n\n        if (_actualTotal > _targetTotal) {\n            return Over; // total score above than line\n        } else if (_actualTotal < _targetTotal) {\n            return Under; // total score below line\n        } else {\n            return NoContest; // draw / tie; some sports eliminate this with half-points\n        }\n    }\n\n    function makeOutcomeNames(string memory _noContestName) private pure returns (string[] memory _names) {\n        _names = new string[](3);\n        _names[NoContest] = _noContestName;\n        _names[Over] = \"Over\";\n        _names[Under] = \"Under\";\n    }\n}\n"
    },
    "contracts/turbo/NCAAFBMarketFactoryV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../libraries/IERC20Full.sol\";\nimport \"../balancer/BPool.sol\";\nimport \"./AbstractMarketFactoryV3.sol\";\nimport \"./FeePot.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/SignedSafeMath.sol\";\nimport \"../libraries/Sport.sol\";\nimport \"../libraries/HasHeadToHeadMarket.sol\";\nimport \"../libraries/HasSpreadMarket.sol\";\nimport \"../libraries/HasOverUnderMarket.sol\";\nimport \"../libraries/ResolveByScore.sol\";\nimport \"../libraries/Versioned.sol\";\n\n// NCAA-FB is identical to NFL except there are no ties.\n// As a consequence, spread and over-under lines add a half-point,\n// and the invalid outcome is just No Contest.\ncontract NCAAFBMarketFactoryV3 is\n    AbstractMarketFactoryV3,\n    SportView,\n    HasHeadToHeadMarket,\n    HasSpreadMarket,\n    HasOverUnderMarket,\n    ResolvesByScore,\n    Versioned\n{\n    using SafeMath for uint256;\n    using SignedSafeMath for int256;\n\n    uint256 constant HeadToHead = 0;\n    uint256 constant Spread = 1;\n    uint256 constant OverUnder = 2;\n    string constant InvalidName = \"No Contest\";\n\n    constructor(\n        address _owner,\n        IERC20Full _collateral,\n        uint256 _shareFactor,\n        FeePot _feePot,\n        uint256[3] memory _fees,\n        address _protocol,\n        address _linkNode\n    )\n        AbstractMarketFactoryV3(_owner, _collateral, _shareFactor, _feePot, _fees, _protocol)\n        Versioned(\"v1.2.0\")\n        ManagedByLink(_linkNode)\n        HasHeadToHeadMarket(HeadToHead, InvalidName)\n        HasSpreadMarket(Spread, InvalidName)\n        HasOverUnderMarket(OverUnder, InvalidName)\n    {}\n\n    function createEvent(\n        uint256 _eventId,\n        string memory _homeTeamName,\n        uint256 _homeTeamId,\n        string memory _awayTeamName,\n        uint256 _awayTeamId,\n        uint256 _startTimestamp,\n        int256 _homeSpread,\n        int256 _totalScore,\n        int256[2] memory _moneylines // [home,away]\n    ) public onlyLinkNode returns (uint256[] memory _marketIds) {\n        _marketIds = makeMarkets(_moneylines, _homeTeamName, _awayTeamName);\n        makeSportsEvent(\n            _eventId,\n            _marketIds,\n            build3Lines(_homeSpread, _totalScore),\n            _startTimestamp,\n            _homeTeamId,\n            _awayTeamId,\n            _homeTeamName,\n            _awayTeamName\n        );\n    }\n\n    function makeMarkets(\n        int256[2] memory _moneylines,\n        string memory _homeTeamName,\n        string memory _awayTeamName\n    ) internal returns (uint256[] memory _marketIds) {\n        _marketIds = new uint256[](3);\n\n        _marketIds[HeadToHead] = makeHeadToHeadMarket(_moneylines, _homeTeamName, _awayTeamName);\n        _marketIds[Spread] = makeSpreadMarket(_homeTeamName, _awayTeamName);\n        _marketIds[OverUnder] = makeOverUnderMarket();\n    }\n\n    function resolveValidEvent(\n        SportsEvent memory _event,\n        uint256 _homeScore,\n        uint256 _awayScore\n    ) internal override {\n        resolveHeadToHeadMarket(_event.markets[HeadToHead], _homeScore, _awayScore);\n        resolveSpreadMarket(_event.markets[Spread], _event.lines[Spread], _homeScore, _awayScore);\n        resolveOverUnderMarket(_event.markets[OverUnder], _event.lines[OverUnder], _homeScore, _awayScore);\n    }\n}\n"
    },
    "contracts/turbo/TrustedMarketFactoryV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\nimport \"../libraries/IERC20Full.sol\";\nimport \"../balancer/BPool.sol\";\nimport \"./AbstractMarketFactoryV2.sol\";\nimport \"./FeePot.sol\";\nimport \"../libraries/CalculateLinesToBPoolOdds.sol\";\n\n\ncontract TrustedMarketFactoryV2 is AbstractMarketFactoryV2, CalculateLinesToBPoolOdds {\n    using SafeMath for uint256;\n\n    event MarketCreated(uint256 id, address creator, uint256 _endTime, string description, string[] outcomes);\n    event MarketResolved(uint256 id, address winner);\n\n    struct MarketDetails {\n        string description;\n    }\n    MarketDetails[] internal marketDetails;\n\n    constructor(\n        address _owner,\n        IERC20Full _collateral,\n        uint256 _shareFactor,\n        FeePot _feePot,\n        uint256 _stakerFee,\n        uint256 _settlementFee,\n        address _protocol,\n        uint256 _protocolFee\n    )\n        AbstractMarketFactoryV2(\n            _owner,\n            _collateral,\n            _shareFactor,\n            _feePot,\n            _stakerFee,\n            _settlementFee,\n            _protocol,\n            _protocolFee\n        )\n    {}\n\n    function createMarket(\n        address _creator,\n        uint256 _endTime,\n        string calldata _description,\n        string[] calldata _names,\n        string[] calldata _symbols,\n        uint256[] calldata _odds\n    ) public onlyOwner returns (uint256) {\n        require(\n            _names.length == _symbols.length && _symbols.length == _odds.length,\n            \"names, symbols, and odds must be the same length\"\n        );\n\n        uint256 _id = markets.length;\n        markets.push(makeMarket(_creator, _names, _symbols, _endTime, _odds));\n        marketDetails.push(MarketDetails(_description));\n\n        emit MarketCreated(_id, _creator, _endTime, _description, _symbols);\n        return _id;\n    }\n\n    function resolveMarket(uint256) public pure override {\n        require(false, \"Only the TrustedMarketFactory owner can resolve the market, using trustedResolveMarket\");\n    }\n\n    function trustedResolveMarket(uint256 _id, uint256 _winningOutcome) public onlyOwner {\n        OwnedERC20 _winner = markets[_id].shareTokens[_winningOutcome];\n        markets[_id].winner = _winner;\n        emit MarketResolved(_id, address(_winner));\n    }\n\n    function getMarketDetails(uint256 _id) public view returns (MarketDetails memory) {\n        return marketDetails[_id];\n    }\n}\n"
    },
    "contracts/turbo/AbstractMarketFactoryV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../libraries/IERC20Full.sol\";\nimport \"../balancer/BPool.sol\";\nimport \"./TurboShareTokenFactory.sol\";\nimport \"./FeePot.sol\";\n\nabstract contract AbstractMarketFactoryV2 is TurboShareTokenFactoryV1, Ownable {\n    using SafeMath for uint256;\n\n    // Should always have ID. Others are optional.\n    // event MarketCreated(uint256 id, address settlementAddress, uint256 endTime, ...);\n\n    // Should always have ID. Others are optional.\n    // event MarketResolved(uint256 id, ...);\n\n    event SharesMinted(uint256 id, uint256 amount, address receiver);\n    event SharesBurned(uint256 id, uint256 amount, address receiver);\n    event WinningsClaimed(\n        uint256 id,\n        address winningOutcome,\n        uint256 amount,\n        uint256 settlementFee,\n        uint256 payout,\n        address indexed receiver\n    );\n\n    event SettlementFeeClaimed(address settlementAddress, uint256 amount, address indexed receiver);\n    event ProtocolFeeClaimed(address protocol, uint256 amount);\n\n    event ProtocolChanged(address protocol);\n    event ProtocolFeeChanged(uint256 fee);\n    event SettlementFeeChanged(uint256 fee);\n    event StakerFeeChanged(uint256 fee);\n\n    IERC20Full public collateral;\n    FeePot public feePot;\n\n    // fees are out of 1e18 and only apply to new markets\n    uint256 public stakerFee;\n    uint256 public settlementFee;\n    uint256 public protocolFee;\n\n    address public protocol; // collects protocol fees\n\n    uint256 public accumulatedProtocolFee = 0;\n    // settlement address => amount of collateral\n    mapping(address => uint256) public accumulatedSettlementFees;\n\n    // How many shares equals one collateral.\n    // Necessary to account for math errors from small numbers in balancer.\n    // shares = collateral / shareFactor\n    // collateral = shares * shareFactor\n    uint256 public shareFactor;\n\n    struct Market {\n        address settlementAddress;\n        OwnedERC20[] shareTokens;\n        uint256 endTime;\n        OwnedERC20 winner;\n        uint256 settlementFee;\n        uint256 protocolFee;\n        uint256 stakerFee;\n        uint256 creationTimestamp;\n        uint256[] initialOdds;\n    }\n    Market[] internal markets;\n\n    uint256 private constant MAX_UINT = 2**256 - 1;\n\n    constructor(\n        address _owner,\n        IERC20Full _collateral,\n        uint256 _shareFactor,\n        FeePot _feePot,\n        uint256 _stakerFee,\n        uint256 _settlementFee,\n        address _protocol,\n        uint256 _protocolFee\n    ) {\n        owner = _owner; // controls fees for new markets\n        collateral = _collateral;\n        shareFactor = _shareFactor;\n        feePot = _feePot;\n        stakerFee = _stakerFee;\n        settlementFee = _settlementFee;\n        protocol = _protocol;\n        protocolFee = _protocolFee;\n\n        _collateral.approve(address(_feePot), MAX_UINT);\n\n        // First market is always empty so that marketid zero means \"no market\"\n        makeEmptyMarket();\n    }\n\n    function makeEmptyMarket() internal {\n        string[] memory _noStrings = new string[](0);\n        uint256[] memory _noUint256s = new uint256[](0);\n        markets.push(makeMarket(address(0), _noStrings, _noStrings, 0, _noUint256s));\n    }\n\n    // function createMarket(address _settlementAddress, uint256 _endTime, ...) public returns (uint256);\n\n    function resolveMarket(uint256 _id) public virtual;\n\n    // Returns an empty struct if the market doesn't exist.\n    // Can check market existence before calling this by comparing _id against markets.length.\n    // Can check market existence of the return struct by checking that shareTokens[0] isn't the null address\n    function getMarket(uint256 _id) public view returns (Market memory) {\n        if (_id >= markets.length) {\n            return Market(address(0), new OwnedERC20[](0), 0, OwnedERC20(address(0)), 0, 0, 0, 0, new uint256[](0));\n        } else {\n            return markets[_id];\n        }\n    }\n\n    function marketCount() public view returns (uint256) {\n        return markets.length;\n    }\n\n    // Returns factory-specific details about a market.\n    // function getMarketDetails(uint256 _id) public view returns (MarketDetails memory);\n\n    function mintShares(\n        uint256 _id,\n        uint256 _shareToMint,\n        address _receiver\n    ) public {\n        require(markets.length > _id, \"No such market\");\n        require(!isMarketResolved(_id), \"Cannot mint shares for resolved market\");\n\n        uint256 _cost = calcCost(_shareToMint);\n        collateral.transferFrom(msg.sender, address(this), _cost);\n\n        Market memory _market = markets[_id];\n        for (uint256 _i = 0; _i < _market.shareTokens.length; _i++) {\n            _market.shareTokens[_i].trustedMint(_receiver, _shareToMint);\n        }\n\n        emit SharesMinted(_id, _shareToMint, _receiver);\n    }\n\n    function burnShares(\n        uint256 _id,\n        uint256 _sharesToBurn,\n        address _receiver\n    ) public returns (uint256) {\n        require(markets.length > _id, \"No such market\");\n        require(!isMarketResolved(_id), \"Cannot burn shares for resolved market\");\n\n        Market memory _market = markets[_id];\n        for (uint256 _i = 0; _i < _market.shareTokens.length; _i++) {\n            // errors if sender doesn't have enough shares\n            _market.shareTokens[_i].trustedBurn(msg.sender, _sharesToBurn);\n        }\n\n        uint256 _payout = calcCost(_sharesToBurn);\n        uint256 _protocolFee = _payout.mul(_market.protocolFee).div(10**18);\n        uint256 _stakerFee = _payout.mul(_market.stakerFee).div(10**18);\n        _payout = _payout.sub(_protocolFee).sub(_stakerFee);\n\n        accumulatedProtocolFee += _protocolFee;\n        collateral.transfer(_receiver, _payout);\n        feePot.depositFees(_stakerFee);\n\n        emit SharesBurned(_id, _sharesToBurn, msg.sender);\n        return _payout;\n    }\n\n    function claimWinnings(uint256 _id, address _receiver) public returns (uint256) {\n        if (!isMarketResolved(_id)) {\n            // errors if market does not exist or is not resolved or resolvable\n            resolveMarket(_id);\n        }\n\n        Market memory _market = markets[_id];\n        uint256 _winningShares = _market.winner.trustedBurnAll(msg.sender);\n        _winningShares = (_winningShares / shareFactor) * shareFactor; // remove unusable dust\n\n        uint256 _payout = calcCost(_winningShares); // will fail if there are no winnings to claim\n        uint256 _settlementFee = _payout.mul(_market.settlementFee).div(10**18);\n        _payout = _payout.sub(_settlementFee);\n\n        accumulatedSettlementFees[_market.settlementAddress] += _settlementFee;\n        collateral.transfer(_receiver, _payout);\n\n        emit WinningsClaimed(_id, address(_market.winner), _winningShares, _settlementFee, _payout, _receiver);\n        return _payout;\n    }\n\n    function claimManyWinnings(uint256[] memory _ids, address _receiver) public returns (uint256) {\n        uint256 _totalWinnings = 0;\n        for (uint256 i = 0; i < _ids.length; i++) {\n            _totalWinnings = _totalWinnings.add(claimWinnings(_ids[i], _receiver));\n        }\n        return _totalWinnings;\n    }\n\n    function claimSettlementFees(address _receiver) public returns (uint256) {\n        uint256 _fees = accumulatedSettlementFees[msg.sender];\n        if (_fees > 0) {\n            accumulatedSettlementFees[msg.sender] = 0;\n            collateral.transfer(_receiver, _fees);\n            emit SettlementFeeClaimed(msg.sender, _fees, _receiver);\n        }\n        return _fees;\n    }\n\n    function claimProtocolFees() public returns (uint256) {\n        require(msg.sender == protocol || msg.sender == address(this), \"Only protocol can claim protocol fee\");\n        uint256 _fees = accumulatedProtocolFee;\n        if (_fees > 0) {\n            accumulatedProtocolFee = 0;\n            collateral.transfer(protocol, _fees);\n            emit ProtocolFeeClaimed(protocol, _fees);\n        }\n        return _fees;\n    }\n\n    function setSettlementFee(uint256 _newFee) external onlyOwner {\n        settlementFee = _newFee;\n        emit SettlementFeeChanged(_newFee);\n    }\n\n    function setStakerFee(uint256 _newFee) external onlyOwner {\n        stakerFee = _newFee;\n        emit StakerFeeChanged(_newFee);\n    }\n\n    function setProtocolFee(uint256 _newFee) external onlyOwner {\n        protocolFee = _newFee;\n        emit ProtocolFeeChanged(_newFee);\n    }\n\n    function setProtocol(address _newProtocol, bool _claimFirst) external onlyOwner {\n        if (_claimFirst) {\n            claimProtocolFees();\n        }\n        protocol = _newProtocol;\n        emit ProtocolChanged(_newProtocol);\n    }\n\n    function makeMarket(\n        address _settlementAddress,\n        string[] memory _names,\n        string[] memory _symbols,\n        uint256 _endTime,\n        uint256[] memory _initialOdds\n    ) internal returns (Market memory _market) {\n        _market = Market(\n            _settlementAddress,\n            createShareTokens(_names, _symbols, address(this)),\n            _endTime,\n            OwnedERC20(address(0)),\n            settlementFee,\n            protocolFee,\n            stakerFee,\n            block.timestamp,\n            _initialOdds\n        );\n    }\n\n    function isMarketResolved(uint256 _id) public view returns (bool) {\n        Market memory _market = markets[_id];\n        return _market.winner != OwnedERC20(address(0));\n    }\n\n    // Only usable off-chain. Gas cost can easily eclipse block limit.\n    function listUnresolvedMarkets() public view returns (uint256[] memory) {\n        uint256 _totalUnresolved = 0;\n        for (uint256 i = 0; i < markets.length; i++) {\n            if (!isMarketResolved(i)) {\n                _totalUnresolved++;\n            }\n        }\n\n        uint256[] memory _marketIds = new uint256[](_totalUnresolved);\n\n        uint256 n = 0;\n        for (uint256 i = 0; i < markets.length; i++) {\n            if (n >= _totalUnresolved) break;\n\n            if (!isMarketResolved(i)) {\n                _marketIds[n] = i;\n                n++;\n            }\n        }\n\n        return _marketIds;\n    }\n\n    // shares => collateral\n    function calcCost(uint256 _shares) public view returns (uint256) {\n        require(\n            _shares >= shareFactor && _shares % shareFactor == 0,\n            \"Shares must be both greater than (or equal to) and divisible by shareFactor\"\n        );\n        return _shares / shareFactor;\n    }\n\n    // collateral => shares\n    function calcShares(uint256 _collateralIn) public view returns (uint256) {\n        return _collateralIn * shareFactor;\n    }\n\n    function onTransferOwnership(address, address) internal override {}\n}\n"
    },
    "contracts/turbo/SportsLinkMarketFactoryV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../libraries/IERC20Full.sol\";\nimport \"../balancer/BPool.sol\";\nimport \"./AbstractMarketFactoryV2.sol\";\nimport \"./FeePot.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/SignedSafeMath.sol\";\nimport \"../libraries/CalculateLinesToBPoolOdds.sol\";\n\ncontract SportsLinkMarketFactoryV2 is AbstractMarketFactoryV2, CalculateLinesToBPoolOdds {\n    using SafeMath for uint256;\n    using SignedSafeMath for int256;\n\n    event MarketCreated(\n        uint256 id,\n        address creator,\n        uint256 endTime,\n        MarketType marketType,\n        uint256 indexed eventId,\n        uint256 homeTeamId,\n        uint256 awayTeamId,\n        uint256 estimatedStartTime,\n        int256 score\n    );\n    event MarketResolved(uint256 id, address winner);\n    event LinkNodeChanged(address newLinkNode);\n\n    enum MarketType {HeadToHead, Spread, OverUnder}\n    enum HeadToHeadOutcome {\n        NoContest, // 0\n        Away, // 1\n        Home // 2\n    }\n    enum SpreadOutcome {\n        NoContest, // 0\n        Away, // 1\n        Home // 2\n    }\n    enum OverUnderOutcome {\n        NoContest, // 0\n        Over, // 1\n        Under // 2\n    }\n    struct MarketDetails {\n        uint256 eventId;\n        uint256 homeTeamId;\n        uint256 awayTeamId;\n        uint256 estimatedStartTime;\n        MarketType marketType;\n        EventStatus eventStatus;\n        // This value depends on the marketType.\n        // HeadToHead: ignored\n        // Spread: the home team spread\n        // OverUnder: total score in game\n        int256 value0;\n    }\n    // MarketId => MarketDetails\n    mapping(uint256 => MarketDetails) internal marketDetails;\n\n    enum EventStatus {Unknown, Scheduled, Final, Postponed, Canceled}\n    struct EventDetails {\n        uint256[3] markets;\n        uint256 startTime;\n        uint256 homeScore;\n        uint256 awayScore;\n        EventStatus status;\n        // If there is a resolution time then the market is resolved but not necessarily finalized.\n        // A market is finalized when its last two score updates were identical.\n        // Score updates must occur after a period of time spedcified by resolutionBuffer.\n        // This mechanism exists to reduce the risk of bad scores being sent by the API then later corrected.\n        // The downside is slower resolution.\n        uint256 resolutionTime; // time since last score update\n        bool finalized; // true after event resolves and has stable scores\n    }\n    // EventId => EventDetails\n    mapping(uint256 => EventDetails) public events;\n    uint256[] public listOfEvents;\n\n    address public linkNode;\n    uint256 public sportId;\n\n    constructor(\n        address _owner,\n        IERC20Full _collateral,\n        uint256 _shareFactor,\n        FeePot _feePot,\n        uint256 _stakerFee,\n        uint256 _settlementFee,\n        address _protocol,\n        uint256 _protocolFee,\n        address _linkNode,\n        uint256 _sportId\n    )\n        AbstractMarketFactoryV2(\n            _owner,\n            _collateral,\n            _shareFactor,\n            _feePot,\n            _stakerFee,\n            _settlementFee,\n            _protocol,\n            _protocolFee\n        )\n    {\n        linkNode = _linkNode;\n        sportId = _sportId;\n    }\n\n    function createMarket(\n        uint256 _eventId,\n        uint256 _homeTeamId,\n        uint256 _awayTeamId,\n        uint256 _startTimestamp,\n        int256 _homeSpread,\n        uint256 _totalScore,\n        bool _makeSpread,\n        bool _makeTotalScore,\n        int256[2] memory _moneylines // [home,away]\n    ) public returns (uint256[3] memory _ids) {\n        require(msg.sender == linkNode, \"Only link node can create markets\");\n\n        address _creator = msg.sender;\n        uint256 _endTime = _startTimestamp.add(60 * 8); // 8 hours\n\n        _ids = events[_eventId].markets;\n\n        if (_ids[0] == 0 && _moneylines[0] != 0 && _moneylines[1] != 0) {\n            _ids[0] = createHeadToHeadMarket(\n                _creator,\n                _endTime,\n                _eventId,\n                _homeTeamId,\n                _awayTeamId,\n                _startTimestamp,\n                _moneylines\n            );\n        }\n\n        if (_ids[1] == 0 && _makeSpread) {\n            // spread market hasn't been created and is ready to be created\n            _ids[1] = createSpreadMarket(\n                _creator,\n                _endTime,\n                _eventId,\n                _homeTeamId,\n                _awayTeamId,\n                _startTimestamp,\n                _homeSpread\n            );\n        }\n\n        if (_ids[2] == 0 && _makeTotalScore) {\n            // over-under market hasn't been created and is ready to be created\n            _ids[2] = createOverUnderMarket(\n                _creator,\n                _endTime,\n                _eventId,\n                _homeTeamId,\n                _awayTeamId,\n                _startTimestamp,\n                _totalScore\n            );\n        }\n\n        events[_eventId].status = EventStatus.Scheduled;\n        events[_eventId].startTime = _startTimestamp;\n        events[_eventId].markets = _ids;\n        listOfEvents.push(_eventId);\n    }\n\n    function createHeadToHeadMarket(\n        address _creator,\n        uint256 _endTime,\n        uint256 _eventId,\n        uint256 _homeTeamId,\n        uint256 _awayTeamId,\n        uint256 _startTimestamp,\n        int256[2] memory _moneylines // [home,away]\n    ) internal returns (uint256) {\n        string[] memory _outcomes = new string[](3);\n        _outcomes[uint256(HeadToHeadOutcome.NoContest)] = \"No Contest\";\n        _outcomes[uint256(HeadToHeadOutcome.Away)] = \"Away\";\n        _outcomes[uint256(HeadToHeadOutcome.Home)] = \"Home\";\n\n        uint256 _id = markets.length;\n        // moneylines is [home,away] but the outcomes are listed [NC,away,home] so they must be reversed\n        markets.push(\n            makeMarket(_creator, _outcomes, _outcomes, _endTime, oddsFromLines(_moneylines[1], _moneylines[0]))\n        );\n        marketDetails[_id] = MarketDetails(\n            _eventId,\n            _homeTeamId,\n            _awayTeamId,\n            _startTimestamp,\n            MarketType.HeadToHead,\n            EventStatus.Scheduled,\n            0\n        );\n        emit MarketCreated(\n            _id,\n            _creator,\n            _endTime,\n            MarketType.HeadToHead,\n            _eventId,\n            _homeTeamId,\n            _awayTeamId,\n            _startTimestamp,\n            0\n        );\n        return _id;\n    }\n\n    function createSpreadMarket(\n        address _creator,\n        uint256 _endTime,\n        uint256 _eventId,\n        uint256 _homeTeamId,\n        uint256 _awayTeamId,\n        uint256 _startTimestamp,\n        int256 _homeSpread\n    ) internal returns (uint256) {\n        string[] memory _outcomes = new string[](3);\n        _outcomes[uint256(SpreadOutcome.NoContest)] = \"No Contest\";\n        _outcomes[uint256(SpreadOutcome.Away)] = \"Away\";\n        _outcomes[uint256(SpreadOutcome.Home)] = \"Home\";\n\n        // The spread is a quantity of tenths. So 55 is 5.5 and -6 is -60.\n        // If the spread is a whole number then make it a half point more extreme, to eliminate ties.\n        // So 50 becomes 55, -60 becomes -65, and 0 becomes 5.\n        if (_homeSpread >= 0 && _homeSpread % 10 == 0) {\n            _homeSpread += 5;\n        } else if (_homeSpread < 0 && (-_homeSpread) % 10 == 0) {\n            _homeSpread -= 5;\n        }\n\n        uint256 _id = markets.length;\n        markets.push(makeMarket(_creator, _outcomes, _outcomes, _endTime, evenOdds(true, 2)));\n        marketDetails[_id] = MarketDetails(\n            _eventId,\n            _homeTeamId,\n            _awayTeamId,\n            _startTimestamp,\n            MarketType.Spread,\n            EventStatus.Scheduled,\n            _homeSpread\n        );\n        emit MarketCreated(\n            _id,\n            _creator,\n            _endTime,\n            MarketType.Spread,\n            _eventId,\n            _homeTeamId,\n            _awayTeamId,\n            _startTimestamp,\n            _homeSpread\n        );\n        return _id;\n    }\n\n    function createOverUnderMarket(\n        address _creator,\n        uint256 _endTime,\n        uint256 _eventId,\n        uint256 _homeTeamId,\n        uint256 _awayTeamId,\n        uint256 _startTimestamp,\n        uint256 _overUnderTotal\n    ) internal returns (uint256) {\n        string[] memory _outcomes = new string[](3);\n        _outcomes[uint256(OverUnderOutcome.NoContest)] = \"No Contest\";\n        _outcomes[uint256(OverUnderOutcome.Over)] = \"Over\";\n        _outcomes[uint256(OverUnderOutcome.Under)] = \"Under\";\n\n        // The total is a quantity of tenths. So 55 is 5.5 and -6 is -60.\n        // If the total is a whole number then make it a half point higher, to eliminate ties.\n        // So 50 becomes 55 and 0 becomes 5.\n        if (_overUnderTotal >= 0 && _overUnderTotal % 10 == 0) {\n            _overUnderTotal += 5;\n        }\n\n        uint256 _id = markets.length;\n        markets.push(makeMarket(_creator, _outcomes, _outcomes, _endTime, evenOdds(true, 2)));\n        marketDetails[_id] = MarketDetails(\n            _eventId,\n            _homeTeamId,\n            _awayTeamId,\n            _startTimestamp,\n            MarketType.OverUnder,\n            EventStatus.Scheduled,\n            int256(_overUnderTotal)\n        );\n        emit MarketCreated(\n            _id,\n            _creator,\n            _endTime,\n            MarketType.OverUnder,\n            _eventId,\n            _homeTeamId,\n            _awayTeamId,\n            _startTimestamp,\n            int256(_overUnderTotal)\n        );\n        return _id;\n    }\n\n    function resolveMarket(uint256) public pure override {\n        require(false, \"Only the link node can resolve the market, using trustedResolveMarkets\");\n    }\n\n    function trustedResolveMarkets(\n        uint256 _eventId,\n        uint256 _eventStatus,\n        uint256 _homeScore,\n        uint256 _awayScore\n    ) public {\n        require(msg.sender == linkNode, \"Only link node can resolve markets\");\n\n        EventDetails storage _event = events[_eventId];\n        uint256[3] memory _ids = _event.markets;\n\n        require(_ids[0] != 0 || _ids[1] != 0 || _ids[2] != 0, \"Cannot resolve markets that weren't created\");\n\n        require(EventStatus(_eventStatus) != EventStatus.Scheduled, \"cannot resolve SCHEDULED markets\");\n\n        // resolve markets as No Contest\n        if (EventStatus(_eventStatus) != EventStatus.Final) {\n            for (uint256 i = 0; i < _ids.length; i++) {\n                uint256 _id = _ids[i];\n                if (_id == 0) continue; // skip non-created markets\n                OwnedERC20 _winner = markets[_id].shareTokens[0]; // 0th outcome is No Contest for all market types\n                markets[_id].winner = _winner;\n                emit MarketResolved(_id, address(_winner));\n            }\n            return;\n        }\n\n        // only resolve markets that were created\n        if (_ids[0] != 0) {\n            resolveHeadToHeadMarket(_ids[0], _homeScore, _awayScore);\n        }\n        if (_ids[1] != 0) {\n            resolveSpreadMarket(_ids[1], _homeScore, _awayScore);\n        }\n        if (_ids[2] != 0) {\n            resolveOverUnderMarket(_ids[2], _homeScore, _awayScore);\n        }\n    }\n\n    function resolveHeadToHeadMarket(\n        uint256 _id,\n        uint256 _homeScore,\n        uint256 _awayScore\n    ) internal {\n        OwnedERC20 _winner;\n        if (_homeScore > _awayScore) {\n            _winner = markets[_id].shareTokens[uint256(HeadToHeadOutcome.Home)]; // home team won\n        } else if (_homeScore < _awayScore) {\n            _winner = markets[_id].shareTokens[uint256(HeadToHeadOutcome.Away)]; // away team won\n        } else {\n            _winner = markets[_id].shareTokens[uint256(HeadToHeadOutcome.NoContest)]; // no contest\n        }\n\n        markets[_id].winner = _winner;\n        emit MarketResolved(_id, address(_winner));\n    }\n\n    function resolveSpreadMarket(\n        uint256 _id,\n        uint256 _homeScore,\n        uint256 _awayScore\n    ) internal {\n        MarketDetails memory _details = marketDetails[_id];\n        int256 _targetSpread = _details.value0;\n\n        int256 _actualSpread = int256(_homeScore).sub(int256(_awayScore));\n\n        OwnedERC20 _winner;\n        if (_actualSpread > _targetSpread) {\n            _winner = markets[_id].shareTokens[uint256(SpreadOutcome.Home)]; // home spread greater\n        } else if (_actualSpread < _targetSpread) {\n            _winner = markets[_id].shareTokens[uint256(SpreadOutcome.Away)]; // home spread lesser\n        } else {\n            _winner = markets[_id].shareTokens[uint256(SpreadOutcome.NoContest)]; // no contest\n        }\n\n        markets[_id].winner = _winner;\n        emit MarketResolved(_id, address(_winner));\n    }\n\n    function resolveOverUnderMarket(\n        uint256 _id,\n        uint256 _homeScore,\n        uint256 _awayScore\n    ) internal {\n        MarketDetails memory _details = marketDetails[_id];\n        int256 _targetTotal = _details.value0;\n\n        int256 _actualTotal = int256(_homeScore).add(int256(_awayScore));\n\n        OwnedERC20 _winner;\n        if (_actualTotal > _targetTotal) {\n            _winner = markets[_id].shareTokens[uint256(OverUnderOutcome.Over)]; // over\n        } else if (_actualTotal < _targetTotal) {\n            _winner = markets[_id].shareTokens[uint256(OverUnderOutcome.Under)]; // under\n        } else {\n            _winner = markets[_id].shareTokens[uint256(OverUnderOutcome.NoContest)]; // no contest\n        }\n\n        markets[_id].winner = _winner;\n        emit MarketResolved(_id, address(_winner));\n    }\n\n    function getMarketDetails(uint256 _marketId) public view returns (MarketDetails memory) {\n        return marketDetails[_marketId];\n    }\n\n    function setLinkNode(address _newLinkNode) external onlyOwner {\n        linkNode = _newLinkNode;\n        emit LinkNodeChanged(_newLinkNode);\n    }\n\n    function getEventMarkets(uint256 _eventId) external view returns (uint256[3] memory) {\n        uint256[3] memory _event = events[_eventId].markets;\n        return _event;\n    }\n\n    // Events can be partially registered, by only creating some markets.\n    // This returns true only if an event is fully registered.\n    function isEventRegistered(uint256 _eventId) public view returns (bool) {\n        uint256[3] memory _event = events[_eventId].markets;\n        return _event[0] != 0 && _event[1] != 0 && _event[2] != 0;\n    }\n\n    function isEventResolved(uint256 _eventId) public view returns (bool) {\n        // check the event's head-to-head market since it will always exist if the event's markets exist\n        uint256 _marketId = events[_eventId].markets[0];\n        return isMarketResolved(_marketId);\n    }\n\n    // Only usable off-chain. Gas cost can easily eclipse block limit.\n    // Lists all events that could be resolved with a call to resolveEvent.\n    // Not all will be resolvable because this does not ensure the game ended.\n    function listResolvableEvents() external view returns (uint256[] memory) {\n        uint256 _totalResolvable = countResolvableEvents();\n        uint256[] memory _resolvableEvents = new uint256[](_totalResolvable);\n\n        uint256 n = 0;\n        for (uint256 i = 0; i < listOfEvents.length; i++) {\n            if (n > _totalResolvable) break;\n            uint256 _eventId = listOfEvents[i];\n            if (isEventResolvable(_eventId)) {\n                _resolvableEvents[n] = _eventId;\n                n++;\n            }\n        }\n\n        return _resolvableEvents;\n    }\n\n    function countResolvableEvents() internal view returns (uint256) {\n        uint256 _totalResolvable = 0;\n        for (uint256 i = 0; i < listOfEvents.length; i++) {\n            uint256 _eventId = listOfEvents[i];\n            if (isEventResolvable(_eventId)) {\n                _totalResolvable++;\n            }\n        }\n        return _totalResolvable;\n    }\n\n    // Returns true if a call to resolveEvent is potentially useful.\n    function isEventResolvable(uint256 _eventId) internal view returns (bool) {\n        EventDetails memory _event = events[_eventId];\n\n        bool _unresolved = false; // default because non-existing markets aren't resolvable\n        for (uint256 i = 0; i < _event.markets.length; i++) {\n            uint256 _marketId = _event.markets[i];\n            if (_marketId != 0 && !isMarketResolved(_marketId)) {\n                _unresolved = true;\n                break;\n            }\n        }\n\n        return _unresolved;\n    }\n}\n"
    },
    "contracts/turbo/SportsLinkMarketFactoryV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../libraries/IERC20Full.sol\";\nimport \"../balancer/BPool.sol\";\nimport \"./AbstractMarketFactoryV1.sol\";\nimport \"./FeePot.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/SignedSafeMath.sol\";\n\ncontract SportsLinkMarketFactoryV1 is AbstractMarketFactoryV1 {\n    using SafeMath for uint256;\n    using SignedSafeMath for int256;\n\n    event MarketCreated(\n        uint256 id,\n        address creator,\n        uint256 endTime,\n        MarketType marketType,\n        uint256 indexed eventId,\n        uint256 homeTeamId,\n        uint256 awayTeamId,\n        uint256 estimatedStartTime,\n        int256 score\n    );\n    event MarketResolved(uint256 id, address winner);\n    event LinkNodeChanged(address newLinkNode);\n\n    enum MarketType {HeadToHead, Spread, OverUnder}\n    enum HeadToHeadOutcome {\n        NoContest, // 0\n        Away, // 1\n        Home // 2\n    }\n    enum SpreadOutcome {\n        NoContest, // 0\n        Away, // 1\n        Home // 2\n    }\n    enum OverUnderOutcome {\n        NoContest, // 0\n        Over, // 1\n        Under // 2\n    }\n    struct MarketDetails {\n        uint256 eventId;\n        uint256 homeTeamId;\n        uint256 awayTeamId;\n        uint256 estimatedStartTime;\n        MarketType marketType;\n        EventStatus eventStatus;\n        // This value depends on the marketType.\n        // HeadToHead: ignored\n        // Spread: the home team spread\n        // OverUnder: total score in game\n        int256 value0;\n    }\n    // MarketId => MarketDetails\n    mapping(uint256 => MarketDetails) internal marketDetails;\n\n    enum EventStatus {Unknown, Scheduled, Final, Postponed, Canceled}\n    struct EventDetails {\n        uint256[3] markets;\n        uint256 startTime;\n        uint256 homeScore;\n        uint256 awayScore;\n        EventStatus status;\n        // If there is a resolution time then the market is resolved but not necessarily finalized.\n        // A market is finalized when its last two score updates were identical.\n        // Score updates must occur after a period of time spedcified by resolutionBuffer.\n        // This mechanism exists to reduce the risk of bad scores being sent by the API then later corrected.\n        // The downside is slower resolution.\n        uint256 resolutionTime; // time since last score update\n        bool finalized; // true after event resolves and has stable scores\n    }\n    // EventId => EventDetails\n    mapping(uint256 => EventDetails) public events;\n    uint256[] public listOfEvents;\n\n    address public linkNode;\n    uint256 public sportId;\n\n    constructor(\n        address _owner,\n        IERC20Full _collateral,\n        uint256 _shareFactor,\n        FeePot _feePot,\n        uint256 _stakerFee,\n        uint256 _settlementFee,\n        address _protocol,\n        uint256 _protocolFee,\n        address _linkNode,\n        uint256 _sportId\n    )\n        AbstractMarketFactoryV1(\n            _owner,\n            _collateral,\n            _shareFactor,\n            _feePot,\n            _stakerFee,\n            _settlementFee,\n            _protocol,\n            _protocolFee\n        )\n    {\n        linkNode = _linkNode;\n        sportId = _sportId;\n    }\n\n    function createMarket(\n        uint256 _eventId,\n        uint256 _homeTeamId,\n        uint256 _awayTeamId,\n        uint256 _startTimestamp,\n        int256 _homeSpread,\n        uint256 _totalScore,\n        bool _makeSpread,\n        bool _makeTotalScore\n    ) public returns (uint256[3] memory _ids) {\n        require(msg.sender == linkNode, \"Only link node can create markets\");\n\n        address _creator = msg.sender;\n        uint256 _endTime = _startTimestamp.add(60 * 8); // 8 hours\n\n        _ids = events[_eventId].markets;\n\n        if (_ids[0] == 0) {\n            _ids[0] = createHeadToHeadMarket(_creator, _endTime, _eventId, _homeTeamId, _awayTeamId, _startTimestamp);\n        }\n\n        if (_ids[1] == 0 && _makeSpread) {\n            // spread market hasn't been created and is ready to be created\n            _ids[1] = createSpreadMarket(\n                _creator,\n                _endTime,\n                _eventId,\n                _homeTeamId,\n                _awayTeamId,\n                _startTimestamp,\n                _homeSpread\n            );\n        }\n\n        if (_ids[2] == 0 && _makeTotalScore) {\n            // over-under market hasn't been created and is ready to be created\n            _ids[2] = createOverUnderMarket(\n                _creator,\n                _endTime,\n                _eventId,\n                _homeTeamId,\n                _awayTeamId,\n                _startTimestamp,\n                _totalScore\n            );\n        }\n\n        events[_eventId].status = EventStatus.Scheduled;\n        events[_eventId].startTime = _startTimestamp;\n        events[_eventId].markets = _ids;\n        listOfEvents.push(_eventId);\n    }\n\n    function createHeadToHeadMarket(\n        address _creator,\n        uint256 _endTime,\n        uint256 _eventId,\n        uint256 _homeTeamId,\n        uint256 _awayTeamId,\n        uint256 _startTimestamp\n    ) internal returns (uint256) {\n        string[] memory _outcomes = new string[](3);\n        _outcomes[uint256(HeadToHeadOutcome.NoContest)] = \"No Contest\";\n        _outcomes[uint256(HeadToHeadOutcome.Away)] = \"Away\";\n        _outcomes[uint256(HeadToHeadOutcome.Home)] = \"Home\";\n\n        uint256 _id = markets.length;\n        markets.push(makeMarket(_creator, _outcomes, _outcomes, _endTime));\n        marketDetails[_id] = MarketDetails(\n            _eventId,\n            _homeTeamId,\n            _awayTeamId,\n            _startTimestamp,\n            MarketType.HeadToHead,\n            EventStatus.Scheduled,\n            0\n        );\n        emit MarketCreated(\n            _id,\n            _creator,\n            _endTime,\n            MarketType.HeadToHead,\n            _eventId,\n            _homeTeamId,\n            _awayTeamId,\n            _startTimestamp,\n            0\n        );\n        return _id;\n    }\n\n    function createSpreadMarket(\n        address _creator,\n        uint256 _endTime,\n        uint256 _eventId,\n        uint256 _homeTeamId,\n        uint256 _awayTeamId,\n        uint256 _startTimestamp,\n        int256 _homeSpread\n    ) internal returns (uint256) {\n        string[] memory _outcomes = new string[](3);\n        _outcomes[uint256(SpreadOutcome.NoContest)] = \"No Contest\";\n        _outcomes[uint256(SpreadOutcome.Away)] = \"Away\";\n        _outcomes[uint256(SpreadOutcome.Home)] = \"Home\";\n\n        // The spread is a quantity of tenths. So 55 is 5.5 and -6 is -60.\n        // If the spread is a whole number then make it a half point more extreme, to eliminate ties.\n        // So 50 becomes 55, -60 becomes -65, and 0 becomes 5.\n        if (_homeSpread >= 0 && _homeSpread % 10 == 0) {\n            _homeSpread += 5;\n        } else if (_homeSpread < 0 && (-_homeSpread) % 10 == 0) {\n            _homeSpread -= 5;\n        }\n\n        uint256 _id = markets.length;\n        markets.push(makeMarket(_creator, _outcomes, _outcomes, _endTime));\n        marketDetails[_id] = MarketDetails(\n            _eventId,\n            _homeTeamId,\n            _awayTeamId,\n            _startTimestamp,\n            MarketType.Spread,\n            EventStatus.Scheduled,\n            _homeSpread\n        );\n        emit MarketCreated(\n            _id,\n            _creator,\n            _endTime,\n            MarketType.Spread,\n            _eventId,\n            _homeTeamId,\n            _awayTeamId,\n            _startTimestamp,\n            _homeSpread\n        );\n        return _id;\n    }\n\n    function createOverUnderMarket(\n        address _creator,\n        uint256 _endTime,\n        uint256 _eventId,\n        uint256 _homeTeamId,\n        uint256 _awayTeamId,\n        uint256 _startTimestamp,\n        uint256 _overUnderTotal\n    ) internal returns (uint256) {\n        string[] memory _outcomes = new string[](3);\n        _outcomes[uint256(OverUnderOutcome.NoContest)] = \"No Contest\";\n        _outcomes[uint256(OverUnderOutcome.Over)] = \"Over\";\n        _outcomes[uint256(OverUnderOutcome.Under)] = \"Under\";\n\n        // The total is a quantity of tenths. So 55 is 5.5 and -6 is -60.\n        // If the total is a whole number then make it a half point higher, to eliminate ties.\n        // So 50 becomes 55 and 0 becomes 5.\n        if (_overUnderTotal >= 0 && _overUnderTotal % 10 == 0) {\n            _overUnderTotal += 5;\n        }\n\n        uint256 _id = markets.length;\n        markets.push(makeMarket(_creator, _outcomes, _outcomes, _endTime));\n        marketDetails[_id] = MarketDetails(\n            _eventId,\n            _homeTeamId,\n            _awayTeamId,\n            _startTimestamp,\n            MarketType.OverUnder,\n            EventStatus.Scheduled,\n            int256(_overUnderTotal)\n        );\n        emit MarketCreated(\n            _id,\n            _creator,\n            _endTime,\n            MarketType.OverUnder,\n            _eventId,\n            _homeTeamId,\n            _awayTeamId,\n            _startTimestamp,\n            int256(_overUnderTotal)\n        );\n        return _id;\n    }\n\n    function resolveMarket(uint256) public pure override {\n        require(false, \"Only the link node can resolve the market, using trustedResolveMarkets\");\n    }\n\n    function trustedResolveMarkets(\n        uint256 _eventId,\n        uint256 _eventStatus,\n        uint256 _homeScore,\n        uint256 _awayScore\n    ) public {\n        require(msg.sender == linkNode, \"Only link node can resolve markets\");\n\n        EventDetails storage _event = events[_eventId];\n        uint256[3] memory _ids = _event.markets;\n\n        require(_ids[0] != 0 || _ids[1] != 0 || _ids[2] != 0, \"Cannot resolve markets that weren't created\");\n\n        require(EventStatus(_eventStatus) != EventStatus.Scheduled, \"cannot resolve SCHEDULED markets\");\n\n        // resolve markets as No Contest\n        if (EventStatus(_eventStatus) != EventStatus.Final) {\n            for (uint256 i = 0; i < _ids.length; i++) {\n                uint256 _id = _ids[i];\n                if (_id == 0) continue; // skip non-created markets\n                OwnedERC20 _winner = markets[_id].shareTokens[0]; // 0th outcome is No Contest for all market types\n                markets[_id].winner = _winner;\n                emit MarketResolved(_id, address(_winner));\n            }\n            return;\n        }\n\n        // only resolve markets that were created\n        if (_ids[0] != 0) {\n            resolveHeadToHeadMarket(_ids[0], _homeScore, _awayScore);\n        }\n        if (_ids[1] != 0) {\n            resolveSpreadMarket(_ids[1], _homeScore, _awayScore);\n        }\n        if (_ids[2] != 0) {\n            resolveOverUnderMarket(_ids[2], _homeScore, _awayScore);\n        }\n    }\n\n    function resolveHeadToHeadMarket(\n        uint256 _id,\n        uint256 _homeScore,\n        uint256 _awayScore\n    ) internal {\n        OwnedERC20 _winner;\n        if (_homeScore > _awayScore) {\n            _winner = markets[_id].shareTokens[uint256(HeadToHeadOutcome.Home)]; // home team won\n        } else if (_homeScore < _awayScore) {\n            _winner = markets[_id].shareTokens[uint256(HeadToHeadOutcome.Away)]; // away team won\n        } else {\n            _winner = markets[_id].shareTokens[uint256(HeadToHeadOutcome.NoContest)]; // no contest\n        }\n\n        markets[_id].winner = _winner;\n        emit MarketResolved(_id, address(_winner));\n    }\n\n    function resolveSpreadMarket(\n        uint256 _id,\n        uint256 _homeScore,\n        uint256 _awayScore\n    ) internal {\n        MarketDetails memory _details = marketDetails[_id];\n        int256 _targetSpread = _details.value0;\n\n        int256 _actualSpread = int256(_homeScore).sub(int256(_awayScore));\n\n        OwnedERC20 _winner;\n        if (_actualSpread > _targetSpread) {\n            _winner = markets[_id].shareTokens[uint256(SpreadOutcome.Home)]; // home spread greater\n        } else if (_actualSpread < _targetSpread) {\n            _winner = markets[_id].shareTokens[uint256(SpreadOutcome.Away)]; // home spread lesser\n        } else {\n            _winner = markets[_id].shareTokens[uint256(SpreadOutcome.NoContest)]; // no contest\n        }\n\n        markets[_id].winner = _winner;\n        emit MarketResolved(_id, address(_winner));\n    }\n\n    function resolveOverUnderMarket(\n        uint256 _id,\n        uint256 _homeScore,\n        uint256 _awayScore\n    ) internal {\n        MarketDetails memory _details = marketDetails[_id];\n        int256 _targetTotal = _details.value0;\n\n        int256 _actualTotal = int256(_homeScore).add(int256(_awayScore));\n\n        OwnedERC20 _winner;\n        if (_actualTotal > _targetTotal) {\n            _winner = markets[_id].shareTokens[uint256(OverUnderOutcome.Over)]; // over\n        } else if (_actualTotal < _targetTotal) {\n            _winner = markets[_id].shareTokens[uint256(OverUnderOutcome.Under)]; // under\n        } else {\n            _winner = markets[_id].shareTokens[uint256(OverUnderOutcome.NoContest)]; // no contest\n        }\n\n        markets[_id].winner = _winner;\n        emit MarketResolved(_id, address(_winner));\n    }\n\n    function getMarketDetails(uint256 _marketId) public view returns (MarketDetails memory) {\n        return marketDetails[_marketId];\n    }\n\n    function setLinkNode(address _newLinkNode) external onlyOwner {\n        linkNode = _newLinkNode;\n        emit LinkNodeChanged(_newLinkNode);\n    }\n\n    function getEventMarkets(uint256 _eventId) external view returns (uint256[3] memory) {\n        uint256[3] memory _event = events[_eventId].markets;\n        return _event;\n    }\n\n    // Events can be partially registered, by only creating some markets.\n    // This returns true only if an event is fully registered.\n    function isEventRegistered(uint256 _eventId) public view returns (bool) {\n        uint256[3] memory _event = events[_eventId].markets;\n        return _event[0] != 0 && _event[1] != 0 && _event[2] != 0;\n    }\n\n    function isEventResolved(uint256 _eventId) public view returns (bool) {\n        // check the event's head-to-head market since it will always exist if the event's markets exist\n        uint256 _marketId = events[_eventId].markets[0];\n        return isMarketResolved(_marketId);\n    }\n\n    // Only usable off-chain. Gas cost can easily eclipse block limit.\n    // Lists all events that could be resolved with a call to resolveEvent.\n    // Not all will be resolvable because this does not ensure the game ended.\n    function listResolvableEvents() external view returns (uint256[] memory) {\n        uint256 _totalResolvable = countResolvableEvents();\n        uint256[] memory _resolvableEvents = new uint256[](_totalResolvable);\n\n        uint256 n = 0;\n        for (uint256 i = 0; i < listOfEvents.length; i++) {\n            if (n > _totalResolvable) break;\n            uint256 _eventId = listOfEvents[i];\n            if (isEventResolvable(_eventId)) {\n                _resolvableEvents[n] = _eventId;\n                n++;\n            }\n        }\n\n        return _resolvableEvents;\n    }\n\n    function countResolvableEvents() internal view returns (uint256) {\n        uint256 _totalResolvable = 0;\n        for (uint256 i = 0; i < listOfEvents.length; i++) {\n            uint256 _eventId = listOfEvents[i];\n            if (isEventResolvable(_eventId)) {\n                _totalResolvable++;\n            }\n        }\n        return _totalResolvable;\n    }\n\n    // Returns true if a call to resolveEvent is potentially useful.\n    function isEventResolvable(uint256 _eventId) internal view returns (bool) {\n        EventDetails memory _event = events[_eventId];\n\n        bool _unresolved = false; // default because non-existing markets aren't resolvable\n        for (uint256 i = 0; i < _event.markets.length; i++) {\n            uint256 _marketId = _event.markets[i];\n            if (_marketId != 0 && !isMarketResolved(_marketId)) {\n                _unresolved = true;\n                break;\n            }\n        }\n\n        return _unresolved;\n    }\n}\n"
    },
    "contracts/turbo/AbstractMarketFactoryV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../libraries/IERC20Full.sol\";\nimport \"../balancer/BPool.sol\";\nimport \"./TurboShareTokenFactory.sol\";\nimport \"./FeePot.sol\";\n\nabstract contract AbstractMarketFactoryV1 is TurboShareTokenFactoryV1, Ownable {\n    using SafeMath for uint256;\n\n    // Should always have ID. Others are optional.\n    // event MarketCreated(uint256 id, address settlementAddress, uint256 endTime, ...);\n\n    // Should always have ID. Others are optional.\n    // event MarketResolved(uint256 id, ...);\n\n    event SharesMinted(uint256 id, uint256 amount, address receiver);\n    event SharesBurned(uint256 id, uint256 amount, address receiver);\n    event WinningsClaimed(\n        uint256 id,\n        address winningOutcome,\n        uint256 amount,\n        uint256 settlementFee,\n        uint256 payout,\n        address indexed receiver\n    );\n\n    event SettlementFeeClaimed(address settlementAddress, uint256 amount, address indexed receiver);\n    event ProtocolFeeClaimed(address protocol, uint256 amount);\n\n    event ProtocolChanged(address protocol);\n    event ProtocolFeeChanged(uint256 fee);\n    event SettlementFeeChanged(uint256 fee);\n    event StakerFeeChanged(uint256 fee);\n\n    IERC20Full public collateral;\n    FeePot public feePot;\n\n    // fees are out of 1e18 and only apply to new markets\n    uint256 public stakerFee;\n    uint256 public settlementFee;\n    uint256 public protocolFee;\n\n    address public protocol; // collects protocol fees\n\n    uint256 public accumulatedProtocolFee = 0;\n    // settlement address => amount of collateral\n    mapping(address => uint256) public accumulatedSettlementFees;\n\n    // How many shares equals one collateral.\n    // Necessary to account for math errors from small numbers in balancer.\n    // shares = collateral / shareFactor\n    // collateral = shares * shareFactor\n    uint256 public shareFactor;\n\n    struct Market {\n        address settlementAddress;\n        OwnedERC20[] shareTokens;\n        uint256 endTime;\n        OwnedERC20 winner;\n        uint256 settlementFee;\n        uint256 protocolFee;\n        uint256 stakerFee;\n        uint256 creationTimestamp;\n    }\n    Market[] internal markets;\n\n    uint256 private constant MAX_UINT = 2**256 - 1;\n\n    constructor(\n        address _owner,\n        IERC20Full _collateral,\n        uint256 _shareFactor,\n        FeePot _feePot,\n        uint256 _stakerFee,\n        uint256 _settlementFee,\n        address _protocol,\n        uint256 _protocolFee\n    ) {\n        owner = _owner; // controls fees for new markets\n        collateral = _collateral;\n        shareFactor = _shareFactor;\n        feePot = _feePot;\n        stakerFee = _stakerFee;\n        settlementFee = _settlementFee;\n        protocol = _protocol;\n        protocolFee = _protocolFee;\n\n        _collateral.approve(address(_feePot), MAX_UINT);\n\n        // First market is always empty so that marketid zero means \"no market\"\n        string[] memory _nothing = new string[](0);\n        markets.push(makeMarket(address(0), _nothing, _nothing, 0));\n    }\n\n    // function createMarket(address _settlementAddress, uint256 _endTime, ...) public returns (uint256);\n\n    function resolveMarket(uint256 _id) public virtual;\n\n    // Returns an empty struct if the market doesn't exist.\n    // Can check market existence before calling this by comparing _id against markets.length.\n    // Can check market existence of the return struct by checking that shareTokens[0] isn't the null address\n    function getMarket(uint256 _id) public view returns (Market memory) {\n        if (_id >= markets.length) {\n            return Market(address(0), new OwnedERC20[](0), 0, OwnedERC20(address(0)), 0, 0, 0, 0);\n        } else {\n            return markets[_id];\n        }\n    }\n\n    function marketCount() public view returns (uint256) {\n        return markets.length;\n    }\n\n    // Returns factory-specific details about a market.\n    // function getMarketDetails(uint256 _id) public view returns (MarketDetails memory);\n\n    function mintShares(\n        uint256 _id,\n        uint256 _shareToMint,\n        address _receiver\n    ) public {\n        require(markets.length > _id, \"No such market\");\n        require(!isMarketResolved(_id), \"Cannot mint shares for resolved market\");\n\n        uint256 _cost = calcCost(_shareToMint);\n        collateral.transferFrom(msg.sender, address(this), _cost);\n\n        Market memory _market = markets[_id];\n        for (uint256 _i = 0; _i < _market.shareTokens.length; _i++) {\n            _market.shareTokens[_i].trustedMint(_receiver, _shareToMint);\n        }\n\n        emit SharesMinted(_id, _shareToMint, _receiver);\n    }\n\n    function burnShares(\n        uint256 _id,\n        uint256 _sharesToBurn,\n        address _receiver\n    ) public returns (uint256) {\n        require(markets.length > _id, \"No such market\");\n        require(!isMarketResolved(_id), \"Cannot burn shares for resolved market\");\n\n        Market memory _market = markets[_id];\n        for (uint256 _i = 0; _i < _market.shareTokens.length; _i++) {\n            // errors if sender doesn't have enough shares\n            _market.shareTokens[_i].trustedBurn(msg.sender, _sharesToBurn);\n        }\n\n        uint256 _payout = calcCost(_sharesToBurn);\n        uint256 _protocolFee = _payout.mul(_market.protocolFee).div(10**18);\n        uint256 _stakerFee = _payout.mul(_market.stakerFee).div(10**18);\n        _payout = _payout.sub(_protocolFee).sub(_stakerFee);\n\n        accumulatedProtocolFee += _protocolFee;\n        collateral.transfer(_receiver, _payout);\n        feePot.depositFees(_stakerFee);\n\n        emit SharesBurned(_id, _sharesToBurn, msg.sender);\n        return _payout;\n    }\n\n    function claimWinnings(uint256 _id, address _receiver) public returns (uint256) {\n        if (!isMarketResolved(_id)) {\n            // errors if market does not exist or is not resolved or resolvable\n            resolveMarket(_id);\n        }\n\n        Market memory _market = markets[_id];\n        uint256 _winningShares = _market.winner.trustedBurnAll(msg.sender);\n        _winningShares = (_winningShares / shareFactor) * shareFactor; // remove unusable dust\n\n        uint256 _payout = calcCost(_winningShares); // will fail if there are no winnings to claim\n        uint256 _settlementFee = _payout.mul(_market.settlementFee).div(10**18);\n        _payout = _payout.sub(_settlementFee);\n\n        accumulatedSettlementFees[_market.settlementAddress] += _settlementFee;\n        collateral.transfer(_receiver, _payout);\n\n        emit WinningsClaimed(_id, address(_market.winner), _winningShares, _settlementFee, _payout, _receiver);\n        return _payout;\n    }\n\n    function claimManyWinnings(uint256[] memory _ids, address _receiver) public returns (uint256) {\n        uint256 _totalWinnings = 0;\n        for (uint256 i = 0; i < _ids.length; i++) {\n            _totalWinnings = _totalWinnings.add(claimWinnings(_ids[i], _receiver));\n        }\n        return _totalWinnings;\n    }\n\n    function claimSettlementFees(address _receiver) public returns (uint256) {\n        uint256 _fees = accumulatedSettlementFees[msg.sender];\n        if (_fees > 0) {\n            accumulatedSettlementFees[msg.sender] = 0;\n            collateral.transfer(_receiver, _fees);\n            emit SettlementFeeClaimed(msg.sender, _fees, _receiver);\n        }\n        return _fees;\n    }\n\n    function claimProtocolFees() public returns (uint256) {\n        require(msg.sender == protocol || msg.sender == address(this), \"Only protocol can claim protocol fee\");\n        uint256 _fees = accumulatedProtocolFee;\n        if (_fees > 0) {\n            accumulatedProtocolFee = 0;\n            collateral.transfer(protocol, _fees);\n            emit ProtocolFeeClaimed(protocol, _fees);\n        }\n        return _fees;\n    }\n\n    function setSettlementFee(uint256 _newFee) external onlyOwner {\n        settlementFee = _newFee;\n        emit SettlementFeeChanged(_newFee);\n    }\n\n    function setStakerFee(uint256 _newFee) external onlyOwner {\n        stakerFee = _newFee;\n        emit StakerFeeChanged(_newFee);\n    }\n\n    function setProtocolFee(uint256 _newFee) external onlyOwner {\n        protocolFee = _newFee;\n        emit ProtocolFeeChanged(_newFee);\n    }\n\n    function setProtocol(address _newProtocol, bool _claimFirst) external onlyOwner {\n        if (_claimFirst) {\n            claimProtocolFees();\n        }\n        protocol = _newProtocol;\n        emit ProtocolChanged(_newProtocol);\n    }\n\n    function makeMarket(\n        address _settlementAddress,\n        string[] memory _names,\n        string[] memory _symbols,\n        uint256 _endTime\n    ) internal returns (Market memory _market) {\n        _market = Market(\n            _settlementAddress,\n            createShareTokens(_names, _symbols, address(this)),\n            _endTime,\n            OwnedERC20(address(0)),\n            settlementFee,\n            protocolFee,\n            stakerFee,\n            block.timestamp\n        );\n    }\n\n    function isMarketResolved(uint256 _id) public view returns (bool) {\n        Market memory _market = markets[_id];\n        return _market.winner != OwnedERC20(address(0));\n    }\n\n    // Only usable off-chain. Gas cost can easily eclipse block limit.\n    function listUnresolvedMarkets() public view returns (uint256[] memory) {\n        uint256 _totalUnresolved = 0;\n        for (uint256 i = 0; i < markets.length; i++) {\n            if (!isMarketResolved(i)) {\n                _totalUnresolved++;\n            }\n        }\n\n        uint256[] memory _marketIds = new uint256[](_totalUnresolved);\n\n        uint256 n = 0;\n        for (uint256 i = 0; i < markets.length; i++) {\n            if (n >= _totalUnresolved) break;\n\n            if (!isMarketResolved(i)) {\n                _marketIds[n] = i;\n                n++;\n            }\n        }\n\n        return _marketIds;\n    }\n\n    // shares => collateral\n    function calcCost(uint256 _shares) public view returns (uint256) {\n        require(\n            _shares >= shareFactor && _shares % shareFactor == 0,\n            \"Shares must be both greater than (or equal to) and divisible by shareFactor\"\n        );\n        return _shares / shareFactor;\n    }\n\n    // collateral => shares\n    function calcShares(uint256 _collateralIn) public view returns (uint256) {\n        return _collateralIn * shareFactor;\n    }\n\n    function onTransferOwnership(address, address) internal override {}\n}\n"
    },
    "contracts/turbo/NFLMarketFactoryV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../libraries/IERC20Full.sol\";\nimport \"../balancer/BPool.sol\";\nimport \"./AbstractMarketFactoryV2.sol\";\nimport \"./FeePot.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/SignedSafeMath.sol\";\nimport \"../libraries/CalculateLinesToBPoolOdds.sol\";\n\ncontract NFLMarketFactoryV2 is AbstractMarketFactoryV2, CalculateLinesToBPoolOdds {\n    using SafeMath for uint256;\n    using SignedSafeMath for int256;\n\n    event MarketCreated(\n        uint256 id,\n        address creator,\n        uint256 endTime,\n        MarketType marketType,\n        uint256 indexed eventId,\n        string homeTeamName,\n        uint256 homeTeamId,\n        string awayTeamName,\n        uint256 awayTeamId,\n        uint256 estimatedStartTime,\n        int256 score\n    );\n    event MarketResolved(uint256 id, address winner);\n    event LinkNodeChanged(address newLinkNode);\n\n    enum MarketType {HeadToHead, Spread, OverUnder}\n    enum HeadToHeadOutcome {\n        NoContest, // 0\n        Away, // 1\n        Home // 2\n    }\n    enum SpreadOutcome {\n        NoContest, // 0\n        Away, // 1\n        Home // 2\n    }\n    enum OverUnderOutcome {\n        NoContest, // 0\n        Over, // 1\n        Under // 2\n    }\n    struct MarketDetails {\n        uint256 eventId;\n        string homeTeamName;\n        uint256 homeTeamId;\n        string awayTeamName;\n        uint256 awayTeamId;\n        uint256 estimatedStartTime;\n        MarketType marketType;\n        EventStatus eventStatus;\n        // This value depends on the marketType.\n        // HeadToHead: ignored\n        // Spread: the home team spread\n        // OverUnder: total score in game\n        int256 value0;\n    }\n    // MarketId => MarketDetails\n    mapping(uint256 => MarketDetails) internal marketDetails;\n\n    enum EventStatus {Unknown, Scheduled, Final, Postponed, Canceled}\n    struct EventDetails {\n        uint256[3] markets;\n        uint256 startTime;\n        uint256 homeScore;\n        uint256 awayScore;\n        EventStatus status;\n        // If there is a resolution time then the market is resolved but not necessarily finalized.\n        // A market is finalized when its last two score updates were identical.\n        // Score updates must occur after a period of time specified by resolutionBuffer.\n        // This mechanism exists to reduce the risk of bad scores being sent by the API then later corrected.\n        // The downside is slower resolution.\n        uint256 resolutionTime; // time since last score update\n        bool finalized; // true after event resolves and has stable scores\n    }\n    // EventId => EventDetails\n    mapping(uint256 => EventDetails) public events;\n    uint256[] public listOfEvents;\n\n    address public linkNode;\n    uint256 public sportId;\n\n    constructor(\n        address _owner,\n        IERC20Full _collateral,\n        uint256 _shareFactor,\n        FeePot _feePot,\n        uint256 _stakerFee,\n        uint256 _settlementFee,\n        address _protocol,\n        uint256 _protocolFee,\n        address _linkNode,\n        uint256 _sportId\n    )\n        AbstractMarketFactoryV2(\n            _owner,\n            _collateral,\n            _shareFactor,\n            _feePot,\n            _stakerFee,\n            _settlementFee,\n            _protocol,\n            _protocolFee\n        )\n    {\n        linkNode = _linkNode;\n        sportId = _sportId;\n    }\n\n    function createMarket(\n        uint256 _eventId,\n        string memory _homeTeamName,\n        uint256 _homeTeamId,\n        string memory _awayTeamName,\n        uint256 _awayTeamId,\n        uint256 _startTimestamp,\n        int256 _homeSpread,\n        uint256 _totalScore,\n        bool _makeSpread,\n        bool _makeTotalScore,\n        int256[2] memory _moneylines // [home,away]\n    ) public returns (uint256[3] memory _ids) {\n        require(msg.sender == linkNode, \"Only link node can create markets\");\n\n        uint256 _endTime = _startTimestamp.add(60 * 8); // 8 hours\n\n        _ids = events[_eventId].markets;\n\n        if (_ids[0] == 0 && _moneylines[0] != 0 && _moneylines[1] != 0) {\n            _ids[0] = createHeadToHeadMarket(\n                msg.sender,\n                _endTime,\n                _eventId,\n                _homeTeamName,\n                _homeTeamId,\n                _awayTeamName,\n                _awayTeamId,\n                _startTimestamp,\n                _moneylines\n            );\n        }\n\n        if (_ids[1] == 0 && _makeSpread) {\n            // spread market hasn't been created and is ready to be created\n            _ids[1] = createSpreadMarket(\n                msg.sender,\n                _endTime,\n                _eventId,\n                _homeTeamName,\n                _homeTeamId,\n                _awayTeamName,\n                _awayTeamId,\n                _startTimestamp,\n                _homeSpread\n            );\n        }\n\n        if (_ids[2] == 0 && _makeTotalScore) {\n            // over-under market hasn't been created and is ready to be created\n            _ids[2] = createOverUnderMarket(\n                msg.sender,\n                _endTime,\n                _eventId,\n                _homeTeamName,\n                _homeTeamId,\n                _awayTeamName,\n                _awayTeamId,\n                _startTimestamp,\n                _totalScore\n            );\n        }\n\n        events[_eventId].status = EventStatus.Scheduled;\n        events[_eventId].startTime = _startTimestamp;\n        events[_eventId].markets = _ids;\n        listOfEvents.push(_eventId);\n    }\n\n    function createHeadToHeadMarket(\n        address _creator,\n        uint256 _endTime,\n        uint256 _eventId,\n        string memory _homeTeamName,\n        uint256 _homeTeamId,\n        string memory _awayTeamName,\n        uint256 _awayTeamId,\n        uint256 _startTimestamp,\n        int256[2] memory _moneylines // [home,away]\n    ) internal returns (uint256) {\n        string[] memory _outcomes = new string[](3);\n        _outcomes[uint256(HeadToHeadOutcome.NoContest)] = \"No Contest / Draw\";\n        _outcomes[uint256(HeadToHeadOutcome.Away)] = _awayTeamName;\n        _outcomes[uint256(HeadToHeadOutcome.Home)] = _homeTeamName;\n\n        uint256 _id = markets.length;\n        // moneylines is [home,away] but the outcomes are listed [NC,away,home] so they must be reversed\n        markets.push(\n            makeMarket(_creator, _outcomes, _outcomes, _endTime, oddsFromLines(_moneylines[1], _moneylines[0]))\n        );\n        marketDetails[_id] = MarketDetails(\n            _eventId,\n            _homeTeamName,\n            _homeTeamId,\n            _awayTeamName,\n            _awayTeamId,\n            _startTimestamp,\n            MarketType.HeadToHead,\n            EventStatus.Scheduled,\n            0\n        );\n        emit MarketCreated(\n            _id,\n            _creator,\n            _endTime,\n            MarketType.HeadToHead,\n            _eventId,\n            _homeTeamName,\n            _homeTeamId,\n            _awayTeamName,\n            _awayTeamId,\n            _startTimestamp,\n            0\n        );\n        return _id;\n    }\n\n    function createSpreadMarket(\n        address _creator,\n        uint256 _endTime,\n        uint256 _eventId,\n        string memory _homeTeamName,\n        uint256 _homeTeamId,\n        string memory _awayTeamName,\n        uint256 _awayTeamId,\n        uint256 _startTimestamp,\n        int256 _homeSpread\n    ) internal returns (uint256) {\n        string[] memory _outcomes = new string[](3);\n        _outcomes[uint256(SpreadOutcome.NoContest)] = \"No Contest\";\n        _outcomes[uint256(SpreadOutcome.Away)] = _awayTeamName;\n        _outcomes[uint256(SpreadOutcome.Home)] = _homeTeamName;\n\n        // The spread is a quantity of tenths. So 55 is 5.5 and -6 is -60.\n        // If the spread is a whole number then make it a half point more extreme, to eliminate ties.\n        // So 50 becomes 55, -60 becomes -65, and 0 becomes 5.\n        if (_homeSpread >= 0 && _homeSpread % 10 == 0) {\n            _homeSpread += 5;\n        } else if (_homeSpread < 0 && (-_homeSpread) % 10 == 0) {\n            _homeSpread -= 5;\n        }\n\n        uint256 _id = markets.length;\n        markets.push(makeMarket(_creator, _outcomes, _outcomes, _endTime, evenOdds(true, 2)));\n        marketDetails[_id] = MarketDetails(\n            _eventId,\n            _homeTeamName,\n            _homeTeamId,\n            _awayTeamName,\n            _awayTeamId,\n            _startTimestamp,\n            MarketType.Spread,\n            EventStatus.Scheduled,\n            _homeSpread\n        );\n        emit MarketCreated(\n            _id,\n            _creator,\n            _endTime,\n            MarketType.Spread,\n            _eventId,\n            _homeTeamName,\n            _homeTeamId,\n            _awayTeamName,\n            _awayTeamId,\n            _startTimestamp,\n            _homeSpread\n        );\n        return _id;\n    }\n\n    function createOverUnderMarket(\n        address _creator,\n        uint256 _endTime,\n        uint256 _eventId,\n        string memory _homeTeamName,\n        uint256 _homeTeamId,\n        string memory _awayTeamName,\n        uint256 _awayTeamId,\n        uint256 _startTimestamp,\n        uint256 _overUnderTotal\n    ) internal returns (uint256) {\n        string[] memory _outcomes = new string[](3);\n        _outcomes[uint256(OverUnderOutcome.NoContest)] = \"No Contest\";\n        _outcomes[uint256(OverUnderOutcome.Over)] = \"Over\";\n        _outcomes[uint256(OverUnderOutcome.Under)] = \"Under\";\n\n        // The total is a quantity of tenths. So 55 is 5.5 and -6 is -60.\n        // If the total is a whole number then make it a half point higher, to eliminate ties.\n        // So 50 becomes 55 and 0 becomes 5.\n        if (_overUnderTotal >= 0 && _overUnderTotal % 10 == 0) {\n            _overUnderTotal += 5;\n        }\n\n        uint256 _id = markets.length;\n        markets.push(makeMarket(_creator, _outcomes, _outcomes, _endTime, evenOdds(true, 2)));\n        marketDetails[_id] = MarketDetails(\n            _eventId,\n            _homeTeamName,\n            _homeTeamId,\n            _awayTeamName,\n            _awayTeamId,\n            _startTimestamp,\n            MarketType.OverUnder,\n            EventStatus.Scheduled,\n            int256(_overUnderTotal)\n        );\n        emit MarketCreated(\n            _id,\n            _creator,\n            _endTime,\n            MarketType.OverUnder,\n            _eventId,\n            _homeTeamName,\n            _homeTeamId,\n            _awayTeamName,\n            _awayTeamId,\n            _startTimestamp,\n            int256(_overUnderTotal)\n        );\n        return _id;\n    }\n\n    function resolveMarket(uint256) public pure override {\n        require(false, \"Only the link node can resolve the market, using trustedResolveMarkets\");\n    }\n\n    function trustedResolveMarkets(\n        uint256 _eventId,\n        uint256 _eventStatus,\n        uint256 _homeScore,\n        uint256 _awayScore\n    ) public {\n        require(msg.sender == linkNode, \"Only link node can resolve markets\");\n\n        EventDetails storage _event = events[_eventId];\n        uint256[3] memory _ids = _event.markets;\n\n        require(_ids[0] != 0 || _ids[1] != 0 || _ids[2] != 0, \"Cannot resolve markets that weren't created\");\n\n        require(EventStatus(_eventStatus) != EventStatus.Scheduled, \"cannot resolve SCHEDULED markets\");\n\n        // resolve markets as No Contest\n        if (EventStatus(_eventStatus) != EventStatus.Final) {\n            for (uint256 i = 0; i < _ids.length; i++) {\n                uint256 _id = _ids[i];\n                if (_id == 0) continue; // skip non-created markets\n                OwnedERC20 _winner = markets[_id].shareTokens[0]; // 0th outcome is No Contest for all market types\n                markets[_id].winner = _winner;\n                emit MarketResolved(_id, address(_winner));\n            }\n            return;\n        }\n\n        // only resolve markets that were created\n        if (_ids[0] != 0) {\n            resolveHeadToHeadMarket(_ids[0], _homeScore, _awayScore);\n        }\n        if (_ids[1] != 0) {\n            resolveSpreadMarket(_ids[1], _homeScore, _awayScore);\n        }\n        if (_ids[2] != 0) {\n            resolveOverUnderMarket(_ids[2], _homeScore, _awayScore);\n        }\n    }\n\n    function resolveHeadToHeadMarket(\n        uint256 _id,\n        uint256 _homeScore,\n        uint256 _awayScore\n    ) internal {\n        OwnedERC20 _winner;\n        if (_homeScore > _awayScore) {\n            _winner = markets[_id].shareTokens[uint256(HeadToHeadOutcome.Home)]; // home team won\n        } else if (_homeScore < _awayScore) {\n            _winner = markets[_id].shareTokens[uint256(HeadToHeadOutcome.Away)]; // away team won\n        } else {\n            _winner = markets[_id].shareTokens[uint256(HeadToHeadOutcome.NoContest)]; // no contest\n        }\n\n        markets[_id].winner = _winner;\n        emit MarketResolved(_id, address(_winner));\n    }\n\n    function resolveSpreadMarket(\n        uint256 _id,\n        uint256 _homeScore,\n        uint256 _awayScore\n    ) internal {\n        MarketDetails memory _details = marketDetails[_id];\n        int256 _targetSpread = _details.value0;\n\n        int256 _actualSpread = int256(_homeScore).sub(int256(_awayScore));\n\n        OwnedERC20 _winner;\n        if (_actualSpread > _targetSpread) {\n            _winner = markets[_id].shareTokens[uint256(SpreadOutcome.Home)]; // home spread greater\n        } else if (_actualSpread < _targetSpread) {\n            _winner = markets[_id].shareTokens[uint256(SpreadOutcome.Away)]; // home spread lesser\n        } else {\n            _winner = markets[_id].shareTokens[uint256(SpreadOutcome.NoContest)]; // no contest\n        }\n\n        markets[_id].winner = _winner;\n        emit MarketResolved(_id, address(_winner));\n    }\n\n    function resolveOverUnderMarket(\n        uint256 _id,\n        uint256 _homeScore,\n        uint256 _awayScore\n    ) internal {\n        MarketDetails memory _details = marketDetails[_id];\n        int256 _targetTotal = _details.value0;\n\n        int256 _actualTotal = int256(_homeScore).add(int256(_awayScore));\n\n        OwnedERC20 _winner;\n        if (_actualTotal > _targetTotal) {\n            _winner = markets[_id].shareTokens[uint256(OverUnderOutcome.Over)]; // over\n        } else if (_actualTotal < _targetTotal) {\n            _winner = markets[_id].shareTokens[uint256(OverUnderOutcome.Under)]; // under\n        } else {\n            _winner = markets[_id].shareTokens[uint256(OverUnderOutcome.NoContest)]; // no contest\n        }\n\n        markets[_id].winner = _winner;\n        emit MarketResolved(_id, address(_winner));\n    }\n\n    function getMarketDetails(uint256 _marketId) public view returns (MarketDetails memory) {\n        return marketDetails[_marketId];\n    }\n\n    function setLinkNode(address _newLinkNode) external onlyOwner {\n        linkNode = _newLinkNode;\n        emit LinkNodeChanged(_newLinkNode);\n    }\n\n    function getEventMarkets(uint256 _eventId) external view returns (uint256[3] memory) {\n        uint256[3] memory _event = events[_eventId].markets;\n        return _event;\n    }\n\n    // Events can be partially registered, by only creating some markets.\n    // This returns true only if an event is fully registered.\n    function isEventRegistered(uint256 _eventId) public view returns (bool) {\n        uint256[3] memory _event = events[_eventId].markets;\n        return _event[0] != 0 && _event[1] != 0 && _event[2] != 0;\n    }\n\n    function isEventResolved(uint256 _eventId) public view returns (bool) {\n        // check the event's head-to-head market since it will always exist if the event's markets exist\n        uint256 _marketId = events[_eventId].markets[0];\n        return isMarketResolved(_marketId);\n    }\n\n    // Only usable off-chain. Gas cost can easily eclipse block limit.\n    // Lists all events that could be resolved with a call to resolveEvent.\n    // Not all will be resolvable because this does not ensure the game ended.\n    function listResolvableEvents() external view returns (uint256[] memory) {\n        uint256 _totalResolvable = countResolvableEvents();\n        uint256[] memory _resolvableEvents = new uint256[](_totalResolvable);\n\n        uint256 n = 0;\n        for (uint256 i = 0; i < listOfEvents.length; i++) {\n            if (n > _totalResolvable) break;\n            uint256 _eventId = listOfEvents[i];\n            if (isEventResolvable(_eventId)) {\n                _resolvableEvents[n] = _eventId;\n                n++;\n            }\n        }\n\n        return _resolvableEvents;\n    }\n\n    function countResolvableEvents() internal view returns (uint256) {\n        uint256 _totalResolvable = 0;\n        for (uint256 i = 0; i < listOfEvents.length; i++) {\n            uint256 _eventId = listOfEvents[i];\n            if (isEventResolvable(_eventId)) {\n                _totalResolvable++;\n            }\n        }\n        return _totalResolvable;\n    }\n\n    // Returns true if a call to resolveEvent is potentially useful.\n    function isEventResolvable(uint256 _eventId) internal view returns (bool) {\n        EventDetails memory _event = events[_eventId];\n\n        bool _unresolved = false; // default because non-existing markets aren't resolvable\n        for (uint256 i = 0; i < _event.markets.length; i++) {\n            uint256 _marketId = _event.markets[i];\n            if (_marketId != 0 && !isMarketResolved(_marketId)) {\n                _unresolved = true;\n                break;\n            }\n        }\n\n        return _unresolved;\n    }\n}\n"
    },
    "contracts/turbo/MMALinkMarketFactoryV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../libraries/IERC20Full.sol\";\nimport \"../balancer/BPool.sol\";\nimport \"./AbstractMarketFactoryV2.sol\";\nimport \"./FeePot.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/SignedSafeMath.sol\";\nimport \"../libraries/CalculateLinesToBPoolOdds.sol\";\n\ncontract MMALinkMarketFactoryV2 is AbstractMarketFactoryV2, CalculateLinesToBPoolOdds {\n    using SafeMath for uint256;\n    using SignedSafeMath for int256;\n\n    event MarketCreated(\n        uint256 id,\n        address creator,\n        uint256 endTime,\n        MarketType marketType,\n        uint256 indexed eventId,\n        string homeFighterName,\n        uint256 homeFighterId,\n        string awayFighterName,\n        uint256 awayFighterId,\n        uint256 estimatedStartTime\n    );\n    event MarketResolved(uint256 id, address winner);\n    event LinkNodeChanged(address newLinkNode);\n\n    enum MarketType {HeadToHead}\n    enum HeadToHeadOutcome {\n        NoContest, // 0\n        Away, // 1\n        Home // 2\n    }\n\n    struct MarketDetails {\n        uint256 eventId;\n        string homeFighterName;\n        uint256 homeFighterId;\n        string awayFighterName;\n        uint256 awayFighterId;\n        uint256 estimatedStartTime;\n        MarketType marketType;\n        EventStatus eventStatus;\n    }\n    // MarketId => MarketDetails\n    mapping(uint256 => MarketDetails) internal marketDetails;\n\n    enum EventStatus {Unknown, Scheduled, Final, Postponed, Canceled}\n    struct EventDetails {\n        uint256[1] markets;\n        uint256 homeFighterId;\n        uint256 awayFighterId;\n        uint256 startTime;\n        EventStatus eventStatus;\n    }\n\n    // EventId => EventDetails\n    mapping(uint256 => EventDetails) public events;\n    uint256[] public listOfEvents;\n\n    address public linkNode;\n    uint256 public sportId;\n\n    constructor(\n        address _owner,\n        IERC20Full _collateral,\n        uint256 _shareFactor,\n        FeePot _feePot,\n        uint256 _stakerFee,\n        uint256 _settlementFee,\n        address _protocol,\n        uint256 _protocolFee,\n        address _linkNode,\n        uint256 _sportId\n    )\n        AbstractMarketFactoryV2(\n            _owner,\n            _collateral,\n            _shareFactor,\n            _feePot,\n            _stakerFee,\n            _settlementFee,\n            _protocol,\n            _protocolFee\n        )\n    {\n        linkNode = _linkNode;\n        sportId = _sportId;\n    }\n\n    function createMarket(\n        uint256 _eventId,\n        string memory _homeFighterName,\n        uint256 _homeFighterId,\n        string memory _awayFighterName,\n        uint256 _awayFighterId,\n        uint256 _startTimestamp,\n        int256[2] memory _moneylines // [home,away]\n    ) public {\n        require(msg.sender == linkNode, \"Only link node can create markets\");\n\n        address _creator = msg.sender;\n        uint256 _endTime = _startTimestamp.add(60 * 8); // 8 hours\n\n        uint256[1] memory _ids = events[_eventId].markets;\n        // require(_ids[0] == 0, \"This event was already used to create markets\");\n\n        _ids[0] = createHeadToHeadMarket(\n            _creator,\n            _endTime,\n            _eventId,\n            _homeFighterName,\n            _homeFighterId,\n            _awayFighterName,\n            _awayFighterId,\n            _startTimestamp,\n            _moneylines\n        );\n\n        events[_eventId].markets = _ids;\n        events[_eventId].homeFighterId = _homeFighterId;\n        events[_eventId].awayFighterId = _awayFighterId;\n        events[_eventId].startTime = _startTimestamp;\n        events[_eventId].eventStatus = EventStatus.Scheduled;\n        listOfEvents.push(_eventId);\n    }\n\n    function createHeadToHeadMarket(\n        address _creator,\n        uint256 _endTime,\n        uint256 _eventId,\n        string memory _homeTeamName,\n        uint256 _homeFighterId,\n        string memory _awayTeamName,\n        uint256 _awayFighterId,\n        uint256 _startTimestamp,\n        int256[2] memory _moneylines // [home,away]\n    ) internal returns (uint256) {\n        string[] memory _outcomes = new string[](3);\n        _outcomes[uint256(HeadToHeadOutcome.NoContest)] = \"No Contest\";\n        _outcomes[uint256(HeadToHeadOutcome.Away)] = _awayTeamName;\n        _outcomes[uint256(HeadToHeadOutcome.Home)] = _homeTeamName;\n\n        uint256 _id = markets.length;\n        // moneylines is [home,away] but the outcomes are listed [NC,away,home] so they must be reversed\n        markets.push(\n            makeMarket(_creator, _outcomes, _outcomes, _endTime, oddsFromLines(_moneylines[1], _moneylines[0]))\n        );\n        marketDetails[_id] = MarketDetails(\n            _eventId,\n            _homeTeamName,\n            _homeFighterId,\n            _awayTeamName,\n            _awayFighterId,\n            _startTimestamp,\n            MarketType.HeadToHead,\n            EventStatus.Scheduled\n        );\n        emit MarketCreated(\n            _id,\n            _creator,\n            _endTime,\n            MarketType.HeadToHead,\n            _eventId,\n            _homeTeamName,\n            _homeFighterId,\n            _awayTeamName,\n            _awayFighterId,\n            _startTimestamp\n        );\n        return _id;\n    }\n\n    enum WhoWon {Unknown, Home, Away, Draw}\n\n    function trustedResolveMarkets(\n        uint256 _eventId,\n        EventStatus _eventStatus,\n        uint256 _homeFighterId,\n        uint256 _awayFighterId,\n        WhoWon _whoWon\n    ) public {\n        require(msg.sender == linkNode, \"Only link node can resolve markets\");\n\n        EventDetails memory _event = events[_eventId];\n        require(_event.markets[0] != 0, \"Cannot resolve markets that weren't created\");\n        require(EventStatus(_eventStatus) != EventStatus.Scheduled, \"Cannot resolve SCHEDULED markets\");\n\n        if (eventIsNoContest(_event, _eventStatus, _homeFighterId, _awayFighterId, _whoWon)) {\n            resolveMarketsAsNoContest(_eventId);\n        } else {\n            resolveHeadToHeadMarket(_event.markets[0], _whoWon);\n        }\n\n        events[_eventId].eventStatus = _eventStatus;\n    }\n\n    function eventIsNoContest(\n        EventDetails memory _event,\n        EventStatus _eventStatus,\n        uint256 _homeFighterId,\n        uint256 _awayFighterId,\n        WhoWon _whoWon\n    ) internal pure returns (bool) {\n        bool _draw = _whoWon == WhoWon.Draw;\n        bool _notFinal = _eventStatus != EventStatus.Final;\n        bool _unstableHomeFighterId = _event.homeFighterId != _homeFighterId;\n        bool _unstableAwayFighterId = _event.awayFighterId != _awayFighterId;\n        return _draw || _notFinal || _unstableHomeFighterId || _unstableAwayFighterId;\n    }\n\n    function resolveMarketsAsNoContest(uint256 _eventId) internal {\n        uint256[1] memory _marketIds = events[_eventId].markets;\n        for (uint256 i = 0; i < _marketIds.length; i++) {\n            uint256 _marketId = _marketIds[i];\n            if (_marketId == 0) continue; // skip non-created markets\n            OwnedERC20 _winner = markets[_marketId].shareTokens[0]; // 0th outcome is No Contest for all market types\n            markets[_marketId].winner = _winner;\n            emit MarketResolved(_marketId, address(_winner));\n        }\n    }\n\n    function resolveHeadToHeadMarket(uint256 _marketId, WhoWon _whoWon) internal {\n        OwnedERC20 _winner;\n        if (WhoWon.Home == _whoWon) {\n            _winner = markets[_marketId].shareTokens[uint256(HeadToHeadOutcome.Home)];\n        } else if (WhoWon.Away == _whoWon) {\n            _winner = markets[_marketId].shareTokens[uint256(HeadToHeadOutcome.Away)];\n        } else {\n            require(false, \"Bad market resolution choice\");\n        }\n\n        markets[_marketId].winner = _winner;\n        emit MarketResolved(_marketId, address(_winner));\n    }\n\n    function getMarketDetails(uint256 _marketId) public view returns (MarketDetails memory) {\n        return marketDetails[_marketId];\n    }\n\n    // Only usable off-chain. Gas cost can easily eclipse block limit.\n    // Lists all events that could be resolved with a call to resolveEvent.\n    // Not all will be resolvable because this does not ensure the game ended.\n    function listResolvableEvents() external view returns (uint256[] memory) {\n        uint256 _totalResolvable = countResolvableEvents();\n        uint256[] memory _resolvableEvents = new uint256[](_totalResolvable);\n\n        uint256 n = 0;\n        for (uint256 i = 0; i < listOfEvents.length; i++) {\n            if (n > _totalResolvable) break;\n            uint256 _eventId = listOfEvents[i];\n            if (isEventResolvable(_eventId)) {\n                _resolvableEvents[n] = _eventId;\n                n++;\n            }\n        }\n\n        return _resolvableEvents;\n    }\n\n    function countResolvableEvents() internal view returns (uint256) {\n        uint256 _totalResolvable = 0;\n        for (uint256 i = 0; i < listOfEvents.length; i++) {\n            uint256 _eventId = listOfEvents[i];\n            if (isEventResolvable(_eventId)) {\n                _totalResolvable++;\n            }\n        }\n        return _totalResolvable;\n    }\n\n    // Returns true if a call to resolveEvent is potentially useful.\n    function isEventResolvable(uint256 _eventId) internal view returns (bool) {\n        EventDetails memory _event = events[_eventId];\n\n        bool _unresolved = false; // default because non-existing markets aren't resolvable\n        for (uint256 i = 0; i < _event.markets.length; i++) {\n            uint256 _marketId = _event.markets[i];\n            if (_marketId != 0 && !isMarketResolved(_marketId)) {\n                _unresolved = true;\n                break;\n            }\n        }\n\n        return _unresolved;\n    }\n\n    function getEvent(uint256 _eventId) external view returns (EventDetails memory _event) {\n        _event = events[_eventId];\n    }\n\n    function setLinkNode(address _newLinkNode) external onlyOwner {\n        linkNode = _newLinkNode;\n        emit LinkNodeChanged(_newLinkNode);\n    }\n\n    function resolveMarket(uint256) public pure override {\n        require(false, \"Only the link node can resolve the market, using trustedResolveMarkets\");\n    }\n}\n"
    },
    "contracts/turbo/MLBMarketFactoryV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../libraries/IERC20Full.sol\";\nimport \"../balancer/BPool.sol\";\nimport \"./AbstractMarketFactoryV3.sol\";\nimport \"./FeePot.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/SignedSafeMath.sol\";\nimport \"../libraries/Sport.sol\";\nimport \"../libraries/HasHeadToHeadMarket.sol\";\nimport \"../libraries/ResolveByScore.sol\";\nimport \"../libraries/Versioned.sol\";\n\ncontract MLBMarketFactoryV3 is AbstractMarketFactoryV3, SportView, HasHeadToHeadMarket, ResolvesByScore, Versioned {\n    using SafeMath for uint256;\n    using SignedSafeMath for int256;\n\n    uint256 constant HeadToHead = 0;\n    string constant InvalidName = \"No Contest\";\n\n    constructor(\n        address _owner,\n        IERC20Full _collateral,\n        uint256 _shareFactor,\n        FeePot _feePot,\n        uint256[3] memory _fees,\n        address _protocol,\n        address _linkNode\n    )\n        AbstractMarketFactoryV3(_owner, _collateral, _shareFactor, _feePot, _fees, _protocol)\n        Versioned(\"v1.4.0\")\n        ManagedByLink(_linkNode)\n        HasHeadToHeadMarket(HeadToHead, InvalidName)\n    {}\n\n    function createEvent(\n        uint256 _eventId,\n        string memory _homeTeamName,\n        uint256 _homeTeamId,\n        string memory _awayTeamName,\n        uint256 _awayTeamId,\n        uint256 _startTimestamp,\n        int256[2] memory _moneylines // [home,away]\n    ) public onlyLinkNode returns (uint256[] memory _marketIds) {\n        _marketIds = makeMarkets(_moneylines, _homeTeamName, _awayTeamName);\n        makeSportsEvent(\n            _eventId,\n            _marketIds,\n            build1Line(),\n            _startTimestamp,\n            _homeTeamId,\n            _awayTeamId,\n            _homeTeamName,\n            _awayTeamName\n        );\n    }\n\n    function makeMarkets(\n        int256[2] memory _moneylines,\n        string memory _homeTeamName,\n        string memory _awayTeamName\n    ) internal returns (uint256[] memory _marketIds) {\n        _marketIds = new uint256[](1);\n        _marketIds[HeadToHead] = makeHeadToHeadMarket(_moneylines, _homeTeamName, _awayTeamName);\n    }\n\n    function resolveValidEvent(\n        SportsEvent memory _event,\n        uint256 _homeScore,\n        uint256 _awayScore\n    ) internal override {\n        resolveHeadToHeadMarket(_event.markets[HeadToHead], _homeScore, _awayScore);\n    }\n}\n"
    },
    "contracts/turbo/CryptoMarketFactoryV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../libraries/IERC20Full.sol\";\nimport \"../balancer/BPool.sol\";\nimport \"./AbstractMarketFactoryV2.sol\";\nimport \"./FeePot.sol\";\nimport \"@openzeppelin/contracts/utils/math/SignedSafeMath.sol\";\n\nimport \"../utils/AggregatorV3Interface.sol\";\nimport \"../libraries/CalculateLinesToBPoolOdds.sol\";\n\ncontract CryptoMarketFactoryV2 is AbstractMarketFactoryV2, CalculateLinesToBPoolOdds {\n    using SafeMath for uint256;\n    using SignedSafeMath for int256;\n\n    event MarketCreated(\n        uint256 id,\n        address creator,\n        uint256 indexed endTime,\n        MarketType marketType,\n        uint256 indexed coinIndex,\n        uint256 price\n    );\n    event MarketResolved(uint256 id, address winner);\n\n    struct Coin {\n        string name;\n        AggregatorV3Interface priceFeed;\n        uint256 price;\n        uint8 imprecision; // how many decimals to truncate\n        uint256[1] currentMarkets;\n    }\n    Coin[] public coins;\n\n    enum MarketType {\n        PriceUpDown // 0\n    }\n    enum PriceUpDownOutcome {\n        Above, // 0\n        NotAbove // 1\n    }\n    struct MarketDetails {\n        MarketType marketType;\n        uint256 coinIndex;\n        uint256 creationPrice;\n        uint256 resolutionPrice;\n    }\n    // MarketId => MarketDetails\n    mapping(uint256 => MarketDetails) internal marketDetails;\n\n    address public linkNode; // market creator and resolver\n\n    uint256 public nextResolutionTime;\n\n    constructor(\n        address _owner,\n        IERC20Full _collateral,\n        uint256 _shareFactor,\n        FeePot _feePot,\n        uint256 _stakerFee,\n        uint256 _settlementFee,\n        address _protocol,\n        uint256 _protocolFee,\n        address _linkNode\n    )\n        AbstractMarketFactoryV2(\n            _owner,\n            _collateral,\n            _shareFactor,\n            _feePot,\n            _stakerFee,\n            _settlementFee,\n            _protocol,\n            _protocolFee\n        )\n    {\n        linkNode = _linkNode;\n\n        string memory _name = \"\";\n        coins.push(makeCoin(_name, AggregatorV3Interface(address(0)), 0));\n    }\n\n    function getMarketDetails(uint256 _marketId) public view returns (MarketDetails memory) {\n        return marketDetails[_marketId];\n    }\n\n    // NOTE: Trusts the owner not to add a coin twice.\n    // Returns the coin index.\n    function addCoin(\n        string calldata _name,\n        AggregatorV3Interface _priceFeed,\n        uint8 _imprecision\n    ) external onlyOwner returns (uint256 _coinIndex) {\n        Coin memory _coin = makeCoin(_name, _priceFeed, _imprecision);\n        _coinIndex = coins.length;\n        coins.push(_coin);\n    }\n\n    function getCoin(uint256 _coinIndex) public view returns (Coin memory _coin) {\n        _coin = coins[_coinIndex];\n    }\n\n    function getCoins() public view returns (Coin[] memory _coins) {\n        _coins = new Coin[](coins.length);\n        // Skip first coin because it's always the zeroed-out fake coin.\n        for (uint256 i = 1; i < coins.length; i++) {\n            _coins[i] = coins[i];\n        }\n    }\n\n    // Iterates over all coins.\n    // If markets do not exist for coin, create them.\n    // Unless _nextResolutionTime is zero; then do not create new markets.\n    // If markets for coin exist and are ready to resolve, resolve them and create new markets.\n    // Else, error.\n    //\n    // Assume that _roundIds has a dummy value at index 0, and is 1 indexed like the\n    // coins array.\n    function createAndResolveMarkets(uint80[] calldata _roundIds, uint256 _nextResolutionTime) public {\n        require(msg.sender == linkNode, \"Only link node can create markets\");\n        // If market creation was stopped then it can be started again.\n        // If market creation wasn't stopped then you must wait for market end time to resolve.\n        require(block.timestamp >= nextResolutionTime, \"Must wait for market resolution\");\n        require(_roundIds.length == coins.length, \"Must specify one roundId for each coin\");\n\n        uint256 _resolutionTime = nextResolutionTime;\n        nextResolutionTime = _nextResolutionTime;\n\n        // Start at 1 to skip the fake Coin in the 0 index\n        for (uint256 i = 1; i < coins.length; i++) {\n            createAndResolveMarketsForCoin(i, _resolutionTime, _roundIds[i]);\n        }\n    }\n\n    function createAndResolveMarketsForCoin(\n        uint256 _coinIndex,\n        uint256 _resolutionTime,\n        uint80 _roundId\n    ) internal {\n        Coin memory _coin = coins[_coinIndex];\n        (uint256 _fullPrice, uint256 _newPrice) = getPrice(_coin, _roundId, _resolutionTime);\n\n        // resolve markets\n        if (_coin.currentMarkets[uint256(MarketType.PriceUpDown)] != 0) {\n            resolvePriceUpDownMarket(_coin, _newPrice, _fullPrice);\n        }\n\n        // update price only AFTER resolution\n        coins[_coinIndex].price = _newPrice;\n\n        // link node sets nextResolutionTime to zero to signify \"do not create markets after resolution\"\n        if (nextResolutionTime == 0) {\n            return;\n        }\n\n        // create markets\n        coins[_coinIndex].currentMarkets[uint256(MarketType.PriceUpDown)] = createPriceUpDownMarket(\n            _coinIndex,\n            linkNode,\n            _newPrice\n        );\n    }\n\n    function resolvePriceUpDownMarket(\n        Coin memory _coin,\n        uint256 _newPrice,\n        uint256 _fullPrice\n    ) internal {\n        uint256 _marketId = _coin.currentMarkets[uint256(MarketType.PriceUpDown)];\n\n        OwnedERC20 _winner;\n        if (_newPrice > _coin.price) {\n            _winner = markets[_marketId].shareTokens[uint256(PriceUpDownOutcome.Above)];\n        } else {\n            _winner = markets[_marketId].shareTokens[uint256(PriceUpDownOutcome.NotAbove)];\n        }\n\n        markets[_marketId].winner = _winner;\n        marketDetails[_marketId].resolutionPrice = _fullPrice;\n        emit MarketResolved(_marketId, address(_winner));\n    }\n\n    function createPriceUpDownMarket(\n        uint256 _coinIndex,\n        address _creator,\n        uint256 _newPrice\n    ) internal returns (uint256 _id) {\n        string[] memory _outcomes = new string[](2);\n        _outcomes[uint256(PriceUpDownOutcome.Above)] = \"Above\";\n        _outcomes[uint256(PriceUpDownOutcome.NotAbove)] = \"Not Above\";\n\n        uint256 _nextResolutionTime = nextResolutionTime;\n        _id = markets.length;\n        markets.push(makeMarket(_creator, _outcomes, _outcomes, _nextResolutionTime, evenOdds(false, 2)));\n        marketDetails[_id] = MarketDetails(MarketType.PriceUpDown, _coinIndex, _newPrice, 0);\n        emit MarketCreated(_id, _creator, _nextResolutionTime, MarketType.PriceUpDown, _coinIndex, _newPrice);\n    }\n\n    // Returns the price based on a few factors.\n    // If _roundId is zero then it returns the latest price.\n    // Else, it returns the price for that round,\n    //       but errors if that isn't the first round after the resolution time.\n    // The price is then altered to match the desired precision.\n    function getPrice(\n        Coin memory _coin,\n        uint80 _roundId,\n        uint256 _resolutionTime\n    ) internal view returns (uint256 _fullPrice, uint256 _truncatedPrice) {\n        if (_roundId == 0) {\n            (, int256 _rawPrice, , , ) = _coin.priceFeed.latestRoundData();\n            require(_rawPrice >= 0, \"Price from feed is negative\");\n            _fullPrice = uint256(_rawPrice);\n        } else {\n            (, int256 _rawPrice, , uint256 updatedAt, ) = _coin.priceFeed.getRoundData(_roundId);\n            require(_rawPrice >= 0, \"Price from feed is negative\");\n            require(updatedAt >= _resolutionTime, \"Price hasn't been updated yet\");\n\n            // if resolution time is zero then market creation was stopped, so the previous round doesn't matter\n            if (_resolutionTime != 0) {\n                (, , , uint256 _previousRoundTime, ) = _coin.priceFeed.getRoundData(previousRound(_roundId));\n                require(_previousRoundTime < _resolutionTime, \"Must use first round after resolution time\");\n            }\n\n            _fullPrice = uint256(_rawPrice);\n        }\n\n        // The precision is how many decimals the price has. Zero is dollars, 2 includes cents, 3 is tenths of a cent, etc.\n        // Our resolution rules want a certain precision. Like BTC is to the dollar and MATIC is to the cent.\n        // If somehow the decimals are larger than the desired precision then add zeroes to the end to meet the precision.\n        // This does not change the resolution outcome but does guard against decimals() changing and therefore altering the basis.\n\n        uint8 _precision = _coin.priceFeed.decimals(); // probably constant but that isn't guaranteed, so query each time\n        if (_precision > _coin.imprecision) {\n            uint8 _truncate = _precision - _coin.imprecision;\n            _truncatedPrice = _fullPrice / (10**_truncate);\n        } else if (_precision < _coin.imprecision) {\n            uint8 _greaten = _coin.imprecision - _precision;\n            _truncatedPrice = _fullPrice * (10**_greaten);\n        } else {\n            _truncatedPrice = _fullPrice;\n        }\n\n        // Round up because that cleanly fits Above/Not-Above.\n        if (_truncatedPrice != _fullPrice) {\n            _truncatedPrice += 1;\n        }\n    }\n\n    function makeCoin(\n        string memory _name,\n        AggregatorV3Interface _priceFeed,\n        uint8 _imprecision\n    ) internal pure returns (Coin memory _coin) {\n        uint256[1] memory _currentMarkets = [uint256(0)];\n        _coin = Coin(_name, _priceFeed, 0, _imprecision, _currentMarkets);\n    }\n\n    function resolveMarket(uint256) public pure override {\n        require(false, \"Use createAndResolveMarkets\");\n    }\n\n    // The roundId is the encoding of two parts: the phase and the phase-specific round id.\n    // To find the previous roundId:\n    // 1. extract the phase and phase-specific round (I call these _phaseId and _roundId)\n    // 2. decrement the phase-specific round\n    // 3. re-encode the phase and phase-specific round.\n    uint256 private constant PHASE_OFFSET = 64;\n\n    function previousRound(uint80 _fullRoundId) internal pure returns (uint80) {\n        uint256 _phaseId = uint256(uint16(_fullRoundId >> PHASE_OFFSET));\n        uint64 _roundId = uint64(_fullRoundId) - 1;\n        return uint80((_phaseId << PHASE_OFFSET) | _roundId);\n    }\n}\n"
    },
    "contracts/libraries/FakePriceFeed.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../utils/AggregatorV3Interface.sol\";\n\ncontract FakePriceFeed is AggregatorV3Interface {\n    uint8 decimals_;\n    string description_;\n    uint256 version_;\n\n    struct Round {\n        uint80 roundId;\n        int256 answer;\n        uint256 startedAt;\n        uint256 updatedAt;\n        uint80 answeredInRound;\n    }\n    mapping(uint80 => Round) rounds;\n    uint80 latestRoundId;\n\n    constructor(\n        uint8 _decimals,\n        string memory _description,\n        uint256 _version\n    ) {\n        decimals_ = _decimals;\n        description_ = _description;\n        version_ = _version;\n    }\n\n    function decimals() external view override returns (uint8) {\n        return decimals_;\n    }\n\n    function description() external view override returns (string memory) {\n        return description_;\n    }\n\n    function version() external view override returns (uint256) {\n        return version_;\n    }\n\n    // getRoundData and latestRoundData should both raise \"No data present\"\n    // if they do not have data to report, instead of returning unset values\n    // which could be misinterpreted as actual reported values.\n    function getRoundData(uint80 roundId_)\n        public\n        view\n        override\n        returns (\n            uint80 _roundId,\n            int256 _answer,\n            uint256 _startedAt,\n            uint256 _updatedAt,\n            uint80 _answeredInRound\n        )\n    {\n        Round memory _round = rounds[roundId_];\n        _roundId = _round.roundId;\n        _answer = _round.answer;\n        _startedAt = _round.startedAt;\n        _updatedAt = _round.updatedAt;\n        _answeredInRound = _round.answeredInRound;\n    }\n\n    function latestRoundData()\n        public\n        view\n        override\n        returns (\n            uint80 _roundId,\n            int256 _answer,\n            uint256 _startedAt,\n            uint256 _updatedAt,\n            uint80 _answeredInRound\n        )\n    {\n        return getRoundData(latestRoundId);\n    }\n\n    function addRound(\n        uint80 _roundId,\n        int256 _answer,\n        uint256 _startedAt,\n        uint256 _updatedAt,\n        uint80 _answeredInRound\n    ) external {\n        rounds[_roundId] = Round(_roundId, _answer, _startedAt, _updatedAt, _answeredInRound);\n        latestRoundId = _roundId;\n    }\n}\n"
    },
    "contracts/stablecoin/indexCDS.sol": {
      "content": "pragma solidity ^0.8.4; \n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n//import \"../ERC20/IERC20.sol\";\n\nimport \"../turbo/AMMFactory.sol\"; \nimport \"../turbo/OwnedShareToken.sol\"; \nimport \"hardhat/console.sol\";\n\ncontract IndexCDS is ERC721, ReentrancyGuard{\n\n\n \tstruct Index{\n \t\tuint256 value;\n \t\tuint256[] amounts; \n \t\taddress[] tokens; \n\n \t\t\n \t}\n \tstruct Index_info{\n \t\tuint256[] token_amounts;\n \t\tuint256[] marketIds; \n \t\tuint256[] outcomes; \n \t}\n\n \tuint256 public totalNumMints;\n \tuint256 num_outcomes = 2; //TODO this is only for binary outcomes \n \tmapping(uint256=> Index_info) index_infos; \n \tmapping(uint256 => Index) indexes; \n \tmapping(address=>uint256) address_to_id;\n\n \tconstructor()\n        ERC721(\"IndexCDS\", \"iCDS\"){\n\n        }\n  \n \t//TODO Call to amm factory\n \tfunction getPrice(address token) internal view returns(uint256){\n \t\treturn 1; \n \t}\n\n \t//TODO Returns the maximum return of this nft including and excluding longCDS tokens\n \tfunction getAPR(address holder) public view returns(uint256){\n \t\treturn 1; \n \t}\n\n \tfunction curValue(address holder) public view returns(uint256){\n \t\tuint256 lockID = address_to_id[holder]; \n \t\taddress[] memory tokens_ = indexes[lockID].tokens; \n \t\tuint256[] memory amounts = indexes[lockID].amounts; \n\n \t\tuint256 num_tokens = tokens_.length;\n \t\tuint256 price; \n \t\tuint256 value;\n \t//\tuint256[] memory prices; \n \t\tfor (uint256 i=0; i< num_tokens; i++){ \n \t\t\tprice = getPrice(tokens_[i]); \n \t\t\tvalue = value + (price * amounts[i]); \n \t\t}\n\n\n \t}\n\n \t//Mints nft for current price of each cds \n \t//Token addresses are for CDS(sharetokens in marketfactory) tokens \n \tfunction mintIndex(address recipient,  bool from_recipient, \n \t\t\t\t\t   uint256[] memory prices,\n \t\t\t\t\t   uint256[] memory amounts, //this is token amount, not collateral\n \t\t\t\t\t   address[] memory tokens_addresses \n \t\t\t\t\t   ) internal returns(uint256){\n \t\tuint256 lockID = ++totalNumMints; \n\n \t\tuint256 num_tokens = prices.length;\n \t\tuint256 value; \n \t\tfor (uint256 i=0; i< num_tokens; i++){ \n \t\t\tvalue = value + (prices[i] * amounts[i]);\n\n \t\t\tif (from_recipient){\n \t\t\t\tOwnedERC20(tokens_addresses[i]).transferFrom(recipient, address(this), amounts[i]);\n \t\t\t}//else each sharetokens are already owned by this contract \n\n \t\t}\n\n \t\tIndex memory index = Index(value,amounts, tokens_addresses); \n \t\tindexes[lockID] = index; \n \t\taddress_to_id[recipient] = lockID; \n\n\t\t_safeMint(recipient, lockID); \n\n\t\treturn lockID; \n\n\n \t}\n\n \t\n \tfunction redeemIndex(address recipient, uint256 lockID, bool from_recipient) internal {\n \t\t\n \t\tIndex memory index = indexes[lockID]; \n \t\tuint256 num_tokens = index.amounts.length;\n\n \t\tif (from_recipient){\n\t \t\tfor (uint256 i=0; i< num_tokens; i++){\n\t \t\t\tSafeERC20.safeTransfer(IERC20(index.tokens[i]), recipient, index.amounts[i]); \n\t \t\t}\n \t\t}\n\n \t\t_burn(lockID); \n \t\tdelete indexes[lockID]; \n\n\n } \t\n\n \tstruct Variable{\n \t\tuint256 amount;\n \t\tuint256 marketId;\n \t\tuint256 outcome;\n \t}\n\n \tfunction getVariable(uint256[] memory marketIds, \n \t\tuint256[] memory outcomes, \n \t\tuint256[] memory amounts) internal returns(Variable[] memory){\n\n \t\tVariable[] memory variables = new Variable[](marketIds.length);\n \t\tfor (uint256 i=0; i< marketIds.length; i++){\n \t\t\tvariables[i] = Variable(amounts[i], marketIds[i], outcomes[i]); \t\t\t\n \t\t}\n \t\treturn variables; \n \t}\n\n \t//This is the function called by contract calls, it first transfers the DS\n \t//from the msg.sender to this contract, and this contract will buy all the sharetokens\n \t//in behalf. It will then mint the nft and give it back to msg.sender\n \t//does the minting nft as well.\n \t//User gives collateral to this contract, this contract buys sharetokens + mints nft and gives back\n \tfunction buyBulk(address recipient,  \n \t\taddress marketFactoryAddress, \n \t\taddress ammFactoryAddress, \n \t\tuint256[] memory marketIds,\n \t\tuint256[] memory outcomes, \n \t\tuint256[] memory amounts) external returns(uint256){\n\n \t\tuint256 num_buys = marketIds.length; \n \t\tAMMFactory amm = AMMFactory(ammFactoryAddress); \n \t\tAbstractMarketFactoryV3 marketFactory = AbstractMarketFactoryV3(marketFactoryAddress);\n \t\tIERC20 collateral = marketFactory.collateral(); //DS\n\n \t\tuint256[] memory prices = new uint256[](num_buys); \n \t\tuint256[] memory token_amounts = new uint256[](num_buys); \n \t\taddress[] memory outcometokens = new address[](num_buys); \n\n \t\tVariable[] memory variable = getVariable(marketIds, outcomes, amounts);\n \t\t//Iterate over all chosen markets \n \t\tfor (uint256 i=0; i<num_buys; i++){\n \t\t\t//Should transfer collateral all at once to save gas \n \t\t\t//This allows this contract to now have the sharetokens for each outcome \n\n \t\t\ttoken_amounts[i] = executeBuy(marketFactory,amm,\n \t\t\t collateral, msg.sender, variable[i]); \n\n \t\t\toutcometokens[i] = getOutcomeToken(marketFactory,variable[i]);\n \t\t\tprices[i] = getPrice(outcometokens[i]); //TODO find how to calculate prices \n\n \t\t}\n\n \t\tuint256 lockId = mintIndex(msg.sender,false, prices, token_amounts, outcometokens  );\n \t\tindex_infos[lockId] = Index_info(token_amounts, marketIds, outcomes);\n \t\t\n \t\treturn lockId;\n \t}\n\n \tfunction getOutcomeToken(AbstractMarketFactoryV3 marketFactory,\n \t\tVariable memory variable ) internal returns(address){\n \t\tAbstractMarketFactoryV3.Market memory _market =  marketFactory.getMarket(variable.marketId); \n\n \t\treturn address(_market.shareTokens[variable.outcome]); \n \t}\n\n \tfunction executeBuy(AbstractMarketFactoryV3 marketFactory, \n \t\tAMMFactory amm, \n \t\tIERC20 collateral, \n \t\taddress recipient, \n \t\tVariable memory variable) internal returns(uint256){\n\n\n \t\tcollateral.transferFrom(recipient, address(this), variable.amount); \n \t\tcollateral.approve(address(amm), variable.amount); \n\n \t\treturn amm.buy(marketFactory, variable.marketId,\n \t\t\tvariable.outcome,variable.amount, 0);\n \t}\n\n\n \t//User gives id of its NFT to this contract, it then burns the NFT and sell the underlying tokens, \n \t//and gives the collateral back to the user. For now it will sell all tokens and give the collateral\n \t//for all tokens back. Users will have to rebuy if they want to just get rid of one token \n \tfunction sellBulk(address recipient, \n \t\tuint256 lockID, \n \t\taddress marketFactoryAddress, \n \t\taddress ammFactoryAddress) external {\n\n \t\tAMMFactory amm = AMMFactory(ammFactoryAddress); \n \t\tAbstractMarketFactoryV3 marketFactory = AbstractMarketFactoryV3(marketFactoryAddress);\n \t\tIERC20 collateral = marketFactory.collateral(); \n\n \t\tIndex_info memory info = index_infos[lockID]; \n\n \t\tuint256[] memory shareTokensIn = new uint256[](num_outcomes); \n \t\tuint256 total_collateral_out = 0; \n \t\tuint256 num_sells = info.marketIds.length; \n\n\n \t\tfor (uint256 i=0; i< num_sells; i++){\n\n \t\t\tfor(uint256 j=0; j<num_outcomes; j++){\n \t\t\t\t//outcome[i] is 0 or 1 (if it is binary)\n \t\t\t\t//0 if outcome[i] != j, info.token_amounts[i] otherwise\n \t\t\t\t//bool isZero = (info.outcomes[i] != j);\n \t\t\t\t//shareTokensIn[j] = isZero ? 0: info.token_amounts[i];\n \t\t\t\tshareTokensIn[j] = info.token_amounts[i];\n \t\t\t}\n \t\t\t//need to approve amm for the sharetokens; \n \t\t\tsell_approve(marketFactory, amm, info.marketIds[i], info.outcomes[i], shareTokensIn); \n\n \t\t\ttotal_collateral_out = total_collateral_out + amm.sellForCollateral(\n \t\t\t\tmarketFactory, \n \t\t\t\tinfo.marketIds[i],\n \t\t\t\tinfo.outcomes[i], \n \t\t\t\tshareTokensIn, \n \t\t\t\t0);\n \t\t\t//Now this contract holds the collateral, so should give it back to msg.sender\n \t\t}\n\n \t\tredeemIndex( recipient,  lockID,  false); \n \t\tcollateral.transfer(msg.sender, total_collateral_out ); \n\n\n\n \t}\n\n \tfunction sell_approve(AbstractMarketFactoryV3 marketFactory, \n \t\tAMMFactory amm ,\n \t\tuint256 marketId, \n \t\tuint256 outcome, \n \t\tuint256[] memory shareTokensIn ) private {\n \t\trequire(shareTokensIn[outcome] > 0); \n \t\t AbstractMarketFactoryV3.Market memory _market = marketFactory.getMarket(marketId);\n \t\t _market.shareTokens[outcome].approve(address(amm), shareTokensIn[outcome]); \n \t}\n\n\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./extensions/IERC721Metadata.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/Strings.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: address zero is not a valid owner\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: invalid token ID\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not token owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner nor approved\");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), \"ERC721: invalid token ID\");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n\t}\n\n\tfunction logUint(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/staking/voting.sol": {
      "content": "pragma solidity ^0.8.4;\n\nimport \"../stablecoin/DSS.sol\";\nimport \"hardhat/console.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\n//Code borrowed and adapted from Tokemak \n\n/// @notice Vote payload to be submitted to Vote Tracker\nstruct UserVotePayload {\n    address account;\n    bytes32 voteSessionKey;\n    uint256 nonce;\n    uint256 chainId;\n    uint256 totalVotes;\n    UserVoteAllocationItem[] allocations;\n}\n\n/// @notice Individual allocation to an asset, exchange, or asset-pair\nstruct UserVoteAllocationItem {\n    bytes32 reactorKey;\n    uint256 amount; //18 Decimals\n}\n\n\nstruct UserVoteDetails {\n    uint256 totalUsedVotes;\n    uint256 totalAvailableVotes;\n}\ncontract VoteTracker {\n    using SafeMath for uint256;\n\n\tDSS public dss;\n\n\n\tmapping(address => UserVoteDetails) userVoteDetails;\n    mapping(address => bytes32[]) public userVoteKeys;\n    mapping(address => mapping(bytes32 => uint256)) public userVoteItems;\n    mapping(bytes32 => uint256) public systemAggregations;\n\n    /// @dev Stores the users next valid vote nonce\n    EnumerableSet.Bytes32Set private allowedreactorKeys;\n\tmapping(address => uint256) public  userNonces; \n\n\tconstructor (address dss_address) public{\n\t\tdss = DSS(dss_address);\n\t}\n\n\n\n    //single user will call this vote function from UI, vote allocation for \n    //each potential borrowers \n\tfunction vote(bytes32 _voteSessionKey, uint256 _nonce, uint256 _totalVotes,\n        bytes32[] memory reactorKeys, uint256[] memory amounts)\n\texternal  {\n        uint256 key_lengths = reactorKeys.length; \n        UserVoteAllocationItem[] memory _allocations = new UserVoteAllocationItem[](key_lengths); \n\n\n        for (uint256 i=0; i < key_lengths; i++){\n            _allocations[i] = UserVoteAllocationItem({\n                reactorKey : reactorKeys[i], \n                amount: amounts[i]\n                });\n\n        }\n\n\n        UserVotePayload memory payload  = UserVotePayload({\n            account : msg.sender, \n            voteSessionKey : _voteSessionKey, \n            nonce: _nonce, \n            chainId : 0, \n            totalVotes: _totalVotes, \n            allocations: _allocations\n            }); \n\n        _vote(payload);\n\n\t}\n\n\n    function _removeUserVoteKey(address account, bytes32 reactorKey) internal  {\n        for (uint256 i = 0; i < userVoteKeys[account].length; i++) {\n            if (userVoteKeys[account][i] == reactorKey) {\n                userVoteKeys[account][i] = userVoteKeys[account][userVoteKeys[account].length - 1];\n                userVoteKeys[account].pop();\n                break;\n            }\n        }\n    }\n\n    \n\n\tfunction _vote(UserVotePayload memory userVotePayload) internal  {\n\t\taddress account = userVotePayload.account; \n\t\tuint256 totalUsedVotes = userVoteDetails[account].totalUsedVotes;\n\n        console.log('nonce', userNonces[account]);\n\t\trequire(userNonces[account] == userVotePayload.nonce, \"INVALID_NONCE\");\n\n\t\t// Ensure the message cannot be replayed\n        userNonces[account] = userNonces[account].add(1);\n\n\t\tfor (uint256 i = 0; i < userVotePayload.allocations.length; i++) {\n\t\t\tbytes32 reactorKey = userVotePayload.allocations[i].reactorKey;\n\t\t\tuint256 amount = userVotePayload.allocations[i].amount; \n\n            //Ensure where they are voting is allowed\n\t\t\t//require(allowedreactorKeys.contains(reactorKey),  \"PLACEMENT_NOT_ALLOWED\"); \n\n            // check if user has already voted for this reactor\n\t\t\tif (userVoteItems[account][reactorKey]>0){\n\t\t\t\tif (amount ==0){\n\t\t\t\t\t_removeUserVoteKey(account, reactorKey);\n\t\t\t\t}\n\n\t\t\t\tuint256 currentAmount = userVoteItems[account][reactorKey];\n\n            }\n\n            else{\n                \n\t\t\t\tif(amount>0){\n\t\t\t\t\tuserVoteKeys[account].push(reactorKey);\n\t\t\t\t\tuserVoteItems[account][reactorKey] = amount; \n\t\t\t\t\tsystemAggregations[reactorKey] = systemAggregations[reactorKey].add(amount);\n\t\t\t\t\ttotalUsedVotes = totalUsedVotes.add(amount);\n\t\t\t\t}\n\n            }\n\n\t\t\t\n\t\t}\n\n        console.log('totalusedvotes',totalUsedVotes,  userVotePayload.totalVotes);\n\t\trequire(totalUsedVotes == userVotePayload.totalVotes, \"VOTE_TOTAL_MISMATCH\");\n\n        uint256 totalAvailableVotes = getMaxVoteBalance(account);\n     //   require(totalUsedVotes <= totalAvailableVotes, \"NOT_ENOUGH_VOTES\");\n\n        userVoteDetails[account] = UserVoteDetails({\n        \ttotalUsedVotes: totalUsedVotes,\n            totalAvailableVotes: totalAvailableVotes\n        \t}); \n\n\n\n\t}\n\n\n\n    function getMaxVoteBalance(address account) public view returns (uint256) {\n    \tuint256 dssbalance = dss.balanceOf(account); \n\n        return _getVotingPower(dssbalance);\n    }\n\n    function _getVotingPower(uint256 balance) private view returns (uint256) {\n\t\treturn balance; \n    }\n\n\n    //get vote for one borrower \n    function getVotes(bytes32 reactorKey) public view returns (uint256){\n        return systemAggregations[reactorKey]; \n    }\n\n\n}"
    },
    "contracts/stablecoin/DSS.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\nimport \"../ERC20/ERC20Custom.sol\";\nimport \"../Common/AccessControl.sol\";\nimport \"../Common/Ownable.sol\";\n\ncontract DSS is ERC20Custom, AccessControl, Ownable {\n    /* ========== STATE VARIABLES ========== */\n    \n    address[] public pools_array;\n    mapping(address => bool) pools;\n    \n    address public creator_address;\n    address timelock_address;\n    address public DEFAULT_ADMIN_ADDRESS;\n    uint256 constant genesis_supply = 1000000e18;\n\n    \n    /* ========== MODIFIERS ========== */\n    modifier onlyPools() {\n        require(pools[msg.sender] == true, \"Only pools can call this function\");\n        _;\n    }\n\n    constructor (\n        address _creator_address,\n        address _timelock_address\n    )  ERC20Custom(\"Debita Stablecoin Share\",\"DSS\") Ownable(_creator_address)\n    {\n        _mint(_creator_address, genesis_supply);\n        creator_address = _creator_address;\n        timelock_address = _timelock_address;\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n        DEFAULT_ADMIN_ADDRESS = _msgSender();\n        _grantRole(DEFAULT_ADMIN_ROLE, _creator_address);\n    }\n\n    function addPool(address pool_address) public onlyOwner {\n        require(pool_address != address(0), \"Zero address detected\");\n\n        require(pools[pool_address] == false, \"Address already exists\");\n        pools[pool_address] = true; \n        pools_array.push(pool_address);\n\n        //emit PoolAdded(pool_address);\n    }\n    \n    // Used by pools when user redeems\n    function pool_burn(address b_address, uint256 b_amount) public onlyPools {\n        super._burn(b_address, b_amount);\n    }\n\n    function pool_mint(address m_address, uint256 m_amount) public onlyPools {\n        super._mint(m_address, m_amount);\n    }\n\n    function dss_price() public view returns(uint256){\n        return 1e6; \n    }\n\n    function get_collateral_ratio() public view returns(uint256){\n        return 1e6;\n    }\n}"
    },
    "contracts/ERC20/ERC20Custom.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\n\nimport \"./IERC20.sol\";\nimport \"../Common/Context.sol\";\n\ncontract ERC20Custom is Context, IERC20 {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 6;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}"
    },
    "contracts/Common/AccessControl.sol": {
      "content": "pragma solidity ^0.8.4;\n\nimport \"./IAccessControl.sol\";\nimport \"./Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(account),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}"
    },
    "contracts/Common/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.4;\n\nimport \"./Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor(address creator_address) {\n        _transferOwnership(creator_address);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}"
    },
    "contracts/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.4;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}"
    },
    "contracts/Common/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.4;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}"
    },
    "contracts/Common/IAccessControl.sol": {
      "content": "pragma solidity ^0.8.4;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}"
    },
    "contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\n\npragma solidity ^0.8.4;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}"
    },
    "contracts/utils/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.4;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}"
    },
    "contracts/utils/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.4;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}"
    },
    "contracts/stablecoin/controller.sol": {
      "content": "pragma solidity ^0.8.4;\nimport \"../rewards/MasterChef.sol\";\nimport \"./ILendingPool.sol\";\nimport \"./IController.sol\";\nimport \"../turbo/TrustedMarketFactoryV3.sol\";\nimport \"hardhat/console.sol\";\n//Controller contract responsible for providing initial liquidity to the\n//borrower cds market, collect winnings when default, and burn the corresponding DS\ncontract Manager is IController {\n    using SafeMath for uint256;\n\n    struct LiquidityInfo {\n    \tuint256 lptokenamount;\n    \tuint256 suppliedDS; \n    }\n\n    mapping(address => bool) validators; \n    mapping(address => bool) pools; \n\n    mapping(address => mapping(uint256=> LiquidityInfo)) lpinfo; \n\n    address[] validators_array; \n    address[] pools_array;\n\n    address creator_address; \n    address timelock_address;\n    address MasterChef_address;\n\n    MasterChef masterchef; \n    ILendingPool lendingpool; \n\n    /* ========== MODIFIERS ========== */\n    modifier onlyValidator() {\n        require(validators[msg.sender] == true, \"Only Validators can call this function\");\n        _;\n    }\n\n    modifier onlyPools() {\n        require(pools[msg.sender] == true, \"Only Pools can call this function\");\n        _;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == creator_address, \"Only Pools can call this function\");\n        _;\n    }\n    constructor (\n        address _creator_address,\n        address _timelock_address,\n        address _MasterChef_address, \n        address _LendingPool_address, \n        address _DS_address\n    )   \n    {   // _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n        // DEFAULT_ADMIN_ADDRESS = _msgSender();\n        // _grantRole(DEFAULT_ADMIN_ROLE, _creator_address);\n        creator_address = _creator_address;\n        MasterChef_address=_MasterChef_address;\n\n        masterchef = MasterChef(_MasterChef_address);\n        lendingpool = ILendingPool(_LendingPool_address); \n        // IERC20Full DScontract = DS(_DS_address);\n\n    } \n\n    //Pool added when contract is deployed \n    function addPool(address pool_address) external override onlyOwner {\n        require(pool_address != address(0), \"Zero address detected\");\n        require(pools[pool_address] == false, \"Address already exists\");\n\n        pools[pool_address] = true; \n        pools_array.push(pool_address);\n\n    }\n\n    //Validator should be added for each borrower\n    function addValidator(address validator_address) external override onlyPools {\n        require(validator_address != address(0), \"Zero address detected\");\n        require(validators[validator_address] == false, \"Address already exists\");\n\n        validators[validator_address] = true; \n        validators_array.push(validator_address);\n\n    }\n\n    //provide initial liquidity when market is created\n    //allow lendingpool to mint DS to controller address, \n    //liquidityAmountUSD determines how much IL loss Debita is willing to take,\n    //which depends on interest rate proposed + principal value of borrowers \n    //It will be computed offchain for now\n    function initiateMarket(address ammFactoryAddress,\n             address marketFactoryAddress, uint256 liquidityAmountUSD,\n             string calldata description, string[] calldata names, \n             uint256[] calldata odds ) external override onlyValidator {\n\n        AMMFactory amm = AMMFactory(ammFactoryAddress);\n        TrustedMarketFactoryV3 marketFactory = TrustedMarketFactoryV3(marketFactoryAddress);\n\n        //TODO change create market modifier to including validators \n        uint256 marketID = marketFactory.createMarket(msg.sender, description, names, odds);\n\n        //Minting DS\n        lendingpool.controllerMintDS(liquidityAmountUSD); \n        marketFactory.collateral().approve(address(masterchef), liquidityAmountUSD);\n\n        //Creating pool and adding minted DS as liquidity to the created market \n        masterchef.createPool(amm, marketFactory, marketID, liquidityAmountUSD, address(this));\n        uint256 pooltokenamount = masterchef.getPoolTokenBalance(amm, marketFactory, marketID,\n        address(this) );\n       \n        LiquidityInfo memory info = LiquidityInfo({\n            lptokenamount: pooltokenamount, \n            suppliedDS: liquidityAmountUSD\n            }); \n\n        lpinfo[marketFactoryAddress][marketID] = info; \n\n\n    }\n\n\n    //Ends market when default occurs OR all loan is payed \n    //first withdraw all liquidity\n    //Then if default, handle default \n    //If not default, handle not default-> just burn \n    //Market is first resolved, and winning outcome is determined before this funciton is called \n    function resolveMarket(address ammFactoryAddress, \n    \taddress marketFactoryAddress, uint256 marketID, bool isDefault) external override onlyValidator{\n        uint256 _collateralOut;\n        uint256[] memory _balances; \n    \t\n    \tAMMFactory amm = AMMFactory(ammFactoryAddress);\n    \tTrustedMarketFactoryV3 marketFactory = TrustedMarketFactoryV3(marketFactoryAddress);\n    \tuint256 lptokensIn = lpinfo[marketFactoryAddress][marketID].lptokenamount; \n\n        uint256 winning_outcome = isDefault? 0: 1; \n        marketFactory.trustedResolveMarket( marketID, winning_outcome); \n        //require(marketFactory.isMarketResolved(marketID), \"Market is not resolved\"); \n\n    \t(_collateralOut, _balances) = masterchef.removeLiquidity(amm, \n    \t\t\t\t\t\t\t\tmarketFactory,\n    \t\t\t\t\t\t\t\tmarketID, lptokensIn, 0, address(this)\n    \t\t\t\t\t\t\t\t );\n\n        uint256 initialSuppliedDS = lpinfo[marketFactoryAddress][marketID].suppliedDS; \n\n        if (isDefault){\n            require(_collateralOut > initialSuppliedDS, \"Payout not sufficient\"); \n        }\n\n        //Whether initial supplied DS is greater or less than payout, they need to be all burned\n        //if greater, IL loss is transferred to shortCDS buyers, \n        //if less, then short cds buyer's collateral is used as payout\n        lendingpool.controllerBurnDS(_collateralOut); \n\n\n        console.log(initialSuppliedDS, _collateralOut); \n\n\n\n    }\n\n    function approveLoan(address recipient, string calldata id) external onlyValidator{\n        lendingpool.approveLoan(recipient, id); \n    }\n\n\n//resolve market fix, resolve market, add borrower\n    //Market needs to be resolved and DS liquidity withdrawn before being called, \n    //withdrawn liquidity should be GREATER than initially supplied liquidity, \n    //which will be burnt from circulation\n    // function handleDefault(address marketFactoryAddress, uint256 marketID, uint256 payout) internal{\n    // \tAbstractMarketFactoryV3 marketFactory = AbstractMarketFactoryV3(marketFactoryAddress);\n\n        \n    //     uint256 initialSuppliedDS = lpinfo[marketFactoryAddress][marketID].liquidityAmountUSD; \n    //     require(payout > initialSuppliedDS, \"Payout not sufficient\"); \n\n    //     lendingpool.controllerBurnDS(payout); \n\n\n\n\n    // }\n\n    //\n    // function handleNoDefault(address marketFactoryAddress, uint256 marketID) internal{\n    // \tAbstractMarketFactoryV3 marketFactory = AbstractMarketFactoryV3(marketFactoryAddress);\n    // \t//supplieedDS-withdrawn liquidity is the impermanent loss, given to the \n    // \t//short CDS holders in the form of a premium, \n\n\n    // \tburn()\n\n    // }    //When default,need to collect longCDS winnings from the market \n    // function collectWinnings() internal {\n\n\n    // }\n\n}"
    },
    "contracts/stablecoin/ILendingPool.sol": {
      "content": "pragma solidity ^0.8.4;\n\ninterface ILendingPool{\n    struct LoanMetadata {\n        bytes32 id;\n        uint256 principal; \n        uint256 totalDebt;\n        uint256 duration;\n        uint256 repaymentDate;\n        uint256 amountRepaid;\n        string description;\n        bool approved;\n    }\n\n    struct LoanData{\n        uint256 _total_borrowed_amount; \n        uint256 _accrued_interest; \n    }\n    function mintDS(uint256 collateral_amount, uint256 DS_out_min) external;\n    function redeemDS(uint256 DS_amount, uint256 DSS_out_min, uint256 COLLATERAL_out_min) external;\n    function collectRedemption(uint256 col_idx) external returns (uint256 dss_amount, uint256 collateral_amount) ;\n    function setPoolParameters(uint256 new_ceiling, uint256 new_bonus_rate, uint256 new_redemption_delay, uint256 new_mint_fee, uint256 new_redeem_fee, uint256 new_buyback_fee, uint256 new_recollat_fee) external;\n    function setController(address controller) external;\n    function controllerMintDS(uint256 amount) external;\n    function controllerBurnDS(uint256 amount) external;\n    function addValidator(address validator, address controller) external;\n    function registerBorrower() external;\n    function deregisterBorrower(address borrower) external;\n    function addProposal(string calldata _id, uint256 _principal, uint256 _duration, uint256 _totalDebt, string calldata _description) external;\n    function removeProposal(string calldata id) external returns (bool); // called by recipient\n    function removeProposal(address recipient, string calldata id) external returns (bool);\n    function approveLoan(address recipient, string calldata id) external returns (bool);\n    function borrow(uint256 amount) external;\n    function repay(uint256 repay_principal, uint256 repay_interest, string calldata loan_id) external returns (bool);\n    function addressCheckDefault(address recipient) external;\n    function fullDefaultCheck() external;\n    function getLoanData() external returns(LoanData memory);\n    function is_borrower(address addr) external returns (bool);\n    function is_registered(address addr) external returns (bool);\n    function retrieveLoan(address borrower, string calldata id) external returns (LoanMetadata memory);\n    function borrower_allowance(address addr) external returns (uint256);\n    function borrower_debt(address addr) external returns (uint256);\n    function num_loans(address addr) external returns (uint256);\n    function num_proposals(address addr) external returns (uint256);\n} "
    },
    "contracts/stablecoin/IController.sol": {
      "content": "pragma solidity ^0.8.4;\n\n\n//controller contract responsible for providing initial liquidity to the\n//borrower cds market, collect winnings when default, and burn the corresponding DS\ninterface IController  {\n    \n    function addPool(address pool_address) external;\n\n    function addValidator(address validator_address) external;\n\n    function initiateMarket(address ammFactoryAddress,\n             address marketFactoryAddress, uint256 liquidityAmountUSD,\n             string calldata description, string[] calldata names, \n             uint256[] calldata odds) external ;\n\n\n    function resolveMarket(address ammFactoryAddress, \n    \taddress marketFactoryAddress, uint256 marketID, bool isDefault) external; \n\n}"
    },
    "contracts/stablecoin/lendingpool.sol": {
      "content": "pragma solidity ^0.8.4;\n\nimport \"./owned.sol\";\nimport \"./DS.sol\"; \nimport \"./DSS.sol\"; \nimport \"./TransferHelper.sol\";\nimport \"../ERC20/IERC20.sol\";\nimport \"../ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"hardhat/console.sol\";\nimport \"./ILendingPool.sol\";\nimport \"./IController.sol\";\n\n//borrowers borrow and repay from this lendingpool \ncontract LendingPool is ILendingPool, Owned {\n\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    address ds_address; \n    address dss_address; \n    address collateral_address; \n    address creator_address; \n    address timelock_address; \n\n\n    uint256 pool_ceiling;\n    uint256 bonus_rate;\n    uint256 redemption_delay;\n    uint256 minting_fee;\n    uint256 redemption_fee;\n    uint256 buyback_fee;\n    uint256 recollat_fee;\n    uint256 missing_decimals; \n\n    uint256 private constant PRICE_PRECISION = 1e6;\n\n    DS private DScontract;\n    DSS private DSScontract;\n\n    mapping (address => uint256) public redeemDSSBalances;\n    mapping (address => uint256) public redeemCollateralBalances;\n    uint256 public unclaimedPoolCollateral;\n    uint256 public unclaimedPoolDSS;\n    mapping (address => uint256) public lastRedeemed;\n\n    //Borrowers Variable \n\n    mapping(address=>bool) public override is_borrower;\n    mapping(address=>bool) public override is_registered;\n    mapping(address=>uint256) public override borrower_allowance; \n    mapping(address=>uint256) public override borrower_debt; \n    address[] public borrowers_array;\n    mapping(address=>LoanMetadata[]) public current_loan_data;\n    mapping(address => uint256) public override num_loans;\n    mapping(address => uint256) public override num_proposals;\n    uint256 immutable MAX_LOANS = 1;\n    uint256 immutable MAX_PROPOSALS = 1;\n\n    uint256 total_borrowed_amount;\n    uint256 immutable public proposal_fee;\n    uint256 accrued_interest;\n\n    // controller\n    address private controller_address;\n\n    modifier onlyByOwnGov() {\n        require(msg.sender == timelock_address || msg.sender == owner, \"Not owner or timelock\");\n        _;\n    }\n\n    modifier onlyController(){\n        require(controller_address == msg.sender, \"is not controller\"); \n        _;\n    }\n\n    modifier onlyBorrower(){\n        require(is_borrower[msg.sender], \"is not borrower\"); \n        _;\n\n    }\n\n    modifier onlyRegistered {\n        require(is_registered[msg.sender], \"is not registered\");\n        _;\n    }\n\n    constructor (\n        address _ds_address,\n        address _dss_address,\n        address _collateral_address,\n        address _creator_address,\n        address _timelock_address\n        // address _controller_address\n    ) public Owned(_creator_address){\n        require(\n            (_ds_address != address(0))\n            && (_dss_address != address(0))\n            && (_collateral_address != address(0))\n            && (_creator_address != address(0))\n            && (_timelock_address != address(0))\n            //&& (_controller_address != address(0))\n        , \"Zero address detected\"); \n\n        DScontract = DS(_ds_address);\n        DSScontract = DSS(_dss_address); \n        ds_address = _ds_address; \n        dss_address = _dss_address; \n        collateral_address = _collateral_address; \n        creator_address = _creator_address; \n\n        timelock_address = _timelock_address;\n        // controller_address = _controller_address;\n        //missing_decimals = uint(6).sub(collateral_token.decimals());\n        missing_decimals = uint(0);\n        proposal_fee = 1e19;\n        \n    }\n\n    //Currently ds decimals is 6, same as USDC, so collateral amount should also be decimal 6\n    function mintDS(uint256 collateral_amount, uint256 DS_out_min) external override {\n        uint256 collateral_amount_d18 = collateral_amount * (10 ** missing_decimals);\n      \n        uint256 DS_amount_18 = collateral_amount_d18; //1to1\n        DS_amount_18 = (DS_amount_18.mul(uint(1e6).sub(minting_fee))).div(uint(1e6));\n        require(DS_out_min <= DS_amount_18); \n\n        IERC20(collateral_address).safeTransferFrom(msg.sender, address(this), collateral_amount);\n        //TransferHelper.safeTransferFrom(collateral_address, msg.sender, address(this), collateral_amount);\n        DScontract.pool_mint(msg.sender, DS_amount_18);\n        \n    }\n\n\n    function redeemDS(uint256 DS_amount, uint256 DSS_out_min, uint256 COLLATERAL_out_min) external override {\n        uint256 dss_price = DScontract.dss_price();\n        uint256 collateral_ratio = DScontract.get_collateral_ratio(); \n        uint256 DS_amount_18 = DS_amount.mul(10**missing_decimals);\n\n        uint256 DS_amount_post_fee = (DS_amount.mul(uint(1e6).sub(redemption_fee))).div(uint(1e6)); \n        uint256 dss_dollar_value = DS_amount_post_fee.sub(DS_amount_post_fee.mul(collateral_ratio).div(PRICE_PRECISION)); \n        uint256 dss_amount = dss_dollar_value.mul(PRICE_PRECISION).div(dss_price); \n\n        uint256 DS_amount_precision = DS_amount_post_fee;\n        uint256 collateral_dollar_value = DS_amount_precision.mul(collateral_ratio).div(PRICE_PRECISION);\n        uint256 collateral_amount = collateral_dollar_value;//.mul(10**missing_decimals); //for now assume collateral is stable \n\n        redeemCollateralBalances[msg.sender] = redeemCollateralBalances[msg.sender].add(collateral_amount);\n        unclaimedPoolCollateral = unclaimedPoolCollateral.add(collateral_amount);\n\n        redeemDSSBalances[msg.sender] = redeemDSSBalances[msg.sender].add(dss_amount);\n        unclaimedPoolDSS = unclaimedPoolDSS.add(dss_amount);\n\n        lastRedeemed[msg.sender] = block.number; \n        DScontract.pool_burn(msg.sender, DS_amount_18);\n        DSScontract.pool_mint(address(this), dss_amount);\n\n\n\n    }\n\n    function collectRedemption(uint256 col_idx) external override returns (uint256 dss_amount, uint256 collateral_amount) {\n        // require(redeemPaused[col_idx] == false, \"Redeeming is paused\");\n        // require((lastRedeemed[msg.sender].add(redemption_delay)) <= block.number, \"Too soon\");\n        bool sendDSS = false; \n        bool sendCollateral = false; \n\n        if (redeemDSSBalances[msg.sender]>0){\n            dss_amount = redeemDSSBalances[msg.sender]; \n            redeemDSSBalances[msg.sender] = 0; \n            unclaimedPoolDSS = unclaimedPoolDSS.sub(dss_amount); \n            sendDSS = true;\n        }\n\n        if (redeemCollateralBalances[msg.sender]>0){\n            collateral_amount = redeemCollateralBalances[msg.sender]; \n            redeemCollateralBalances[msg.sender] = 0; \n            unclaimedPoolCollateral = unclaimedPoolCollateral.sub(collateral_amount);\n            sendCollateral = true;\n        }\n\n        if (sendDSS){\n            //TransferHelper.safeTransfer(address(DSScontract), msg.sender, dss_amount);\n            IERC20(address(DSScontract)).safeTransfer(msg.sender, dss_amount);\n        }\n\n        if (sendCollateral){\n            //TransferHelper.safeTransfer(collateral_address, msg.sender, collateral_amount);\n            IERC20(address(collateral_address)).safeTransfer(msg.sender, collateral_amount);\n        }\n\n    }\n\n    function setPoolParameters(uint256 new_ceiling, uint256 new_bonus_rate, uint256 new_redemption_delay, uint256 new_mint_fee, uint256 new_redeem_fee, uint256 new_buyback_fee, uint256 new_recollat_fee) external override onlyByOwnGov {\n        pool_ceiling = new_ceiling;\n        bonus_rate = new_bonus_rate;\n        redemption_delay = new_redemption_delay;\n        minting_fee = new_mint_fee;\n        redemption_fee = new_redeem_fee;\n        buyback_fee = new_buyback_fee;\n        recollat_fee = new_recollat_fee;\n\n        //emit PoolParametersSet(new_ceiling, new_bonus_rate, new_redemption_delay, new_mint_fee, new_redeem_fee, new_buyback_fee, new_recollat_fee);\n    }\n\n    //Controller Functions\n\n    function setController(address controller) external override onlyByOwnGov{\n        controller_address = controller; \n    }\n\n    function controllerMintDS(uint256 amount) external override onlyController {\n        DScontract.pool_mint(msg.sender, amount);\n\n    }\n\n    function controllerBurnDS(uint256 amount) external override onlyController {\n        DScontract.pool_burn(msg.sender, amount);\n\n    }\n\n    //TODO external for now, but needs to be internal+called when borrower proposes\n    function addValidator(address validator, address controller) external override {\n        IController(controller).addValidator(validator);\n    }\n\n        // registration\n    function registerBorrower() external override {\n        require(!is_registered[msg.sender], \"already paid proposal fee\");\n        require(IERC20(collateral_address).balanceOf(msg.sender) >= proposal_fee && IERC20(collateral_address).allowance(msg.sender, address(this)) >= proposal_fee, \"no allowance\");\n        //TransferHelper.safeTransferFrom(address(collateral_address), msg.sender, address(this), proposal_fee);\n        IERC20(collateral_address).safeTransferFrom(msg.sender, address(this), proposal_fee);\n        is_registered[msg.sender] = true;\n    }\n\n    function deregisterBorrower(address borrower) onlyByOwnGov public override {\n        require(is_registered[borrower], \"borrower not registered\");\n        is_registered[borrower] = false;\n    }\n\n    // loan proposal\n    function addProposal(\n        string calldata _id,\n        uint256 _principal,\n        uint256 _duration,\n        uint256 _totalDebt,\n        string calldata _description\n    ) external  override {\n        require(num_proposals[msg.sender] < MAX_PROPOSALS, \"proposal limit reached\");\n        bytes32 hashed_id = keccak256(abi.encodePacked(_id));\n        for (uint i = 0; i < num_proposals[msg.sender]; i++) {\n            require(current_loan_data[msg.sender][i].id != hashed_id, \"Loan ID must be unique\");\n        }\n\n        num_proposals[msg.sender]++;\n\n        current_loan_data[msg.sender].push(LoanMetadata({\n            id: hashed_id,\n            principal: _principal,\n            totalDebt: _totalDebt,\n            duration: _duration,\n            amountRepaid: 0,\n            description: _description,\n            approved: false,\n            repaymentDate: 0\n        }));\n        emit LoanProposal(msg.sender, _id);\n    }\n\n    function removeProposal(string calldata id) onlyRegistered external override returns (bool) {\n        return _removeProposal(msg.sender, keccak256(abi.encodePacked(id)));\n    }\n\n    function removeProposal(address recipient, string calldata id) onlyByOwnGov external override returns (bool) {\n        return _removeProposal(recipient, keccak256(abi.encodePacked(id)));\n    }\n\n    function _removeProposal(address recipient, bytes32 id) internal returns (bool) {\n        for (uint i = 0; i < num_proposals[recipient]; i++) {\n            if (id == current_loan_data[recipient][i].id){\n                emit LoanProposalRemoval(recipient, current_loan_data[recipient][i]);\n                _removeLoan(recipient, i);\n                num_proposals[recipient]--;\n                // delete CDS Market here???\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function _removeLoan(address addr, uint i) private {\n        require(i < current_loan_data[addr].length, \"invalid array index\");\n        uint256 terminal_index = current_loan_data[addr].length - 1;\n        current_loan_data[addr][i] = current_loan_data[addr][terminal_index];\n        current_loan_data[addr].pop();\n    }\n\n    function retrieveLoan(address borrower, string calldata id) public view override returns (LoanMetadata memory) {\n        bytes32 hashed_id = keccak256(abi.encodePacked(id));\n        for (uint i = 0; i < current_loan_data[borrower].length; i++) {\n            if (hashed_id == current_loan_data[borrower][i].id) {\n                return current_loan_data[borrower][i];\n            }\n        }\n        revert(\"loan not found\");\n    }\n\n    // called by controller\n    function approveLoan(address recipient, string calldata id) onlyController public override returns (bool) {\n        require(num_loans[recipient] < MAX_LOANS, \"max number of loans reached\");\n        bytes32 hashed_id = keccak256(abi.encodePacked(id));\n        for (uint i = 0; i < current_loan_data[recipient].length; i++) {\n            if (hashed_id == current_loan_data[recipient][i].id) {\n                require(!current_loan_data[recipient][i].approved, \"loan already approved\");\n                LoanMetadata storage loan = current_loan_data[recipient][i];\n                emit LoanApproval(recipient, current_loan_data[recipient][i]);\n                loan.approved = true;\n                loan.repaymentDate = block.timestamp + loan.duration;\n                \n                if (!is_borrower[recipient]) {\n                    is_borrower[recipient] = true;\n                    borrowers_array.push(recipient);\n                }\n                \n                num_loans[recipient]++;\n                num_proposals[recipient]--;\n                borrower_allowance[recipient] += loan.principal;\n                borrower_debt[recipient] += loan.principal;\n                return true;\n            }\n        }\n        return false; \n    }\n\n    function removeBorrower(address borrower) private {\n        uint length = borrowers_array.length;\n        for (uint i = 0; i < length; i++) {\n            if (borrower == borrowers_array[i]) {\n                borrowers_array[i] = borrowers_array[length - 1];\n                borrowers_array.pop();\n            }\n        }\n    }\n\n\n    function borrow(uint256 amount) external onlyBorrower onlyRegistered override {\n        require(amount <= borrower_allowance[msg.sender], \"Exceeds borrow allowance\");\n        require(amount > 0, \"amount must be greater than 0\");\n        \n        borrower_allowance[msg.sender] = borrower_allowance[msg.sender].sub(amount);\n        TransferHelper.safeTransfer(collateral_address, msg.sender, amount);\n        borrower_debt[msg.sender] = borrower_debt[msg.sender].add(amount);\n        total_borrowed_amount = total_borrowed_amount.add(amount);\n        emit FundsBorrowed(msg.sender, amount);\n    }\n\n    function repay(uint256 repay_principal, uint256 repay_interest, string calldata loan_id) external onlyBorrower override returns (bool) {\n        uint256 total_repayment = repay_principal.add(repay_interest);\n        bytes32 hashed_id = keccak256(abi.encodePacked(loan_id));\n        for (uint i = 0; i< current_loan_data[msg.sender].length; i++) {\n            if (hashed_id == current_loan_data[msg.sender][i].id) {\n                LoanMetadata storage loan = current_loan_data[msg.sender][i];\n                require(loan.amountRepaid + total_repayment <= loan.principal, \"overpaid for specified loan\");\n\n                loan.amountRepaid += total_repayment;\n                borrower_debt[msg.sender] = borrower_debt[msg.sender].sub(repay_principal);\n                accrued_interest.add(repay_interest);\n                console.log('total_borrowed_amount', total_borrowed_amount);\n                total_borrowed_amount = total_borrowed_amount.sub(repay_principal);\n\n                TransferHelper.safeTransferFrom(collateral_address, msg.sender, address(this), total_repayment); \n                if (loan.amountRepaid == loan.totalDebt) {\n                    emit FullRepayment(msg.sender, loan);\n                    // do something w/ cds here.\n                    num_loans[msg.sender]--;\n                    _removeLoan(msg.sender, i);\n                    if (num_loans[msg.sender] == 0) {\n                        is_borrower[msg.sender] = false;\n                        removeBorrower(msg.sender);\n                    }\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n\n    // restrictions on acccess?\n    function fullDefaultCheck() public override {\n        for (uint i = 0; i < borrowers_array.length; i++) {\n            address borrower = borrowers_array[i];\n            LoanMetadata[] storage loans = current_loan_data[borrower];\n            uint length = loans.length;\n            for (uint j = 0; j < length; j++) {\n                checkDefault(borrower, j);\n            }\n        }   \n    }\n\n    function checkDefault(address recipient, uint256 index) private {\n        if (current_loan_data[recipient][index].repaymentDate < block.timestamp) {\n            emit Default(recipient, current_loan_data[recipient][index]);\n            num_loans[recipient]--;\n            // default logic handler => resolve cds market (loan id => marketID)\n        }\n    }\n\n    // restrictions on access?\n    function addressCheckDefault(address recipient) public override {\n        for (uint i = 0; i < current_loan_data[recipient].length; i++) {\n            checkDefault(recipient, i);\n        }\n    }\n\n    function getLoanData() public view override returns(LoanData memory){\n        LoanData memory loandata = LoanData({\n            _total_borrowed_amount: total_borrowed_amount, \n            _accrued_interest : accrued_interest\n            });\n        return loandata;\n    }\n\n    event LoanProposal(address indexed recipient, string loan_id);\n    event LoanApproval(address indexed recipient, LoanMetadata loan);\n    event FullRepayment(address indexed recipient, LoanMetadata loan);\n    event Default(address indexed defaultor, LoanMetadata loan);\n    event LoanProposalRemoval(address indexed recipient, LoanMetadata loan);\n    event FundsBorrowed(address indexed recipient, uint256 amount);\n}"
    },
    "contracts/stablecoin/owned.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.4;\n\n// https://docs.synthetix.io/contracts/Owned\ncontract Owned {\n    address public owner;\n    address public nominatedOwner;\n\n    constructor (address _owner) public {\n        require(_owner != address(0), \"Owner address cannot be 0\");\n        owner = _owner;\n        emit OwnerChanged(address(0), _owner);\n    }\n\n    function nominateNewOwner(address _owner) external onlyOwner {\n        nominatedOwner = _owner;\n        emit OwnerNominated(_owner);\n    }\n\n    function acceptOwnership() external {\n        require(msg.sender == nominatedOwner, \"You must be nominated before you can accept ownership\");\n        emit OwnerChanged(owner, nominatedOwner);\n        owner = nominatedOwner;\n        nominatedOwner = address(0);\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner, \"Only the contract owner may perform this action\");\n        _;\n    }\n\n    event OwnerNominated(address newOwner);\n    event OwnerChanged(address oldOwner, address newOwner);\n}"
    },
    "contracts/stablecoin/DS.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../ERC20/ERC20Custom.sol\";\nimport \"../Common/AccessControl.sol\";\nimport \"../Common/Ownable.sol\";\n\ncontract DS is ERC20Custom, AccessControl, Ownable {\n    /* ========== STATE VARIABLES ========== */\n    \n    mapping(address => bool) pools;\n    \n    address[] public pools_array;\n    address public creator_address;\n    address timelock_address;\n    address public DEFAULT_ADMIN_ADDRESS;\n    \n    uint256 constant genesis_supply = 1000000e18;\n\n    \n    /* ========== MODIFIERS ========== */\n    modifier onlyPools() {\n        require(pools[msg.sender] == true, \"Only pools can call this function\");\n        _;\n    }\n\n    /* ========== CONSTRUCTOR ========== */\n    constructor (\n        address _creator_address,\n        address _timelock_address\n    )  ERC20Custom(\"Debita Stablecoin\",\"DS\") Ownable(_creator_address)\n    {\n        _mint(_creator_address, genesis_supply);\n        creator_address = _creator_address;\n        timelock_address = _timelock_address;\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n        DEFAULT_ADMIN_ADDRESS = _msgSender();\n        _grantRole(DEFAULT_ADMIN_ROLE, _creator_address);\n    }\n\n    function addPool(address pool_address) public onlyOwner {\n        require(pool_address != address(0), \"Zero address detected\");\n\n        require(pools[pool_address] == false, \"Address already exists\");\n        pools[pool_address] = true; \n        pools_array.push(pool_address);\n    }\n    \n    // Used by pools when user redeems\n    function pool_burn(address b_address, uint256 b_amount) public onlyPools {\n        super._burn(b_address, b_amount);\n    }\n\n    function pool_mint(address m_address, uint256 m_amount) public onlyPools {\n        super._mint(m_address, m_amount);\n    }\n\n    function dss_price() public view returns(uint256){\n        return 1e6; \n    }\n\n    function get_collateral_ratio() public view returns(uint256){\n        return 1e6;\n    }\n}"
    },
    "contracts/stablecoin/TransferHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper {\n    function safeApprove(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n    }\n\n    function safeTransfer(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n    }\n\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n    }\n\n    function safeTransferETH(address to, uint value) internal {\n        (bool success,) = to.call{value:value}(new bytes(0));\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\n    }\n}"
    },
    "contracts/ERC20/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.4;\n\nimport \"./IERC20.sol\";\nimport \"./draft-IERC20Permit.sol\";\nimport \"../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}"
    },
    "contracts/ERC20/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.4;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}"
    },
    "contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.4;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n    // function isContract(address account) internal view returns (bool) {\n    //     // This method relies on extcodesize, which returns 0 for contracts in\n    //     // construction, since the code is only stored at the end of the\n    //     // constructor execution.\n\n    //     uint256 size;\n    //     // solhint-disable-next-line no-inline-assembly\n    //     assembly { size := extcodesize(account) }\n    //     return size > 0;\n    // }\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}"
    },
    "contracts/staking/stakingpool.sol": {
      "content": "pragma solidity ^0.8.4;\n\nimport \"../stablecoin/DS.sol\"; \nimport \"../stablecoin/owned.sol\";\nimport \"../stablecoin/TransferHelper.sol\";\n\nimport \"./stakedDS.sol\";\nimport \"../ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n//import \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n\ncontract StakingPool is Owned{\n\n\n    using SafeMath for uint256;\n\n    address ds_address; \n    address collateral_address; \n    address creator_address; \n\n    ERC20 private collateral_token;\n    DS private DScontract;\n    sDS private sDScontract;\n\n    uint256 missing_decimals; \n\n   mapping(address=>bool)  userStaked; \n   constructor (\n        address _ds_address,\n        address _collateral_address,\n        address _creator_address,\n\n        address _sDS_address\n        \n    ) public Owned(_creator_address){\n        require(\n            (_ds_address != address(0))\n            && (_collateral_address != address(0))\n            && (_creator_address != address(0))\n        , \"Zero address detected\"); \n        DScontract = DS(_ds_address);\n        sDScontract = sDS(_sDS_address);\n        collateral_token = ERC20(_collateral_address); \n\n        ds_address = _ds_address; \n        collateral_address = _collateral_address; \n        creator_address = _creator_address; \n\n    \n        missing_decimals = uint(18).sub(collateral_token.decimals());\n        \n        \n    }\n\tfunction stake(uint256 amount) public virtual{\n\t\tuint256 exchange_rate = get_exchange_rate();\n        TransferHelper.safeTransferFrom(address(ds_address), msg.sender, address(sDScontract), amount);\n        sDScontract.mint(msg.sender, amount, exchange_rate); \n\n        userStaked[msg.sender] = true; \n\n\n\t}\n\n\tfunction withdraw(uint256 amount) public virtual{\n\t\tuint256 exchange_rate = get_exchange_rate();\n\n\t\tsDScontract.burn(msg.sender, amount, exchange_rate);\n\n\t\tif (sDScontract.balanceOf(msg.sender) == 0){\n\t\tuserStaked[msg.sender] = false; \n\t\t}\n\n\n\t}\n\tfunction get_exchange_rate() private returns(uint256){\n\t\treturn 1e6; \n\t}\n}"
    },
    "contracts/staking/stakedDS.sol": {
      "content": "pragma solidity ^0.8.4;\n\n//import \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"../ERC20/ERC20.sol\";\nimport \"../stablecoin/owned.sol\";\nimport \"../stablecoin/TransferHelper.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n//import \"../stablecoin/safemath.sol\";\n\n\ncontract sDS is ERC20, Owned {\n\n  mapping(address => bool) pools;\n   using SafeMath for uint256;\n\n  address[] public pools_array;\n  address deployer_address; \n  address timelock_address; \n  address ds_address; \n\n\n  constructor(string memory _name,\n        string memory _symbol,\n        address _deployer_address,\n        address _timelock_address,\n        address _ds_address) ERC20(_name, _symbol) Owned(_deployer_address) {\n\n    deployer_address = _deployer_address;\n    timelock_address = _timelock_address; \n    ds_address = _ds_address; \n\n  }\n\n  modifier onlyByOwner() {\n        require(msg.sender == owner , \"Not the owner, controller, or the governance timelock\");\n        _;\n    }\n  \n  modifier onlyPools() {\n     require(pools[msg.sender] == true, \"Only pools can call this function\");\n      _;\n  } \n\n  function addPool(address pool_address) public onlyByOwner {\n      require(pool_address != address(0), \"Zero address detected\");\n\n      require(pools[pool_address] == false, \"Address already exists\");\n      pools[pool_address] = true; \n      pools_array.push(pool_address);\n\n      //emit PoolAdded(pool_address);\n  }\n\n\n  function mint(address to, uint256 amount, uint256 exchange_rate) public onlyPools {\n  \tuint256 amountScaled = amount.mul(uint(1e6)).div(exchange_rate); //exchange_rate >=1\n\n    _mint(to, amountScaled);\n  }\n\n  function burn(address account, uint256 amount, uint256 exchange_rate) public onlyPools {\n  \tuint256 amountScaled =amount.mul(uint(1e6)).div(exchange_rate);\n   _burn(account, amount);\n\tTransferHelper.safeTransfer(ds_address, account ,amountScaled); \n\n  }\n\n\n}"
    },
    "contracts/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.4;\n\nimport \"./IERC20.sol\";\nimport \"./IERC20Metadata.sol\";\nimport \"../Common/Context.sol\";\n\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}"
    },
    "contracts/ERC20/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.4;\n\nimport \"./IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}"
    },
    "contracts/libraries/PlaceholderReputationToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n/**\n * @title Cash\n * @dev Test contract for collateral\n */\ncontract PlaceholderReputationToken is ERC20 {\n    uint8 private _decimals;\n\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_\n    ) ERC20(name_, symbol_) {\n        _decimals = decimals_;\n    }\n\n    function decimals() public view virtual override(ERC20) returns (uint8) {\n        return _decimals;\n    }\n}\n"
    },
    "contracts/libraries/Cash.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n/**\n * @title Cash\n * @dev Test contract for collateral\n */\ncontract Cash is ERC20 {\n    uint8 private _decimals;\n\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_\n    ) ERC20(name_, symbol_) {\n        _decimals = decimals_;\n    }\n\n    function decimals() public view virtual override(ERC20) returns (uint8) {\n        return _decimals;\n    }\n\n    function faucet(uint256 _amount) public returns (bool) {\n        _mint(msg.sender, _amount);\n        return true;\n    }\n}\n"
    },
    "contracts/balancer/BPoolForTesting.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./BFactory.sol\";\nimport \"../libraries/IERC20Full.sol\";\nimport \"../libraries/Cash.sol\";\n\ncontract BPoolForTesting {\n    BFactory private bFactory;\n    BPool private bPool;\n    uint256 private constant MAX_UINT = 2**256 - 1;\n\n    constructor(BFactory _bFactory) {\n        bFactory = _bFactory;\n    }\n\n    function createBPoolForTesting(\n        Cash[] calldata _tokens,\n        uint256[] calldata _initialLiquidity,\n        uint256[] calldata _weights\n    ) external returns (BPool) {\n        require(\n            _tokens.length == _weights.length && _tokens.length == _initialLiquidity.length,\n            \"Tokens, weights and initial liquidity should all have the same length.\"\n        );\n\n        bPool = bFactory.newBPool();\n\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            _tokens[i].approve(address(bPool), MAX_UINT);\n            bPool.bind(address(_tokens[i]), _initialLiquidity[i], _weights[i]);\n        }\n\n        bPool.finalize();\n\n        return bPool;\n    }\n\n    function getBPool() external view returns (BPool) {\n        return bPool;\n    }\n}\n"
    },
    "contracts/libraries/EvenTheOdds.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../balancer/BPool.sol\";\nimport \"../turbo/AbstractMarketFactoryV3.sol\";\nimport \"hardhat/console.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\ncontract EvenTheOdds is BNum {\n    using SafeMath for uint256;\n\n    uint256 private constant MAX_UINT = 2**256 - 1;\n\n    function bringTokenBalanceToMatchOtherToken(\n        AbstractMarketFactoryV3 _marketFactory,\n        uint256 _marketId,\n        BPool _bPool,\n        uint256 _maxOutcome,\n        uint256 _maxCollateralIn\n    ) public returns (uint256 _collateralOut, uint256[] memory _balancesOut) {\n        IERC20 _collateral = _marketFactory.collateral();\n\n        // Will send remaining back.\n        _collateral.transferFrom(msg.sender, address(this), _maxCollateralIn);\n        _collateral.approve(address(_marketFactory), _maxCollateralIn);\n\n        AbstractMarketFactoryV3.Market memory _market = _marketFactory.getMarket(_marketId);\n\n        uint256 _sets = _marketFactory.calcShares(_maxCollateralIn);\n        _marketFactory.mintShares(_marketId, _sets, address(this));\n\n        uint256 _poolAmountOut = 0;\n        uint256 _targetBalance = _bPool.getBalance(address(_market.shareTokens[_maxOutcome]));\n        for (uint256 i = 0; i < _market.shareTokens.length; i++) {\n            if (i == _maxOutcome) continue;\n\n            OwnedERC20 _token = _market.shareTokens[i];\n            address _tokenAddress = address(_token);\n            uint256 _amountToAdd = _targetBalance.sub(_bPool.getBalance(_tokenAddress));\n            _token.approve(address(_bPool), _amountToAdd);\n\n            require(_sets >= _amountToAdd, \"_maxCollateralIn is insufficient\");\n\n            while (_amountToAdd > 0) {\n                // This amount will increase as more of the token is added.\n                uint256 _maxAmountAddable = bmul(_bPool.getBalance(_tokenAddress), MAX_IN_RATIO);\n                uint256 _amountThisPass = _amountToAdd;\n\n                if (_amountToAdd >= _maxAmountAddable) {\n                    _amountThisPass = _maxAmountAddable;\n                }\n\n                _poolAmountOut += _bPool.joinswapExternAmountIn(_tokenAddress, _amountThisPass, 0);\n                _amountToAdd = _amountToAdd.sub(_amountThisPass);\n            }\n        }\n\n        uint256[] memory minAmountsOut = new uint256[](_market.shareTokens.length);\n        _bPool.exitPool(_poolAmountOut, minAmountsOut);\n\n        uint256 _setsToSell = MAX_UINT;\n        for (uint256 i = 0; i < _market.shareTokens.length; i++) {\n            if (_setsToSell > _market.shareTokens[i].balanceOf(address(this))) {\n                _setsToSell = _market.shareTokens[i].balanceOf(address(this));\n            }\n        }\n\n        // Must be a multiple of share factor.\n        _setsToSell = (_setsToSell / _marketFactory.shareFactor()) * _marketFactory.shareFactor();\n\n        // Send back collateral.\n        _collateralOut = _marketFactory.burnShares(_marketId, _setsToSell, msg.sender);\n\n        // Send back any lingering shares.\n        _balancesOut = new uint256[](_market.shareTokens.length);\n        for (uint256 i = 0; i < _market.shareTokens.length; i++) {\n            _balancesOut[i] = _market.shareTokens[i].balanceOf(address(this));\n            _market.shareTokens[i].transfer(msg.sender, _balancesOut[i]);\n        }\n    }\n}\n"
    },
    "contracts/turbo/CDSMarketFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./AbstractMarketFactoryV3.sol\";\nimport \"../libraries/CalculateLinesToBPoolOdds.sol\";\nimport \"../libraries/Versioned.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\ncontract CDSMarketFactory is AbstractMarketFactoryV3, CalculateLinesToBPoolOdds, Versioned {\n    using SafeMath for uint256;\n\n    struct MarketDetails {\n        string description;\n    }\n    MarketDetails[] internal marketDetails;\n\n    constructor(\n        address _owner,\n        IERC20Full _collateral,\n        uint256 _shareFactor,\n        FeePot _feePot,\n        uint256[3] memory _fees,\n        address _protocol\n    ) AbstractMarketFactoryV3(_owner, _collateral, _shareFactor, _feePot, _fees, _protocol) Versioned(\"v1.1.0\") {}\n\n    function createMarket(\n        address _creator,\n        string calldata _description,\n        string[] calldata _names,\n        uint256[] calldata _odds\n    ) public onlyOwner returns (uint256) {\n        marketDetails.push(MarketDetails(_description));\n        return startMarket(_creator, _names, _odds, true);\n    }\n\n    function trustedResolveMarket(uint256 _id, uint256 _winningOutcome) public onlyOwner {\n        endMarket(_id, _winningOutcome);\n    }\n\n    function getMarketDetails(uint256 _id) public view returns (MarketDetails memory) {\n        return marketDetails[_id];\n    }\n\n    function getRewardEndTime(uint256 _marketId) public view override returns (uint256) {\n        return 0;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates",
          "devdoc",
          "userdoc"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}