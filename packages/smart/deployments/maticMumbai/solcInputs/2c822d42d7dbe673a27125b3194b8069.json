{
  "language": "Solidity",
  "sources": {
    "contracts/balancer/BColor.sol": {
      "content": "// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ninterface BColor {\n    function getColor() external view returns (bytes32);\n}\n\ncontract BBronze is BColor {\n    function getColor() external pure override returns (bytes32) {\n        return bytes32(\"BRONZE\");\n    }\n}\n"
    },
    "contracts/balancer/BConst.sol": {
      "content": "// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./BColor.sol\";\n\ncontract BConst is BBronze {\n    uint256 public constant BONE = 10**18;\n\n    uint256 public constant MIN_BOUND_TOKENS = 2;\n    uint256 public constant MAX_BOUND_TOKENS = 8;\n\n    uint256 public constant MIN_FEE = BONE / 10**6;\n    uint256 public constant MAX_FEE = BONE / 10;\n    uint256 public constant EXIT_FEE = 0;\n\n    uint256 public constant MIN_WEIGHT = BONE;\n    uint256 public constant MAX_WEIGHT = BONE * 50;\n    uint256 public constant MAX_TOTAL_WEIGHT = BONE * 50;\n    uint256 public constant MIN_BALANCE = BONE / 10**12;\n\n    uint256 public constant INIT_POOL_SUPPLY = BONE * 100;\n\n    uint256 public constant MIN_BPOW_BASE = 1 wei;\n    uint256 public constant MAX_BPOW_BASE = (2 * BONE) - 1 wei;\n    uint256 public constant BPOW_PRECISION = BONE / 10**10;\n\n    uint256 public constant MAX_IN_RATIO = BONE / 2;\n    uint256 public constant MAX_OUT_RATIO = (BONE / 3) + 1 wei;\n}\n"
    },
    "contracts/balancer/BNum.sol": {
      "content": "// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./BConst.sol\";\n\ncontract BNum is BConst {\n    function btoi(uint256 a) internal pure returns (uint256) {\n        return a / BONE;\n    }\n\n    function bfloor(uint256 a) internal pure returns (uint256) {\n        return btoi(a) * BONE;\n    }\n\n    function badd(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"ERR_ADD_OVERFLOW\");\n        return c;\n    }\n\n    function bsub(uint256 a, uint256 b) internal pure returns (uint256) {\n        (uint256 c, bool flag) = bsubSign(a, b);\n        require(!flag, \"ERR_SUB_UNDERFLOW\");\n        return c;\n    }\n\n    function bsubSign(uint256 a, uint256 b) internal pure returns (uint256, bool) {\n        if (a >= b) {\n            return (a - b, false);\n        } else {\n            return (b - a, true);\n        }\n    }\n\n    function bmul(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c0 = a * b;\n        require(a == 0 || c0 / a == b, \"ERR_MUL_OVERFLOW\");\n        uint256 c1 = c0 + (BONE / 2);\n        require(c1 >= c0, \"ERR_MUL_OVERFLOW\");\n        uint256 c2 = c1 / BONE;\n        return c2;\n    }\n\n    function bdiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"ERR_DIV_ZERO\");\n        uint256 c0 = a * BONE;\n        require(a == 0 || c0 / a == BONE, \"ERR_DIV_INTERNAL\"); // bmul overflow\n        uint256 c1 = c0 + (b / 2);\n        require(c1 >= c0, \"ERR_DIV_INTERNAL\"); //  badd require\n        uint256 c2 = c1 / b;\n        return c2;\n    }\n\n    // DSMath.wpow\n    function bpowi(uint256 a, uint256 n) internal pure returns (uint256) {\n        uint256 z = n % 2 != 0 ? a : BONE;\n\n        for (n /= 2; n != 0; n /= 2) {\n            a = bmul(a, a);\n\n            if (n % 2 != 0) {\n                z = bmul(z, a);\n            }\n        }\n        return z;\n    }\n\n    // Compute b^(e.w) by splitting it into (b^e)*(b^0.w).\n    // Use `bpowi` for `b^e` and `bpowK` for k iterations\n    // of approximation of b^0.w\n    function bpow(uint256 base, uint256 exp) internal pure returns (uint256) {\n        require(base >= MIN_BPOW_BASE, \"ERR_BPOW_BASE_TOO_LOW\");\n        require(base <= MAX_BPOW_BASE, \"ERR_BPOW_BASE_TOO_HIGH\");\n\n        uint256 whole = bfloor(exp);\n        uint256 remain = bsub(exp, whole);\n\n        uint256 wholePow = bpowi(base, btoi(whole));\n\n        if (remain == 0) {\n            return wholePow;\n        }\n\n        uint256 partialResult = bpowApprox(base, remain, BPOW_PRECISION);\n        return bmul(wholePow, partialResult);\n    }\n\n    function bpowApprox(\n        uint256 base,\n        uint256 exp,\n        uint256 precision\n    ) internal pure returns (uint256) {\n        // term 0:\n        uint256 a = exp;\n        (uint256 x, bool xneg) = bsubSign(base, BONE);\n        uint256 term = BONE;\n        uint256 sum = term;\n        bool negative = false;\n\n        // term(k) = numer / denom\n        //         = (product(a - i - 1, i=1-->k) * x^k) / (k!)\n        // each iteration, multiply previous term by (a-(k-1)) * x / k\n        // continue until term is less than precision\n        for (uint256 i = 1; term >= precision; i++) {\n            uint256 bigK = i * BONE;\n            (uint256 c, bool cneg) = bsubSign(a, bsub(bigK, BONE));\n            term = bmul(term, bmul(c, x));\n            term = bdiv(term, bigK);\n            if (term == 0) break;\n\n            if (xneg) negative = !negative;\n            if (cneg) negative = !negative;\n            if (negative) {\n                sum = bsub(sum, term);\n            } else {\n                sum = badd(sum, term);\n            }\n        }\n\n        return sum;\n    }\n}\n"
    },
    "contracts/turbo/AMMFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../balancer/BFactory.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"./AbstractMarketFactoryV3.sol\";\nimport \"../balancer/BNum.sol\";\nimport \"../bonds/Ibondingcurve.sol\"; \n\ncontract AMMFactory is BNum {\n    using SafeMath for uint256;\n\n    uint256 private constant MAX_UINT = 2**256 - 1;\n    uint256 private constant MIN_INITIAL_LIQUIDITY = BONE * 100;\n\n    BFactory public bFactory;\n    // MarketFactory => Market => BPool\n    mapping(address => mapping(uint256 => BPool)) public pools;\n    uint256 fee;\n\n    event PoolCreated(\n        address pool,\n        address indexed marketFactory,\n        uint256 indexed marketId,\n        address indexed creator,\n        address lpTokenRecipient\n    );\n    event LiquidityChanged(\n        address indexed marketFactory,\n        uint256 indexed marketId,\n        address indexed user,\n        address recipient,\n        // from the perspective of the user. e.g. collateral is negative when adding liquidity\n        int256 collateral,\n        int256 lpTokens,\n        uint256[] sharesReturned\n    );\n    event SharesSwapped(\n        address indexed marketFactory,\n        uint256 indexed marketId,\n        address indexed user,\n        uint256 outcome,\n        // from the perspective of the user. e.g. collateral is negative when buying\n        int256 collateral,\n        int256 shares,\n        uint256 price\n    );\n\n    constructor(BFactory _bFactory, uint256 _fee) {\n        bFactory = _bFactory;\n        fee = _fee;\n    }\n\n    function createPool(\n        AbstractMarketFactoryV3 _marketFactory,\n        uint256 _marketId,\n        uint256 _initialLiquidity,\n        address _lpTokenRecipient\n    ) public returns (uint256) {\n        require(pools[address(_marketFactory)][_marketId] == BPool(address(0)), \"Pool already created\");\n\n        AbstractMarketFactoryV3.Market memory _market = _marketFactory.getMarket(_marketId);\n\n        uint256 _sets = _marketFactory.calcShares(_initialLiquidity);\n\n        // Comparing to sets because sets are normalized to 10e18.\n        require(_sets >= MIN_INITIAL_LIQUIDITY, \"Initial liquidity must be at least 100 collateral.\");\n\n        //  Turn collateral into shares\n        IERC20Full _collateral = _marketFactory.collateral();\n        require(\n            _collateral.allowance(msg.sender, address(this)) >= _initialLiquidity,\n            \"insufficient collateral allowance for initial liquidity\"\n        );\n\n        _collateral.transferFrom(msg.sender, address(this), _initialLiquidity);\n        _collateral.approve(address(_marketFactory), MAX_UINT);\n\n        _marketFactory.mintShares(_marketId, _sets, address(this));\n\n        // Create pool\n        BPool _pool = bFactory.newBPool();\n\n        // Add each outcome to the pool. Collateral is NOT added.\n        for (uint256 i = 0; i < _market.shareTokens.length; i++) {\n            OwnedERC20 _token = _market.shareTokens[i];\n            _token.approve(address(_pool), MAX_UINT);\n            _pool.bind(address(_token), _sets, _market.initialOdds[i]);\n        }\n\n        // Set the swap fee.\n        _pool.setSwapFee(fee);\n\n        // Finalize pool setup\n        _pool.finalize();\n\n        pools[address(_marketFactory)][_marketId] = _pool;\n\n        // Pass along LP tokens for initial liquidity\n        uint256 _lpTokenBalance = _pool.balanceOf(address(this)) - (BONE / 1000);\n\n        // Burn (BONE / 1000) lp tokens to prevent the bpool from locking up. When all liquidity is removed.\n        _pool.transfer(address(0x0), (BONE / 1000));\n        _pool.transfer(_lpTokenRecipient, _lpTokenBalance);\n\n        uint256[] memory _balances = new uint256[](_market.shareTokens.length);\n        for (uint256 i = 0; i < _market.shareTokens.length; i++) {\n            _balances[i] = 0;\n        }\n\n        emit PoolCreated(address(_pool), address(_marketFactory), _marketId, msg.sender, _lpTokenRecipient);\n        emit LiquidityChanged(\n            address(_marketFactory),\n            _marketId,\n            msg.sender,\n            _lpTokenRecipient,\n            -int256(_initialLiquidity),\n            int256(_lpTokenBalance),\n            _balances\n        );\n\n        return _lpTokenBalance;\n    }\n\n    function addLiquidity(\n        AbstractMarketFactoryV3 _marketFactory,\n        uint256 _marketId,\n        uint256 _collateralIn,\n        uint256 _minLPTokensOut,\n        address _lpTokenRecipient\n    ) public returns (uint256 _poolAmountOut, uint256[] memory _balances) {\n        BPool _pool = pools[address(_marketFactory)][_marketId];\n        require(_pool != BPool(address(0)), \"Pool needs to be created\");\n\n        AbstractMarketFactoryV3.Market memory _market = _marketFactory.getMarket(_marketId);\n\n        //  Turn collateral into shares\n        IERC20Full _collateral = _marketFactory.collateral();\n        _collateral.transferFrom(msg.sender, address(this), _collateralIn);\n        _collateral.approve(address(_marketFactory), MAX_UINT);\n        uint256 _sets = _marketFactory.calcShares(_collateralIn);\n        _marketFactory.mintShares(_marketId, _sets, address(this));\n\n        // Find poolAmountOut\n        _poolAmountOut = MAX_UINT;\n\n        {\n            uint256 _totalSupply = _pool.totalSupply();\n            uint256[] memory _maxAmountsIn = new uint256[](_market.shareTokens.length);\n            for (uint256 i = 0; i < _market.shareTokens.length; i++) {\n                _maxAmountsIn[i] = _sets;\n\n                OwnedERC20 _token = _market.shareTokens[i];\n                uint256 _bPoolTokenBalance = _pool.getBalance(address(_token));\n\n                // This is the result the following when solving for poolAmountOut:\n                // uint256 ratio = bdiv(poolAmountOut, poolTotal);\n                // uint256 tokenAmountIn = bmul(ratio, bal);\n                uint256 _tokenPoolAmountOut =\n                    (((((_sets * BONE) - (BONE / 2)) * _totalSupply) / _bPoolTokenBalance) - (_totalSupply / 2)) / BONE;\n\n                if (_tokenPoolAmountOut < _poolAmountOut) {\n                    _poolAmountOut = _tokenPoolAmountOut;\n                }\n            }\n            _pool.joinPool(_poolAmountOut, _maxAmountsIn);\n        }\n\n        require(_poolAmountOut >= _minLPTokensOut, \"Would not have received enough LP tokens\");\n\n        _pool.transfer(_lpTokenRecipient, _poolAmountOut);\n\n        // Transfer the remaining shares back to _lpTokenRecipient.\n        _balances = new uint256[](_market.shareTokens.length);\n        for (uint256 i = 0; i < _market.shareTokens.length; i++) {\n            OwnedERC20 _token = _market.shareTokens[i];\n            _balances[i] = _token.balanceOf(address(this));\n            if (_balances[i] > 0) {\n                _token.transfer(_lpTokenRecipient, _balances[i]);\n            }\n        }\n\n        emit LiquidityChanged(\n            address(_marketFactory),\n            _marketId,\n            msg.sender,\n            _lpTokenRecipient,\n            -int256(_collateralIn),\n            int256(_poolAmountOut),\n            _balances\n        );\n    }\n\n    function removeLiquidity(\n        AbstractMarketFactoryV3 _marketFactory,\n        uint256 _marketId,\n        uint256 _lpTokensIn,\n        uint256 _minCollateralOut,\n        address _collateralRecipient\n    ) public returns (uint256 _collateralOut, uint256[] memory _balances) {\n        BPool _pool = pools[address(_marketFactory)][_marketId];\n        require(_pool != BPool(address(0)), \"Pool needs to be created\");\n\n        AbstractMarketFactoryV3.Market memory _market = _marketFactory.getMarket(_marketId);\n\n        _pool.transferFrom(msg.sender, address(this), _lpTokensIn);\n\n        uint256[] memory exitPoolEstimate;\n        {\n            uint256[] memory minAmountsOut = new uint256[](_market.shareTokens.length);\n            exitPoolEstimate = _pool.calcExitPool(_lpTokensIn, minAmountsOut);\n            _pool.exitPool(_lpTokensIn, minAmountsOut);\n        }\n\n        // Find the number of sets to sell.\n        uint256 _setsToSell = MAX_UINT;\n        for (uint256 i = 0; i < _market.shareTokens.length; i++) {\n            uint256 _acquiredTokenBalance = exitPoolEstimate[i];\n            if (_acquiredTokenBalance < _setsToSell) _setsToSell = _acquiredTokenBalance;\n        }\n\n        // Must be a multiple of share factor.\n        _setsToSell = (_setsToSell / _marketFactory.shareFactor()) * _marketFactory.shareFactor();\n\n        bool _resolved = _marketFactory.isMarketResolved(_marketId);\n        if (_resolved) {\n            _collateralOut = _marketFactory.claimWinnings(_marketId, _collateralRecipient);\n        } else {\n            _collateralOut = _marketFactory.burnShares(_marketId, _setsToSell, _collateralRecipient);\n        }\n        require(_collateralOut > _minCollateralOut, \"Amount of collateral returned too low.\");\n\n        // Transfer the remaining shares back to _collateralRecipient.\n        _balances = new uint256[](_market.shareTokens.length);\n        for (uint256 i = 0; i < _market.shareTokens.length; i++) {\n            OwnedERC20 _token = _market.shareTokens[i];\n            if (_resolved && _token == _market.winner) continue; // all winning shares claimed when market is resolved\n            _balances[i] = exitPoolEstimate[i] - _setsToSell;\n            if (_balances[i] > 0) {\n                _token.transfer(_collateralRecipient, _balances[i]);\n            }\n        }\n\n        emit LiquidityChanged(\n            address(_marketFactory),\n            _marketId,\n            msg.sender,\n            _collateralRecipient,\n            int256(_collateralOut),\n            -int256(_lpTokensIn),\n            _balances\n        );\n    }\n\n\n    function buyZCB(\n        AbstractMarketFactoryV3 _marketFactory, \n        address from, \n        address bondingcurve, \n        uint256 _marketId, \n        uint256 _collateralIn\n        ) external returns(uint256){\n\n\n        IERC20Full _collateral = _marketFactory.collateral();\n        _collateral.transferFrom(from, address(this), _collateralIn);\n        _collateral.approve(bondingcurve, _collateralIn); \n\n        return IBondingCurve(bondingcurve).buy(address(_marketFactory), from, _collateralIn, _marketId);\n    }\n\n    function sellZCB(\n        AbstractMarketFactoryV3 _marketFactory, \n        address from, \n        address bondingcurve, \n        uint256 _marketId, \n        uint256 _zcb_amountIn\n        ) external returns(uint256){\n\n        uint256 fee_deducted_collateral_out = IBondingCurve(bondingcurve).sell(\n            address(_marketFactory),\n            from, \n            _zcb_amountIn, \n             _marketId); \n\n        IERC20Full _collateral = _marketFactory.collateral();\n        _collateral.transfer(from, fee_deducted_collateral_out); \n\n        return fee_deducted_collateral_out; \n    }\n\n\n    function buy(\n        AbstractMarketFactoryV3 _marketFactory,\n        uint256 _marketId,\n        uint256 _outcome,\n        uint256 _collateralIn,\n        uint256 _minTokensOut\n    ) external returns (uint256) {\n        BPool _pool = pools[address(_marketFactory)][_marketId];\n        require(_pool != BPool(address(0)), \"Pool needs to be created\");\n\n        AbstractMarketFactoryV3.Market memory _market = _marketFactory.getMarket(_marketId);\n        _marketFactory.logTrade(_marketId, _outcome, _collateralIn); \n\n        IERC20Full _collateral = _marketFactory.collateral();\n        _collateral.transferFrom(msg.sender, address(this), _collateralIn);\n        uint256 _sets = _marketFactory.calcShares(_collateralIn);\n        _marketFactory.mintShares(_marketId, _sets, address(this));\n\n        uint256 _totalDesiredOutcome = _sets;\n        {\n            OwnedERC20 _desiredToken = _market.shareTokens[_outcome];\n\n            for (uint256 i = 0; i < _market.shareTokens.length; i++) {\n                if (i == _outcome) continue;\n                OwnedERC20 _token = _market.shareTokens[i];\n                (uint256 _acquiredToken, ) =\n                    _pool.swapExactAmountIn(address(_token), _sets, address(_desiredToken), 0, MAX_UINT);\n                _totalDesiredOutcome += _acquiredToken;\n            }\n            require(_totalDesiredOutcome >= _minTokensOut, \"Slippage exceeded\");\n\n            _desiredToken.transfer(msg.sender, _totalDesiredOutcome);\n        }\n\n        emit SharesSwapped(\n            address(_marketFactory),\n            _marketId,\n            msg.sender,\n            _outcome,\n            -int256(_collateralIn),\n            int256(_totalDesiredOutcome),\n            bdiv(_sets, _totalDesiredOutcome)\n        );\n\n        return _totalDesiredOutcome;\n    }\n\n    function sellForCollateral(\n        AbstractMarketFactoryV3 _marketFactory,\n        uint256 _marketId,\n        uint256 _outcome,\n        uint256[] memory _shareTokensIn,\n        uint256 _minSetsOut\n    ) external returns (uint256) {\n        BPool _pool = pools[address(_marketFactory)][_marketId];\n        require(_pool != BPool(address(0)), \"Pool needs to be created\");\n        AbstractMarketFactoryV3.Market memory _market = _marketFactory.getMarket(_marketId);\n\n        uint256 _setsOut = MAX_UINT;\n        uint256 _totalUndesiredTokensIn = 0;\n        for (uint256 i = 0; i < _market.shareTokens.length; i++) {\n            _totalUndesiredTokensIn += _shareTokensIn[i];\n        }\n\n        {\n            _market.shareTokens[_outcome].transferFrom(msg.sender, address(this), _totalUndesiredTokensIn);\n            _market.shareTokens[_outcome].approve(address(_pool), MAX_UINT);\n\n            for (uint256 i = 0; i < _market.shareTokens.length; i++) {\n                if (i == _outcome) continue;\n                OwnedERC20 _token = _market.shareTokens[i];\n                (uint256 tokenAmountOut, ) =\n                    _pool.swapExactAmountIn(\n                        address(_market.shareTokens[_outcome]),\n                        _shareTokensIn[i],\n                        address(_token),\n                        0,\n                        MAX_UINT\n                    );\n\n                //Ensure tokenAmountOut is a multiple of shareFactor.\n                tokenAmountOut = (tokenAmountOut / _marketFactory.shareFactor()) * _marketFactory.shareFactor();\n                if (tokenAmountOut < _setsOut) _setsOut = tokenAmountOut;\n            }\n\n            require(_setsOut >= _minSetsOut, \"Minimum sets not available.\");\n            _marketFactory.burnShares(_marketId, _setsOut, msg.sender);\n        }\n\n        // Transfer undesired token balance back.\n        for (uint256 i = 0; i < _market.shareTokens.length; i++) {\n            OwnedERC20 _token = _market.shareTokens[i];\n            uint256 _balance = _token.balanceOf(address(this));\n            if (_balance > 0) {\n                _token.transfer(msg.sender, _balance);\n            }\n        }\n\n        uint256 _collateralOut = _marketFactory.calcCost(_setsOut);\n        emit SharesSwapped(\n            address(_marketFactory),\n            _marketId,\n            msg.sender,\n            _outcome,\n            int256(_collateralOut),\n            -int256(_totalUndesiredTokensIn),\n            bdiv(_setsOut, _totalUndesiredTokensIn)\n        );\n\n        return _collateralOut;\n    }\n\n    // Returns an array of token values for the outcomes of the market, relative to the first outcome.\n    // So the first outcome is 10**18 and all others are higher or lower.\n    // Prices can be derived due to the fact that the total of all outcome shares equals one collateral, possibly with a scaling factor,\n    function tokenRatios(AbstractMarketFactoryV3 _marketFactory, uint256 _marketId)\n        external\n        view\n        returns (uint256[] memory)\n    {\n        BPool _pool = pools[address(_marketFactory)][_marketId];\n        // Pool does not exist. Do not want to revert because multicall.\n        if (_pool == BPool(address(0))) {\n            return new uint256[](0);\n        }\n\n        AbstractMarketFactoryV3.Market memory _market = _marketFactory.getMarket(_marketId);\n        address _basisToken = address(_market.shareTokens[0]);\n        uint256[] memory _ratios = new uint256[](_market.shareTokens.length);\n        _ratios[0] = 10**18;\n        for (uint256 i = 1; i < _market.shareTokens.length; i++) {\n            uint256 _price = _pool.getSpotPrice(_basisToken, address(_market.shareTokens[i]));\n            _ratios[i] = _price;\n        }\n        return _ratios;\n    }\n\n    function getPoolBalances(AbstractMarketFactoryV3 _marketFactory, uint256 _marketId)\n        external\n        view\n        returns (uint256[] memory)\n    {\n        BPool _pool = pools[address(_marketFactory)][_marketId];\n        // Pool does not exist. Do not want to revert because multicall.\n        if (_pool == BPool(address(0))) {\n            return new uint256[](0);\n        }\n\n        address[] memory _tokens = _pool.getCurrentTokens();\n        uint256[] memory _balances = new uint256[](_tokens.length);\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            _balances[i] = _pool.getBalance(_tokens[i]);\n        }\n        return _balances;\n    }\n\n    function getPoolWeights(AbstractMarketFactoryV3 _marketFactory, uint256 _marketId)\n        external\n        view\n        returns (uint256[] memory)\n    {\n        BPool _pool = pools[address(_marketFactory)][_marketId];\n        // Pool does not exist. Do not want to revert because multicall.\n        if (_pool == BPool(address(0))) {\n            return new uint256[](0);\n        }\n\n        address[] memory _tokens = _pool.getCurrentTokens();\n        uint256[] memory _weights = new uint256[](_tokens.length);\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            _weights[i] = _pool.getDenormalizedWeight(_tokens[i]);\n        }\n        return _weights;\n    }\n\n    function getSwapFee(AbstractMarketFactoryV3 _marketFactory, uint256 _marketId) external view returns (uint256) {\n        BPool _pool = pools[address(_marketFactory)][_marketId];\n        return _pool.getSwapFee();\n    }\n\n    function getPoolTokenBalance(\n        AbstractMarketFactoryV3 _marketFactory,\n        uint256 _marketId,\n        address _user\n    ) external view returns (uint256) {\n        BPool _pool = pools[address(_marketFactory)][_marketId];\n        return _pool.balanceOf(_user);\n    }\n\n    function getPool(AbstractMarketFactoryV3 _marketFactory, uint256 _marketId) external view returns (BPool) {\n        return pools[address(_marketFactory)][_marketId];\n    }\n}\n"
    },
    "contracts/balancer/BFactory.sol": {
      "content": "// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is disstributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n// Builds new BPools, logging their addresses and providing `isBPool(address) -> (bool)`\n\nimport \"./BPool.sol\";\n\ncontract BFactory is BBronze {\n    event LOG_NEW_POOL(address indexed caller, address indexed pool);\n\n    event LOG_BLABS(address indexed caller, address indexed blabs);\n\n    mapping(address => bool) private _isBPool;\n\n    function isBPool(address b) external view returns (bool) {\n        return _isBPool[b];\n    }\n\n    function newBPool() external returns (BPool) {\n        BPool bpool = new BPool();\n        _isBPool[address(bpool)] = true;\n        emit LOG_NEW_POOL(msg.sender, address(bpool));\n        bpool.setController(msg.sender);\n        return bpool;\n    }\n\n    address private _blabs;\n\n    constructor() {\n        _blabs = msg.sender;\n    }\n\n    function getBLabs() external view returns (address) {\n        return _blabs;\n    }\n\n    function setBLabs(address b) external {\n        require(msg.sender == _blabs, \"ERR_NOT_BLABS\");\n        emit LOG_BLABS(msg.sender, b);\n        _blabs = b;\n    }\n\n    function collect(BPool pool) external {\n        require(msg.sender == _blabs, \"ERR_NOT_BLABS\");\n        uint256 collected = IERC20Balancer(pool).balanceOf(address(this));\n        bool xfer = pool.transfer(_blabs, collected);\n        require(xfer, \"ERR_ERC20_FAILED\");\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "contracts/turbo/AbstractMarketFactoryV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../libraries/IERC20Full.sol\";\nimport \"../balancer/BPool.sol\";\nimport \"./TurboShareTokenFactory.sol\";\nimport \"./FeePot.sol\";\nimport \"../libraries/Rewardable.sol\";\nimport { LinearBondingCurve } from \"../bonds/LinearBondingCurve.sol\";\n\nabstract contract AbstractMarketFactoryV3 is ZCBFactory, TurboShareTokenFactory, Ownable, Rewardable {\n    using SafeMath for uint256;\n\n    event MarketCreated(uint256 id, string[] names, uint256[] initialOdds);\n    event MarketResolved(uint256 id, address winner, uint256 winnerIndex, string winnerName);\n    event MarketActivated(uint256 id);\n\n    event SharesMinted(uint256 id, uint256 amount, address receiver);\n    event SharesBurned(uint256 id, uint256 amount, address receiver);\n    event WinningsClaimed(\n        uint256 id,\n        address winningOutcome,\n        uint256 winningIndex,\n        string winningName,\n        uint256 amount,\n        uint256 settlementFee,\n        uint256 payout,\n        address indexed receiver\n    );\n\n    IERC20Full public collateral;\n    FeePot public feePot;\n\n    // fees are out of 1e18 and only apply to new markets\n    uint256 public stakerFee;\n    uint256 public settlementFee;\n    uint256 public protocolFee;\n\n    address public protocol; // collects protocol fees\n\n    uint256 public accumulatedProtocolFee = 0;\n    // settlement address => amount of collateral\n    mapping(address => uint256) public accumulatedSettlementFees;\n\n    // How many shares equals one collateral.\n    // Necessary to account for math errors from small numbers in balancer.\n    // shares = collateral / shareFactor\n    // collateral = shares * shareFactor\n    uint256 public shareFactor;\n\n    struct Market {\n        address settlementAddress;\n        OwnedERC20[] shareTokens;\n        OwnedERC20 winner;\n        uint256 winnerIndex;\n        uint256 settlementFee;\n        uint256 protocolFee;\n        uint256 stakerFee;\n        uint256 creationTimestamp;\n        uint256 resolutionTimestamp; // when winner is declared\n        uint256[] initialOdds;\n        bool active; // false if not ready to use or if resolved\n    }\n\n    Market[] internal markets;\n    // ZCBMarket[] internal zcbmarkets; \n\n    uint256 private constant MAX_UINT = 2**256 - 1;\n\n    mapping(uint256=> mapping(uint256=>uint256)) TradeDetails; //marketid -> (outcome->amount)\n    mapping(uint256 => bool ) inAssessment; \n    mapping(uint256=> uint256) buy_thresholds;\n\n\n    constructor(\n        address _owner,\n        IERC20Full _collateral,\n        uint256 _shareFactor,\n        FeePot _feePot,\n        uint256[3] memory _fees, // staker, settlement, protocol\n        address _protocol\n    ) {\n        owner = _owner; // controls fees for new markets\n        collateral = _collateral;\n        shareFactor = _shareFactor;\n        feePot = _feePot;\n        stakerFee = _fees[0];\n        settlementFee = _fees[1];\n        protocolFee = _fees[2];\n        protocol = _protocol;\n\n        _collateral.approve(address(_feePot), MAX_UINT);\n\n        // First market is always empty so that marketid zero means \"no market\"\n        markets.push(makeEmptyMarket());\n\n        //FOR TESTING ONLY\n        buy_thresholds[0] = MAX_UINT;\n        buy_thresholds[1] = MAX_UINT; \n        buy_thresholds[2] = MAX_UINT; \n    }\n        \n\n   // function quantityAvailable(uint256 marketId)\n\n    //Called by lendingpool when market is created i.e , and when loan is approved \n    function handleAssessment(uint256 _marketId, bool startAssessing) \n    external\n    //onlyController\n     {\n        bool market_inAssessment = startAssessing? true : false; \n        inAssessment[_marketId] = market_inAssessment; \n    }\n    function handleOnlyReputable(uint256 _marketId)\n    external \n    //onlyController\n    {\n\n    }\n    //Called by controller after assessment phase \n    function set_buy_threshold(uint256 _marketId, uint256 threshold)\n    external \n    //onlyController\n    {\n        buy_thresholds[_marketId] = threshold;\n    }\n\n    function get_buy_threshold(uint256 _marketId) external view returns(uint256){\n        return buy_thresholds[_marketId]; \n    }\n    function isInAssessment(uint256 _marketId) external view returns(bool){\n        return inAssessment[_marketId]; \n    }\n\n    function onlyReputable(uint256 _marketId) external view returns(bool){\n        return false;\n    }\n    function logTrade(uint256 _marketId, uint256 _outcome, uint256 _collateralIn) external {\n        TradeDetails[_marketId][_outcome] = TradeDetails[_marketId][_outcome] + _collateralIn; \n\n    }\n\n    function getTradeDetails(uint256 _marketId, uint256 _outcome) external view returns(uint256){\n        return TradeDetails[_marketId][_outcome]; \n    }\n\n\n\n\n    // Returns an empty struct if the market doesn't exist.\n    // Can check market existence before calling this by comparing _id against markets.length.\n    // Can check market existence of the return struct by checking that shareTokens[0] isn't the null address\n    function getMarket(uint256 _id) public view returns (Market memory) {\n        if (_id >= markets.length) {\n            return makeEmptyMarket();\n        } else {\n            return markets[_id];\n        }\n    }\n\n    function marketCount() public view returns (uint256) {\n        return markets.length; //+ zcbmarkets.length;\n    }\n\n    // Returns factory-specific details about a market.\n    // function getMarketDetails(uint256 _id) public view returns (MarketDetails memory);\n\n    function mintShares(\n        uint256 _id,\n        uint256 _shareToMint,\n        address _receiver\n    ) public {\n        require(markets.length > _id);\n        require(markets[_id].active);\n\n        uint256 _cost = calcCost(_shareToMint);\n        collateral.transferFrom(msg.sender, address(this), _cost);\n\n        Market memory _market = markets[_id];\n        for (uint256 _i = 0; _i < _market.shareTokens.length; _i++) {\n            _market.shareTokens[_i].trustedMint(_receiver, _shareToMint);\n        }\n\n        emit SharesMinted(_id, _shareToMint, _receiver);\n    }\n\n    function burnShares(\n        uint256 _id,\n        uint256 _sharesToBurn,\n        address _receiver\n    ) public returns (uint256) {\n        require(markets.length > _id);\n        require(markets[_id].active);\n\n        Market memory _market = markets[_id];\n        for (uint256 _i = 0; _i < _market.shareTokens.length; _i++) {\n            // errors if sender doesn't have enough shares\n            _market.shareTokens[_i].trustedBurn(msg.sender, _sharesToBurn);\n        }\n\n        uint256 _payout = calcCost(_sharesToBurn);\n        uint256 _protocolFee = _payout.mul(_market.protocolFee).div(10**18);\n        uint256 _stakerFee = _payout.mul(_market.stakerFee).div(10**18);\n        _payout = _payout.sub(_protocolFee).sub(_stakerFee);\n\n        accumulatedProtocolFee += _protocolFee;\n        collateral.transfer(_receiver, _payout);\n        feePot.depositFees(_stakerFee);\n\n        emit SharesBurned(_id, _sharesToBurn, msg.sender);\n        return _payout;\n    }\n\n    function claimWinnings(uint256 _id, address _receiver) public returns (uint256) {\n        require(isMarketResolved(_id), \"market unresolved\");\n\n        Market memory _market = markets[_id];\n        uint256 _winningShares = _market.winner.trustedBurnAll(msg.sender);\n        _winningShares = (_winningShares / shareFactor) * shareFactor; // remove unusable dust\n\n        uint256 _payout = calcCost(_winningShares); // will fail if there are no winnings to claim\n        uint256 _settlementFee = _payout.mul(_market.settlementFee).div(10**18);\n        _payout = _payout.sub(_settlementFee);\n\n        accumulatedSettlementFees[_market.settlementAddress] += _settlementFee;\n        collateral.transfer(_receiver, _payout);\n\n        uint256 _winningIndex = _market.winnerIndex;\n        string memory _winningName = _market.winner.name();\n\n        emit WinningsClaimed(\n            _id,\n            address(_market.winner),\n            _winningIndex,\n            _winningName,\n            _winningShares,\n            _settlementFee,\n            _payout,\n            _receiver\n        );\n        return _payout;\n    }\n\n    function claimManyWinnings(uint256[] memory _ids, address _receiver) public returns (uint256) {\n        uint256 _totalWinnings = 0;\n        for (uint256 i = 0; i < _ids.length; i++) {\n            _totalWinnings = _totalWinnings.add(claimWinnings(_ids[i], _receiver));\n        }\n        return _totalWinnings;\n    }\n\n    function claimSettlementFees(address _receiver) public returns (uint256) {\n        uint256 _fees = accumulatedSettlementFees[msg.sender];\n        if (_fees > 0) {\n            accumulatedSettlementFees[msg.sender] = 0;\n            collateral.transfer(_receiver, _fees);\n        }\n        return _fees;\n    }\n\n    function claimProtocolFees() public returns (uint256) {\n        require(msg.sender == protocol || msg.sender == address(this));\n        uint256 _fees = accumulatedProtocolFee;\n        if (_fees > 0) {\n            accumulatedProtocolFee = 0;\n            collateral.transfer(protocol, _fees);\n        }\n        return _fees;\n    }\n\n    function setSettlementFee(uint256 _newFee) external onlyOwner {\n        settlementFee = _newFee;\n    }\n\n    function setStakerFee(uint256 _newFee) external onlyOwner {\n        stakerFee = _newFee;\n    }\n\n    function setProtocolFee(uint256 _newFee) external onlyOwner {\n        protocolFee = _newFee;\n    }\n\n    function setProtocol(address _newProtocol, bool _claimFirst) external onlyOwner {\n        if (_claimFirst) {\n            claimProtocolFees();\n        }\n        protocol = _newProtocol;\n    }\n\n\n    function startMarket(\n        address _settlementAddress,\n        string[] memory _names,\n        uint256[] memory _initialOdds,\n        bool _active\n    ) internal returns (uint256 _marketId) {\n        _marketId = markets.length;\n        markets.push(\n            Market(\n                _settlementAddress,\n                createShareTokens(_names, address(this)),\n                OwnedERC20(address(0)),\n                0,\n                settlementFee,\n                protocolFee,\n                stakerFee,\n                block.timestamp,\n                0,\n                _initialOdds,\n                _active\n            )\n        );\n        emit MarketCreated(_marketId, _names, _initialOdds);\n        if (_active) {\n            emit MarketActivated(_marketId);\n        }\n    }\n       \n    \n    function activateMarket(uint256 _marketId) internal {\n        markets[_marketId].active = true;\n        emit MarketActivated(_marketId);\n    }\n\n    function makeEmptyMarket() private pure returns (Market memory) {\n        OwnedERC20[] memory _tokens = new OwnedERC20[](0);\n        uint256[] memory _initialOdds = new uint256[](0);\n        return Market(address(0), _tokens, OwnedERC20(address(0)), 0, 0, 0, 0, 0, 0, _initialOdds, false);\n    }\n\n\n    function endMarket(uint256 _marketId, uint256 _winningOutcome) internal {\n        Market storage _market = markets[_marketId];\n        OwnedERC20 _winner = _market.shareTokens[_winningOutcome];\n\n        _market.winner = _winner;\n        _market.active = false;\n        _market.winnerIndex = _winningOutcome;\n        _market.resolutionTimestamp = block.timestamp;\n        string memory _outcomeName = _winner.name();\n        emit MarketResolved(_marketId, address(_winner), _winningOutcome, _outcomeName);\n    }\n\n    function isMarketResolved(uint256 _id) public view returns (bool) {\n        Market memory _market = markets[_id];\n        return _market.winner != OwnedERC20(address(0));\n    }\n\n    // shares => collateral\n    // Shares must be both greater than (or equal to) and divisible by shareFactor.\n    function calcCost(uint256 _shares) public view returns (uint256) {\n        require(_shares >= shareFactor && _shares % shareFactor == 0);\n        return _shares / shareFactor;\n    }\n\n    // collateral => shares\n    function calcShares(uint256 _collateralIn) public view returns (uint256) {\n        return _collateralIn * shareFactor;\n    }\n\n    function onTransferOwnership(address, address) internal override {}\n\n    /**\n     @notice \n     */\n    function startZCBMarket(\n        address _settlementAddress,\n        uint256[] memory _initialOdds,\n        bool _active,\n        OwnedERC20 _zcb\n    ) internal returns (uint256 _marketId){\n\n        _marketId = markets.length;\n        OwnedERC20[] memory zcb = new OwnedERC20[](2);\n        zcb[0] = _zcb;\n        markets.push(\n            Market(\n                _settlementAddress,\n                zcb,\n                OwnedERC20(address(0)),\n                0,\n                settlementFee,\n                protocolFee,\n                stakerFee,\n                block.timestamp,\n                0,\n                _initialOdds,\n                _active\n                )\n            );\n\n        if (_active) {\n            emit MarketActivated(_marketId);\n        }\n\n    }\n\n    function getZCBMarket(uint256 _id) public view returns (Market memory) {\n        if (_id >= markets.length) {\n           revert(\"Market Not Activated\");\n        } else {\n            return markets[_id];\n        }\n    }\n}\n"
    },
    "contracts/bonds/Ibondingcurve.sol": {
      "content": "pragma solidity ^0.8.4; \n\n\ninterface IBondingCurve{\n\tfunction setMarketManager(address _market_manager) external;\n\tfunction getTotalZCB(uint256 marketId) external returns (uint256 result);\n\tfunction getTotalDS(uint256 marketId) external returns (uint256 result);\n\tfunction getMaxQuantity(uint256 marketId) external view returns (uint256 result);\n\tfunction curveInit(uint256 marketId) external;\n\tfunction getExpectedPrice(uint256 marketId, uint256 amountIn) external view returns (uint256 result);\n\tfunction getCollateral() external returns (address);\n\tfunction buy(\n\t\taddress marketFactoryAddress, \n\t\taddress trader,\n\t\tuint256 amountIn, \n\t\tuint256 marketId\n\t) external returns(uint256);\n\tfunction sell(\n\t\taddress marketFactoryAddress, \n\t\taddress trader,\n\t\tuint256 amountIn, \n\t\tuint256 marketId\n\t) external returns (uint256);\n\tfunction redeem(\n\t\tuint256 marketId, \n\t\taddress receiver, \n\t\tuint256 zcb_redeem_amount, \n\t\tuint256 collateral_redeem_amount\n\t) external;\n\tfunction redeemPostAssessment(\n\t\tuint256 marketId, \n\t\taddress redeemer,\n\t\tuint256 collateral_amount\n\t) external;\n\tfunction burnFirstLoss(\n\t\tuint256 marketId, \n\t\tuint256 burn_collateral_amount\n\t) external;\n\tfunction mint(\n\t\tuint256 marketId, \n\t\tuint256 mintAmount,\n\t\taddress to\n\t) external;\n\tfunction burn(\n\t\tuint256 marketId, \n\t\tuint256 burnAmount, \n\t\taddress to\n\t) external;\n}"
    },
    "contracts/balancer/BPool.sol": {
      "content": "// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./BToken.sol\";\nimport \"./BMath.sol\";\n\ncontract BPool is BBronze, BToken, BMath {\n    struct Record {\n        bool bound; // is token bound to pool\n        uint256 index; // private\n        uint256 denorm; // denormalized weight\n        uint256 balance;\n    }\n\n    event LOG_SWAP(\n        address indexed caller,\n        address indexed tokenIn,\n        address indexed tokenOut,\n        uint256 tokenAmountIn,\n        uint256 tokenAmountOut\n    );\n\n    event LOG_JOIN(address indexed caller, address indexed tokenIn, uint256 tokenAmountIn);\n\n    event LOG_EXIT(address indexed caller, address indexed tokenOut, uint256 tokenAmountOut);\n\n    event LOG_CALL(bytes4 indexed sig, address indexed caller, bytes data) anonymous;\n\n    modifier _logs_() {\n        emit LOG_CALL(msg.sig, msg.sender, msg.data);\n        _;\n    }\n\n    modifier _lock_() {\n        require(!_mutex, \"ERR_REENTRY\");\n        _mutex = true;\n        _;\n        _mutex = false;\n    }\n\n    modifier _viewlock_() {\n        require(!_mutex, \"ERR_REENTRY\");\n        _;\n    }\n\n    bool private _mutex;\n\n    address private _factory; // BFactory address to push token exitFee to\n    address private _controller; // has CONTROL role\n    bool private _publicSwap; // true if PUBLIC can call SWAP functions\n\n    // `setSwapFee` and `finalize` require CONTROL\n    // `finalize` sets `PUBLIC can SWAP`, `PUBLIC can JOIN`\n    uint256 private _swapFee;\n    bool private _finalized;\n\n    address[] private _tokens;\n    mapping(address => Record) private _records;\n    uint256 private _totalWeight;\n\n    constructor() {\n        _controller = msg.sender;\n        _factory = msg.sender;\n        _swapFee = MIN_FEE;\n        _publicSwap = false;\n        _finalized = false;\n    }\n\n    function isPublicSwap() external view returns (bool) {\n        return _publicSwap;\n    }\n\n    function isFinalized() external view returns (bool) {\n        return _finalized;\n    }\n\n    function isBound(address t) external view returns (bool) {\n        return _records[t].bound;\n    }\n\n    function getNumTokens() external view returns (uint256) {\n        return _tokens.length;\n    }\n\n    function getCurrentTokens() external view _viewlock_ returns (address[] memory tokens) {\n        return _tokens;\n    }\n\n    function getFinalTokens() external view _viewlock_ returns (address[] memory tokens) {\n        require(_finalized, \"ERR_NOT_FINALIZED\");\n        return _tokens;\n    }\n\n    function getDenormalizedWeight(address token) external view _viewlock_ returns (uint256) {\n        require(_records[token].bound, \"ERR_NOT_BOUND\");\n        return _records[token].denorm;\n    }\n\n    function getTotalDenormalizedWeight() external view _viewlock_ returns (uint256) {\n        return _totalWeight;\n    }\n\n    function getNormalizedWeight(address token) external view _viewlock_ returns (uint256) {\n        require(_records[token].bound, \"ERR_NOT_BOUND\");\n        uint256 denorm = _records[token].denorm;\n        return bdiv(denorm, _totalWeight);\n    }\n\n    function getBalance(address token) external view _viewlock_ returns (uint256) {\n        require(_records[token].bound, \"ERR_NOT_BOUND\");\n        return _records[token].balance;\n    }\n\n    function getSwapFee() external view _viewlock_ returns (uint256) {\n        return _swapFee;\n    }\n\n    function getController() external view _viewlock_ returns (address) {\n        return _controller;\n    }\n\n    function setSwapFee(uint256 swapFee) external _logs_ _lock_ {\n        require(!_finalized, \"ERR_IS_FINALIZED\");\n        require(msg.sender == _controller, \"ERR_NOT_CONTROLLER\");\n        require(swapFee >= MIN_FEE, \"ERR_MIN_FEE\");\n        require(swapFee <= MAX_FEE, \"ERR_MAX_FEE\");\n        _swapFee = swapFee;\n    }\n\n    function setController(address manager) external _logs_ _lock_ {\n        require(msg.sender == _controller, \"ERR_NOT_CONTROLLER\");\n        _controller = manager;\n    }\n\n    function setPublicSwap(bool public_) external _logs_ _lock_ {\n        require(!_finalized, \"ERR_IS_FINALIZED\");\n        require(msg.sender == _controller, \"ERR_NOT_CONTROLLER\");\n        _publicSwap = public_;\n    }\n\n    function finalize() external _logs_ _lock_ {\n        require(msg.sender == _controller, \"ERR_NOT_CONTROLLER\");\n        require(!_finalized, \"ERR_IS_FINALIZED\");\n        require(_tokens.length >= MIN_BOUND_TOKENS, \"ERR_MIN_TOKENS\");\n\n        _finalized = true;\n        _publicSwap = true;\n\n        _mintPoolShare(INIT_POOL_SUPPLY);\n        _pushPoolShare(msg.sender, INIT_POOL_SUPPLY);\n    }\n\n    function bind(\n        address token,\n        uint256 balance,\n        uint256 denorm\n    )\n        external\n        _logs_ // _lock_  Bind does not lock because it jumps to `rebind`, which does\n    {\n        require(msg.sender == _controller, \"ERR_NOT_CONTROLLER\");\n        require(!_records[token].bound, \"ERR_IS_BOUND\");\n        require(!_finalized, \"ERR_IS_FINALIZED\");\n\n        require(_tokens.length < MAX_BOUND_TOKENS, \"ERR_MAX_TOKENS\");\n\n        _records[token] = Record({\n            bound: true,\n            index: _tokens.length,\n            denorm: 0, // balance and denorm will be validated\n            balance: 0 // and set by `rebind`\n        });\n        _tokens.push(token);\n        rebind(token, balance, denorm);\n    }\n\n    function rebind(\n        address token,\n        uint256 balance,\n        uint256 denorm\n    ) public _logs_ _lock_ {\n        require(msg.sender == _controller, \"ERR_NOT_CONTROLLER\");\n        require(_records[token].bound, \"ERR_NOT_BOUND\");\n        require(!_finalized, \"ERR_IS_FINALIZED\");\n\n        require(denorm >= MIN_WEIGHT, \"ERR_MIN_WEIGHT\");\n        require(denorm <= MAX_WEIGHT, \"ERR_MAX_WEIGHT\");\n        require(balance >= MIN_BALANCE, \"ERR_MIN_BALANCE\");\n\n        // Adjust the denorm and totalWeight\n        uint256 oldWeight = _records[token].denorm;\n        if (denorm > oldWeight) {\n            _totalWeight = badd(_totalWeight, bsub(denorm, oldWeight));\n            require(_totalWeight <= MAX_TOTAL_WEIGHT, \"ERR_MAX_TOTAL_WEIGHT\");\n        } else if (denorm < oldWeight) {\n            _totalWeight = bsub(_totalWeight, bsub(oldWeight, denorm));\n        }\n        _records[token].denorm = denorm;\n\n        // Adjust the balance record and actual token balance\n        uint256 oldBalance = _records[token].balance;\n        _records[token].balance = balance;\n        if (balance > oldBalance) {\n            _pullUnderlying(token, msg.sender, bsub(balance, oldBalance));\n        } else if (balance < oldBalance) {\n            // In this case liquidity is being withdrawn, so charge EXIT_FEE\n            uint256 tokenBalanceWithdrawn = bsub(oldBalance, balance);\n            uint256 tokenExitFee = bmul(tokenBalanceWithdrawn, EXIT_FEE);\n            _pushUnderlying(token, msg.sender, bsub(tokenBalanceWithdrawn, tokenExitFee));\n            _pushUnderlying(token, _factory, tokenExitFee);\n        }\n    }\n\n    function unbind(address token) external _logs_ _lock_ {\n        require(msg.sender == _controller, \"ERR_NOT_CONTROLLER\");\n        require(_records[token].bound, \"ERR_NOT_BOUND\");\n        require(!_finalized, \"ERR_IS_FINALIZED\");\n\n        uint256 tokenBalance = _records[token].balance;\n        uint256 tokenExitFee = bmul(tokenBalance, EXIT_FEE);\n\n        _totalWeight = bsub(_totalWeight, _records[token].denorm);\n\n        // Swap the token-to-unbind with the last token,\n        // then delete the last token\n        uint256 index = _records[token].index;\n        uint256 last = _tokens.length - 1;\n        _tokens[index] = _tokens[last];\n        _records[_tokens[index]].index = index;\n        _tokens.pop();\n        _records[token] = Record({bound: false, index: 0, denorm: 0, balance: 0});\n\n        _pushUnderlying(token, msg.sender, bsub(tokenBalance, tokenExitFee));\n        _pushUnderlying(token, _factory, tokenExitFee);\n    }\n\n    // Absorb any tokens that have been sent to this contract into the pool\n    function gulp(address token) external _logs_ _lock_ {\n        require(_records[token].bound, \"ERR_NOT_BOUND\");\n        _records[token].balance = IERC20Balancer(token).balanceOf(address(this));\n    }\n\n    function getSpotPrice(address tokenIn, address tokenOut) external view _viewlock_ returns (uint256 spotPrice) {\n        require(_records[tokenIn].bound, \"ERR_NOT_BOUND\");\n        require(_records[tokenOut].bound, \"ERR_NOT_BOUND\");\n        Record storage inRecord = _records[tokenIn];\n        Record storage outRecord = _records[tokenOut];\n        return calcSpotPrice(inRecord.balance, inRecord.denorm, outRecord.balance, outRecord.denorm, _swapFee);\n    }\n\n    function getSpotPriceSansFee(address tokenIn, address tokenOut)\n        external\n        view\n        _viewlock_\n        returns (uint256 spotPrice)\n    {\n        require(_records[tokenIn].bound, \"ERR_NOT_BOUND\");\n        require(_records[tokenOut].bound, \"ERR_NOT_BOUND\");\n        Record storage inRecord = _records[tokenIn];\n        Record storage outRecord = _records[tokenOut];\n        return calcSpotPrice(inRecord.balance, inRecord.denorm, outRecord.balance, outRecord.denorm, 0);\n    }\n\n    function joinPool(uint256 poolAmountOut, uint256[] calldata maxAmountsIn) external _logs_ _lock_ {\n        require(_finalized, \"ERR_NOT_FINALIZED\");\n\n        uint256 poolTotal = totalSupply();\n        uint256 ratio = bdiv(poolAmountOut, poolTotal);\n        require(ratio != 0, \"ERR_MATH_APPROX\");\n\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            address t = _tokens[i];\n            uint256 bal = _records[t].balance;\n            uint256 tokenAmountIn = bmul(ratio, bal);\n            require(tokenAmountIn != 0, \"ERR_MATH_APPROX\");\n            require(tokenAmountIn <= maxAmountsIn[i], \"ERR_LIMIT_IN\");\n            _records[t].balance = badd(_records[t].balance, tokenAmountIn);\n            emit LOG_JOIN(msg.sender, t, tokenAmountIn);\n            _pullUnderlying(t, msg.sender, tokenAmountIn);\n        }\n        _mintPoolShare(poolAmountOut);\n        _pushPoolShare(msg.sender, poolAmountOut);\n    }\n\n    function exitPool(uint256 poolAmountIn, uint256[] calldata minAmountsOut) external _logs_ _lock_ {\n        require(_finalized, \"ERR_NOT_FINALIZED\");\n\n        uint256 poolTotal = totalSupply();\n        uint256 exitFee = bmul(poolAmountIn, EXIT_FEE);\n        uint256 pAiAfterExitFee = bsub(poolAmountIn, exitFee);\n        uint256 ratio = bdiv(pAiAfterExitFee, poolTotal);\n        require(ratio != 0, \"ERR_MATH_APPROX\");\n\n        _pullPoolShare(msg.sender, poolAmountIn);\n        _pushPoolShare(_factory, exitFee);\n        _burnPoolShare(pAiAfterExitFee);\n\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            address t = _tokens[i];\n            uint256 bal = _records[t].balance;\n            uint256 tokenAmountOut = bmul(ratio, bal);\n            require(tokenAmountOut != 0, \"ERR_MATH_APPROX\");\n            require(tokenAmountOut >= minAmountsOut[i], \"ERR_LIMIT_OUT\");\n            _records[t].balance = bsub(_records[t].balance, tokenAmountOut);\n            emit LOG_EXIT(msg.sender, t, tokenAmountOut);\n            _pushUnderlying(t, msg.sender, tokenAmountOut);\n        }\n    }\n\n    function calcExitPool(uint256 poolAmountIn, uint256[] calldata minAmountsOut)\n        external\n        view\n        returns (uint256[] memory)\n    {\n        require(_finalized, \"ERR_NOT_FINALIZED\");\n\n        uint256 poolTotal = totalSupply();\n        uint256 exitFee = bmul(poolAmountIn, EXIT_FEE);\n        uint256 pAiAfterExitFee = bsub(poolAmountIn, exitFee);\n        uint256 ratio = bdiv(pAiAfterExitFee, poolTotal);\n\n        uint256[] memory _amounts = new uint256[](_tokens.length * 2);\n\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            address t = _tokens[i];\n            uint256 bal = _records[t].balance;\n\n            _amounts[i] = bmul(ratio, bal);\n            _amounts[_tokens.length + i] = minAmountsOut[i];\n            require(_amounts[i] >= minAmountsOut[i], \"ERR_LIMIT_OUT\");\n        }\n\n        return _amounts;\n    }\n\n    function swapExactAmountIn(\n        address tokenIn,\n        uint256 tokenAmountIn,\n        address tokenOut,\n        uint256 minAmountOut,\n        uint256 maxPrice\n    ) external _logs_ _lock_ returns (uint256 tokenAmountOut, uint256 spotPriceAfter) {\n        require(_records[tokenIn].bound, \"ERR_NOT_BOUND\");\n        require(_records[tokenOut].bound, \"ERR_NOT_BOUND\");\n        require(_publicSwap, \"ERR_SWAP_NOT_PUBLIC\");\n\n        Record storage inRecord = _records[address(tokenIn)];\n        Record storage outRecord = _records[address(tokenOut)];\n\n        require(tokenAmountIn <= bmul(inRecord.balance, MAX_IN_RATIO), \"ERR_MAX_IN_RATIO\");\n\n        uint256 spotPriceBefore =\n            calcSpotPrice(inRecord.balance, inRecord.denorm, outRecord.balance, outRecord.denorm, _swapFee);\n        require(spotPriceBefore <= maxPrice, \"ERR_BAD_LIMIT_PRICE\");\n\n        tokenAmountOut = calcOutGivenIn(\n            inRecord.balance,\n            inRecord.denorm,\n            outRecord.balance,\n            outRecord.denorm,\n            tokenAmountIn,\n            _swapFee\n        );\n        require(tokenAmountOut >= minAmountOut, \"ERR_LIMIT_OUT\");\n\n        inRecord.balance = badd(inRecord.balance, tokenAmountIn);\n        outRecord.balance = bsub(outRecord.balance, tokenAmountOut);\n\n        spotPriceAfter = calcSpotPrice(\n            inRecord.balance,\n            inRecord.denorm,\n            outRecord.balance,\n            outRecord.denorm,\n            _swapFee\n        );\n        require(spotPriceAfter >= spotPriceBefore, \"ERR_MATH_APPROX\");\n        require(spotPriceAfter <= maxPrice, \"ERR_LIMIT_PRICE\");\n        require(spotPriceBefore <= bdiv(tokenAmountIn, tokenAmountOut), \"ERR_MATH_APPROX\");\n\n        emit LOG_SWAP(msg.sender, tokenIn, tokenOut, tokenAmountIn, tokenAmountOut);\n\n        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\n        _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\n\n        return (tokenAmountOut, spotPriceAfter);\n    }\n\n    function swapExactAmountOut(\n        address tokenIn,\n        uint256 maxAmountIn,\n        address tokenOut,\n        uint256 tokenAmountOut,\n        uint256 maxPrice\n    ) external _logs_ _lock_ returns (uint256 tokenAmountIn, uint256 spotPriceAfter) {\n        require(_records[tokenIn].bound, \"ERR_NOT_BOUND\");\n        require(_records[tokenOut].bound, \"ERR_NOT_BOUND\");\n        require(_publicSwap, \"ERR_SWAP_NOT_PUBLIC\");\n\n        Record storage inRecord = _records[address(tokenIn)];\n        Record storage outRecord = _records[address(tokenOut)];\n\n        require(tokenAmountOut <= bmul(outRecord.balance, MAX_OUT_RATIO), \"ERR_MAX_OUT_RATIO\");\n\n        uint256 spotPriceBefore =\n            calcSpotPrice(inRecord.balance, inRecord.denorm, outRecord.balance, outRecord.denorm, _swapFee);\n        require(spotPriceBefore <= maxPrice, \"ERR_BAD_LIMIT_PRICE\");\n\n        tokenAmountIn = calcInGivenOut(\n            inRecord.balance,\n            inRecord.denorm,\n            outRecord.balance,\n            outRecord.denorm,\n            tokenAmountOut,\n            _swapFee\n        );\n        require(tokenAmountIn <= maxAmountIn, \"ERR_LIMIT_IN\");\n\n        inRecord.balance = badd(inRecord.balance, tokenAmountIn);\n        outRecord.balance = bsub(outRecord.balance, tokenAmountOut);\n\n        spotPriceAfter = calcSpotPrice(\n            inRecord.balance,\n            inRecord.denorm,\n            outRecord.balance,\n            outRecord.denorm,\n            _swapFee\n        );\n        require(spotPriceAfter >= spotPriceBefore, \"ERR_MATH_APPROX\");\n        require(spotPriceAfter <= maxPrice, \"ERR_LIMIT_PRICE\");\n        require(spotPriceBefore <= bdiv(tokenAmountIn, tokenAmountOut), \"ERR_MATH_APPROX\");\n\n        emit LOG_SWAP(msg.sender, tokenIn, tokenOut, tokenAmountIn, tokenAmountOut);\n\n        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\n        _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\n\n        return (tokenAmountIn, spotPriceAfter);\n    }\n\n    function joinswapExternAmountIn(\n        address tokenIn,\n        uint256 tokenAmountIn,\n        uint256 minPoolAmountOut\n    ) external _logs_ _lock_ returns (uint256 poolAmountOut) {\n        require(_finalized, \"ERR_NOT_FINALIZED\");\n        require(_records[tokenIn].bound, \"ERR_NOT_BOUND\");\n        require(tokenAmountIn <= bmul(_records[tokenIn].balance, MAX_IN_RATIO), \"ERR_MAX_IN_RATIO\");\n\n        Record storage inRecord = _records[tokenIn];\n\n        poolAmountOut = calcPoolOutGivenSingleIn(\n            inRecord.balance,\n            inRecord.denorm,\n            _totalSupply,\n            _totalWeight,\n            tokenAmountIn,\n            _swapFee\n        );\n\n        require(poolAmountOut >= minPoolAmountOut, \"ERR_LIMIT_OUT\");\n\n        inRecord.balance = badd(inRecord.balance, tokenAmountIn);\n\n        emit LOG_JOIN(msg.sender, tokenIn, tokenAmountIn);\n\n        _mintPoolShare(poolAmountOut);\n        _pushPoolShare(msg.sender, poolAmountOut);\n        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\n\n        return poolAmountOut;\n    }\n\n    function joinswapPoolAmountOut(\n        address tokenIn,\n        uint256 poolAmountOut,\n        uint256 maxAmountIn\n    ) external _logs_ _lock_ returns (uint256 tokenAmountIn) {\n        require(_finalized, \"ERR_NOT_FINALIZED\");\n        require(_records[tokenIn].bound, \"ERR_NOT_BOUND\");\n\n        Record storage inRecord = _records[tokenIn];\n\n        tokenAmountIn = calcSingleInGivenPoolOut(\n            inRecord.balance,\n            inRecord.denorm,\n            _totalSupply,\n            _totalWeight,\n            poolAmountOut,\n            _swapFee\n        );\n\n        require(tokenAmountIn != 0, \"ERR_MATH_APPROX\");\n        require(tokenAmountIn <= maxAmountIn, \"ERR_LIMIT_IN\");\n\n        require(tokenAmountIn <= bmul(_records[tokenIn].balance, MAX_IN_RATIO), \"ERR_MAX_IN_RATIO\");\n\n        inRecord.balance = badd(inRecord.balance, tokenAmountIn);\n\n        emit LOG_JOIN(msg.sender, tokenIn, tokenAmountIn);\n\n        _mintPoolShare(poolAmountOut);\n        _pushPoolShare(msg.sender, poolAmountOut);\n        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\n\n        return tokenAmountIn;\n    }\n\n    function exitswapPoolAmountIn(\n        address tokenOut,\n        uint256 poolAmountIn,\n        uint256 minAmountOut\n    ) external _logs_ _lock_ returns (uint256 tokenAmountOut) {\n        require(_finalized, \"ERR_NOT_FINALIZED\");\n        require(_records[tokenOut].bound, \"ERR_NOT_BOUND\");\n\n        Record storage outRecord = _records[tokenOut];\n\n        tokenAmountOut = calcSingleOutGivenPoolIn(\n            outRecord.balance,\n            outRecord.denorm,\n            _totalSupply,\n            _totalWeight,\n            poolAmountIn,\n            _swapFee\n        );\n\n        require(tokenAmountOut >= minAmountOut, \"ERR_LIMIT_OUT\");\n\n        require(tokenAmountOut <= bmul(_records[tokenOut].balance, MAX_OUT_RATIO), \"ERR_MAX_OUT_RATIO\");\n\n        outRecord.balance = bsub(outRecord.balance, tokenAmountOut);\n\n        uint256 exitFee = bmul(poolAmountIn, EXIT_FEE);\n\n        emit LOG_EXIT(msg.sender, tokenOut, tokenAmountOut);\n\n        _pullPoolShare(msg.sender, poolAmountIn);\n        _burnPoolShare(bsub(poolAmountIn, exitFee));\n        _pushPoolShare(_factory, exitFee);\n        _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\n\n        return tokenAmountOut;\n    }\n\n    function exitswapExternAmountOut(\n        address tokenOut,\n        uint256 tokenAmountOut,\n        uint256 maxPoolAmountIn\n    ) external _logs_ _lock_ returns (uint256 poolAmountIn) {\n        require(_finalized, \"ERR_NOT_FINALIZED\");\n        require(_records[tokenOut].bound, \"ERR_NOT_BOUND\");\n        require(tokenAmountOut <= bmul(_records[tokenOut].balance, MAX_OUT_RATIO), \"ERR_MAX_OUT_RATIO\");\n\n        Record storage outRecord = _records[tokenOut];\n\n        poolAmountIn = calcPoolInGivenSingleOut(\n            outRecord.balance,\n            outRecord.denorm,\n            _totalSupply,\n            _totalWeight,\n            tokenAmountOut,\n            _swapFee\n        );\n\n        require(poolAmountIn != 0, \"ERR_MATH_APPROX\");\n        require(poolAmountIn <= maxPoolAmountIn, \"ERR_LIMIT_IN\");\n\n        outRecord.balance = bsub(outRecord.balance, tokenAmountOut);\n\n        uint256 exitFee = bmul(poolAmountIn, EXIT_FEE);\n\n        emit LOG_EXIT(msg.sender, tokenOut, tokenAmountOut);\n\n        _pullPoolShare(msg.sender, poolAmountIn);\n        _burnPoolShare(bsub(poolAmountIn, exitFee));\n        _pushPoolShare(_factory, exitFee);\n        _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\n\n        return poolAmountIn;\n    }\n\n    // ==\n    // 'Underlying' token-manipulation functions make external calls but are NOT locked\n    // You must `_lock_` or otherwise ensure reentry-safety\n\n    function _pullUnderlying(\n        address erc20,\n        address from,\n        uint256 amount\n    ) internal {\n        bool xfer = IERC20Balancer(erc20).transferFrom(from, address(this), amount);\n        require(xfer, \"ERR_ERC20_FALSE\");\n    }\n\n    function _pushUnderlying(\n        address erc20,\n        address to,\n        uint256 amount\n    ) internal {\n        bool xfer = IERC20Balancer(erc20).transfer(to, amount);\n        require(xfer, \"ERR_ERC20_FALSE\");\n    }\n\n    function _pullPoolShare(address from, uint256 amount) internal {\n        _pull(from, amount);\n    }\n\n    function _pushPoolShare(address to, uint256 amount) internal {\n        _push(to, amount);\n    }\n\n    function _mintPoolShare(uint256 amount) internal {\n        _mint(amount);\n    }\n\n    function _burnPoolShare(uint256 amount) internal {\n        _burn(amount);\n    }\n}\n"
    },
    "contracts/balancer/BToken.sol": {
      "content": "// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./BNum.sol\";\n\ninterface IERC20Balancer {\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address whom) external view returns (uint256);\n\n    function allowance(address src, address dst) external view returns (uint256);\n\n    function approve(address dst, uint256 amt) external returns (bool);\n\n    function transfer(address dst, uint256 amt) external returns (bool);\n\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 amt\n    ) external returns (bool);\n}\n\ncontract BTokenBase is BNum {\n    mapping(address => uint256) internal _balance;\n    mapping(address => mapping(address => uint256)) internal _allowance;\n    uint256 internal _totalSupply;\n\n    event Approval(address indexed src, address indexed dst, uint256 amt);\n    event Transfer(address indexed src, address indexed dst, uint256 amt);\n\n    function _mint(uint256 amt) internal {\n        _balance[address(this)] = badd(_balance[address(this)], amt);\n        _totalSupply = badd(_totalSupply, amt);\n        emit Transfer(address(0), address(this), amt);\n    }\n\n    function _burn(uint256 amt) internal {\n        require(_balance[address(this)] >= amt, \"ERR_INSUFFICIENT_BAL\");\n        _balance[address(this)] = bsub(_balance[address(this)], amt);\n        _totalSupply = bsub(_totalSupply, amt);\n        emit Transfer(address(this), address(0), amt);\n    }\n\n    function _move(\n        address src,\n        address dst,\n        uint256 amt\n    ) internal {\n        require(_balance[src] >= amt, \"ERR_INSUFFICIENT_BAL\");\n        _balance[src] = bsub(_balance[src], amt);\n        _balance[dst] = badd(_balance[dst], amt);\n        emit Transfer(src, dst, amt);\n    }\n\n    function _push(address to, uint256 amt) internal {\n        _move(address(this), to, amt);\n    }\n\n    function _pull(address from, uint256 amt) internal {\n        _move(from, address(this), amt);\n    }\n}\n\ncontract BToken is BTokenBase, IERC20Balancer {\n    string private _name = \"Balancer Pool Token\";\n    string private _symbol = \"BPT\";\n    uint8 private _decimals = 18;\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    function allowance(address src, address dst) external view override returns (uint256) {\n        return _allowance[src][dst];\n    }\n\n    function balanceOf(address whom) external view override returns (uint256) {\n        return _balance[whom];\n    }\n\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    function approve(address dst, uint256 amt) external override returns (bool) {\n        _allowance[msg.sender][dst] = amt;\n        emit Approval(msg.sender, dst, amt);\n        return true;\n    }\n\n    function increaseApproval(address dst, uint256 amt) external returns (bool) {\n        _allowance[msg.sender][dst] = badd(_allowance[msg.sender][dst], amt);\n        emit Approval(msg.sender, dst, _allowance[msg.sender][dst]);\n        return true;\n    }\n\n    function decreaseApproval(address dst, uint256 amt) external returns (bool) {\n        uint256 oldValue = _allowance[msg.sender][dst];\n        if (amt > oldValue) {\n            _allowance[msg.sender][dst] = 0;\n        } else {\n            _allowance[msg.sender][dst] = bsub(oldValue, amt);\n        }\n        emit Approval(msg.sender, dst, _allowance[msg.sender][dst]);\n        return true;\n    }\n\n    function transfer(address dst, uint256 amt) external override returns (bool) {\n        _move(msg.sender, dst, amt);\n        return true;\n    }\n\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 amt\n    ) external override returns (bool) {\n        require(msg.sender == src || amt <= _allowance[src][msg.sender], \"ERR_BTOKEN_BAD_CALLER\");\n        _move(src, dst, amt);\n        if (msg.sender != src && _allowance[src][msg.sender] != type(uint256).max) {\n            _allowance[src][msg.sender] = bsub(_allowance[src][msg.sender], amt);\n            emit Approval(msg.sender, dst, _allowance[src][msg.sender]);\n        }\n        return true;\n    }\n}\n"
    },
    "contracts/balancer/BMath.sol": {
      "content": "// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./BNum.sol\";\n\ncontract BMath is BBronze, BConst, BNum {\n    /**********************************************************************************************\n    // calcSpotPrice                                                                             //\n    // sP = spotPrice                                                                            //\n    // bI = tokenBalanceIn                ( bI / wI )         1                                  //\n    // bO = tokenBalanceOut         sP =  -----------  *  ----------                             //\n    // wI = tokenWeightIn                 ( bO / wO )     ( 1 - sF )                             //\n    // wO = tokenWeightOut                                                                       //\n    // sF = swapFee                                                                              //\n    **********************************************************************************************/\n    function calcSpotPrice(\n        uint256 tokenBalanceIn,\n        uint256 tokenWeightIn,\n        uint256 tokenBalanceOut,\n        uint256 tokenWeightOut,\n        uint256 swapFee\n    ) public pure returns (uint256 spotPrice) {\n        uint256 numer = bdiv(tokenBalanceIn, tokenWeightIn);\n        uint256 denom = bdiv(tokenBalanceOut, tokenWeightOut);\n        uint256 ratio = bdiv(numer, denom);\n        uint256 scale = bdiv(BONE, bsub(BONE, swapFee));\n        return (spotPrice = bmul(ratio, scale));\n    }\n\n    /**********************************************************************************************\n    // calcOutGivenIn                                                                            //\n    // aO = tokenAmountOut                                                                       //\n    // bO = tokenBalanceOut                                                                      //\n    // bI = tokenBalanceIn              /      /            bI             \\    (wI / wO) \\      //\n    // aI = tokenAmountIn    aO = bO * |  1 - | --------------------------  | ^            |     //\n    // wI = tokenWeightIn               \\      \\ ( bI + ( aI * ( 1 - sF )) /              /      //\n    // wO = tokenWeightOut                                                                       //\n    // sF = swapFee                                                                              //\n    **********************************************************************************************/\n    function calcOutGivenIn(\n        uint256 tokenBalanceIn,\n        uint256 tokenWeightIn,\n        uint256 tokenBalanceOut,\n        uint256 tokenWeightOut,\n        uint256 tokenAmountIn,\n        uint256 swapFee\n    ) public pure returns (uint256 tokenAmountOut) {\n        uint256 weightRatio = bdiv(tokenWeightIn, tokenWeightOut);\n        uint256 adjustedIn = bsub(BONE, swapFee);\n        adjustedIn = bmul(tokenAmountIn, adjustedIn);\n        uint256 y = bdiv(tokenBalanceIn, badd(tokenBalanceIn, adjustedIn));\n        uint256 foo = bpow(y, weightRatio);\n        uint256 bar = bsub(BONE, foo);\n        tokenAmountOut = bmul(tokenBalanceOut, bar);\n        return tokenAmountOut;\n    }\n\n    /**********************************************************************************************\n    // calcInGivenOut                                                                            //\n    // aI = tokenAmountIn                                                                        //\n    // bO = tokenBalanceOut               /  /     bO      \\    (wO / wI)      \\                 //\n    // bI = tokenBalanceIn          bI * |  | ------------  | ^            - 1  |                //\n    // aO = tokenAmountOut    aI =        \\  \\ ( bO - aO ) /                   /                 //\n    // wI = tokenWeightIn           --------------------------------------------                 //\n    // wO = tokenWeightOut                          ( 1 - sF )                                   //\n    // sF = swapFee                                                                              //\n    **********************************************************************************************/\n    function calcInGivenOut(\n        uint256 tokenBalanceIn,\n        uint256 tokenWeightIn,\n        uint256 tokenBalanceOut,\n        uint256 tokenWeightOut,\n        uint256 tokenAmountOut,\n        uint256 swapFee\n    ) public pure returns (uint256 tokenAmountIn) {\n        uint256 weightRatio = bdiv(tokenWeightOut, tokenWeightIn);\n        uint256 diff = bsub(tokenBalanceOut, tokenAmountOut);\n        uint256 y = bdiv(tokenBalanceOut, diff);\n        uint256 foo = bpow(y, weightRatio);\n        foo = bsub(foo, BONE);\n        tokenAmountIn = bsub(BONE, swapFee);\n        tokenAmountIn = bdiv(bmul(tokenBalanceIn, foo), tokenAmountIn);\n        return tokenAmountIn;\n    }\n\n    /**********************************************************************************************\n    // calcPoolOutGivenSingleIn                                                                  //\n    // pAo = poolAmountOut         /                                              \\              //\n    // tAi = tokenAmountIn        ///      /     //    wI \\      \\\\       \\     wI \\             //\n    // wI = tokenWeightIn        //| tAi *| 1 - || 1 - --  | * sF || + tBi \\    --  \\            //\n    // tW = totalWeight     pAo=||  \\      \\     \\\\    tW /      //         | ^ tW   | * pS - pS //\n    // tBi = tokenBalanceIn      \\\\  ------------------------------------- /        /            //\n    // pS = poolSupply            \\\\                    tBi               /        /             //\n    // sF = swapFee                \\                                              /              //\n    **********************************************************************************************/\n\n    // Charge the trading fee for the proportion of tokenAi\n    ///  which is implicitly traded to the other pool tokens.\n    // That proportion is (1- weightTokenIn)\n    // tokenAiAfterFee = tAi * (1 - (1-weightTi) * poolFee);\n\n    function calcPoolOutGivenSingleIn(\n        uint256 tokenBalanceIn,\n        uint256 tokenWeightIn,\n        uint256 poolSupply,\n        uint256 totalWeight,\n        uint256 tokenAmountIn,\n        uint256 swapFee\n    ) public pure returns (uint256 poolAmountOut) {\n        uint256 normalizedWeight = bdiv(tokenWeightIn, totalWeight);\n        uint256 zaz = bmul(bsub(BONE, normalizedWeight), swapFee);\n        uint256 tokenAmountInAfterFee = bmul(tokenAmountIn, bsub(BONE, zaz));\n\n        uint256 newTokenBalanceIn = badd(tokenBalanceIn, tokenAmountInAfterFee);\n        uint256 tokenInRatio = bdiv(newTokenBalanceIn, tokenBalanceIn);\n\n        // uint newPoolSupply = (ratioTi ^ weightTi) * poolSupply;\n        uint256 poolRatio = bpow(tokenInRatio, normalizedWeight);\n        uint256 newPoolSupply = bmul(poolRatio, poolSupply);\n        poolAmountOut = bsub(newPoolSupply, poolSupply);\n        return poolAmountOut;\n    }\n\n    /**********************************************************************************************\n    // calcSingleInGivenPoolOut                                                                  //\n    // tAi = tokenAmountIn              //(pS + pAo)\\     /    1    \\\\                           //\n    // pS = poolSupply                 || ---------  | ^ | --------- || * bI - bI                //\n    // pAo = poolAmountOut              \\\\    pS    /     \\(wI / tW)//                           //\n    // bI = balanceIn          tAi =  --------------------------------------------               //\n    // wI = weightIn                              /      wI  \\                                   //\n    // tW = totalWeight                          |  1 - ----  |  * sF                            //\n    // sF = swapFee                               \\      tW  /                                   //\n    **********************************************************************************************/\n    function calcSingleInGivenPoolOut(\n        uint256 tokenBalanceIn,\n        uint256 tokenWeightIn,\n        uint256 poolSupply,\n        uint256 totalWeight,\n        uint256 poolAmountOut,\n        uint256 swapFee\n    ) public pure returns (uint256 tokenAmountIn) {\n        uint256 normalizedWeight = bdiv(tokenWeightIn, totalWeight);\n        uint256 newPoolSupply = badd(poolSupply, poolAmountOut);\n        uint256 poolRatio = bdiv(newPoolSupply, poolSupply);\n\n        //uint newBalTi = poolRatio^(1/weightTi) * balTi;\n        uint256 boo = bdiv(BONE, normalizedWeight);\n        uint256 tokenInRatio = bpow(poolRatio, boo);\n        uint256 newTokenBalanceIn = bmul(tokenInRatio, tokenBalanceIn);\n        uint256 tokenAmountInAfterFee = bsub(newTokenBalanceIn, tokenBalanceIn);\n        // Do reverse order of fees charged in joinswap_ExternAmountIn, this way\n        //     ``` pAo == joinswap_ExternAmountIn(Ti, joinswap_PoolAmountOut(pAo, Ti)) ```\n        //uint tAi = tAiAfterFee / (1 - (1-weightTi) * swapFee) ;\n        uint256 zar = bmul(bsub(BONE, normalizedWeight), swapFee);\n        tokenAmountIn = bdiv(tokenAmountInAfterFee, bsub(BONE, zar));\n        return tokenAmountIn;\n    }\n\n    /**********************************************************************************************\n    // calcSingleOutGivenPoolIn                                                                  //\n    // tAo = tokenAmountOut            /      /                                             \\\\   //\n    // bO = tokenBalanceOut           /      // pS - (pAi * (1 - eF)) \\     /    1    \\      \\\\  //\n    // pAi = poolAmountIn            | bO - || ----------------------- | ^ | --------- | * b0 || //\n    // ps = poolSupply                \\      \\\\          pS           /     \\(wO / tW)/      //  //\n    // wI = tokenWeightIn      tAo =   \\      \\                                             //   //\n    // tW = totalWeight                    /     /      wO \\       \\                             //\n    // sF = swapFee                    *  | 1 - |  1 - ---- | * sF  |                            //\n    // eF = exitFee                        \\     \\      tW /       /                             //\n    **********************************************************************************************/\n    function calcSingleOutGivenPoolIn(\n        uint256 tokenBalanceOut,\n        uint256 tokenWeightOut,\n        uint256 poolSupply,\n        uint256 totalWeight,\n        uint256 poolAmountIn,\n        uint256 swapFee\n    ) public pure returns (uint256 tokenAmountOut) {\n        uint256 normalizedWeight = bdiv(tokenWeightOut, totalWeight);\n        // charge exit fee on the pool token side\n        // pAiAfterExitFee = pAi*(1-exitFee)\n        uint256 poolAmountInAfterExitFee = bmul(poolAmountIn, bsub(BONE, EXIT_FEE));\n        uint256 newPoolSupply = bsub(poolSupply, poolAmountInAfterExitFee);\n        uint256 poolRatio = bdiv(newPoolSupply, poolSupply);\n\n        // newBalTo = poolRatio^(1/weightTo) * balTo;\n        uint256 tokenOutRatio = bpow(poolRatio, bdiv(BONE, normalizedWeight));\n        uint256 newTokenBalanceOut = bmul(tokenOutRatio, tokenBalanceOut);\n\n        uint256 tokenAmountOutBeforeSwapFee = bsub(tokenBalanceOut, newTokenBalanceOut);\n\n        // charge swap fee on the output token side\n        //uint tAo = tAoBeforeSwapFee * (1 - (1-weightTo) * swapFee)\n        uint256 zaz = bmul(bsub(BONE, normalizedWeight), swapFee);\n        tokenAmountOut = bmul(tokenAmountOutBeforeSwapFee, bsub(BONE, zaz));\n        return tokenAmountOut;\n    }\n\n    /**********************************************************************************************\n    // calcPoolInGivenSingleOut                                                                  //\n    // pAi = poolAmountIn               // /               tAo             \\\\     / wO \\     \\   //\n    // bO = tokenBalanceOut            // | bO - -------------------------- |\\   | ---- |     \\  //\n    // tAo = tokenAmountOut      pS - ||   \\     1 - ((1 - (tO / tW)) * sF)/  | ^ \\ tW /  * pS | //\n    // ps = poolSupply                 \\\\ -----------------------------------/                /  //\n    // wO = tokenWeightOut  pAi =       \\\\               bO                 /                /   //\n    // tW = totalWeight           -------------------------------------------------------------  //\n    // sF = swapFee                                        ( 1 - eF )                            //\n    // eF = exitFee                                                                              //\n    **********************************************************************************************/\n    function calcPoolInGivenSingleOut(\n        uint256 tokenBalanceOut,\n        uint256 tokenWeightOut,\n        uint256 poolSupply,\n        uint256 totalWeight,\n        uint256 tokenAmountOut,\n        uint256 swapFee\n    ) public pure returns (uint256 poolAmountIn) {\n        // charge swap fee on the output token side\n        uint256 normalizedWeight = bdiv(tokenWeightOut, totalWeight);\n        //uint tAoBeforeSwapFee = tAo / (1 - (1-weightTo) * swapFee) ;\n        uint256 zoo = bsub(BONE, normalizedWeight);\n        uint256 zar = bmul(zoo, swapFee);\n        uint256 tokenAmountOutBeforeSwapFee = bdiv(tokenAmountOut, bsub(BONE, zar));\n\n        uint256 newTokenBalanceOut = bsub(tokenBalanceOut, tokenAmountOutBeforeSwapFee);\n        uint256 tokenOutRatio = bdiv(newTokenBalanceOut, tokenBalanceOut);\n\n        //uint newPoolSupply = (ratioTo ^ weightTo) * poolSupply;\n        uint256 poolRatio = bpow(tokenOutRatio, normalizedWeight);\n        uint256 newPoolSupply = bmul(poolRatio, poolSupply);\n        uint256 poolAmountInAfterExitFee = bsub(poolSupply, newPoolSupply);\n\n        // charge exit fee on the pool token side\n        // pAi = pAiAfterExitFee/(1-exitFee)\n        poolAmountIn = bdiv(poolAmountInAfterExitFee, bsub(BONE, EXIT_FEE));\n        return poolAmountIn;\n    }\n}\n"
    },
    "contracts/libraries/IERC20Full.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IERC20Full is IERC20 {\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/turbo/TurboShareTokenFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./OwnedShareToken.sol\";\n\n\n\nabstract contract ZCBFactory {\n    function createZCB(string memory _name, address _owner) internal returns(OwnedERC20[] memory){\n        uint256 _numOutcomes = 1; \n        OwnedERC20[] memory _tokens = new OwnedERC20[](_numOutcomes);\n\n        for (uint256 _i = 0; _i < _numOutcomes; _i++) {\n            _tokens[_i] = new OwnedERC20(_name, _name, _owner);\n        }\n        return _tokens; \n    }\n}\n\n\nabstract contract TurboShareTokenFactory {\n    function createShareTokens(string[] memory _names, address _owner) internal returns (OwnedERC20[] memory) {\n        uint256 _numOutcomes = _names.length;\n        OwnedERC20[] memory _tokens = new OwnedERC20[](_numOutcomes);\n\n        for (uint256 _i = 0; _i < _numOutcomes; _i++) {\n            _tokens[_i] = new OwnedERC20(_names[_i], _names[_i], _owner);\n        }\n        return _tokens;\n    }\n}\n\nabstract contract TurboShareTokenFactoryV1 {\n    function createShareTokens(\n        string[] memory _names,\n        string[] memory _symbols,\n        address _owner\n    ) internal returns (OwnedERC20[] memory) {\n        uint256 _numOutcomes = _names.length;\n        OwnedERC20[] memory _tokens = new OwnedERC20[](_numOutcomes);\n\n        for (uint256 _i = 0; _i < _numOutcomes; _i++) {\n            _tokens[_i] = new OwnedERC20(_names[_i], _symbols[_i], _owner);\n        }\n        return _tokens;\n    }\n}\n"
    },
    "contracts/turbo/FeePot.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"../libraries/IERC20Full.sol\";\n\ncontract FeePot is ERC20 {\n    using SafeMath for uint256;\n\n    uint256 internal constant magnitude = 2**128;\n\n    IERC20Full public collateral;\n    IERC20Full public reputationToken;\n\n    uint256 public magnifiedFeesPerShare;\n\n    mapping(address => uint256) public magnifiedFeesCorrections;\n    mapping(address => uint256) public storedFees;\n\n    uint256 public feeReserve;\n\n    constructor(IERC20Full _collateral, IERC20Full _reputationToken)\n        ERC20(\n            string(abi.encodePacked(\"S_\", _reputationToken.symbol())),\n            string(abi.encodePacked(\"S_\", _reputationToken.symbol()))\n        )\n    {\n        collateral = _collateral;\n        reputationToken = _reputationToken;\n\n        require(_collateral != IERC20Full(address(0)));\n    }\n\n    function depositFees(uint256 _amount) public returns (bool) {\n        collateral.transferFrom(msg.sender, address(this), _amount);\n        uint256 _totalSupply = totalSupply(); // after collateral.transferFrom to prevent reentrancy causing stale totalSupply\n        if (_totalSupply == 0) {\n            feeReserve = feeReserve.add(_amount);\n            return true;\n        }\n        if (feeReserve > 0) {\n            _amount = _amount.add(feeReserve);\n            feeReserve = 0;\n        }\n        magnifiedFeesPerShare = magnifiedFeesPerShare.add((_amount).mul(magnitude) / _totalSupply);\n        return true;\n    }\n\n    function withdrawableFeesOf(address _owner) public view returns (uint256) {\n        return earnedFeesOf(_owner).add(storedFees[_owner]);\n    }\n\n    function earnedFeesOf(address _owner) public view returns (uint256) {\n        uint256 _ownerBalance = balanceOf(_owner);\n        uint256 _magnifiedFees = magnifiedFeesPerShare.mul(_ownerBalance);\n        return _magnifiedFees.sub(magnifiedFeesCorrections[_owner]) / magnitude;\n    }\n\n    function _transfer(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) internal override {\n        storedFees[_from] = storedFees[_from].add(earnedFeesOf(_from));\n        super._transfer(_from, _to, _amount);\n\n        magnifiedFeesCorrections[_from] = magnifiedFeesPerShare.mul(balanceOf(_from));\n        magnifiedFeesCorrections[_to] = magnifiedFeesCorrections[_to].add(magnifiedFeesPerShare.mul(_amount));\n    }\n\n    function stake(uint256 _amount) external returns (bool) {\n        reputationToken.transferFrom(msg.sender, address(this), _amount);\n        _mint(msg.sender, _amount);\n        magnifiedFeesCorrections[msg.sender] = magnifiedFeesCorrections[msg.sender].add(\n            magnifiedFeesPerShare.mul(_amount)\n        );\n        return true;\n    }\n\n    function exit(uint256 _amount) external returns (bool) {\n        redeemInternal(msg.sender);\n        _burn(msg.sender, _amount);\n        reputationToken.transfer(msg.sender, _amount);\n        magnifiedFeesCorrections[msg.sender] = magnifiedFeesPerShare.mul(balanceOf(msg.sender));\n        return true;\n    }\n\n    function redeem() public returns (bool) {\n        redeemInternal(msg.sender);\n        magnifiedFeesCorrections[msg.sender] = magnifiedFeesPerShare.mul(balanceOf(msg.sender));\n        return true;\n    }\n\n    function redeemInternal(address _account) internal {\n        uint256 _withdrawableFees = withdrawableFeesOf(_account);\n        if (_withdrawableFees > 0) {\n            storedFees[_account] = 0;\n            collateral.transfer(_account, _withdrawableFees);\n        }\n    }\n}\n"
    },
    "contracts/libraries/Rewardable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nabstract contract Rewardable {\n    // Rewards will be paid out over the lifetime of an event.\n    // An value of zero will start rewards immediately and proceed based on the values set in master chef.\n\n    // _Id here is the market id passed to the amm factory when creating a pool.\n    function getRewardEndTime(uint256 _marketId) public view virtual returns (uint256);\n}\n"
    },
    "contracts/bonds/LinearBondingCurve.sol": {
      "content": "pragma solidity ^0.8.4;\n\nimport {BondingCurve} from \"./bondingcurve.sol\";\nimport {FixedPointMathLib} from \"solmate/src/utils/FixedPointMathLib.sol\";\nimport \"hardhat/console.sol\";\n\n/// @notice y = a * x + b\n/// @dev NEED TO REDO FOR GAS EFFICIENT\ncontract LinearBondingCurve is BondingCurve {\n  // ASSUMES 18 TRAILING DECIMALS IN UINT256\n  using FixedPointMathLib for uint256;\n  uint256 a;\n  uint256 b;\n\n  constructor (\n      string memory name,\n      string memory symbol,\n      address owner,\n      address collateral,\n      uint256 _a,\n      uint256 _b\n  ) BondingCurve(name, symbol, owner, collateral) {\n      a = _a;\n      b = _b;\n  }\n  /**\n   @dev tokens returned = [((a*s + b)^2 + 2*a*p)^(1/2) - (a*s + b)] / a\n   @param amount: amount collateral in => has collateral decimal number.\n   tokens returned in 60.18\n   */\n  function _calculatePurchaseReturn(uint256 amount) view internal override virtual returns(uint256) {\n    uint256 s = totalSupply() ;\n    uint256 _amount = amount * 10 ** (18 - collateral_dec);\n    console.log('s', s, a); \n    console.log('b', b); \n\n    uint256 x = ((a.mulWadDown(s) + b) ** 2)/math_precision; \n    console.log('x', x); \n\n    uint256 y = 2*( a.mulWadDown(_amount)); \n    console.log('y', y); \n\n    uint256 x_y_sqrt = ((x+y)*math_precision).sqrt();\n    console.log('x_y_sqrt', x_y_sqrt); \n\n    uint256 z = (a.mulWadDown(s) + b); \n    console.log('z', z); \n\n    uint256 result = (x_y_sqrt-z).divWadDown(a);\n    console.log('result', result); \n\n    return result; \n\n\n      // uint256 two = uint256(2).fromUint();\n      // result = (((a.mul(s) + b).pow(two) + two.mul(a).mul(amount)).sqrt() - (a.mul(s) + b)).div(a);\n      //result = ( ( ( ((a.mulWadDown(s) + b) ** 2)/math_precision + 2 * a.mulWadDown(_amount) ) * math_precision ).sqrt() - (a.mulWadDown(s) + b) ).divWadDown(a);\n  }\n\n  /// @notice calculates area under the curve from current supply to s+amount\n  /// result = a * amount / 2  * (2* supply + amount) + b * amount\n  /// @dev amount is in 60.18.\n  /// returned in collateral decimals\n  function _calcAreaUnderCurve(uint256 amount) internal view override virtual returns(uint256){\n    uint256 s = totalSupply(); \n\n    uint256 result = ( a.mulWadDown(amount) / 2 ).mulWadDown(2 * s + amount) + b.mulWadDown(amount); \n    console.log('result', result); \n    result /= (10 ** (18 - collateral_dec));\n\n    return result; \n  }\n\n  /**\n   @notice calculates area under curve from s-amount to s, is c(as-ac/2+b) where c is amount \n   @dev collateral tokens returned\n   @param amount: tokens burning => 60.18 amount needs to be in 18 decimal \n   @dev returns amount of collateral tokens with collateral decimals\n   */\n  function _calculateSaleReturn(uint256 amount) view internal override virtual returns (uint256) {\n    uint s = totalSupply();\n\n    console.log('amount', amount, s); \n\n    uint256 x = a.mulWadDown(s); \n    console.log('x', x); \n    uint256 y = a.mulWadDown(amount)/2; \n    console.log('y', y); \n    uint256 z = b + x - y; \n    console.log('z', z); \n    uint256 result = amount.mulWadDown(z); \n    console.log('result', result); \n\n    result = result / (10 ** (18 - collateral_dec));\n\n    return result; \n    \n    // uint256 _reserves = reserves * 10 ** (18 - collateral_dec);\n\n    // console.log(\"_reserves\", _reserves);\n    // result = _reserves - ( (a / 2).mulWadDown((((s - amount)**2) / math_precision)) + b.mulWadDown(s - amount) );\n    // console.log(\"s - amount\", s - amount);\n    // result /= (10 ** (18 - collateral_dec));\n  }\n\n  /**\n   @param amount: amount added in 60.18\n   @dev returns price in 60.18\n   */\n  function _calculateExpectedPrice(uint256 amount) view internal override virtual returns (uint256 result) {\n    uint256 s = totalSupply();\n\n    result = (s + amount).mulWadDown(a) + b;\n  }\n\n  function _calculateDecreasedPrice(uint256 amount) view internal override virtual returns (uint256 result) {\n    result = (totalSupply() - amount).mulWadDown(a) + b;\n  }\n\n  /**\n   @notice probability = a * x + b, 60.18\n   returns probability in 60.18\n   */\n  function _calculateProbability(uint256 amount) view internal override virtual returns (uint256 score) {\n      //score = amount.mul(a) + b;\n    score = amount.mulWadDown(a) + b;\n  }\n\n\n\n function _calculateScore(uint256 priceOut, bool atLoss)view internal override virtual returns (uint256 score) {\n      // uint256 two = uint256(2).fromUint();\n      // if (atLoss) {score =  ((priceOut-math_precision).div(math_precision)).pow(two);}\n      // else {score = ((priceOut).div(math_precision)).pow(two);}\n    if (atLoss) {\n        score = ((priceOut - math_precision) ** 2) / math_precision;\n    } else {\n        score = (priceOut ** 2) / math_precision;\n    }\n\n  }\n\n  function getParams() public view returns(uint,uint){\n    return (a,b); \n  }\n}"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "contracts/turbo/OwnedShareToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"../libraries/Ownable.sol\";\n\ncontract OwnedERC20 is ERC20, Ownable {\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        address _owner\n    ) ERC20(name_, symbol_) {\n        owner = _owner;\n    }\n\n    function trustedTransfer(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) external onlyOwner {\n        _transfer(_from, _to, _amount);\n    }\n\n    function trustedMint(address _target, uint256 _amount) external virtual onlyOwner {\n        _mint(_target, _amount);\n    }\n\n    function trustedBurn(address _target, uint256 _amount) external virtual onlyOwner {\n        _burn(_target, _amount);\n    }\n\n    function trustedBurnAll(address _target) external onlyOwner returns (uint256) {\n        uint256 _balance = balanceOf(_target);\n        _burn(_target, _balance);\n        return _balance;\n    }\n\n    function onTransferOwnership(address, address) internal override {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "contracts/libraries/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./IOwnable.sol\";\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\nabstract contract Ownable is IOwnable {\n    address internal owner;\n\n    /**\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n     * account.\n     */\n    constructor() {\n        owner = msg.sender;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function getOwner() public view override returns (address) {\n        return owner;\n    }\n\n    /**\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n     * @param _newOwner The address to transfer ownership to.\n     */\n    function transferOwnership(address _newOwner) public override onlyOwner returns (bool) {\n        require(_newOwner != address(0));\n        onTransferOwnership(owner, _newOwner);\n        owner = _newOwner;\n        return true;\n    }\n\n    // Subclasses of this token may want to send additional logs through the centralized Augur log emitter contract\n    function onTransferOwnership(address, address) internal virtual;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/libraries/IOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ninterface IOwnable {\n    function getOwner() external view returns (address);\n\n    function transferOwnership(address _newOwner) external returns (bool);\n}\n"
    },
    "contracts/bonds/bondingcurve.sol": {
      "content": "pragma solidity ^0.8.4;\nimport {OwnedERC20} from \"../turbo/OwnedShareToken.sol\";\nimport \"hardhat/console.sol\";\n//import \"../prb/PRBMathUD60x18.sol\";\nimport {FixedPointMathLib} from \"solmate/src/utils/FixedPointMathLib.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n//TODO need to actually review for security and shit.\nabstract contract BondingCurve is OwnedERC20 {\n    // ASSUMES 18 TRAILING DECIMALS IN UINT256\n    using SafeERC20 for ERC20;\n    using FixedPointMathLib for uint256;\n\n    uint256 internal price_upper_bound;\n    uint256 internal price_lower_bound;\n    uint256 internal reserves;\n    uint256 internal max_quantity;\n    uint256 internal math_precision; \n    uint256 internal collateral_dec;\n    ERC20 collateral; // NEED TO CHANGE ONCE VAULT IS DONE\n    address[] private buyers; // keeps track for final reputation.\n\n\n    constructor (\n        string memory name,\n        string memory symbol,\n        address owner, // market manager.\n        address _collateral\n    ) OwnedERC20(name, symbol, owner) {\n        collateral = ERC20(_collateral);\n        math_precision = 1e18;\n        collateral_dec = collateral.decimals();\n    }\n\n    function setUpperBound(uint256 upper_bound) public onlyOwner {\n        price_upper_bound = upper_bound;\n    }\n\n    function setLowerBound(uint256 lower_bound) public onlyOwner {\n        price_lower_bound = lower_bound;\n    }\n\n    function setMaxQuantity(uint256 _max_quantity) public onlyOwner {\n        max_quantity = _max_quantity;\n    }\n\n    /**\n     @notice called by market manager, like trustedMint but returns amount out\n     @param collateral_amount: amount of collateral in. => w/ collateral decimals\n     */\n    function trustedBuy(address trader, uint256 collateral_amount) public onlyOwner returns (uint256) {\n        uint256 tokens = _calculatePurchaseReturn(collateral_amount);\n        console.log('TOKENS', tokens, collateral_amount); \n        reserves += collateral_amount;\n\n        require(collateral.balanceOf(trader)>= collateral_amount,\"not enough balance\"); \n        collateral.safeTransferFrom(trader, address(this), collateral_amount);\n        _mint(trader, tokens);\n        return tokens;\n    }\n\n    /**\n     @param zcb_amount: amount of zcb tokens burned, needs to be in 18 decimals \n     */\n    function trustedSell(address trader, uint256 zcb_amount) public onlyOwner returns (uint256) {\n        uint256 collateral_out = _calculateSaleReturn(zcb_amount);\n        console.log(\"colalteralout\", collateral_out); \n        _burn(trader, zcb_amount);\n\n        collateral.safeTransfer(trader, collateral_out);\n        reserves -= collateral_out;\n        return collateral_out;\n    }\n\n    function trustedApproveCollateralTransfer(address trader, uint256 amount) public onlyOwner {\n        collateral.approve(trader, amount);\n    }\n\n    /**\n     @notice calculates tokens returns from input collateral\n     @dev shouldn't be calling this function, should be calculating amount from frontend.\n     @param amount: input collateral (ds)\n     */\n    function calculatePurchaseReturn(uint256 amount) public view  returns (uint256 result) {\n        result = _calculatePurchaseReturn(amount);\n    }\n\n\n    /// @notice gets required amount of collateral to purchase X amount of tokens\n    /// need to get area under the curve from current supply X_  to X_+X \n    function calcAreaUnderCurve(uint256 amount) public view  returns(uint){\n    \t  return _calcAreaUnderCurve(amount); \n    }\n\n    /**\n     @notice calculates collateral returns from selling tokens\n     @param amount: amount of tokens selling\n     */\n    function calculateSaleReturn(uint256 amount) public view  returns (uint256 result) {\n        result = _calculateSaleReturn(amount);\n    }\n\n    /// @notice calculates score necessary to update reputation score\n    function calculateScore(uint256 priceOut, bool atLoss) public view returns(uint){\n    \treturn _calculateScore(priceOut, atLoss);\n    }\n\n\n\n    /// @notice calculates implied probability of the trader \n    /// @param quantity is the ratio amount(in colalteral) / total collateral budget for trader, in 18 decimals \n    function calcImpliedProbability(uint256 collateral_amount, uint256 quantity) public view returns(uint256 prob){\n    \tuint256 zcb_amount = calculatePurchaseReturn(collateral_amount); \n    \tconsole.log('zcb_amount', zcb_amount); \n    \t//uint256 avg_price = collateral_amount/zcb_amount; \n    \tuint256 avg_price = calcAveragePrice(zcb_amount); //18 decimals \n    \tconsole.log('avg_price', avg_price); \n    \tuint256 b = avg_price.mulWadDown(math_precision - avg_price);\n    \tconsole.log('b', b);\n    \tuint256 prob = quantity.mulWadDown(b)+ avg_price; \n    \treturn prob; \n    }\n\n    /// @notice caluclates average price for the user to buy amount tokens \n    /// @dev which is average under the curve divided by amount \n    /// amount is the amount of bonds, 18 decimals \n    function calcAveragePrice(uint256 amount) public view returns(uint256){\n\n    \tuint256 area = calcAreaUnderCurve(amount); //this takes in 18 \n    \tconsole.log(\"area\", area); \n\n    \t//area is in decimal 6, amount is in 18\n    \tuint256 area_in_precision = area*(10**12); \n    \tuint256 result = area_in_precision.divWadDown(amount); \n    \t//returns a 18 decimal avg price \n    \treturn result; \n    }\n\n    /**\n     @notice calculates expected price given user buys X tokens\n     @param amount: hypothetical amount of tokens bought\n     */\t\n    function calculateExpectedPrice(uint256 amount) public view  returns (uint256 result) {\n        result = _calculateExpectedPrice(amount);\n    }\n    \n    function getTotalCollateral() public view returns (uint256 result) {\n        result = collateral.balanceOf(address(this));\n    }\n\n    function getCollateral() public view returns (address) {\n        return address(collateral);\n    } \n\n    function getTotalZCB() public view returns (uint256 result) {\n        result = totalSupply();\n    }\n\n    function getMaxQuantity() public view returns (uint256 result) {\n        result = max_quantity;\n    }\n\n    function getUpperBound() public view returns (uint256 result) {\n        result = price_upper_bound;\n    }\n\n    function getLowerBound() public view returns (uint256 result) {\n        result = price_lower_bound;\n    }\n    function getReserves() public view returns(uint256){\n    \treturn reserves; \n    }\n\n    /**\n     @notice buy bond tokens with necessary checks and transfers of collateral.\n     @param amount: amount of collateral/ds paid in exchange for tokens\n     @dev amount has number of collateral decimals\n     */\n    function buy(uint256 amount) public {\n        uint256 tokens = _calculatePurchaseReturn(amount);\n        console.log(\"buy:tokens\", tokens);\n        reserves += amount; // CAN REPLACE WITH collateral.balanceOf(this)\n        _mint(msg.sender, tokens);\n        collateral.safeTransferFrom(msg.sender, address(this), amount);\n    }\n\n    /**\n     @notice sell bond tokens with necessary checks and transfers of collateral\n     @param amount: amount of tokens selling. 60.18.\n     */\n    function sell(uint256 amount) public {\n        uint256 sale = _calculateSaleReturn(amount);\n        _burn(msg.sender, amount);\n        collateral.safeTransfer(msg.sender, sale);\n        reserves -= sale;\n    }\n\n    /**\n     @dev doesn't perform any checks, checks performed by caller\n     */\n    function incrementReserves(uint256 amount) public onlyOwner{\n        reserves += amount;\n    }\n    \n    /**\n     @dev doesn't perform any checks, checks performed by caller\n     */\n    function decrementReserves(uint256 amount) public onlyOwner {\n        reserves -= amount;\n    }\n\n    /**\n     @notice used for calculating reputation score on resolved market.\n     */\n    function calculateProbability(uint256 amount) view public returns (uint256 score) {\n        return _calculateProbability(amount);\n    }\n\n    function redeem(\n\t\taddress receiver, \n\t\tuint256 zcb_redeem_amount, \n\t\tuint256 collateral_redeem_amount\n\t) external  onlyOwner {\n        _burn(receiver, zcb_redeem_amount);\n\t\tcollateral.safeTransfer(receiver, collateral_redeem_amount); \n        reserves -= collateral_redeem_amount;\n\t}\n\n    function redeemPostAssessment(\n\t\taddress redeemer,\n\t\tuint256 collateral_amount\n\t) external  onlyOwner{\n        uint256 redeem_amount = balanceOf(redeemer);\n\t\t_burn(redeemer, redeem_amount); \n\t\tcollateral.safeTransfer(redeemer, collateral_amount); \n        reserves -= collateral_amount;\n\t}\n\n    function burnFirstLoss(\n\t\tuint256 burn_collateral_amount\n\t) external onlyOwner{\n\t\tcollateral.safeTransfer(owner, burn_collateral_amount); \n        reserves -= burn_collateral_amount;\n\t}\n\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal override virtual {\n        // on _mint\n        if (from == address(0) && price_upper_bound > 0) {\n            console.log(\"beforeTT: price_upper_bound\", price_upper_bound);\n            require(_calculateExpectedPrice(amount) <= price_upper_bound, \"above price upper bound\");\n            // if (balanceOf(to) == 0 && amount > 0) {\n            //     buyers.push(to);\n            // }\n        }\n        // on _burn\n        else if (to == address(0) && price_lower_bound > 0) {\n            require(_calculateDecreasedPrice(amount) >= price_lower_bound, \"below price lower bound\");\n        }\n    }\n\n    /**\n     @dev amount is tokens burned.\n     */\n    function calculateDecreasedPrice(uint256 amount) view internal virtual returns (uint256 result) {\n        result = _calculateDecreasedPrice(amount);\n    }\n\n    function _calcAreaUnderCurve(uint256 amount) internal view  virtual returns(uint256 result); \n\n    function _calculateScore(uint256 priceOut, bool atLoss) view internal virtual returns(uint256 score);\n\n    function _calculatePurchaseReturn(uint256 amount) view internal virtual returns(uint256 result);\n\n    function _calculateSaleReturn(uint256 amount) view internal virtual returns (uint256 result);\n\n    function _calculateExpectedPrice(uint256 amount) view internal virtual returns (uint256 result);\n\n    function _calculateProbability(uint256 amount) view internal virtual returns (uint256 score);\n\n    function _calculateDecreasedPrice(uint256 amount) view internal virtual returns (uint256 result);\n}"
    },
    "solmate/src/utils/FixedPointMathLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Arithmetic library with operations for fixed-point numbers.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\nlibrary FixedPointMathLib {\n    /*//////////////////////////////////////////////////////////////\n                    SIMPLIFIED FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\n\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\n    }\n\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\n    }\n\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\n    }\n\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                    LOW LEVEL FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function mulDivDown(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        assembly {\n            // Store x * y in z for now.\n            z := mul(x, y)\n\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\n                revert(0, 0)\n            }\n\n            // Divide z by the denominator.\n            z := div(z, denominator)\n        }\n    }\n\n    function mulDivUp(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        assembly {\n            // Store x * y in z for now.\n            z := mul(x, y)\n\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\n                revert(0, 0)\n            }\n\n            // First, divide z - 1 by the denominator and add 1.\n            // We allow z - 1 to underflow if z is 0, because we multiply the\n            // end result by 0 if z is zero, ensuring we return 0 if z is zero.\n            z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))\n        }\n    }\n\n    function rpow(\n        uint256 x,\n        uint256 n,\n        uint256 scalar\n    ) internal pure returns (uint256 z) {\n        assembly {\n            switch x\n            case 0 {\n                switch n\n                case 0 {\n                    // 0 ** 0 = 1\n                    z := scalar\n                }\n                default {\n                    // 0 ** n = 0\n                    z := 0\n                }\n            }\n            default {\n                switch mod(n, 2)\n                case 0 {\n                    // If n is even, store scalar in z for now.\n                    z := scalar\n                }\n                default {\n                    // If n is odd, store x in z for now.\n                    z := x\n                }\n\n                // Shifting right by 1 is like dividing by 2.\n                let half := shr(1, scalar)\n\n                for {\n                    // Shift n right by 1 before looping to halve it.\n                    n := shr(1, n)\n                } n {\n                    // Shift n right by 1 each iteration to halve it.\n                    n := shr(1, n)\n                } {\n                    // Revert immediately if x ** 2 would overflow.\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\n                    if shr(128, x) {\n                        revert(0, 0)\n                    }\n\n                    // Store x squared.\n                    let xx := mul(x, x)\n\n                    // Round to the nearest number.\n                    let xxRound := add(xx, half)\n\n                    // Revert if xx + half overflowed.\n                    if lt(xxRound, xx) {\n                        revert(0, 0)\n                    }\n\n                    // Set x to scaled xxRound.\n                    x := div(xxRound, scalar)\n\n                    // If n is even:\n                    if mod(n, 2) {\n                        // Compute z * x.\n                        let zx := mul(z, x)\n\n                        // If z * x overflowed:\n                        if iszero(eq(div(zx, x), z)) {\n                            // Revert if x is non-zero.\n                            if iszero(iszero(x)) {\n                                revert(0, 0)\n                            }\n                        }\n\n                        // Round to the nearest number.\n                        let zxRound := add(zx, half)\n\n                        // Revert if zx + half overflowed.\n                        if lt(zxRound, zx) {\n                            revert(0, 0)\n                        }\n\n                        // Return properly scaled zxRound.\n                        z := div(zxRound, scalar)\n                    }\n                }\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        GENERAL NUMBER UTILITIES\n    //////////////////////////////////////////////////////////////*/\n\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\n        assembly {\n            // Start off with z at 1.\n            z := 1\n\n            // Used below to help find a nearby power of 2.\n            let y := x\n\n            // Find the lowest power of 2 that is at least sqrt(x).\n            if iszero(lt(y, 0x100000000000000000000000000000000)) {\n                y := shr(128, y) // Like dividing by 2 ** 128.\n                z := shl(64, z) // Like multiplying by 2 ** 64.\n            }\n            if iszero(lt(y, 0x10000000000000000)) {\n                y := shr(64, y) // Like dividing by 2 ** 64.\n                z := shl(32, z) // Like multiplying by 2 ** 32.\n            }\n            if iszero(lt(y, 0x100000000)) {\n                y := shr(32, y) // Like dividing by 2 ** 32.\n                z := shl(16, z) // Like multiplying by 2 ** 16.\n            }\n            if iszero(lt(y, 0x10000)) {\n                y := shr(16, y) // Like dividing by 2 ** 16.\n                z := shl(8, z) // Like multiplying by 2 ** 8.\n            }\n            if iszero(lt(y, 0x100)) {\n                y := shr(8, y) // Like dividing by 2 ** 8.\n                z := shl(4, z) // Like multiplying by 2 ** 4.\n            }\n            if iszero(lt(y, 0x10)) {\n                y := shr(4, y) // Like dividing by 2 ** 4.\n                z := shl(2, z) // Like multiplying by 2 ** 2.\n            }\n            if iszero(lt(y, 0x8)) {\n                // Equivalent to 2 ** z.\n                z := shl(1, z)\n            }\n\n            // Shifting right by 1 is like dividing by 2.\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n\n            // Compute a rounded down version of z.\n            let zRoundDown := div(x, z)\n\n            // If zRoundDown is smaller, use it.\n            if lt(zRoundDown, z) {\n                z := zRoundDown\n            }\n        }\n    }\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n\t}\n\n\tfunction logUint(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/draft-IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/turbo/random.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n\nimport \"../libraries/IERC20Full.sol\";\nimport \"../balancer/BPool.sol\";\nimport \"./AbstractMarketFactoryV3.sol\";\nimport \"./FeePot.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/SignedSafeMath.sol\";\nimport \"./MMAMarketFactoryV3.sol\";\nimport \"./AMMFactory.sol\";\nimport \"./CryptoMarketFactoryV3.sol\";\nimport \"./NBAMarketFactoryV3.sol\";\nimport \"../rewards/MasterChef.sol\";\nimport \"./CryptoCurrencyMarketFactoryV3.sol\";\nimport \"./TrustedMarketFactoryV3.sol\";\nimport \"./Fetcher.sol\";\n\ncontract TrustedFetcher is Fetcher {\n    constructor() Fetcher(\"Trusted\", \"TBD\") {}\n\n    struct SpecificMarketFactoryBundle {\n        MarketFactoryBundle _super;\n    }\n\n    struct SpecificStaticMarketBundle {\n        StaticMarketBundle _super;\n        // uint256 coinIndex;\n        // uint256 creationValue;\n        // uint256 resolutionTime;\n        // // Dynamics\n        // uint256 resolutionValue;\n        string description;\n    }\n\n    struct SpecificDynamicMarketBundle {\n        DynamicMarketBundle _super;\n        //uint256 resolutionValue;\n        string description;\n\n    }\n\n    function sayHi() public view returns(uint256){\n        return 0; \n    }\n\n    function getMarket( address _marketFactory,\n    AMMFactory _ammFactory,\n    MasterChef _masterChef,\n    uint256 _marketId) public view returns(   SpecificStaticMarketBundle memory _bundle\n){\n    TrustedMarketFactoryV3.MarketDetails memory _details =\n        TrustedMarketFactoryV3(_marketFactory).getMarketDetails(_marketId);\n    _bundle._super = buildStaticMarketBundle(\n        TrustedMarketFactoryV3(_marketFactory),\n        _ammFactory,\n        _masterChef,\n        _marketId\n    );\n    _bundle.description = _details.description;\n    }\n\n\n  function fetchInitial(\n        address _marketFactory,\n        AMMFactory _ammFactory,\n        MasterChef _masterChef,\n        uint256 _offset,\n        uint256 _total\n    )\n        public\n        view\n        returns (\n            SpecificMarketFactoryBundle memory _marketFactoryBundle,\n            SpecificStaticMarketBundle[] memory _marketBundles,\n            uint256 _lowestMarketIndex,\n            uint256 _timestamp\n        )\n    {\n        _marketFactoryBundle = buildSpecificMarketFactoryBundle(_marketFactory);\n\n        uint256[] memory _marketIds;\n\n       (_marketIds, _lowestMarketIndex) = listOfInterestingMarkets(_marketFactory, _offset, _total);\n        // (_marketIds, _lowestMarketIndex) = interestingMarkets(_marketFactory, _offset, _total);\n\n        _total = _marketIds.length;\n        _marketBundles = new SpecificStaticMarketBundle[](_total);\n        for (uint256 i; i < _total; i++) {\n            _marketBundles[i] = buildSpecificStaticMarketBundle(\n                _marketFactory,\n                _ammFactory,\n                _masterChef,\n                 _marketIds[i]\n                \n            );\n        }\n\n        _timestamp = block.timestamp;\n    }\n\n\n    function buildSpecificMarketFactoryBundle(address _marketFactory)\n        internal\n        view\n        returns (SpecificMarketFactoryBundle memory _bundle)\n    {\n        _bundle._super = buildMarketFactoryBundle(TrustedMarketFactoryV3(_marketFactory));\n    }\n\n\n function buildSpecificStaticMarketBundle(\n        address _marketFactory,\n        AMMFactory _ammFactory,\n        MasterChef _masterChef,\n        uint256 _marketId\n    ) internal view returns (SpecificStaticMarketBundle memory _bundle) {\n        TrustedMarketFactoryV3.MarketDetails memory _details =\n            TrustedMarketFactoryV3(_marketFactory).getMarketDetails(_marketId);\n        _bundle._super = buildStaticMarketBundle(\n            TrustedMarketFactoryV3(_marketFactory),\n            _ammFactory,\n            _masterChef,\n            _marketId+1\n        );\n        _bundle.description = _details.description;\n        // _bundle.creationValue = _details.creationValue;\n        // _bundle.coinIndex = _details.coinIndex;\n        // _bundle.resolutionValue = _details.resolutionValue;\n        // _bundle.resolutionTime = _details.resolutionTime;\n    }\n\nfunction listOfInterestingMarkets(\n        address _marketFactory,\n        uint256 _offset,\n        uint256 _total\n    ) internal view returns (uint256[] memory _interestingMarketIds, uint256 _marketId) {\n        _interestingMarketIds = new uint256[](_total);\n        uint256 _max = AbstractMarketFactoryV3(_marketFactory).marketCount() - 1;\n\n        // No markets so return nothing. (needed to prevent integer underflow below)\n        if (_max == 0 || _offset >= _max) {\n            return (new uint256[](0), 0);\n        }\n\n        // Starts at the end, less offset.\n        // Stops before the 0th market since that market is always fake.\n        uint256 _collectedMarkets = 0;\n        _marketId = _max - _offset-1;\n\n        while (true) {\n            if (openOrHasWinningShares(AbstractMarketFactoryV3(_marketFactory), _marketId)) {\n                _interestingMarketIds[_collectedMarkets] = _marketId;\n                _collectedMarkets++;\n            }\n\n            if (_collectedMarkets >= _total) break;\n            if (_marketId == 0) break; // skipping 0th market, which is fake\n            _marketId--; // starts out oone too high, so this works\n        }\n\n        if (_total > _collectedMarkets) {\n            assembly {\n                // shortens array\n                mstore(_interestingMarketIds, _collectedMarkets)\n            }\n        }\n    }\n\n    function fetchDynamic(\n        address _marketFactory,\n        AMMFactory _ammFactory,\n        uint256 _offset,\n        uint256 _total\n    )\n        public\n        view\n        returns (\n            SpecificDynamicMarketBundle[] memory _bundles,\n            uint256 _lowestMarketIndex,\n            uint256 _timestamp\n        )\n    {\n        uint256[] memory _marketIds;\n        (_marketIds, _lowestMarketIndex) = listOfInterestingMarkets(_marketFactory, _offset, _total);\n\n        _total = _marketIds.length;\n        _bundles = new SpecificDynamicMarketBundle[](_total);\n        for (uint256 i; i < _total; i++) {\n            _bundles[i] = buildSpecificDynamicMarketBundle(_marketFactory, _ammFactory, _marketIds[i]);\n        }\n\n        _timestamp = block.timestamp;\n    }\n \n\n\n    function buildSpecificDynamicMarketBundle(\n        address _marketFactory,\n        AMMFactory _ammFactory,\n        uint256 _marketId\n    ) internal view returns (SpecificDynamicMarketBundle memory _bundle) {\n        TrustedMarketFactoryV3.MarketDetails memory _details =\n            TrustedMarketFactoryV3(_marketFactory).getMarketDetails(_marketId);\n        _bundle._super = buildDynamicMarketBundle(TrustedMarketFactoryV3(_marketFactory), _ammFactory, _marketId+1);\n        _bundle.description = _details.description;\n    }\n\n\n    }\n\n\n\n\n\n\n// contract TrustedFetcher is Fetcher {\n//     constructor() Fetcher(\"Trusted\", \"TBD\") {}\n\n//     struct SpecificMarketFactoryBundle {\n//         MarketFactoryBundle _super;\n//     }\n\n//     struct SpecificStaticMarketBundle {\n//         StaticMarketBundle _super;\n//         // uint256 coinIndex;\n//         // uint256 creationValue;\n//         // uint256 resolutionTime;\n//         // // Dynamics\n//         // uint256 resolutionValue;\n//         string description;\n//     }\n\n//     struct SpecificDynamicMarketBundle {\n//         DynamicMarketBundle _super;\n//         //uint256 resolutionValue;\n//         string description;\n\n//     }\n\n//     function getMarket(    address _marketFactory,\n//         AMMFactory _ammFactory,\n//         MasterChef _masterChef,\n//         uint256 _marketId) public view returns(   SpecificStaticMarketBundle memory _bundle\n// ){\n//         TrustedMarketFactoryV3.MarketDetails memory _details =\n//             TrustedMarketFactoryV3(_marketFactory).getMarketDetails(_marketId);\n//         _bundle._super = buildStaticMarketBundle(\n//             TrustedMarketFactoryV3(_marketFactory),\n//             _ammFactory,\n//             _masterChef,\n//             _marketId\n//         );\n//         _bundle.description = _details.description;\n//     }\n\n//     function buildSpecificMarketFactoryBundle(address _marketFactory)\n//         internal\n//         view\n//         returns (SpecificMarketFactoryBundle memory _bundle)\n//     {\n//         _bundle._super = buildMarketFactoryBundle(TrustedMarketFactoryV3(_marketFactory));\n//     }\n\n//     function buildSpecificStaticMarketBundle(\n//         address _marketFactory,\n//         AMMFactory _ammFactory,\n//         MasterChef _masterChef,\n//         uint256 _marketId\n//     ) internal view returns (SpecificStaticMarketBundle memory _bundle) {\n//         TrustedMarketFactoryV3.MarketDetails memory _details =\n//             TrustedMarketFactoryV3(_marketFactory).getMarketDetails(_marketId);\n//         _bundle._super = buildStaticMarketBundle(\n//             TrustedMarketFactoryV3(_marketFactory),\n//             _ammFactory,\n//             _masterChef,\n//             _marketId\n//         );\n//         _bundle.description = _details.description;\n//         // _bundle.creationValue = _details.creationValue;\n//         // _bundle.coinIndex = _details.coinIndex;\n//         // _bundle.resolutionValue = _details.resolutionValue;\n//         // _bundle.resolutionTime = _details.resolutionTime;\n//     }\n\n//     function buildSpecificDynamicMarketBundle(\n//         address _marketFactory,\n//         AMMFactory _ammFactory,\n//         uint256 _marketId\n//     ) internal view returns (SpecificDynamicMarketBundle memory _bundle) {\n//         TrustedMarketFactoryV3.MarketDetails memory _details =\n//             TrustedMarketFactoryV3(_marketFactory).getMarketDetails(_marketId);\n//         _bundle._super = buildDynamicMarketBundle(TrustedMarketFactoryV3(_marketFactory), _ammFactory, _marketId);\n//         _bundle.description = _details.description;\n//     }\n\n//     function fetchInitial(\n//         address _marketFactory,\n//         AMMFactory _ammFactory,\n//         MasterChef _masterChef,\n//         uint256 _offset,\n//         uint256 _total\n//     )\n//         public\n//         view\n//         returns (\n//             SpecificMarketFactoryBundle memory _marketFactoryBundle,\n//             SpecificStaticMarketBundle[] memory _marketBundles,\n//             uint256 _lowestMarketIndex,\n//             uint256 _timestamp\n//         )\n//     {\n//         _marketFactoryBundle = buildSpecificMarketFactoryBundle(_marketFactory);\n\n//         uint256[] memory _marketIds;\n//         (_marketIds, _lowestMarketIndex) = listOfInterestingMarkets(_marketFactory, _offset, _total);\n\n//         _total = _marketIds.length;\n//         _marketBundles = new SpecificStaticMarketBundle[](_total);\n//         for (uint256 i; i < _total; i++) {\n//             _marketBundles[i] = buildSpecificStaticMarketBundle(\n//                 _marketFactory,\n//                 _ammFactory,\n//                 _masterChef,\n//                 _marketIds[i]\n//             );\n//         }\n\n//         _timestamp = block.timestamp;\n//     }\n\n//     function fetchDynamic(\n//         address _marketFactory,\n//         AMMFactory _ammFactory,\n//         uint256 _offset,\n//         uint256 _total\n//     )\n//         public\n//         view\n//         returns (\n//             SpecificDynamicMarketBundle[] memory _bundles,\n//             uint256 _lowestMarketIndex,\n//             uint256 _timestamp\n//         )\n//     {\n//         uint256[] memory _marketIds;\n//         (_marketIds, _lowestMarketIndex) = listOfInterestingMarkets(_marketFactory, _offset, _total);\n\n//         _total = _marketIds.length;\n//         _bundles = new SpecificDynamicMarketBundle[](_total);\n//         for (uint256 i; i < _total; i++) {\n//             _bundles[i] = buildSpecificDynamicMarketBundle(_marketFactory, _ammFactory, _marketIds[i]);\n//         }\n\n//         _timestamp = block.timestamp;\n//     }\n\n//     // Starts from the end of the markets list because newer markets are more interesting.\n//     // _offset is skipping all markets, not just interesting markets\n//     function listOfInterestingMarkets(\n//         address _marketFactory,\n//         uint256 _offset,\n//         uint256 _total\n//     ) internal view returns (uint256[] memory _interestingMarketIds, uint256 _marketId) {\n//         _interestingMarketIds = new uint256[](_total);\n//         uint256 _max = AbstractMarketFactoryV3(_marketFactory).marketCount() - 1;\n\n//         // No markets so return nothing. (needed to prevent integer underflow below)\n//         if (_max == 0 || _offset >= _max) {\n//             return (new uint256[](0), 0);\n//         }\n\n//         // Starts at the end, less offset.\n//         // Stops before the 0th market since that market is always fake.\n//         uint256 _collectedMarkets = 0;\n//         _marketId = _max - _offset;\n\n//         while (true) {\n//             if (openOrHasWinningShares(AbstractMarketFactoryV3(_marketFactory), _marketId)) {\n//                 _interestingMarketIds[_collectedMarkets] = _marketId;\n//                 _collectedMarkets++;\n//             }\n\n//             if (_collectedMarkets >= _total) break;\n//             if (_marketId == 1) break; // skipping 0th market, which is fake\n//             _marketId--; // starts out oone too high, so this works\n//         }\n\n//         if (_total > _collectedMarkets) {\n//             assembly {\n//                 // shortens array\n//                 mstore(_interestingMarketIds, _collectedMarkets)\n//             }\n//         }\n//     }"
    },
    "@openzeppelin/contracts/utils/math/SignedSafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/SignedSafeMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SignedSafeMath` is no longer needed starting with Solidity 0.8. The compiler\n * now has built in overflow checking.\n */\nlibrary SignedSafeMath {\n    /**\n     * @dev Returns the multiplication of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(int256 a, int256 b) internal pure returns (int256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two signed integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(int256 a, int256 b) internal pure returns (int256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(int256 a, int256 b) internal pure returns (int256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the addition of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(int256 a, int256 b) internal pure returns (int256) {\n        return a + b;\n    }\n}\n"
    },
    "contracts/turbo/MMAMarketFactoryV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./AbstractMarketFactoryV3.sol\";\nimport \"./FeePot.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/SignedSafeMath.sol\";\nimport \"../libraries/Sport.sol\";\nimport \"../libraries/ResolveByFiat.sol\";\nimport \"../libraries/HasHeadToHeadMarket.sol\";\nimport \"../libraries/Versioned.sol\";\n\ncontract MMAMarketFactoryV3 is AbstractMarketFactoryV3, SportView, ResolvesByFiat, HasHeadToHeadMarket, Versioned {\n    using SafeMath for uint256;\n    using SignedSafeMath for int256;\n\n    uint256 constant HeadToHead = 0;\n    string constant InvalidName = \"No Contest / Draw\";\n\n    constructor(\n        address _owner,\n        IERC20Full _collateral,\n        uint256 _shareFactor,\n        FeePot _feePot,\n        uint256[3] memory _fees,\n        address _protocol,\n        address _linkNode\n    )\n        AbstractMarketFactoryV3(_owner, _collateral, _shareFactor, _feePot, _fees, _protocol)\n        Versioned(\"v1.2.0\")\n        ManagedByLink(_linkNode)\n        HasHeadToHeadMarket(HeadToHead, InvalidName)\n    {}\n\n    function createEvent(\n        uint256 _eventId,\n        string memory _homeTeamName,\n        uint256 _homeTeamId,\n        string memory _awayTeamName,\n        uint256 _awayTeamId,\n        uint256 _startTimestamp,\n        int256[2] memory _moneylines // [home,away]\n    ) public onlyLinkNode returns (uint256[] memory _marketIds) {\n        _marketIds = makeMarkets(_moneylines, _homeTeamName, _awayTeamName);\n        makeSportsEvent(\n            _eventId,\n            _marketIds,\n            build1Line(),\n            _startTimestamp,\n            _homeTeamId,\n            _awayTeamId,\n            _homeTeamName,\n            _awayTeamName\n        );\n    }\n\n    function makeMarkets(\n        int256[2] memory _moneylines,\n        string memory _homeTeamName,\n        string memory _awayTeamName\n    ) internal returns (uint256[] memory _marketIds) {\n        _marketIds = new uint256[](1);\n        _marketIds[HeadToHead] = makeHeadToHeadMarket(_moneylines, _homeTeamName, _awayTeamName);\n    }\n\n    function resolveValidEvent(SportsEvent memory _event, uint256 _whoWon) internal override {\n        resolveHeadToHeadMarket(_event.markets[HeadToHead], _whoWon);\n    }\n\n    function resolveHeadToHeadMarket(uint256 _marketId, uint256 _whoWon) internal {\n        uint256 _shareTokenIndex = calcHeadToHeadWinner(_whoWon);\n        endMarket(_marketId, _shareTokenIndex);\n    }\n\n    function calcHeadToHeadWinner(uint256 _whoWon) internal pure returns (uint256) {\n        if (WhoWonHome == _whoWon) {\n            return HeadToHeadHome;\n        } else if (WhoWonAway == _whoWon) {\n            return HeadToHeadAway;\n        } else {\n            return NoContest; // shouldn't happen here\n        }\n    }\n}\n"
    },
    "contracts/turbo/CryptoMarketFactoryV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../libraries/IERC20Full.sol\";\nimport \"../balancer/BPool.sol\";\nimport \"./AbstractMarketFactoryV3.sol\";\nimport \"./FeePot.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/SignedSafeMath.sol\";\nimport \"../utils/AggregatorV3Interface.sol\";\nimport \"../libraries/CalculateLinesToBPoolOdds.sol\";\nimport \"../libraries/Versioned.sol\";\nimport \"../libraries/ManagedByLink.sol\";\nimport \"../libraries/Rewardable.sol\";\n\ncontract CryptoMarketFactoryV3 is AbstractMarketFactoryV3, CalculateLinesToBPoolOdds, Versioned, ManagedByLink {\n    using SafeMath for uint256;\n    using SignedSafeMath for int256;\n\n    event CoinAdded(uint256 indexed id, string name);\n\n    event NewPrices(uint256 indexed nextResolutionTime, uint256[] markets, uint256[] prices);\n\n    struct Coin {\n        string name;\n        AggregatorV3Interface priceFeed;\n        uint256 price;\n        uint8 imprecision; // how many decimals to truncate\n        uint256[1] currentMarkets;\n    }\n    Coin[] public coins;\n\n    enum MarketType {\n        PriceUpDown // 0\n    }\n    enum PriceUpDownOutcome {\n        Above, // 0\n        NotAbove // 1\n    }\n    struct MarketDetails {\n        MarketType marketType;\n        uint256 coinIndex;\n        uint256 creationPrice;\n        uint256 resolutionPrice;\n        uint256 resolutionTime; // price at given time; this is that time\n    }\n    // MarketId => MarketDetails\n    mapping(uint256 => MarketDetails) internal marketDetails;\n\n    uint256 public nextResolutionTime;\n\n    constructor(\n        address _owner,\n        IERC20Full _collateral,\n        uint256 _shareFactor,\n        FeePot _feePot,\n        uint256[3] memory _fees,\n        address _protocol,\n        address _linkNode\n    )\n        AbstractMarketFactoryV3(_owner, _collateral, _shareFactor, _feePot, _fees, _protocol)\n        Versioned(\"v1.2.0\")\n        ManagedByLink(_linkNode)\n    {\n        string memory _name = \"\";\n        coins.push(makeCoin(_name, AggregatorV3Interface(address(0)), 0));\n    }\n\n    function getMarketDetails(uint256 _marketId) public view returns (MarketDetails memory) {\n        return marketDetails[_marketId];\n    }\n\n    // NOTE: Trusts the owner not to add a coin twice.\n    // Returns the coin index.\n    function addCoin(\n        string calldata _name,\n        AggregatorV3Interface _priceFeed,\n        uint8 _imprecision\n    ) external onlyOwner returns (uint256 _coinIndex) {\n        Coin memory _coin = makeCoin(_name, _priceFeed, _imprecision);\n        _coinIndex = coins.length;\n        coins.push(_coin);\n        emit CoinAdded(_coinIndex, _name);\n    }\n\n    function getCoin(uint256 _coinIndex) public view returns (Coin memory _coin) {\n        _coin = coins[_coinIndex];\n    }\n\n    function getCoins() public view returns (Coin[] memory _coins) {\n        _coins = new Coin[](coins.length);\n        // Skip first coin because it's always the zeroed-out fake coin.\n        for (uint256 i = 1; i < coins.length; i++) {\n            _coins[i] = coins[i];\n        }\n    }\n\n    // Iterates over all coins.\n    // If markets do not exist for coin, create them.\n    // Unless _nextResolutionTime is zero; then do not create new markets.\n    // If markets for coin exist and are ready to resolve, resolve them and create new markets.\n    // Else, error.\n    //\n    // Assume that _roundIds has a dummy value at index 0, and is 1 indexed like the\n    // coins array.\n    function createAndResolveMarkets(uint80[] calldata _roundIds, uint256 _nextResolutionTime) public onlyLinkNode {\n        // If market creation was stopped then it can be started again.\n        // If market creation wasn't stopped then you must wait for market end time to resolve.\n        require(block.timestamp >= nextResolutionTime, \"Must wait for market resolution\");\n        require(_roundIds.length == coins.length, \"Must specify one roundId for each coin\");\n\n        uint256 _resolutionTime = nextResolutionTime;\n        nextResolutionTime = _nextResolutionTime;\n\n        uint256[] memory _prices = new uint256[](coins.length - 1);\n        uint256[] memory _newMarketIds = new uint256[](coins.length - 1);\n        // Start at 1 to skip the fake Coin in the 0 index\n        for (uint256 i = 1; i < coins.length; i++) {\n            (_prices[i - 1], _newMarketIds[i - 1]) = createAndResolveMarketsForCoin(i, _resolutionTime, _roundIds[i]);\n        }\n\n        emit NewPrices(nextResolutionTime, _newMarketIds, _prices);\n    }\n\n    function createAndResolveMarketsForCoin(\n        uint256 _coinIndex,\n        uint256 _resolutionTime,\n        uint80 _roundId\n    ) internal returns (uint256 _price, uint256 _newMarketId) {\n        Coin memory _coin = coins[_coinIndex];\n        (uint256 _fullPrice, uint256 _newPrice) = getPrice(_coin, _roundId, _resolutionTime);\n\n        // resolve markets\n        if (_coin.currentMarkets[uint256(MarketType.PriceUpDown)] != 0) {\n            resolvePriceUpDownMarket(_coin, _newPrice, _fullPrice);\n        }\n\n        // update price only AFTER resolution\n        coins[_coinIndex].price = _newPrice;\n\n        // link node sets nextResolutionTime to zero to signify \"do not create markets after resolution\"\n        if (nextResolutionTime == 0) {\n            return (0, 0);\n        }\n\n        // create markets\n        _newMarketId = createPriceUpDownMarket(_coinIndex, linkNode, _newPrice);\n        coins[_coinIndex].currentMarkets[uint256(MarketType.PriceUpDown)] = _newMarketId;\n\n        return (_newPrice, _newMarketId);\n    }\n\n    function resolvePriceUpDownMarket(\n        Coin memory _coin,\n        uint256 _newPrice,\n        uint256 _fullPrice\n    ) internal {\n        uint256 _marketId = _coin.currentMarkets[uint256(MarketType.PriceUpDown)];\n\n        uint256 _winningOutcome;\n        if (_newPrice > _coin.price) {\n            _winningOutcome = uint256(PriceUpDownOutcome.Above);\n        } else {\n            _winningOutcome = uint256(PriceUpDownOutcome.NotAbove);\n        }\n\n        endMarket(_marketId, _winningOutcome);\n        marketDetails[_marketId].resolutionPrice = _fullPrice;\n    }\n\n    function createPriceUpDownMarket(\n        uint256 _coinIndex,\n        address _creator,\n        uint256 _newPrice\n    ) internal returns (uint256 _id) {\n        string[] memory _outcomes = new string[](2);\n        _outcomes[uint256(PriceUpDownOutcome.Above)] = \"Above\";\n        _outcomes[uint256(PriceUpDownOutcome.NotAbove)] = \"Not Above\";\n\n        _id = startMarket(_creator, _outcomes, evenOdds(false, 2), true);\n        marketDetails[_id] = MarketDetails(MarketType.PriceUpDown, _coinIndex, _newPrice, 0, nextResolutionTime);\n    }\n\n    // Returns the price based on a few factors.\n    // If _roundId is zero then it returns the latest price.\n    // Else, it returns the price for that round,\n    //       but errors if that isn't the first round after the resolution time.\n    // The price is then altered to match the desired precision.\n    function getPrice(\n        Coin memory _coin,\n        uint80 _roundId,\n        uint256 _resolutionTime\n    ) internal view returns (uint256 _fullPrice, uint256 _truncatedPrice) {\n        if (_roundId == 0) {\n            (, int256 _rawPrice, , , ) = _coin.priceFeed.latestRoundData();\n            require(_rawPrice >= 0, \"Price from feed is negative\");\n            _fullPrice = uint256(_rawPrice);\n        } else {\n            (, int256 _rawPrice, , uint256 updatedAt, ) = _coin.priceFeed.getRoundData(_roundId);\n            require(_rawPrice >= 0, \"Price from feed is negative\");\n            require(updatedAt >= _resolutionTime, \"Price hasn't been updated yet\");\n\n            // if resolution time is zero then market creation was stopped, so the previous round doesn't matter\n            if (_resolutionTime != 0) {\n                (, , , uint256 _previousRoundTime, ) = _coin.priceFeed.getRoundData(previousRound(_roundId));\n                require(_previousRoundTime < _resolutionTime, \"Must use first round after resolution time\");\n            }\n\n            _fullPrice = uint256(_rawPrice);\n        }\n\n        // The precision is how many decimals the price has. Zero is dollars, 2 includes cents, 3 is tenths of a cent, etc.\n        // Our resolution rules want a certain precision. Like BTC is to the dollar and MATIC is to the cent.\n        // If somehow the decimals are larger than the desired precision then add zeroes to the end to meet the precision.\n        // This does not change the resolution outcome but does guard against decimals() changing and therefore altering the basis.\n\n        uint8 _precision = _coin.priceFeed.decimals(); // probably constant but that isn't guaranteed, so query each time\n        if (_precision > _coin.imprecision) {\n            uint8 _truncate = _precision - _coin.imprecision;\n            _truncatedPrice = _fullPrice / (10**_truncate);\n        } else if (_precision < _coin.imprecision) {\n            uint8 _greaten = _coin.imprecision - _precision;\n            _truncatedPrice = _fullPrice * (10**_greaten);\n        } else {\n            _truncatedPrice = _fullPrice;\n        }\n\n        // Round up because that cleanly fits Above/Not-Above.\n        if (_truncatedPrice != _fullPrice) {\n            _truncatedPrice += 1;\n        }\n    }\n\n    function makeCoin(\n        string memory _name,\n        AggregatorV3Interface _priceFeed,\n        uint8 _imprecision\n    ) internal pure returns (Coin memory _coin) {\n        uint256[1] memory _currentMarkets = [uint256(0)];\n        _coin = Coin(_name, _priceFeed, 0, _imprecision, _currentMarkets);\n    }\n\n    // The roundId is the encoding of two parts: the phase and the phase-specific round id.\n    // To find the previous roundId:\n    // 1. extract the phase and phase-specific round (I call these _phaseId and _roundId)\n    // 2. decrement the phase-specific round\n    // 3. re-encode the phase and phase-specific round.\n    uint256 private constant PHASE_OFFSET = 64;\n\n    function previousRound(uint80 _fullRoundId) internal pure returns (uint80) {\n        uint256 _phaseId = uint256(uint16(_fullRoundId >> PHASE_OFFSET));\n        uint64 _roundId = uint64(_fullRoundId) - 1;\n        return uint80((_phaseId << PHASE_OFFSET) | _roundId);\n    }\n\n    function getRewardEndTime(uint256 _marketId) public view override returns (uint256) {\n        return getMarketDetails(_marketId).resolutionTime;\n    }\n}\n"
    },
    "contracts/turbo/NBAMarketFactoryV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../libraries/IERC20Full.sol\";\nimport \"../balancer/BPool.sol\";\nimport \"./AbstractMarketFactoryV3.sol\";\nimport \"./FeePot.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/SignedSafeMath.sol\";\nimport \"../libraries/Sport.sol\";\nimport \"../libraries/HasSpreadMarket.sol\";\nimport \"../libraries/ResolveByScore.sol\";\nimport \"../libraries/Versioned.sol\";\n\ncontract NBAMarketFactoryV3 is AbstractMarketFactoryV3, SportView, HasSpreadMarket, ResolvesByScore, Versioned {\n    using SafeMath for uint256;\n    using SignedSafeMath for int256;\n\n    uint256 constant Spread = 0;\n    string constant InvalidName = \"No Contest\";\n\n    constructor(\n        address _owner,\n        IERC20Full _collateral,\n        uint256 _shareFactor,\n        FeePot _feePot,\n        uint256[3] memory _fees,\n        address _protocol,\n        address _linkNode\n    )\n        AbstractMarketFactoryV3(_owner, _collateral, _shareFactor, _feePot, _fees, _protocol)\n        Versioned(\"1.5.0\")\n        ManagedByLink(_linkNode)\n        HasSpreadMarket(Spread, InvalidName)\n    {}\n\n    function createEvent(\n        uint256 _eventId,\n        string memory _homeTeamName,\n        uint256 _homeTeamId,\n        string memory _awayTeamName,\n        uint256 _awayTeamId,\n        uint256 _startTimestamp,\n        int256 _homeSpread\n    ) public onlyLinkNode returns (uint256[] memory _marketIds) {\n        _marketIds = makeMarkets(_homeTeamName, _awayTeamName);\n        makeSportsEvent(\n            _eventId,\n            _marketIds,\n            makeLine(_homeSpread),\n            _startTimestamp,\n            _homeTeamId,\n            _awayTeamId,\n            _homeTeamName,\n            _awayTeamName\n        );\n    }\n\n    function makeMarkets(string memory _homeTeamName, string memory _awayTeamName)\n        internal\n        returns (uint256[] memory _marketIds)\n    {\n        _marketIds = new uint256[](1);\n        _marketIds[Spread] = makeSpreadMarket(_homeTeamName, _awayTeamName);\n    }\n\n    function makeLine(int256 _homeSpread) internal pure returns (int256[] memory _line) {\n        _line = build1Line();\n        _line[0] = addHalfPoint(_homeSpread);\n    }\n\n    function resolveValidEvent(\n        SportsEvent memory _event,\n        uint256 _homeScore,\n        uint256 _awayScore\n    ) internal override {\n        resolveSpreadMarket(_event.markets[Spread], _event.lines[Spread], _homeScore, _awayScore);\n    }\n}\n"
    },
    "contracts/rewards/MasterChef.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\" as OpenZeppelinOwnable;\nimport \"../turbo/AbstractMarketFactoryV3.sol\";\nimport \"../turbo/AMMFactory.sol\";\n\n// MasterChef is the master of Reward. He can make Reward and he is a fair guy.\ncontract MasterChef is OpenZeppelinOwnable.Ownable {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    uint256 public constant BONE = 10**18;\n\n    // The percentage of the rewards period that early deposit bonus will payout.\n    // e.g. Early deposit bonus hits if LP is done in the first x percent of the period.\n    uint256 public constant EARLY_DEPOSIT_BONUS_REWARDS_PERCENTAGE = BONE / 10; // 10% of reward period.\n\n    // Info of each user.\n    struct UserInfo {\n        uint256 amount; // How many LP tokens the user has provided.\n        uint256 rewardDebt; // Reward debt. See explanation below.\n        uint256 lastActionTimestamp; // Timestamp of the withdrawal or deposit from this user.\n        //\n        // We do some fancy math here. Basically, any point in time, the amount of REWARDs\n        // entitled to a user but is pending to be distributed is:\n        //\n        //   pending reward = (user.amount * pool.accRewardsPerShare) - user.rewardDebt\n        //\n        // Whenever a user deposits or withdraws LP tokens to a pool. Here's what happens:\n        //   1. The pool's `accRewardsPerShare` (and `lastRewardBlock`) gets updated.\n        //   2. User receives the pending reward sent to his/her address.\n        //   3. User's `amount` gets updated.\n        //   4. User's `rewardDebt` gets updated.\n    }\n    // Info of each user that deposits LP tokens.\n    mapping(uint256 => mapping(address => UserInfo)) public userInfo;\n\n    // Info of each pool.\n    struct PoolInfo {\n        IERC20 lpToken; // Address of LP token contract.\n        uint256 accRewardsPerShare; // Accumulated REWARDs per share, times BONE. See below.\n        uint256 totalEarlyDepositBonusRewardShares; // The total number of share currently qualifying bonus REWARDs.\n        uint256 beginTimestamp; // The timestamp to begin calculating rewards at.\n        uint256 endTimestamp; // Timestamp of the end of the rewards period.\n        uint256 earlyDepositBonusRewards; // Amount of REWARDs to distribute to early depositors.\n        uint256 lastRewardTimestamp; // Last timestamp REWARDs distribution occurred.\n        uint256 rewardsPerSecond; // Number of rewards paid out per second.\n    }\n    // Info of each pool.\n    PoolInfo[] public poolInfo;\n\n    // This is a snapshot of the current state of a market.\n    struct PoolStatusInfo {\n        uint256 beginTimestamp;\n        uint256 endTimestamp;\n        uint256 earlyDepositEndTimestamp;\n        uint256 totalRewardsAccrued;\n        bool created;\n    }\n\n    struct PendingRewardInfo {\n        uint256 beginTimestamp;\n        uint256 endTimestamp;\n        uint256 earlyDepositEndTimestamp;\n        uint256 accruedStandardRewards;\n        uint256 accruedEarlyDepositBonusRewards;\n        uint256 pendingEarlyDepositBonusRewards;\n        bool created;\n    }\n\n    struct MarketFactoryInfo {\n        uint256 earlyDepositBonusRewards; // Amount of REWARDs per day to distribute to early depositors.\n        uint256 rewardsPeriods; // Number of days the rewards for this pool will payout.\n        uint256 rewardsPerPeriod; // Amount of rewards to be given out for a given period.\n    }\n    mapping(address => MarketFactoryInfo) marketFactoryRewardInfo;\n\n    struct RewardPoolLookupInfo {\n        uint256 pid;\n        bool created;\n    }\n\n    // AMMFactory => MarketFactory => MarketId\n    mapping(address => mapping(address => mapping(uint256 => RewardPoolLookupInfo))) public rewardPoolLookup;\n\n    // The REWARD TOKEN!\n    IERC20 private rewardsToken;\n\n    mapping(address => bool) private approvedAMMFactories;\n\n    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);\n    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount, address recipient);\n    event TrustMarketFactory(\n        address indexed MarketFactory,\n        uint256 OriginEarlyDepositBonusRewards,\n        uint256 OriginrewardsPeriods,\n        uint256 OriginRewardsPerPeriod,\n        uint256 EarlyDepositBonusRewards,\n        uint256 rewardsPeriods,\n        uint256 RewardsPerPeriod\n    );\n\n    event PoolCreated(\n        address indexed ammFactory,\n        address indexed marketFactory,\n        uint256 indexed marketId,\n        address creator,\n        address lpTokenRecipient\n    );\n    event LiquidityChanged(\n        address indexed ammFactory,\n        address indexed marketFactory,\n        uint256 indexed marketId,\n        address user,\n        address recipient,\n        // from the perspective of the user. e.g. collateral is negative when adding liquidity\n        int256 collateral,\n        int256 lpTokens,\n        uint256[] sharesReturned\n    );\n\n    event EmergencyWithdraw(address indexed user, uint256 indexed pid, uint256 amount);\n\n    constructor(IERC20 _rewardsToken) {\n        rewardsToken = _rewardsToken;\n    }\n\n    function trustAMMFactory(address _ammFactory) public onlyOwner {\n        approvedAMMFactories[_ammFactory] = true;\n    }\n\n    function untrustAMMFactory(address _ammFactory) public onlyOwner {\n        delete approvedAMMFactories[_ammFactory];\n    }\n\n    // This method can also be used to update rewards\n    function addRewards(\n        address _marketFactory,\n        uint256 _rewardsPerMarket,\n        uint256 _rewardDaysPerMarket,\n        uint256 _earlyDepositBonusRewards\n    ) public onlyOwner {\n        MarketFactoryInfo memory _oldMarketFactoryInfo = marketFactoryRewardInfo[_marketFactory];\n\n        marketFactoryRewardInfo[_marketFactory] = MarketFactoryInfo({\n            rewardsPeriods: _rewardDaysPerMarket,\n            rewardsPerPeriod: _rewardsPerMarket,\n            earlyDepositBonusRewards: _earlyDepositBonusRewards\n        });\n\n        emit TrustMarketFactory(\n            _marketFactory,\n            _oldMarketFactoryInfo.earlyDepositBonusRewards,\n            _oldMarketFactoryInfo.rewardsPeriods,\n            _oldMarketFactoryInfo.rewardsPerPeriod,\n            _earlyDepositBonusRewards,\n            _rewardDaysPerMarket,\n            _rewardsPerMarket\n        );\n    }\n\n    function poolLength() external view returns (uint256) {\n        return poolInfo.length;\n    }\n\n    // Add a new lp to the pool. Can only be called by the owner.\n    // XXX DO NOT add the same LP token more than once. Rewards will be messed up if you do.\n    // An _endTimestamp of zero means the rewards start immediately.\n    function add(\n        address _ammFactory,\n        address _marketFactory,\n        uint256 _marketId,\n        IERC20 _lpToken,\n        uint256 _endTimestamp\n    ) public onlyOwner returns (uint256 _nextPID) {\n        return addInternal(_ammFactory, _marketFactory, _marketId, _lpToken, _endTimestamp);\n    }\n\n    function addInternal(\n        address _ammFactory,\n        address _marketFactory,\n        uint256 _marketId,\n        IERC20 _lpToken,\n        uint256 _endTimestamp\n    ) internal returns (uint256 _nextPID) {\n        require(\n            !rewardPoolLookup[_ammFactory][_marketFactory][_marketId].created,\n            \"Reward pool has already been created.\"\n        );\n\n        require(approvedAMMFactories[address(_ammFactory)], \"AMMFactory must be approved to create pool\");\n\n        _nextPID = poolInfo.length;\n\n        rewardPoolLookup[_ammFactory][_marketFactory][_marketId] = RewardPoolLookupInfo({pid: _nextPID, created: true});\n\n        MarketFactoryInfo memory _marketFactoryInfo = marketFactoryRewardInfo[_marketFactory];\n\n        // Need to figure out the beginning/end of the reward period.\n        uint256 _rewardsPeriodsInSeconds = _marketFactoryInfo.rewardsPeriods * 1 days;\n        uint256 _beginTimestamp = block.timestamp;\n\n        // Add one hour buffer for LPs to withdraw before event start.\n        if (_endTimestamp != 0) {\n            _endTimestamp = _endTimestamp - 1 hours;\n        }\n\n        if (_endTimestamp == 0) {\n            _endTimestamp = _beginTimestamp + _rewardsPeriodsInSeconds;\n        } else if ((_endTimestamp - _rewardsPeriodsInSeconds) > block.timestamp) {\n            _beginTimestamp = _endTimestamp - _rewardsPeriodsInSeconds;\n        } else if (block.timestamp >= _endTimestamp) {\n            // reward period already over.\n            _beginTimestamp = _endTimestamp;\n        }\n        poolInfo.push(\n            PoolInfo({\n                accRewardsPerShare: 0,\n                beginTimestamp: _beginTimestamp,\n                endTimestamp: _endTimestamp,\n                totalEarlyDepositBonusRewardShares: 0,\n                earlyDepositBonusRewards: (_marketFactoryInfo.earlyDepositBonusRewards / 1 days) *\n                    (_endTimestamp - _beginTimestamp),\n                lpToken: _lpToken,\n                rewardsPerSecond: (_marketFactoryInfo.rewardsPerPeriod / 1 days),\n                lastRewardTimestamp: _beginTimestamp\n            })\n        );\n    }\n\n    // Return number of seconds elapsed in terms of BONEs.\n    function getTimeElapsed(uint256 _pid) public view returns (uint256) {\n        PoolInfo storage _pool = poolInfo[_pid];\n        uint256 _fromTimestamp = block.timestamp;\n\n        if (\n            // Rewards have not started yet.\n            _pool.beginTimestamp > _fromTimestamp ||\n            // Not sure how this happens but it is accounted for in the original master chef contract.\n            _pool.lastRewardTimestamp > _fromTimestamp ||\n            // No rewards to be distributed\n            _pool.rewardsPerSecond == 0\n        ) {\n            return 0;\n        }\n\n        // Rewards are over for this pool. No more rewards have accrued.\n        if (_pool.lastRewardTimestamp >= _pool.endTimestamp) {\n            return 0;\n        }\n\n        return min(_fromTimestamp, _pool.endTimestamp).sub(_pool.lastRewardTimestamp).add(1).mul(BONE);\n        // return (min(_fromTimestamp, _pool.endTimestamp) - _pool.lastRewardTimestamp + 1) * BONE;\n    }\n\n    function getPoolTokenBalance(\n        AMMFactory _ammFactory,\n        AbstractMarketFactoryV3 _marketFactory,\n        uint256 _marketId,\n        address _user\n    ) external view returns (uint256) {\n        RewardPoolLookupInfo memory _rewardPoolLookupInfo =\n            rewardPoolLookup[address(_ammFactory)][address(_marketFactory)][_marketId];\n\n        if (_rewardPoolLookupInfo.created) {\n            return userInfo[_rewardPoolLookupInfo.pid][_user].amount;\n        } else {\n            return 0;\n        }\n    }\n\n    function getUserAmount(uint256 _pid, address _user) external view returns (uint256) {\n        return userInfo[_pid][_user].amount;\n    }\n\n    function getPoolRewardEndTimestamp(uint256 _pid) public view returns (uint256) {\n        PoolInfo storage _pool = poolInfo[_pid];\n        return _pool.endTimestamp;\n    }\n\n    function getEarlyDepositEndTimestamp(uint256 _pid) public view returns (uint256) {\n        PoolInfo storage _pool = poolInfo[_pid];\n        uint256 _duration = _pool.endTimestamp - _pool.beginTimestamp;\n\n        return ((_duration * EARLY_DEPOSIT_BONUS_REWARDS_PERCENTAGE) / BONE) + _pool.beginTimestamp + 1;\n    }\n\n    function getPoolLPTokenTotalSupply(\n        AMMFactory _ammFactory,\n        AbstractMarketFactoryV3 _marketFactory,\n        uint256 _marketId\n    ) public view returns (uint256) {\n        RewardPoolLookupInfo memory _rewardPoolLookupInfo =\n            rewardPoolLookup[address(_ammFactory)][address(_marketFactory)][_marketId];\n\n        return poolInfo[_rewardPoolLookupInfo.pid].lpToken.totalSupply();\n    }\n\n    function getPoolLPToken(\n        AMMFactory _ammFactory,\n        AbstractMarketFactoryV3 _marketFactory,\n        uint256 _marketId\n    ) public view returns (IERC20) {\n        RewardPoolLookupInfo memory _rewardPoolLookupInfo =\n            rewardPoolLookup[address(_ammFactory)][address(_marketFactory)][_marketId];\n\n        return poolInfo[_rewardPoolLookupInfo.pid].lpToken;\n    }\n\n    function getPoolInfo(\n        AMMFactory _ammFactory,\n        AbstractMarketFactoryV3 _marketFactory,\n        uint256 _marketId\n    ) public view returns (PoolStatusInfo memory _poolStatusInfo) {\n        RewardPoolLookupInfo memory _rewardPoolLookupInfo =\n            rewardPoolLookup[address(_ammFactory)][address(_marketFactory)][_marketId];\n\n        // This cannot revert as it will be used in a multicall.\n        if (_rewardPoolLookupInfo.created) {\n            PoolInfo storage _pool = poolInfo[_rewardPoolLookupInfo.pid];\n\n            _poolStatusInfo.beginTimestamp = _pool.beginTimestamp;\n            _poolStatusInfo.endTimestamp = _pool.endTimestamp;\n            _poolStatusInfo.earlyDepositEndTimestamp = getEarlyDepositEndTimestamp(_rewardPoolLookupInfo.pid);\n\n            _poolStatusInfo.totalRewardsAccrued =\n                (min(block.timestamp, _pool.endTimestamp) - _pool.beginTimestamp) *\n                _pool.rewardsPerSecond;\n            _poolStatusInfo.created = true;\n        }\n    }\n\n    // View function to see pending REWARDs on frontend.\n    function getUserPendingRewardInfo(\n        AMMFactory _ammFactory,\n        AbstractMarketFactoryV3 _marketFactory,\n        uint256 _marketId,\n        address _userAddress\n    ) external view returns (PendingRewardInfo memory _pendingRewardInfo) {\n        RewardPoolLookupInfo memory _rewardPoolLookupInfo =\n            rewardPoolLookup[address(_ammFactory)][address(_marketFactory)][_marketId];\n\n        if (_rewardPoolLookupInfo.created) {\n            PoolInfo storage _pool = poolInfo[_rewardPoolLookupInfo.pid];\n            UserInfo storage _user = userInfo[_rewardPoolLookupInfo.pid][_userAddress];\n            uint256 accRewardsPerShare = _pool.accRewardsPerShare;\n            uint256 lpSupply = _pool.lpToken.balanceOf(address(this));\n\n            uint256 _duration = _pool.endTimestamp - _pool.beginTimestamp;\n\n            _pendingRewardInfo.created = true;\n            _pendingRewardInfo.beginTimestamp = _pool.beginTimestamp;\n            _pendingRewardInfo.endTimestamp = _pool.endTimestamp;\n            _pendingRewardInfo.earlyDepositEndTimestamp = getEarlyDepositEndTimestamp(_rewardPoolLookupInfo.pid);\n\n            if (_user.lastActionTimestamp <= _pendingRewardInfo.earlyDepositEndTimestamp) {\n                if (_pool.totalEarlyDepositBonusRewardShares > 0 && block.timestamp > _pendingRewardInfo.endTimestamp) {\n                    _pendingRewardInfo.accruedEarlyDepositBonusRewards = _pool\n                        .earlyDepositBonusRewards\n                        .mul(_user.amount)\n                        .div(_pool.totalEarlyDepositBonusRewardShares);\n                } else if (_pool.totalEarlyDepositBonusRewardShares > 0) {\n                    _pendingRewardInfo.pendingEarlyDepositBonusRewards = _pool\n                        .earlyDepositBonusRewards\n                        .mul(_user.amount)\n                        .div(_pool.totalEarlyDepositBonusRewardShares);\n                }\n            }\n\n            if (block.timestamp > _pool.lastRewardTimestamp && lpSupply != 0) {\n                uint256 multiplier = getTimeElapsed(_rewardPoolLookupInfo.pid);\n                accRewardsPerShare = accRewardsPerShare.add(multiplier.mul(_pool.rewardsPerSecond).div(lpSupply));\n            }\n\n            _pendingRewardInfo.accruedStandardRewards = _user.amount.mul(accRewardsPerShare).div(BONE).sub(\n                _user.rewardDebt\n            );\n        }\n    }\n\n    // Update reward variables for all pools. Be careful of gas spending!\n    function massUpdatePools() public {\n        uint256 length = poolInfo.length;\n        for (uint256 pid = 0; pid < length; ++pid) {\n            updatePool(pid);\n        }\n    }\n\n    // Update reward variables of the given pool to be up-to-date.\n    function updatePool(uint256 _pid) public {\n        PoolInfo storage pool = poolInfo[_pid];\n        if (block.timestamp <= pool.lastRewardTimestamp) {\n            return;\n        }\n        uint256 lpSupply = pool.lpToken.balanceOf(address(this));\n        if (lpSupply == 0) {\n            pool.lastRewardTimestamp = block.timestamp;\n            return;\n        }\n        uint256 multiplier = getTimeElapsed(_pid);\n        pool.accRewardsPerShare = pool.accRewardsPerShare.add(multiplier.mul(pool.rewardsPerSecond).div(lpSupply));\n        pool.lastRewardTimestamp = block.timestamp;\n    }\n\n    // Deposit LP tokens to MasterChef for REWARD allocation.\n    // Assumes the staked tokens are already on contract.\n    function depositInternal(\n        address _userAddress,\n        uint256 _pid,\n        uint256 _amount\n    ) internal {\n        PoolInfo storage _pool = poolInfo[_pid];\n        UserInfo storage _user = userInfo[_pid][_userAddress];\n\n        updatePool(_pid);\n\n        if (_user.amount > 0) {\n            uint256 pending = _user.amount.mul(_pool.accRewardsPerShare).div(BONE).sub(_user.rewardDebt);\n            safeRewardsTransfer(_userAddress, pending);\n        }\n\n        uint256 _rewardsPeriodsInSeconds = _pool.endTimestamp - _pool.beginTimestamp;\n        uint256 _bonusrewardsPeriodsEndTimestamp =\n            ((_rewardsPeriodsInSeconds * EARLY_DEPOSIT_BONUS_REWARDS_PERCENTAGE) / BONE) + _pool.beginTimestamp + 1;\n\n        // If the user was an early deposit, remove user amount from the pool.\n        // Even if the pools reward period has elapsed. They must withdraw first.\n        if (\n            block.timestamp > _bonusrewardsPeriodsEndTimestamp &&\n            _user.lastActionTimestamp <= _bonusrewardsPeriodsEndTimestamp\n        ) {\n            _pool.totalEarlyDepositBonusRewardShares = _pool.totalEarlyDepositBonusRewardShares.sub(_user.amount);\n        }\n\n        // Still in the early deposit bonus period.\n        if (_bonusrewardsPeriodsEndTimestamp > block.timestamp) {\n            _pool.totalEarlyDepositBonusRewardShares = _pool.totalEarlyDepositBonusRewardShares.add(_amount);\n        }\n\n        _user.amount = _user.amount.add(_amount);\n\n        _user.rewardDebt = _user.amount.mul(_pool.accRewardsPerShare).div(BONE);\n        _user.lastActionTimestamp = block.timestamp;\n        emit Deposit(_userAddress, _pid, _amount);\n    }\n\n    function depositByMarket(\n        AMMFactory _ammFactory,\n        AbstractMarketFactoryV3 _marketFactory,\n        uint256 _marketId,\n        uint256 _amount\n    ) public {\n        RewardPoolLookupInfo memory _rewardPoolLookupInfo =\n            rewardPoolLookup[address(_ammFactory)][address(_marketFactory)][_marketId];\n\n        require(_rewardPoolLookupInfo.created, \"Reward pool has not been created.\");\n\n        deposit(_rewardPoolLookupInfo.pid, _amount);\n    }\n\n    function deposit(uint256 _pid, uint256 _amount) public {\n        depositInternal(msg.sender, _pid, _amount);\n        poolInfo[_pid].lpToken.safeTransferFrom(msg.sender, address(this), _amount);\n    }\n\n    // Withdraw LP tokens from MasterChef.\n    // Assumes caller is handling distribution of LP tokens.\n    function withdrawInternal(\n        address _userAddress,\n        uint256 _pid,\n        uint256 _amount,\n        address _tokenRecipientAddress\n    ) internal {\n        PoolInfo storage _pool = poolInfo[_pid];\n        UserInfo storage _user = userInfo[_pid][_userAddress];\n        require(_user.amount >= _amount, \"withdraw: not good\");\n\n        updatePool(_pid);\n\n        uint256 _rewardsPeriodsInSeconds = _pool.endTimestamp - _pool.beginTimestamp;\n        uint256 _bonusrewardsPeriodsEndTimestamp =\n            ((_rewardsPeriodsInSeconds * EARLY_DEPOSIT_BONUS_REWARDS_PERCENTAGE) / BONE) + _pool.beginTimestamp + 1;\n        uint256 _rewardPeriodEndTimestamp = _rewardsPeriodsInSeconds + _pool.beginTimestamp + 1;\n\n        if (_rewardPeriodEndTimestamp <= block.timestamp) {\n            if (\n                _pool.totalEarlyDepositBonusRewardShares > 0 &&\n                _user.lastActionTimestamp <= _bonusrewardsPeriodsEndTimestamp\n            ) {\n                uint256 _rewardsToUser =\n                    _pool.earlyDepositBonusRewards.mul(_user.amount).div(_pool.totalEarlyDepositBonusRewardShares);\n                safeRewardsTransfer(_userAddress, _rewardsToUser);\n            }\n        } else if (_bonusrewardsPeriodsEndTimestamp >= block.timestamp) {\n            // Still in the early deposit bonus period.\n            _pool.totalEarlyDepositBonusRewardShares = _pool.totalEarlyDepositBonusRewardShares.sub(_amount);\n        } else if (\n            // If the user was an early deposit, remove user amount from the pool.\n            _bonusrewardsPeriodsEndTimestamp >= _user.lastActionTimestamp\n        ) {\n            _pool.totalEarlyDepositBonusRewardShares = _pool.totalEarlyDepositBonusRewardShares.sub(_user.amount);\n        }\n\n        uint256 pending = _user.amount.mul(_pool.accRewardsPerShare).div(BONE).sub(_user.rewardDebt);\n\n        safeRewardsTransfer(_tokenRecipientAddress, pending);\n        _user.amount = _user.amount.sub(_amount);\n        _user.rewardDebt = _user.amount.mul(_pool.accRewardsPerShare).div(BONE);\n        _user.lastActionTimestamp = block.timestamp;\n\n        emit Withdraw(msg.sender, _pid, _amount, _tokenRecipientAddress);\n    }\n\n    function withdrawByMarket(\n        AMMFactory _ammFactory,\n        AbstractMarketFactoryV3 _marketFactory,\n        uint256 _marketId,\n        uint256 _amount\n    ) public {\n        RewardPoolLookupInfo memory _rewardPoolLookupInfo =\n            rewardPoolLookup[address(_ammFactory)][address(_marketFactory)][_marketId];\n\n        require(_rewardPoolLookupInfo.created, \"Reward pool has not been created.\");\n\n        withdraw(_rewardPoolLookupInfo.pid, _amount);\n    }\n\n    function withdraw(uint256 _pid, uint256 _amount) public {\n        withdrawInternal(msg.sender, _pid, _amount, msg.sender);\n        poolInfo[_pid].lpToken.safeTransfer(msg.sender, _amount);\n    }\n\n    function createPool(\n        AMMFactory _ammFactory,\n        AbstractMarketFactoryV3 _marketFactory,\n        uint256 _marketId,\n        uint256 _initialLiquidity,\n        address _lpTokenRecipient\n    ) public returns (uint256) {\n        _marketFactory.collateral().transferFrom(msg.sender, address(this), _initialLiquidity);\n        _marketFactory.collateral().approve(address(_ammFactory), _initialLiquidity);\n\n        uint256 _lpTokensIn = _ammFactory.createPool(_marketFactory, _marketId, _initialLiquidity, address(this));\n        IERC20 _lpToken = IERC20(address(_ammFactory.getPool(_marketFactory, _marketId)));\n\n        uint256 _nextPID =\n            addInternal(\n                address(_ammFactory),\n                address(_marketFactory),\n                _marketId,\n                _lpToken,\n                _marketFactory.getRewardEndTime(_marketId)\n            );\n\n        depositInternal(_lpTokenRecipient, _nextPID, _lpTokensIn);\n\n        AbstractMarketFactoryV3.Market memory _market = _marketFactory.getMarket(_marketId);\n        uint256[] memory _balances = new uint256[](_market.shareTokens.length);\n        for (uint256 i = 0; i < _market.shareTokens.length; i++) {\n            _balances[i] = 0;\n        }\n\n        emit PoolCreated(address(_ammFactory), address(_marketFactory), _marketId, msg.sender, _lpTokenRecipient);\n        emit LiquidityChanged(\n            address(_ammFactory),\n            address(_marketFactory),\n            _marketId,\n            msg.sender,\n            _lpTokenRecipient,\n            -int256(_initialLiquidity),\n            int256(_lpTokensIn),\n            _balances\n        );\n\n        return _lpTokensIn;\n    }\n\n    function addLiquidity(\n        AMMFactory _ammFactory,\n        AbstractMarketFactoryV3 _marketFactory,\n        uint256 _marketId,\n        uint256 _collateralIn,\n        uint256 _minLPTokensOut,\n        address _lpTokenRecipient\n    ) public returns (uint256 _poolAmountOut, uint256[] memory _balances) {\n        RewardPoolLookupInfo memory _rewardPoolLookupInfo =\n            rewardPoolLookup[address(_ammFactory)][address(_marketFactory)][_marketId];\n\n        uint256 _pid = _rewardPoolLookupInfo.pid;\n\n        // If not created should attempt to create it.\n        if (!_rewardPoolLookupInfo.created) {\n            BPool _bPool = _ammFactory.getPool(_marketFactory, _marketId);\n            require(_bPool != BPool(address(0)), \"Pool not created.\");\n\n            _pid = addInternal(\n                address(_ammFactory),\n                address(_marketFactory),\n                _marketId,\n                IERC20(address(_bPool)),\n                _marketFactory.getRewardEndTime(_marketId)\n            );\n        }\n\n        _marketFactory.collateral().transferFrom(msg.sender, address(this), _collateralIn);\n        _marketFactory.collateral().approve(address(_ammFactory), _collateralIn);\n\n        (_poolAmountOut, _balances) = _ammFactory.addLiquidity(\n            _marketFactory,\n            _marketId,\n            _collateralIn,\n            _minLPTokensOut,\n            address(this)\n        );\n\n        AbstractMarketFactoryV3.Market memory _market = _marketFactory.getMarket(_marketId);\n        for (uint256 i = 0; i < _balances.length; i++) {\n            if (_balances[i] > 0) {\n                _market.shareTokens[i].transfer(_lpTokenRecipient, _balances[i]);\n            }\n        }\n\n        depositInternal(_lpTokenRecipient, _pid, _poolAmountOut);\n\n        emit LiquidityChanged(\n            address(_ammFactory),\n            address(_marketFactory),\n            _marketId,\n            msg.sender,\n            _lpTokenRecipient,\n            -int256(_collateralIn),\n            int256(_poolAmountOut),\n            _balances\n        );\n    }\n\n    function removeLiquidity(\n        AMMFactory _ammFactory,\n        AbstractMarketFactoryV3 _marketFactory,\n        uint256 _marketId,\n        uint256 _lpTokensIn,\n        uint256 _minCollateralOut,\n        address _collateralRecipient\n    ) public returns (uint256 _collateralOut, uint256[] memory _balances) {\n        RewardPoolLookupInfo memory _rewardPoolLookupInfo =\n            rewardPoolLookup[address(_ammFactory)][address(_marketFactory)][_marketId];\n\n        require(_rewardPoolLookupInfo.created, \"Reward pool has not been created.\");\n\n        withdrawInternal(msg.sender, _rewardPoolLookupInfo.pid, _lpTokensIn, _collateralRecipient);\n\n        PoolInfo storage _pool = poolInfo[_rewardPoolLookupInfo.pid];\n\n        _pool.lpToken.approve(address(_ammFactory), _lpTokensIn);\n\n        (_collateralOut, _balances) = _ammFactory.removeLiquidity(\n            _marketFactory,\n            _marketId,\n            _lpTokensIn,\n            _minCollateralOut,\n            _collateralRecipient\n        );\n\n        emit LiquidityChanged(\n            address(_ammFactory),\n            address(_marketFactory),\n            _marketId,\n            msg.sender,\n            _collateralRecipient,\n            int256(_collateralOut),\n            -int256(_lpTokensIn),\n            _balances\n        );\n    }\n\n    function withdrawRewards(uint256 _amount) external onlyOwner {\n        rewardsToken.transfer(msg.sender, _amount);\n    }\n\n    // Withdraw without caring about rewards. EMERGENCY ONLY.\n    function emergencyWithdraw(uint256 _pid) public {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        pool.lpToken.safeTransfer(address(msg.sender), user.amount);\n        emit EmergencyWithdraw(msg.sender, _pid, user.amount);\n        user.amount = 0;\n        user.rewardDebt = 0;\n        user.lastActionTimestamp = 0;\n    }\n\n    function safeRewardsTransfer(address _to, uint256 _amount) internal {\n        uint256 _rewardsBal = rewardsToken.balanceOf(address(this));\n        if (_amount > _rewardsBal) {\n            rewardsToken.transfer(_to, _rewardsBal);\n        } else {\n            rewardsToken.transfer(_to, _amount);\n        }\n    }\n\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a <= b) {\n            return a;\n        } else {\n            return b;\n        }\n    }\n}\n"
    },
    "contracts/turbo/CryptoCurrencyMarketFactoryV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../libraries/IERC20Full.sol\";\nimport \"../balancer/BPool.sol\";\nimport \"./AbstractMarketFactoryV3.sol\";\nimport \"./FeePot.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/SignedSafeMath.sol\";\nimport \"../utils/AggregatorV3Interface.sol\";\nimport \"../libraries/CalculateLinesToBPoolOdds.sol\";\nimport \"../libraries/Versioned.sol\";\nimport \"../libraries/ManagedByLink.sol\";\n\ncontract CryptoCurrencyMarketFactoryV3 is AbstractMarketFactoryV3, CalculateLinesToBPoolOdds, Versioned, ManagedByLink {\n    using SafeMath for uint256;\n    using SignedSafeMath for int256;\n\n    event CoinAdded(uint256 indexed id, string name);\n    event ValueUpdate(uint256 indexed coinIndex, uint256 indexed resolutionTime, uint256 market, uint256 value);\n\n    enum Outcome {\n        Above, // 0\n        NotAbove // 1\n    }\n    string constant Above = \"Above\";\n    string constant NotAbove = \"Not Above\";\n\n    struct Coin {\n        string name;\n        AggregatorV3Interface feed;\n        uint256 value;\n        uint8 imprecision; // how many decimals to truncate\n        uint256 currentMarket; // 0 indicates no current market\n    }\n    Coin[] public coins;\n\n    struct MarketDetails {\n        uint256 coinIndex;\n        uint256 creationValue;\n        uint256 resolutionValue;\n        uint256 resolutionTime; // value at given time; this is that time\n    }\n    // MarketId => MarketDetails\n    mapping(uint256 => MarketDetails) internal marketDetails;\n\n    constructor(\n        address _owner,\n        IERC20Full _collateral,\n        uint256 _shareFactor,\n        FeePot _feePot,\n        uint256[3] memory _fees,\n        address _protocol,\n        address _linkNode\n    )\n        AbstractMarketFactoryV3(_owner, _collateral, _shareFactor, _feePot, _fees, _protocol)\n        Versioned(\"v1.3.3\")\n        ManagedByLink(_linkNode)\n    {\n        string memory _name = \"\";\n        coins.push(makeCoin(_name, AggregatorV3Interface(address(0)), 0));\n    }\n\n    function getMarketDetails(uint256 _marketId) public view returns (MarketDetails memory) {\n        return marketDetails[_marketId];\n    }\n\n    // NOTE: Trusts the owner not to add a coin twice.\n    function addCoin(\n        string calldata _name,\n        AggregatorV3Interface _feed,\n        uint8 _imprecision\n    ) external onlyOwner returns (uint256 _coinIndex) {\n        Coin memory _coin = makeCoin(_name, _feed, _imprecision);\n        _coinIndex = coins.length;\n        coins.push(_coin);\n        emit CoinAdded(_coinIndex, _name);\n    }\n\n    function getCoin(uint256 _coinIndex) public view returns (Coin memory _coin) {\n        _coin = coins[_coinIndex];\n    }\n\n    function getCoins() public view returns (Coin[] memory _coins) {\n        _coins = new Coin[](coins.length);\n        // Skip first coin because it's always the zeroed-out fake coin.\n        for (uint256 i = 1; i < coins.length; i++) {\n            _coins[i] = coins[i];\n        }\n    }\n\n    // If _resolutionTime is 0 then do NOT create.\n    // If _roundId is 0 then do NOT resolve.\n    function pokeCoin(\n        uint256 _coinIndex,\n        uint256 _resolutionTime,\n        uint80 _roundId\n    ) public onlyLinkNode {\n        Coin storage _coin = coins[_coinIndex];\n\n        // There's a market to resolve.\n        if (_roundId != 0 && _coin.currentMarket != 0) {\n            resolveMarket(_coin, _roundId);\n        }\n\n        // Create a market\n        if (_resolutionTime != 0 && _coin.currentMarket == 0) {\n            createMarket(_coinIndex, _coin, _resolutionTime);\n        }\n    }\n\n    function createMarket(\n        uint256 _coinIndex,\n        Coin storage _coin,\n        uint256 _resolutionTime\n    ) internal returns (uint256 _marketId) {\n        (, uint256 _newValue) = getLatestValue(_coin);\n\n        string[] memory _outcomes = new string[](2);\n        _outcomes[uint256(Outcome.Above)] = Above;\n        _outcomes[uint256(Outcome.NotAbove)] = NotAbove;\n\n        _marketId = startMarket(linkNode, _outcomes, evenOdds(false, 2), true);\n        marketDetails[_marketId] = MarketDetails(_coinIndex, _newValue, 0, _resolutionTime);\n        _coin.currentMarket = _marketId;\n        _coin.value = _newValue;\n        emit ValueUpdate(_coinIndex, _resolutionTime, _marketId, _newValue);\n    }\n\n    function resolveMarket(Coin storage _coin, uint80 _roundId) internal {\n        uint256 _resolutionTime = marketDetails[_coin.currentMarket].resolutionTime;\n        (uint256 _fullValue, uint256 _newValue) = getSpecificValue(_coin, _roundId, _resolutionTime);\n\n        uint256 _winningOutcome;\n        if (_newValue > _coin.value) {\n            _winningOutcome = uint256(Outcome.Above);\n        } else {\n            _winningOutcome = uint256(Outcome.NotAbove);\n        }\n\n        endMarket(_coin.currentMarket, _winningOutcome);\n        marketDetails[_coin.currentMarket].resolutionValue = _fullValue;\n        _coin.currentMarket = 0;\n        _coin.value = 0;\n    }\n\n    function getLatestValue(Coin storage _coin) internal view returns (uint256 _fullValue, uint256 _truncatedValue) {\n        (, int256 _rawValue, , , ) = _coin.feed.latestRoundData();\n        require(_rawValue >= 0, \"Value from feed is negative\");\n        _fullValue = uint256(_rawValue);\n        _truncatedValue = calcTruncatedValue(_coin, _fullValue);\n    }\n\n    // Get value at a specific round, but fail if it isn't after a specific time.\n    function getSpecificValue(\n        Coin storage _coin,\n        uint80 _roundId,\n        uint256 _resolutionTime\n    ) internal view returns (uint256 _fullValue, uint256 _truncatedValue) {\n        (, int256 _rawValue, , uint256 _updatedAt, ) = _coin.feed.getRoundData(_roundId);\n        require(_rawValue >= 0, \"Value from feed is negative\");\n        require(_updatedAt >= _resolutionTime, \"Value hasn't been updated yet\");\n\n        (, , , uint256 _previousRoundTime, ) = _coin.feed.getRoundData(previousRound(_roundId));\n        require(_previousRoundTime < _resolutionTime, \"Must use first round after resolution time\");\n\n        _fullValue = uint256(_rawValue);\n        _truncatedValue = calcTruncatedValue(_coin, _fullValue);\n    }\n\n    // The precision is how many decimals the value has. Zero is dollars, 2 includes cents, 3 is tenths of a cent, etc.\n    // Our resolution rules want a certain precision. Like BTC is to the dollar and MATIC is to the cent.\n    // If somehow the decimals are larger than the desired precision then add zeroes to the end to meet the precision.\n    // This does not change the resolution outcome but does guard against decimals() changing and therefore altering the basis.\n    function calcTruncatedValue(Coin storage _coin, uint256 _fullValue)\n        internal\n        view\n        returns (uint256 _truncatedValue)\n    {\n        uint8 _precision = _coin.feed.decimals(); // probably constant but that isn't guaranteed, so query each time\n        if (_precision > _coin.imprecision) {\n            uint8 _truncate = _precision - _coin.imprecision;\n            _truncatedValue = _fullValue / (10**_truncate);\n        } else if (_precision < _coin.imprecision) {\n            uint8 _greaten = _coin.imprecision - _precision;\n            _truncatedValue = _fullValue * (10**_greaten);\n        } else {\n            _truncatedValue = _fullValue;\n        }\n\n        // Round up because that cleanly fits Above/Not-Above.\n        if (_truncatedValue != _fullValue) {\n            _truncatedValue += 1;\n        }\n    }\n\n    function makeCoin(\n        string memory _name,\n        AggregatorV3Interface _feed,\n        uint8 _imprecision\n    ) internal pure returns (Coin memory _coin) {\n        _coin = Coin(_name, _feed, 0, _imprecision, 0);\n    }\n\n    // The roundId is the encoding of two parts: the phase and the phase-specific round id.\n    // To find the previous roundId:\n    // 1. extract the phase and phase-specific round (I call these _phaseId and _roundId)\n    // 2. decrement the phase-specific round\n    // 3. re-encode the phase and phase-specific round.\n    uint256 private constant PHASE_OFFSET = 64;\n\n    function previousRound(uint80 _fullRoundId) internal pure returns (uint80) {\n        uint256 _phaseId = uint256(uint16(_fullRoundId >> PHASE_OFFSET));\n        uint64 _roundId = uint64(_fullRoundId) - 1;\n        return uint80((_phaseId << PHASE_OFFSET) | _roundId);\n    }\n\n    function getRewardEndTime(uint256 _marketId) public view override returns (uint256) {\n        return getMarketDetails(_marketId).resolutionTime;\n    }\n}\n"
    },
    "contracts/turbo/TrustedMarketFactoryV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./AbstractMarketFactoryV3.sol\";\nimport \"../libraries/CalculateLinesToBPoolOdds.sol\";\nimport \"../libraries/Versioned.sol\";\n\ncontract TrustedMarketFactoryV3 is AbstractMarketFactoryV3, CalculateLinesToBPoolOdds, Versioned {\n\n    struct MarketDetails {\n        string description;\n    }\n    MarketDetails[] internal marketDetails;\n    // mapping(uint256=> mapping(uint256=>uint256)) TradeDetails; //marketid -> (outcome->amount)\n\n    modifier onlyOwnerManager() {\n        require(msg.sender == owner || managers[msg.sender] , \"Only Validators can call this function\");\n        _;\n    }\n\n    mapping(address=>bool) managers; \n\n    constructor(\n        address _owner,\n        IERC20Full _collateral,\n        uint256 _shareFactor,\n        FeePot _feePot,\n        uint256[3] memory _fees,\n        address _protocol\n    ) AbstractMarketFactoryV3(_owner, _collateral, _shareFactor, _feePot, _fees, _protocol) Versioned(\"v1.1.0\") {}\n\n    //TODO add managers \n    function createMarket(\n        address _creator,\n        string calldata _description,\n        string[] calldata _names,\n        uint256[] calldata _odds\n    ) public  returns (uint256) {\n        marketDetails.push(MarketDetails(_description));\n        return startMarket(_creator, _names, _odds, true);\n    }\n\n    //TODO add managers \n    function trustedResolveMarket(uint256 _id, uint256 _winningOutcome) public {\n        endMarket(_id, _winningOutcome);\n    }\n\n    function getMarketDetails(uint256 _id) public view returns (MarketDetails memory) {\n        return marketDetails[_id];\n    }\n\n    function getRewardEndTime(uint256 _marketId) public view override returns (uint256) {\n        return 0;\n    }\n    \n\n\n    //ZCB markets\n      function createZCBMarket(\n        address _creator,\n        string calldata _description,\n        uint256[] calldata _odds, \n        OwnedERC20 zcb\n    ) public  returns (uint256) {\n        marketDetails.push(MarketDetails(_description));\n        return startZCBMarket(_creator, _odds, true, zcb);\n    }\n}\n"
    },
    "contracts/turbo/Fetcher.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../libraries/IERC20Full.sol\";\nimport \"../balancer/BPool.sol\";\nimport \"./AbstractMarketFactoryV3.sol\";\nimport \"./FeePot.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/SignedSafeMath.sol\";\nimport \"./MMAMarketFactoryV3.sol\";\nimport \"./AMMFactory.sol\";\nimport \"./CryptoMarketFactoryV3.sol\";\nimport \"./NBAMarketFactoryV3.sol\";\nimport \"../rewards/MasterChef.sol\";\nimport \"./CryptoCurrencyMarketFactoryV3.sol\";\nimport \"./TrustedMarketFactoryV3.sol\";\n\n// Helper contract for grabbing huge amounts of data without overloading multicall.\nabstract contract Fetcher {\n    using SafeMath for uint256;\n    using SignedSafeMath for int256;\n\n    struct CollateralBundle {\n        address addr;\n        string symbol;\n        uint256 decimals;\n    }\n\n    struct MarketFactoryBundle {\n        uint256 shareFactor;\n        uint256 stakerFee;\n        uint256 settlementFee;\n        uint256 protocolFee;\n        FeePot feePot;\n        CollateralBundle collateral;\n        uint256 marketCount;\n    }\n\n    struct PoolBundle {\n        address addr;\n        uint256[] tokenRatios;\n        uint256[] balances;\n        uint256[] weights;\n        uint256 swapFee;\n        uint256 totalSupply;\n    }\n\n    struct StaticMarketBundle {\n        AbstractMarketFactoryV3 factory;\n        uint256 marketId;\n        PoolBundle pool;\n        MasterChef.PoolStatusInfo rewards;\n        OwnedERC20[] shareTokens;\n        uint256 creationTimestamp;\n        OwnedERC20 winner;\n        uint256[] initialOdds;\n    }\n\n    struct DynamicMarketBundle {\n        AbstractMarketFactoryV3 factory;\n        uint256 marketId;\n        PoolBundle pool;\n        OwnedERC20 winner;\n    }\n\n    string public marketType;\n    string public version;\n\n    constructor(string memory _type, string memory _version) {\n        marketType = _type;\n        version = _version;\n    }\n\n    function buildCollateralBundle(IERC20Full _collateral) internal view returns (CollateralBundle memory _bundle) {\n        _bundle.addr = address(_collateral);\n        _bundle.symbol = _collateral.symbol();\n        _bundle.decimals = _collateral.decimals();\n    }\n\n    function buildMarketFactoryBundle(AbstractMarketFactoryV3 _marketFactory)\n        internal\n        view\n        returns (MarketFactoryBundle memory _bundle)\n    {\n        _bundle.shareFactor = _marketFactory.shareFactor();\n        _bundle.stakerFee = _marketFactory.stakerFee();\n        _bundle.settlementFee = _marketFactory.settlementFee();\n        _bundle.protocolFee = _marketFactory.protocolFee();\n        _bundle.feePot = _marketFactory.feePot();\n        _bundle.collateral = buildCollateralBundle(_marketFactory.collateral());\n        _bundle.marketCount = _marketFactory.marketCount();\n    }\n\n    function buildStaticMarketBundle(\n        AbstractMarketFactoryV3 _marketFactory,\n        AMMFactory _ammFactory,\n        MasterChef _masterChef,\n        uint256 _marketId\n    ) internal view returns (StaticMarketBundle memory _bundle) {\n        AbstractMarketFactoryV3.Market memory _market = _marketFactory.getMarket(_marketId);\n        _bundle.factory = _marketFactory;\n        _bundle.marketId = _marketId;\n        _bundle.pool = buildPoolBundle(_marketFactory, _ammFactory, _marketId);\n        _bundle.rewards = _masterChef.getPoolInfo(_ammFactory, _marketFactory, _marketId);\n        _bundle.shareTokens = _market.shareTokens;\n        _bundle.creationTimestamp = _market.creationTimestamp;\n        _bundle.winner = _market.winner;\n        _bundle.initialOdds = _market.initialOdds;\n    }\n\n    function buildDynamicMarketBundle(\n        AbstractMarketFactoryV3 _marketFactory,\n        AMMFactory _ammFactory,\n        uint256 _marketId\n    ) internal view returns (DynamicMarketBundle memory _bundle) {\n        AbstractMarketFactoryV3.Market memory _market = _marketFactory.getMarket(_marketId);\n\n        _bundle.factory = _marketFactory;\n        _bundle.marketId = _marketId;\n        _bundle.winner = _market.winner;\n        _bundle.pool = buildPoolBundle(_marketFactory, _ammFactory, _marketId);\n    }\n\n    function buildPoolBundle(\n        AbstractMarketFactoryV3 _marketFactory,\n        AMMFactory _ammFactory,\n        uint256 _marketId\n    ) internal view returns (PoolBundle memory _bundle) {\n        BPool _pool = _ammFactory.getPool(_marketFactory, _marketId);\n        if (_pool == BPool(address(0))) return _bundle;\n\n        _bundle.addr = address(_pool);\n        _bundle.totalSupply = _pool.totalSupply();\n        _bundle.swapFee = _ammFactory.getSwapFee(_marketFactory, _marketId);\n        _bundle.balances = _ammFactory.getPoolBalances(_marketFactory, _marketId);\n        _bundle.tokenRatios = _ammFactory.tokenRatios(_marketFactory, _marketId);\n        _bundle.weights = _ammFactory.getPoolWeights(_marketFactory, _marketId);\n    }\n\n    function openOrHasWinningShares(AbstractMarketFactoryV3 _marketFactory, uint256 _marketId)\n        internal\n        view\n        returns (bool)\n    {\n        AbstractMarketFactoryV3.Market memory _market = _marketFactory.getMarket(_marketId);\n        if (_market.winner == OwnedERC20(address(0))) return true; // open\n        return _market.winner.totalSupply() > 0; // has winning shares\n    }\n}\n\nabstract contract SportsFetcher is Fetcher {\n    struct SpecificMarketFactoryBundle {\n        MarketFactoryBundle _super;\n    }\n\n    struct StaticEventBundle {\n        uint256 id;\n        StaticMarketBundle[] markets;\n        int256[] lines;\n        uint256 estimatedStartTime;\n        uint256 homeTeamId;\n        uint256 awayTeamId;\n        string homeTeamName;\n        string awayTeamName;\n        // Dynamics\n        Sport.SportsEventStatus status;\n        uint256 homeScore;\n        uint256 awayScore;\n    }\n\n    struct DynamicEventBundle {\n        uint256 id;\n        Sport.SportsEventStatus status;\n        DynamicMarketBundle[] markets;\n        uint256 homeScore;\n        uint256 awayScore;\n    }\n\n    function buildSpecificMarketFactoryBundle(address _marketFactory)\n        internal\n        view\n        returns (SpecificMarketFactoryBundle memory _bundle)\n    {\n        _bundle._super = buildMarketFactoryBundle(AbstractMarketFactoryV3(_marketFactory));\n    }\n\n    function fetchInitial(\n        address _marketFactory,\n        AMMFactory _ammFactory,\n        MasterChef _masterChef,\n        uint256 _offset,\n        uint256 _total\n    )\n        public\n        view\n        returns (\n            SpecificMarketFactoryBundle memory _marketFactoryBundle,\n            StaticEventBundle[] memory _eventBundles,\n            uint256 _lowestEventIndex,\n            uint256 _timestamp\n        )\n    {\n        _marketFactoryBundle = buildSpecificMarketFactoryBundle(_marketFactory);\n        (_eventBundles, _lowestEventIndex) = buildStaticEventBundles(\n            _marketFactory,\n            _ammFactory,\n            _masterChef,\n            _offset,\n            _total\n        );\n        _timestamp = block.timestamp;\n    }\n\n    function fetchDynamic(\n        address _marketFactory,\n        AMMFactory _ammFactory,\n        uint256 _offset,\n        uint256 _total\n    )\n        public\n        view\n        returns (\n            DynamicEventBundle[] memory _bundles,\n            uint256 _lowestEventIndex,\n            uint256 _timestamp\n        )\n    {\n        (_bundles, _lowestEventIndex) = buildDynamicEventBundles(_marketFactory, _ammFactory, _offset, _total);\n        _timestamp = block.timestamp;\n    }\n\n    function buildStaticEventBundles(\n        address _marketFactory,\n        AMMFactory _ammFactory,\n        MasterChef _masterChef,\n        uint256 _offset,\n        uint256 _total\n    ) internal view returns (StaticEventBundle[] memory _bundles, uint256 _lowestEventIndex) {\n        uint256[] memory _eventIds;\n        (_eventIds, _lowestEventIndex) = listOfInterestingEvents(_marketFactory, _offset, _total);\n\n        _total = _eventIds.length;\n        _bundles = new StaticEventBundle[](_total);\n        for (uint256 i; i < _total; i++) {\n            _bundles[i] = buildStaticEventBundle(_marketFactory, _ammFactory, _masterChef, _eventIds[i]);\n        }\n    }\n\n    function buildDynamicEventBundles(\n        address _marketFactory,\n        AMMFactory _ammFactory,\n        uint256 _offset,\n        uint256 _total\n    ) internal view returns (DynamicEventBundle[] memory _bundles, uint256 _lowestEventIndex) {\n        uint256[] memory _eventIds;\n        (_eventIds, _lowestEventIndex) = listOfInterestingEvents(_marketFactory, _offset, _total);\n\n        _total = _eventIds.length;\n        _bundles = new DynamicEventBundle[](_total);\n        for (uint256 i; i < _total; i++) {\n            _bundles[i] = buildDynamicEventBundle(_marketFactory, _ammFactory, _eventIds[i]);\n        }\n    }\n\n    function buildStaticEventBundle(\n        address _marketFactory,\n        AMMFactory _ammFactory,\n        MasterChef _masterChef,\n        uint256 _eventId\n    ) internal view returns (StaticEventBundle memory _bundle) {\n        Sport.SportsEvent memory _event = Sport(_marketFactory).getSportsEvent(_eventId);\n\n        StaticMarketBundle[] memory _markets = new StaticMarketBundle[](_event.markets.length);\n        for (uint256 i = 0; i < _markets.length; i++) {\n            _markets[i] = buildStaticMarketBundle(\n                AbstractMarketFactoryV3(_marketFactory),\n                _ammFactory,\n                _masterChef,\n                _event.markets[i]\n            );\n        }\n\n        _bundle.id = _eventId;\n        _bundle.status = _event.status;\n        _bundle.markets = _markets;\n        _bundle.lines = _event.lines;\n        _bundle.estimatedStartTime = _event.estimatedStartTime;\n        _bundle.homeTeamId = _event.homeTeamId;\n        _bundle.awayTeamId = _event.awayTeamId;\n        _bundle.homeTeamName = _event.homeTeamName;\n        _bundle.awayTeamName = _event.awayTeamName;\n        _bundle.homeScore = _event.homeScore;\n        _bundle.awayScore = _event.awayScore;\n    }\n\n    function buildDynamicEventBundle(\n        address _marketFactory,\n        AMMFactory _ammFactory,\n        uint256 _eventId\n    ) internal view returns (DynamicEventBundle memory _bundle) {\n        Sport.SportsEvent memory _event = Sport(_marketFactory).getSportsEvent(_eventId);\n\n        DynamicMarketBundle[] memory _markets = new DynamicMarketBundle[](_event.markets.length);\n        for (uint256 i = 0; i < _markets.length; i++) {\n            _markets[i] = buildDynamicMarketBundle(\n                AbstractMarketFactoryV3(_marketFactory),\n                _ammFactory,\n                _event.markets[i]\n            );\n        }\n\n        _bundle.id = _eventId;\n        _bundle.markets = _markets;\n        _bundle.status = _event.status;\n        _bundle.homeScore = _event.homeScore;\n        _bundle.awayScore = _event.awayScore;\n    }\n\n    // Starts from the end of the events list because newer events are more interesting.\n    // _offset is skipping all events, not just interesting events\n    function listOfInterestingEvents(\n        address _marketFactory,\n        uint256 _offset,\n        uint256 _total\n    ) internal view returns (uint256[] memory _interestingEventIds, uint256 _eventIndex) {\n        _interestingEventIds = new uint256[](_total);\n\n        uint256 _eventCount = Sport(_marketFactory).eventCount();\n\n        // No events so return nothing. (needed to avoid integer underflow below)\n        if (_eventCount == 0) {\n            return (new uint256[](0), 0);\n        }\n\n        uint256 _max = _eventCount;\n\n        // No remaining events so return nothing. (needed to avoid integer underflow below)\n        if (_offset > _max) {\n            return (new uint256[](0), 0);\n        }\n\n        uint256 _collectedEvents = 0;\n        _eventIndex = _max - _offset;\n        while (true) {\n            if (_collectedEvents >= _total) break;\n            if (_eventIndex == 0) break;\n\n            _eventIndex--; // starts out one too high, so this works\n\n            (Sport.SportsEvent memory _event, uint256 _eventId) =\n                Sport(_marketFactory).getSportsEventByIndex(_eventIndex);\n\n            if (isEventInteresting(_event, AbstractMarketFactoryV3(_marketFactory))) {\n                _interestingEventIds[_collectedEvents] = _eventId;\n                _collectedEvents++;\n            }\n        }\n\n        if (_total > _collectedEvents) {\n            assembly {\n                // shortens array\n                mstore(_interestingEventIds, _collectedEvents)\n            }\n        }\n    }\n\n    function isEventInteresting(Sport.SportsEvent memory _event, AbstractMarketFactoryV3 _marketFactory)\n        private\n        view\n        returns (bool)\n    {\n        for (uint256 i = 0; i < _event.markets.length; i++) {\n            uint256 _marketId = _event.markets[i];\n            if (openOrHasWinningShares(_marketFactory, _marketId)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n\ncontract NBAFetcher is SportsFetcher {\n    constructor() Fetcher(\"NBA\", \"TBD\") {}\n}\n\ncontract MLBFetcher is SportsFetcher {\n    constructor() Fetcher(\"MLB\", \"TBD\") {}\n}\n\ncontract MMAFetcher is SportsFetcher {\n    constructor() Fetcher(\"MMA\", \"TBD\") {}\n}\n\ncontract NFLFetcher is SportsFetcher {\n    constructor() Fetcher(\"NFL\", \"TBD\") {}\n}\n\ncontract CryptoFetcher is Fetcher {\n    constructor() Fetcher(\"Crypto\", \"TBD\") {}\n\n    struct SpecificMarketFactoryBundle {\n        MarketFactoryBundle _super;\n    }\n\n    struct SpecificStaticMarketBundle {\n        StaticMarketBundle _super;\n        uint8 marketType;\n        uint256 coinIndex;\n        uint256 creationPrice;\n        uint256 resolutionTime;\n        // Dynamics\n        uint256 resolutionPrice;\n    }\n\n    struct SpecificDynamicMarketBundle {\n        DynamicMarketBundle _super;\n        uint256 resolutionPrice;\n    }\n\n    function buildSpecificMarketFactoryBundle(address _marketFactory)\n        internal\n        view\n        returns (SpecificMarketFactoryBundle memory _bundle)\n    {\n        _bundle._super = buildMarketFactoryBundle(CryptoMarketFactoryV3(_marketFactory));\n    }\n\n    function buildSpecificStaticMarketBundle(\n        address _marketFactory,\n        AMMFactory _ammFactory,\n        MasterChef _masterChef,\n        uint256 _marketId\n    ) internal view returns (SpecificStaticMarketBundle memory _bundle) {\n        CryptoMarketFactoryV3.MarketDetails memory _details =\n            CryptoMarketFactoryV3(_marketFactory).getMarketDetails(_marketId);\n        _bundle._super = buildStaticMarketBundle(\n            CryptoMarketFactoryV3(_marketFactory),\n            _ammFactory,\n            _masterChef,\n            _marketId\n        );\n        _bundle.marketType = uint8(_details.marketType);\n        _bundle.creationPrice = _details.creationPrice;\n        _bundle.coinIndex = _details.coinIndex;\n        _bundle.resolutionPrice = _details.resolutionPrice;\n        _bundle.resolutionTime = _details.resolutionTime;\n    }\n\n    function buildSpecificDynamicMarketBundle(\n        address _marketFactory,\n        AMMFactory _ammFactory,\n        uint256 _marketId\n    ) internal view returns (SpecificDynamicMarketBundle memory _bundle) {\n        CryptoMarketFactoryV3.MarketDetails memory _details =\n            CryptoMarketFactoryV3(_marketFactory).getMarketDetails(_marketId);\n        _bundle._super = buildDynamicMarketBundle(CryptoMarketFactoryV3(_marketFactory), _ammFactory, _marketId);\n        _bundle.resolutionPrice = _details.resolutionPrice;\n    }\n\n    function fetchInitial(\n        address _marketFactory,\n        AMMFactory _ammFactory,\n        MasterChef _masterChef,\n        uint256 _offset,\n        uint256 _total\n    )\n        public\n        view\n        returns (\n            SpecificMarketFactoryBundle memory _marketFactoryBundle,\n            SpecificStaticMarketBundle[] memory _marketBundles,\n            uint256 _lowestMarketIndex,\n            uint256 _timestamp\n        )\n    {\n        _marketFactoryBundle = buildSpecificMarketFactoryBundle(_marketFactory);\n\n        uint256[] memory _marketIds;\n        (_marketIds, _lowestMarketIndex) = listOfInterestingMarkets(_marketFactory, _offset, _total);\n\n        _total = _marketIds.length;\n        _marketBundles = new SpecificStaticMarketBundle[](_total);\n        for (uint256 i; i < _total; i++) {\n            _marketBundles[i] = buildSpecificStaticMarketBundle(\n                _marketFactory,\n                _ammFactory,\n                _masterChef,\n                _marketIds[i]\n            );\n        }\n\n        _timestamp = block.timestamp;\n    }\n\n    function fetchDynamic(\n        address _marketFactory,\n        AMMFactory _ammFactory,\n        uint256 _offset,\n        uint256 _total\n    )\n        public\n        view\n        returns (\n            SpecificDynamicMarketBundle[] memory _bundles,\n            uint256 _lowestMarketIndex,\n            uint256 _timestamp\n        )\n    {\n        uint256[] memory _marketIds;\n        (_marketIds, _lowestMarketIndex) = listOfInterestingMarkets(_marketFactory, _offset, _total);\n\n        _total = _marketIds.length;\n        _bundles = new SpecificDynamicMarketBundle[](_total);\n        for (uint256 i; i < _total; i++) {\n            _bundles[i] = buildSpecificDynamicMarketBundle(_marketFactory, _ammFactory, _marketIds[i]);\n        }\n\n        _timestamp = block.timestamp;\n    }\n\n    // Starts from the end of the markets list because newer markets are more interesting.\n    // _offset is skipping all markets, not just interesting markets\n    function listOfInterestingMarkets(\n        address _marketFactory,\n        uint256 _offset,\n        uint256 _total\n    ) internal view returns (uint256[] memory _interestingMarketIds, uint256 _marketId) {\n        _interestingMarketIds = new uint256[](_total);\n        uint256 _max = AbstractMarketFactoryV3(_marketFactory).marketCount() - 1;\n\n        // No markets so return nothing. (needed to prevent integer underflow below)\n        if (_max == 0 || _offset >= _max) {\n            return (new uint256[](0), 0);\n        }\n\n        // Starts at the end, less offset.\n        // Stops before the 0th market since that market is always fake.\n        uint256 _collectedMarkets = 0;\n        _marketId = _max - _offset;\n\n        while (true) {\n            if (openOrHasWinningShares(AbstractMarketFactoryV3(_marketFactory), _marketId)) {\n                _interestingMarketIds[_collectedMarkets] = _marketId;\n                _collectedMarkets++;\n            }\n\n            if (_collectedMarkets >= _total) break;\n            if (_marketId == 1) break; // skipping 0th market, which is fake\n            _marketId--; // starts out oone too high, so this works\n        }\n\n        if (_total > _collectedMarkets) {\n            assembly {\n                // shortens array\n                mstore(_interestingMarketIds, _collectedMarkets)\n            }\n        }\n    }\n}\n\ncontract CryptoCurrencyFetcher is Fetcher {\n    constructor() Fetcher(\"CryptoCurrency\", \"TBD\") {}\n\n    struct SpecificMarketFactoryBundle {\n        MarketFactoryBundle _super;\n    }\n\n    struct SpecificStaticMarketBundle {\n        StaticMarketBundle _super;\n        uint256 coinIndex;\n        uint256 creationValue;\n        uint256 resolutionTime;\n        // Dynamics\n        uint256 resolutionValue;\n    }\n\n    struct SpecificDynamicMarketBundle {\n        DynamicMarketBundle _super;\n        uint256 resolutionValue;\n    }\n\n    function buildSpecificMarketFactoryBundle(address _marketFactory)\n        internal\n        view\n        returns (SpecificMarketFactoryBundle memory _bundle)\n    {\n        _bundle._super = buildMarketFactoryBundle(CryptoCurrencyMarketFactoryV3(_marketFactory));\n    }\n\n    function buildSpecificStaticMarketBundle(\n        address _marketFactory,\n        AMMFactory _ammFactory,\n        MasterChef _masterChef,\n        uint256 _marketId\n    ) internal view returns (SpecificStaticMarketBundle memory _bundle) {\n        CryptoCurrencyMarketFactoryV3.MarketDetails memory _details =\n            CryptoCurrencyMarketFactoryV3(_marketFactory).getMarketDetails(_marketId);\n        _bundle._super = buildStaticMarketBundle(\n            CryptoCurrencyMarketFactoryV3(_marketFactory),\n            _ammFactory,\n            _masterChef,\n            _marketId\n        );\n        _bundle.creationValue = _details.creationValue;\n        _bundle.coinIndex = _details.coinIndex;\n        _bundle.resolutionValue = _details.resolutionValue;\n        _bundle.resolutionTime = _details.resolutionTime;\n    }\n\n    function buildSpecificDynamicMarketBundle(\n        address _marketFactory,\n        AMMFactory _ammFactory,\n        uint256 _marketId\n    ) internal view returns (SpecificDynamicMarketBundle memory _bundle) {\n        CryptoCurrencyMarketFactoryV3.MarketDetails memory _details =\n            CryptoCurrencyMarketFactoryV3(_marketFactory).getMarketDetails(_marketId);\n        _bundle._super = buildDynamicMarketBundle(CryptoCurrencyMarketFactoryV3(_marketFactory), _ammFactory, _marketId);\n        _bundle.resolutionValue = _details.resolutionValue;\n    }\n\n    function fetchInitial(\n        address _marketFactory,\n        AMMFactory _ammFactory,\n        MasterChef _masterChef,\n        uint256 _offset,\n        uint256 _total\n    )\n        public\n        view\n        returns (\n            SpecificMarketFactoryBundle memory _marketFactoryBundle,\n            SpecificStaticMarketBundle[] memory _marketBundles,\n            uint256 _lowestMarketIndex,\n            uint256 _timestamp\n        )\n    {\n        _marketFactoryBundle = buildSpecificMarketFactoryBundle(_marketFactory);\n\n        uint256[] memory _marketIds;\n        (_marketIds, _lowestMarketIndex) = listOfInterestingMarkets(_marketFactory, _offset, _total);\n\n        _total = _marketIds.length;\n        _marketBundles = new SpecificStaticMarketBundle[](_total);\n        for (uint256 i; i < _total; i++) {\n            _marketBundles[i] = buildSpecificStaticMarketBundle(\n                _marketFactory,\n                _ammFactory,\n                _masterChef,\n                _marketIds[i]\n            );\n        }\n\n        _timestamp = block.timestamp;\n    }\n\n    function fetchDynamic(\n        address _marketFactory,\n        AMMFactory _ammFactory,\n        uint256 _offset,\n        uint256 _total\n    )\n        public\n        view\n        returns (\n            SpecificDynamicMarketBundle[] memory _bundles,\n            uint256 _lowestMarketIndex,\n            uint256 _timestamp\n        )\n    {\n        uint256[] memory _marketIds;\n        (_marketIds, _lowestMarketIndex) = listOfInterestingMarkets(_marketFactory, _offset, _total);\n\n        _total = _marketIds.length;\n        _bundles = new SpecificDynamicMarketBundle[](_total);\n        for (uint256 i; i < _total; i++) {\n            _bundles[i] = buildSpecificDynamicMarketBundle(_marketFactory, _ammFactory, _marketIds[i]);\n        }\n\n        _timestamp = block.timestamp;\n    }\n\n    // Starts from the end of the markets list because newer markets are more interesting.\n    // _offset is skipping all markets, not just interesting markets\n    function listOfInterestingMarkets(\n        address _marketFactory,\n        uint256 _offset,\n        uint256 _total\n    ) internal view returns (uint256[] memory _interestingMarketIds, uint256 _marketId) {\n        _interestingMarketIds = new uint256[](_total);\n        uint256 _max = AbstractMarketFactoryV3(_marketFactory).marketCount() - 1;\n\n        // No markets so return nothing. (needed to prevent integer underflow below)\n        if (_max == 0 || _offset >= _max) {\n            return (new uint256[](0), 0);\n        }\n\n        // Starts at the end, less offset.\n        // Stops before the 0th market since that market is always fake.\n        uint256 _collectedMarkets = 0;\n        _marketId = _max - _offset;\n\n        while (true) {\n            if (openOrHasWinningShares(AbstractMarketFactoryV3(_marketFactory), _marketId)) {\n                _interestingMarketIds[_collectedMarkets] = _marketId;\n                _collectedMarkets++;\n            }\n\n            if (_collectedMarkets >= _total) break;\n            if (_marketId == 1) break; // skipping 0th market, which is fake\n            _marketId--; // starts out oone too high, so this works\n        }\n\n        if (_total > _collectedMarkets) {\n            assembly {\n                // shortens array\n                mstore(_interestingMarketIds, _collectedMarkets)\n            }\n        }\n    }\n}\n\n\n// contract TrustedFetcher is Fetcher {\n//     constructor() Fetcher(\"Trusted\", \"TBD\") {}\n\n//     struct SpecificMarketFactoryBundle {\n//         MarketFactoryBundle _super;\n//     }\n\n//     struct SpecificStaticMarketBundle {\n//         StaticMarketBundle _super;\n//         // uint256 coinIndex;\n//         // uint256 creationValue;\n//         // uint256 resolutionTime;\n//         // // Dynamics\n//         // uint256 resolutionValue;\n//         string description;\n//     }\n\n//     struct SpecificDynamicMarketBundle {\n//         DynamicMarketBundle _super;\n//         //uint256 resolutionValue;\n//         string description;\n\n//     }\n\n//     function getMarket(    address _marketFactory,\n//         AMMFactory _ammFactory,\n//         MasterChef _masterChef,\n//         uint256 _marketId) public view returns(   SpecificStaticMarketBundle memory _bundle\n// ){\n//         TrustedMarketFactoryV3.MarketDetails memory _details =\n//             TrustedMarketFactoryV3(_marketFactory).getMarketDetails(_marketId);\n//         _bundle._super = buildStaticMarketBundle(\n//             TrustedMarketFactoryV3(_marketFactory),\n//             _ammFactory,\n//             _masterChef,\n//             _marketId\n//         );\n//         _bundle.description = _details.description;\n//     }\n\n//     function buildSpecificMarketFactoryBundle(address _marketFactory)\n//         internal\n//         view\n//         returns (SpecificMarketFactoryBundle memory _bundle)\n//     {\n//         _bundle._super = buildMarketFactoryBundle(TrustedMarketFactoryV3(_marketFactory));\n//     }\n\n//     function buildSpecificStaticMarketBundle(\n//         address _marketFactory,\n//         AMMFactory _ammFactory,\n//         MasterChef _masterChef,\n//         uint256 _marketId\n//     ) internal view returns (SpecificStaticMarketBundle memory _bundle) {\n//         TrustedMarketFactoryV3.MarketDetails memory _details =\n//             TrustedMarketFactoryV3(_marketFactory).getMarketDetails(_marketId);\n//         _bundle._super = buildStaticMarketBundle(\n//             TrustedMarketFactoryV3(_marketFactory),\n//             _ammFactory,\n//             _masterChef,\n//             _marketId\n//         );\n//         _bundle.description = _details.description;\n//         // _bundle.creationValue = _details.creationValue;\n//         // _bundle.coinIndex = _details.coinIndex;\n//         // _bundle.resolutionValue = _details.resolutionValue;\n//         // _bundle.resolutionTime = _details.resolutionTime;\n//     }\n\n//     function buildSpecificDynamicMarketBundle(\n//         address _marketFactory,\n//         AMMFactory _ammFactory,\n//         uint256 _marketId\n//     ) internal view returns (SpecificDynamicMarketBundle memory _bundle) {\n//         TrustedMarketFactoryV3.MarketDetails memory _details =\n//             TrustedMarketFactoryV3(_marketFactory).getMarketDetails(_marketId);\n//         _bundle._super = buildDynamicMarketBundle(TrustedMarketFactoryV3(_marketFactory), _ammFactory, _marketId);\n//         _bundle.description = _details.description;\n//     }\n\n//     function fetchInitial(\n//         address _marketFactory,\n//         AMMFactory _ammFactory,\n//         MasterChef _masterChef,\n//         uint256 _offset,\n//         uint256 _total\n//     )\n//         public\n//         view\n//         returns (\n//             SpecificMarketFactoryBundle memory _marketFactoryBundle,\n//             SpecificStaticMarketBundle[] memory _marketBundles,\n//             uint256 _lowestMarketIndex,\n//             uint256 _timestamp\n//         )\n//     {\n//         _marketFactoryBundle = buildSpecificMarketFactoryBundle(_marketFactory);\n\n//         uint256[] memory _marketIds;\n//         (_marketIds, _lowestMarketIndex) = listOfInterestingMarkets(_marketFactory, _offset, _total);\n\n//         _total = _marketIds.length;\n//         _marketBundles = new SpecificStaticMarketBundle[](_total);\n//         for (uint256 i; i < _total; i++) {\n//             _marketBundles[i] = buildSpecificStaticMarketBundle(\n//                 _marketFactory,\n//                 _ammFactory,\n//                 _masterChef,\n//                 _marketIds[i]\n//             );\n//         }\n\n//         _timestamp = block.timestamp;\n//     }\n\n//     function fetchDynamic(\n//         address _marketFactory,\n//         AMMFactory _ammFactory,\n//         uint256 _offset,\n//         uint256 _total\n//     )\n//         public\n//         view\n//         returns (\n//             SpecificDynamicMarketBundle[] memory _bundles,\n//             uint256 _lowestMarketIndex,\n//             uint256 _timestamp\n//         )\n//     {\n//         uint256[] memory _marketIds;\n//         (_marketIds, _lowestMarketIndex) = listOfInterestingMarkets(_marketFactory, _offset, _total);\n\n//         _total = _marketIds.length;\n//         _bundles = new SpecificDynamicMarketBundle[](_total);\n//         for (uint256 i; i < _total; i++) {\n//             _bundles[i] = buildSpecificDynamicMarketBundle(_marketFactory, _ammFactory, _marketIds[i]);\n//         }\n\n//         _timestamp = block.timestamp;\n//     }\n\n//     // Starts from the end of the markets list because newer markets are more interesting.\n//     // _offset is skipping all markets, not just interesting markets\n//     function listOfInterestingMarkets(\n//         address _marketFactory,\n//         uint256 _offset,\n//         uint256 _total\n//     ) internal view returns (uint256[] memory _interestingMarketIds, uint256 _marketId) {\n//         _interestingMarketIds = new uint256[](_total);\n//         uint256 _max = AbstractMarketFactoryV3(_marketFactory).marketCount() - 1;\n\n//         // No markets so return nothing. (needed to prevent integer underflow below)\n//         if (_max == 0 || _offset >= _max) {\n//             return (new uint256[](0), 0);\n//         }\n\n//         // Starts at the end, less offset.\n//         // Stops before the 0th market since that market is always fake.\n//         uint256 _collectedMarkets = 0;\n//         _marketId = _max - _offset;\n\n//         while (true) {\n//             if (openOrHasWinningShares(AbstractMarketFactoryV3(_marketFactory), _marketId)) {\n//                 _interestingMarketIds[_collectedMarkets] = _marketId;\n//                 _collectedMarkets++;\n//             }\n\n//             if (_collectedMarkets >= _total) break;\n//             if (_marketId == 1) break; // skipping 0th market, which is fake\n//             _marketId--; // starts out oone too high, so this works\n//         }\n\n//         if (_total > _collectedMarkets) {\n//             assembly {\n//                 // shortens array\n//                 mstore(_interestingMarketIds, _collectedMarkets)\n//             }\n//         }\n//     }\n// }\n"
    },
    "contracts/libraries/Sport.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../turbo/AbstractMarketFactoryV3.sol\";\nimport \"./LineHelper.sol\";\n\nabstract contract Sport is AbstractMarketFactoryV3, LineHelper {\n    event SportsEventCreated(\n        uint256 id,\n        uint256[] markets,\n        int256[] lines,\n        uint256 homeTeamId,\n        uint256 awayTeamId,\n        string homeTeamName,\n        string awayTeamName,\n        uint256 estimatedStartTime\n    );\n\n    enum SportsEventStatus {Unknown, Scheduled, Final, Postponed, Canceled}\n    struct SportsEvent {\n        SportsEventStatus status;\n        uint256[] markets;\n        int256[] lines;\n        uint256 estimatedStartTime;\n        uint256 homeTeamId;\n        uint256 awayTeamId;\n        string homeTeamName;\n        string awayTeamName;\n        uint256 homeScore;\n        uint256 awayScore;\n    }\n    // EventId => EventDetails\n    mapping(uint256 => SportsEvent) public sportsEvents;\n    uint256[] public listOfSportsEvents;\n    mapping(uint256 => uint256) public marketIdToEventIdMapping;\n    uint256 constant NoContest = 0;\n\n    function eventCount() public view returns (uint256) {\n        return listOfSportsEvents.length;\n    }\n\n    function getSportsEvent(uint256 _eventId) public view returns (SportsEvent memory) {\n        return sportsEvents[_eventId];\n    }\n\n    function getSportsEventByIndex(uint256 _index) public view returns (SportsEvent memory _event, uint256 _eventId) {\n        _eventId = listOfSportsEvents[_index];\n        _event = getSportsEvent(_eventId);\n    }\n\n    function makeSportsEvent(\n        uint256 _eventId,\n        uint256[] memory _markets,\n        int256[] memory _lines,\n        uint256 _estimatedStartTime,\n        uint256 _homeTeamId,\n        uint256 _awayTeamId,\n        string memory _homeTeamName,\n        string memory _awayTeamName\n    ) internal {\n        // Cannot create markets for an event twice.\n        require(sportsEvents[_eventId].status == SportsEventStatus.Unknown, \"event exists\");\n\n        for (uint256 i = 0; i < _markets.length; i++) {\n            marketIdToEventIdMapping[_markets[i]] = _eventId;\n        }\n\n        listOfSportsEvents.push(_eventId);\n        sportsEvents[_eventId].status = SportsEventStatus.Scheduled; // new events must be Scheduled\n        sportsEvents[_eventId].markets = _markets;\n        sportsEvents[_eventId].lines = _lines;\n        sportsEvents[_eventId].estimatedStartTime = _estimatedStartTime;\n        sportsEvents[_eventId].homeTeamId = _homeTeamId;\n        sportsEvents[_eventId].awayTeamId = _awayTeamId;\n        sportsEvents[_eventId].homeTeamName = _homeTeamName;\n        sportsEvents[_eventId].awayTeamName = _awayTeamName;\n        // homeScore and awayScore default to zero, which is correct for new events\n\n        emit SportsEventCreated(\n            _eventId,\n            _markets,\n            _lines,\n            _homeTeamId,\n            _awayTeamId,\n            _homeTeamName,\n            _awayTeamName,\n            _estimatedStartTime\n        );\n    }\n\n    uint256 constant WhoWonUnknown = 0;\n    uint256 constant WhoWonHome = 1;\n    uint256 constant WhoWonAway = 2;\n    uint256 constant WhoWonDraw = 3;\n\n    function eventIsNoContest(\n        SportsEvent memory _event,\n        SportsEventStatus _eventStatus,\n        uint256 _homeTeamId,\n        uint256 _awayTeamId,\n        uint256 _whoWon // pass in WhoWonUnknown if using a scoring sport\n    ) internal pure returns (bool) {\n        bool _draw = _whoWon == WhoWonDraw;\n        bool _notFinal = _eventStatus != SportsEventStatus.Final;\n        bool _unstableHomeTeamId = _event.homeTeamId != _homeTeamId;\n        bool _unstableAwayTeamId = _event.awayTeamId != _awayTeamId;\n        return _draw || _notFinal || _unstableHomeTeamId || _unstableAwayTeamId;\n    }\n\n    function resolveInvalidEvent(uint256 _eventId) internal {\n        uint256[] memory _marketIds = sportsEvents[_eventId].markets;\n        for (uint256 i = 0; i < _marketIds.length; i++) {\n            uint256 _marketId = _marketIds[i];\n            if (_marketId == 0) continue; // skip non-created markets\n            endMarket(_marketId, NoContest);\n        }\n    }\n\n    // TODO is this needed? getSportsEvent should do the same\n    function getEventMarkets(uint256 _eventId) public view returns (uint256[] memory _markets) {\n        uint256[] storage _original = sportsEvents[_eventId].markets;\n        uint256 _len = _original.length;\n        _markets = new uint256[](_len);\n        for (uint256 i = 0; i < _len; i++) {\n            _markets[i] = _original[i];\n        }\n    }\n\n    function getRewardEndTime(uint256 _marketId) public view override returns (uint256) {\n        uint256 _eventId = marketIdToEventIdMapping[_marketId];\n        return getSportsEvent(_eventId).estimatedStartTime;\n    }\n}\n\n// TODO change this to work with the Fetcher contracts and use it there, since it's offchain-read-only.\nabstract contract SportView is Sport {\n    // Only usable off-chain. Gas cost can easily eclipse block limit.\n    // Lists all events that could be resolved with a call to resolveEvent.\n    // Not all will be resolvable because this does not ensure the game ended.\n    function listResolvableEvents() external view returns (uint256[] memory) {\n        uint256 _totalResolvable = countResolvableEvents();\n        uint256[] memory _resolvableEvents = new uint256[](_totalResolvable);\n\n        uint256 n = 0;\n        for (uint256 i = 0; i < listOfSportsEvents.length; i++) {\n            if (n > _totalResolvable) break;\n            uint256 _eventId = listOfSportsEvents[i];\n            if (isEventResolvable(_eventId)) {\n                _resolvableEvents[n] = _eventId;\n                n++;\n            }\n        }\n\n        return _resolvableEvents;\n    }\n\n    function countResolvableEvents() internal view returns (uint256) {\n        uint256 _totalResolvable = 0;\n        for (uint256 i = 0; i < listOfSportsEvents.length; i++) {\n            uint256 _eventId = listOfSportsEvents[i];\n            if (isEventResolvable(_eventId)) {\n                _totalResolvable++;\n            }\n        }\n        return _totalResolvable;\n    }\n\n    // Returns true if a call to resolveEvent is potentially useful.\n    function isEventResolvable(uint256 _eventId) internal view returns (bool) {\n        uint256[] memory _markets = getEventMarkets(_eventId);\n\n        bool _unresolved = false; // default because non-existing markets aren't resolvable\n        for (uint256 i = 0; i < _markets.length; i++) {\n            uint256 _marketId = _markets[i];\n            if (_marketId != 0 && !isMarketResolved(_marketId)) {\n                _unresolved = true;\n                break;\n            }\n        }\n\n        return _unresolved;\n    }\n}\n"
    },
    "contracts/libraries/ResolveByFiat.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./Sport.sol\";\nimport \"./ManagedByLink.sol\";\n\nabstract contract ResolvesByFiat is Sport, ManagedByLink {\n    function resolveEvent(\n        uint256 _eventId,\n        SportsEventStatus _eventStatus,\n        uint256 _homeTeamId, // for verifying team stability\n        uint256 _awayTeamId, // for verifying team stability\n        uint256 _whoWon\n    ) public onlyLinkNode {\n        SportsEvent storage _event = sportsEvents[_eventId];\n\n        require(_event.status == SportsEventStatus.Scheduled);\n        require(SportsEventStatus(_eventStatus) != SportsEventStatus.Scheduled);\n\n        if (eventIsNoContest(_event, _eventStatus, _homeTeamId, _awayTeamId, _whoWon)) {\n            resolveInvalidEvent(_eventId);\n        } else {\n            resolveValidEvent(_event, _whoWon);\n        }\n\n        sportsEvents[_eventId].status = _eventStatus;\n    }\n\n    function resolveValidEvent(SportsEvent memory _event, uint256 _whoWon) internal virtual;\n}\n"
    },
    "contracts/libraries/HasHeadToHeadMarket.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../turbo/AbstractMarketFactoryV3.sol\";\nimport \"./Sport.sol\";\nimport \"./CalculateLinesToBPoolOdds.sol\";\nimport \"./TokenNamesFromTeams.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/SignedSafeMath.sol\";\n\nabstract contract HasHeadToHeadMarket is\n    AbstractMarketFactoryV3,\n    Sport,\n    CalculateLinesToBPoolOdds,\n    TokenNamesFromTeams\n{\n    using SafeMath for uint256;\n    using SignedSafeMath for int256;\n\n    uint256 private headToHeadMarketType;\n    string private noContestName;\n\n    uint256 constant HeadToHeadAway = 1;\n    uint256 constant HeadToHeadHome = 2;\n\n    constructor(uint256 _marketType, string memory _noContestName) {\n        headToHeadMarketType = _marketType;\n        noContestName = _noContestName;\n    }\n\n    function makeHeadToHeadMarket(\n        int256[2] memory _moneylines,\n        string memory _homeTeamName,\n        string memory _awayTeamName\n    ) internal returns (uint256) {\n        // moneylines is [home,away] but the outcomes are listed [NC,away,home] so they must be reversed\n        return\n            makeSportsMarket(\n                noContestName,\n                _homeTeamName,\n                _awayTeamName,\n                oddsFromLines(_moneylines[1], _moneylines[0])\n            );\n    }\n\n    function resolveHeadToHeadMarket(\n        uint256 _marketId,\n        uint256 _homeScore,\n        uint256 _awayScore\n    ) internal {\n        uint256 _shareTokenIndex = calcHeadToHeadWinner(_homeScore, _awayScore);\n        endMarket(_marketId, _shareTokenIndex);\n    }\n\n    function calcHeadToHeadWinner(uint256 _homeScore, uint256 _awayScore) private pure returns (uint256) {\n        if (_homeScore > _awayScore) {\n            return HeadToHeadHome;\n        } else if (_homeScore < _awayScore) {\n            return HeadToHeadAway;\n        } else {\n            return NoContest;\n        }\n    }\n}\n"
    },
    "contracts/libraries/Versioned.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nabstract contract Versioned {\n    string internal version;\n\n    constructor(string memory _version) {\n        version = _version;\n    }\n\n    function getVersion() public view returns (string memory) {\n        return version;\n    }\n}\n"
    },
    "contracts/libraries/LineHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nabstract contract LineHelper {\n    function build1Line() internal pure returns (int256[] memory _lines) {\n        _lines = new int256[](1);\n    }\n\n    function build3Lines(int256 _homeSpread, int256 _totalScore) internal pure returns (int256[] memory _lines) {\n        _lines = new int256[](3);\n        // 0 is the Head-to-Head market, which has no lines\n        _lines[1] = addHalfPoint(_homeSpread);\n        _lines[2] = addHalfPoint(_totalScore);\n    }\n\n    function addHalfPoint(int256 _line) internal pure returns (int256) {\n        // The line is a quantity of tenths. So 55 is 5.5 and -6 is -60.\n        // If the line is a whole number then make it a half point more extreme, to eliminate ties.\n        // So 50 becomes 55, -60 becomes -65, and 0 becomes 5.\n        if (_line >= 0 && _line % 10 == 0) {\n            return _line + 5;\n        } else if (_line < 0 && (-_line) % 10 == 0) {\n            return _line - 5;\n        } else {\n            return _line;\n        }\n    }\n}\n"
    },
    "contracts/libraries/ManagedByLink.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./Ownable.sol\";\n\nabstract contract ManagedByLink is Ownable {\n    event LinkNodeChanged(address newLinkNode);\n\n    address public linkNode;\n\n    constructor(address _linkNode) {\n        linkNode = _linkNode;\n    }\n\n    function setLinkNode(address _newLinkNode) external onlyOwner {\n        linkNode = _newLinkNode;\n        emit LinkNodeChanged(_newLinkNode);\n    }\n\n    modifier onlyLinkNode() {\n        require(msg.sender == linkNode);\n        _;\n    }\n}\n"
    },
    "contracts/libraries/CalculateLinesToBPoolOdds.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/SignedSafeMath.sol\";\n\nabstract contract CalculateLinesToBPoolOdds {\n    using SafeMath for uint256;\n    using SignedSafeMath for int256;\n\n    uint256 constant MAX_BPOOL_WEIGHT = 50e18;\n\n    function ratioOdds(uint256[] memory _proportions) internal pure returns (uint256[] memory _odds) {\n        uint256 _total = sum(_proportions);\n\n        _odds = new uint256[](_proportions.length);\n        for (uint256 i = 0; i < _proportions.length; i++) {\n            _odds[i] = (MAX_BPOOL_WEIGHT).mul(_proportions[i]).div(_total);\n            require(_odds[i] >= 1e18, \"min outcome weight is 2%\");\n        }\n    }\n\n    function sum(uint256[] memory _numbers) private pure returns (uint256 _sum) {\n        for (uint256 i = 0; i < _numbers.length; i++) {\n            _sum += _numbers[i];\n        }\n    }\n\n    function evenOdds(bool _invalid, uint256 _outcomes) internal pure returns (uint256[] memory _odds) {\n        uint256 _size = _outcomes + (_invalid ? 1 : 0);\n        _odds = new uint256[](_size);\n\n        if (_invalid) _odds[0] = 1e18; // 2%\n\n        uint256 _each = (_invalid ? 49e18 : 50e18) / _outcomes;\n        for (uint256 i = _invalid ? 1 : 0; i < _size; i++) {\n            _odds[i] = _each;\n        }\n    }\n\n    function oddsFromLines(int256 _moneyline1, int256 _moneyline2) internal pure returns (uint256[] memory _odds) {\n        uint256 _odds1 = __calcLineToOdds(_moneyline1);\n        uint256 _odds2 = __calcLineToOdds(_moneyline2);\n\n        uint256 _total = _odds1 + _odds2;\n\n        _odds1 = uint256(49e18).mul(_odds1).div(_total);\n        _odds2 = uint256(49e18).mul(_odds2).div(_total);\n\n        // Moneyline odds are too skewed: would have under 2% odds.\n        require(_odds1 >= 1e18);\n        require(_odds2 >= 1e18);\n\n        _odds = new uint256[](3);\n        _odds[0] = 1e18; // Invalid, 2%\n        _odds[1] = _odds1;\n        _odds[2] = _odds2;\n    }\n\n    function __calcLineToOdds(int256 _line) internal pure returns (uint256) {\n        if (_line < 0) {\n            // favored\n            uint256 _posLine = uint256(-_line);\n            return _posLine.mul(49e18).div(_posLine.add(100)); // 49e18 * _line / (_line + 100)\n        } else {\n            // underdog\n            return uint256(4900e18).div(uint256(_line).add(100)); // 49e18 * 100 / (_line + 100)\n        }\n    }\n}\n"
    },
    "contracts/libraries/TokenNamesFromTeams.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./Sport.sol\";\n\nabstract contract TokenNamesFromTeams is Sport {\n    uint256 constant Away = 1;\n    uint256 constant Home = 2;\n\n    function makeSportsMarket(\n        string memory _noContestName,\n        string memory _homeTeamName,\n        string memory _awayTeamName,\n        uint256[] memory _odds\n    ) internal returns (uint256) {\n        string[] memory _outcomeNames = makeOutcomeNames(_noContestName, _homeTeamName, _awayTeamName);\n        return startMarket(msg.sender, _outcomeNames, _odds, true);\n    }\n\n    function makeOutcomeNames(\n        string memory _noContestName,\n        string memory _homeTeamName,\n        string memory _awayTeamName\n    ) private pure returns (string[] memory _names) {\n        _names = new string[](3);\n        _names[NoContest] = _noContestName;\n        _names[Away] = _awayTeamName;\n        _names[Home] = _homeTeamName;\n    }\n}\n"
    },
    "contracts/utils/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}"
    },
    "contracts/libraries/HasSpreadMarket.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../turbo/AbstractMarketFactoryV3.sol\";\nimport \"./Sport.sol\";\nimport \"./CalculateLinesToBPoolOdds.sol\";\nimport \"./TokenNamesFromTeams.sol\";\n\nabstract contract HasSpreadMarket is AbstractMarketFactoryV3, Sport, CalculateLinesToBPoolOdds, TokenNamesFromTeams {\n    using SafeMath for uint256;\n    using SignedSafeMath for int256;\n\n    uint256 private spreadMarketType;\n    string private noContestName;\n\n    uint256 constant SpreadAway = 1;\n    uint256 constant SpreadHome = 2;\n\n    constructor(uint256 _marketType, string memory _noContestName) {\n        spreadMarketType = _marketType;\n        noContestName = _noContestName;\n    }\n\n    function makeSpreadMarket(string memory _homeTeamName, string memory _awayTeamName) internal returns (uint256) {\n        return makeSportsMarket(noContestName, _homeTeamName, _awayTeamName, evenOdds(true, 2));\n    }\n\n    function resolveSpreadMarket(\n        uint256 _marketId,\n        int256 _line,\n        uint256 _homeScore,\n        uint256 _awayScore\n    ) internal {\n        uint256 _shareTokenIndex = calcSpreadWinner(_homeScore, _awayScore, _line);\n        endMarket(_marketId, _shareTokenIndex);\n    }\n\n    function calcSpreadWinner(\n        uint256 _homeScore,\n        uint256 _awayScore,\n        int256 _targetSpread\n    ) internal pure returns (uint256) {\n        int256 _adjustedHomeScore = int256(_homeScore) + int256(_targetSpread);\n\n        if (_adjustedHomeScore > int256(_awayScore)) {\n            return SpreadHome; // home spread greater\n        } else if (_adjustedHomeScore < int256(_awayScore)) {\n            return SpreadAway; // away spread lesser\n        } else {\n            // draw / tie; some sports eliminate this with half-points\n            return NoContest;\n        }\n    }\n}\n"
    },
    "contracts/libraries/ResolveByScore.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./Sport.sol\";\nimport \"./ManagedByLink.sol\";\n\nabstract contract ResolvesByScore is Sport, ManagedByLink {\n    function resolveEvent(\n        uint256 _eventId,\n        SportsEventStatus _eventStatus,\n        uint256 _homeTeamId, // for verifying team stability\n        uint256 _awayTeamId, // for verifying team stability\n        uint256 _homeScore,\n        uint256 _awayScore\n    ) public onlyLinkNode {\n        SportsEvent storage _event = sportsEvents[_eventId];\n\n        require(_event.status == SportsEventStatus.Scheduled);\n        require(uint8(_eventStatus) >= uint8(SportsEventStatus.Final));\n\n        if (eventIsNoContest(_event, _eventStatus, _homeTeamId, _awayTeamId, WhoWonUnknown)) {\n            resolveInvalidEvent(_eventId);\n        } else {\n            resolveValidEvent(_event, _homeScore, _awayScore);\n        }\n\n        _event.status = _eventStatus;\n        _event.homeScore = _homeScore;\n        _event.awayScore = _awayScore;\n    }\n\n    function resolveValidEvent(\n        SportsEvent memory _event,\n        uint256 _homeScore,\n        uint256 _awayScore\n    ) internal virtual;\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/structs/EnumerableSet.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n *  Trying to delete such a structure from storage will likely result in data corruption, rendering the structure unusable.\n *  See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n *  In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "contracts/turbo/GroupFetcher.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./Fetcher.sol\";\nimport \"./Grouped.sol\";\n\nabstract contract GroupFetcher is Fetcher {\n    struct SpecificMarketFactoryBundle {\n        MarketFactoryBundle _super;\n    }\n\n    struct StaticGroupBundle {\n        uint256 id;\n        string name;\n        StaticMarketBundle[] markets;\n        string[] marketNames;\n        StaticMarketBundle invalidMarket;\n        string invalidMarketName;\n        uint256 endTime;\n        string category;\n        // Dynamics\n        Grouped.GroupStatus status;\n    }\n\n    struct DynamicGroupBundle {\n        uint256 id;\n        Grouped.GroupStatus status;\n        DynamicMarketBundle[] markets;\n        DynamicMarketBundle invalidMarket;\n    }\n\n    function buildSpecificMarketFactoryBundle(address _marketFactory)\n        internal\n        view\n        returns (SpecificMarketFactoryBundle memory _bundle)\n    {\n        _bundle._super = buildMarketFactoryBundle(AbstractMarketFactoryV3(_marketFactory));\n    }\n\n    function fetchInitial(\n        address _marketFactory,\n        AMMFactory _ammFactory,\n        MasterChef _masterChef,\n        uint256 _offset,\n        uint256 _total\n    )\n        public\n        view\n        returns (\n            SpecificMarketFactoryBundle memory _marketFactoryBundle,\n            StaticGroupBundle[] memory _groupBundles,\n            uint256 _lowestGroupIndex,\n            uint256 _timestamp\n        )\n    {\n        _marketFactoryBundle = buildSpecificMarketFactoryBundle(_marketFactory);\n        (_groupBundles, _lowestGroupIndex) = buildStaticGroupBundles(\n            _marketFactory,\n            _ammFactory,\n            _masterChef,\n            _offset,\n            _total\n        );\n        _timestamp = block.timestamp;\n    }\n\n    function fetchDynamic(\n        address _marketFactory,\n        AMMFactory _ammFactory,\n        uint256 _offset,\n        uint256 _total\n    )\n        public\n        view\n        returns (\n            DynamicGroupBundle[] memory _bundles,\n            uint256 _lowestGroupIndex,\n            uint256 _timestamp\n        )\n    {\n        (_bundles, _lowestGroupIndex) = buildDynamicGroupBundles(_marketFactory, _ammFactory, _offset, _total);\n        _timestamp = block.timestamp;\n    }\n\n    function buildStaticGroupBundles(\n        address _marketFactory,\n        AMMFactory _ammFactory,\n        MasterChef _masterChef,\n        uint256 _offset,\n        uint256 _total\n    ) internal view returns (StaticGroupBundle[] memory _bundles, uint256 _lowestGroupIndex) {\n        uint256[] memory _groupIds;\n        (_groupIds, _lowestGroupIndex) = listOfInterestingGroups(_marketFactory, _offset, _total);\n\n        _total = _groupIds.length;\n        _bundles = new StaticGroupBundle[](_total);\n        for (uint256 i; i < _total; i++) {\n            _bundles[i] = buildStaticGroupBundle(_marketFactory, _ammFactory, _masterChef, _groupIds[i]);\n        }\n    }\n\n    function buildDynamicGroupBundles(\n        address _marketFactory,\n        AMMFactory _ammFactory,\n        uint256 _offset,\n        uint256 _total\n    ) internal view returns (DynamicGroupBundle[] memory _bundles, uint256 _lowestGroupIndex) {\n        uint256[] memory _groupIds;\n        (_groupIds, _lowestGroupIndex) = listOfInterestingGroups(_marketFactory, _offset, _total);\n\n        _total = _groupIds.length;\n        _bundles = new DynamicGroupBundle[](_total);\n        for (uint256 i; i < _total; i++) {\n            _bundles[i] = buildDynamicGroupBundle(_marketFactory, _ammFactory, _groupIds[i]);\n        }\n    }\n\n    function buildStaticGroupBundle(\n        address _marketFactory,\n        AMMFactory _ammFactory,\n        MasterChef _masterChef,\n        uint256 _groupId\n    ) internal view returns (StaticGroupBundle memory _bundle) {\n        Grouped.MarketGroup memory _group = Grouped(_marketFactory).getGroup(_groupId);\n\n        StaticMarketBundle[] memory _markets = new StaticMarketBundle[](_group.markets.length);\n        for (uint256 i = 0; i < _markets.length; i++) {\n            _markets[i] = buildStaticMarketBundle(\n                AbstractMarketFactoryV3(_marketFactory),\n                _ammFactory,\n                _masterChef,\n                _group.markets[i]\n            );\n        }\n\n        _bundle.id = _groupId;\n        _bundle.name = _group.name;\n        _bundle.status = _group.status;\n        _bundle.markets = _markets;\n        _bundle.endTime = _group.endTime;\n        _bundle.invalidMarket = buildStaticMarketBundle(\n            AbstractMarketFactoryV3(_marketFactory),\n            _ammFactory,\n            _masterChef,\n            _group.invalidMarket\n        );\n        _bundle.invalidMarketName = _group.invalidMarketName;\n        _bundle.marketNames = _group.marketNames;\n        _bundle.category = _group.category;\n    }\n\n    function buildDynamicGroupBundle(\n        address _marketFactory,\n        AMMFactory _ammFactory,\n        uint256 _groupId\n    ) internal view returns (DynamicGroupBundle memory _bundle) {\n        Grouped.MarketGroup memory _group = Grouped(_marketFactory).getGroup(_groupId);\n\n        DynamicMarketBundle[] memory _markets = new DynamicMarketBundle[](_group.markets.length);\n        for (uint256 i = 0; i < _markets.length; i++) {\n            _markets[i] = buildDynamicMarketBundle(\n                AbstractMarketFactoryV3(_marketFactory),\n                _ammFactory,\n                _group.markets[i]\n            );\n        }\n\n        _bundle.id = _groupId;\n        _bundle.markets = _markets;\n        _bundle.invalidMarket = buildDynamicMarketBundle(\n            AbstractMarketFactoryV3(_marketFactory),\n            _ammFactory,\n            _group.invalidMarket\n        );\n        _bundle.status = _group.status;\n    }\n\n    // Starts from the end of the groups list because newer groups are more interesting.\n    // _offset is skipping all groups, not just interesting groups\n    function listOfInterestingGroups(\n        address _marketFactory,\n        uint256 _offset,\n        uint256 _total\n    ) internal view returns (uint256[] memory _interestingGroupIds, uint256 _groupIndex) {\n        _interestingGroupIds = new uint256[](_total);\n\n        uint256 _groupCount = Grouped(_marketFactory).groupCount();\n\n        // No groups so return nothing. (needed to avoid integer underflow below)\n        if (_groupCount == 0) {\n            return (new uint256[](0), 0);\n        }\n\n        uint256 _max = _groupCount;\n\n        // No remaining groups so return nothing. (needed to avoid integer underflow below)\n        if (_offset > _max) {\n            return (new uint256[](0), 0);\n        }\n\n        uint256 _collectedGroups = 0;\n        _groupIndex = _max - _offset;\n        while (true) {\n            if (_collectedGroups >= _total) break;\n            if (_groupIndex == 0) break;\n\n            _groupIndex--; // starts out one too high, so this works\n\n            (Grouped.MarketGroup memory _group, uint256 _groupId) =\n                Grouped(_marketFactory).getGroupByIndex(_groupIndex);\n\n            if (isGroupInteresting(_group, AbstractMarketFactoryV3(_marketFactory))) {\n                _interestingGroupIds[_collectedGroups] = _groupId;\n                _collectedGroups++;\n            }\n        }\n\n        if (_total > _collectedGroups) {\n            assembly {\n                // shortens array\n                mstore(_interestingGroupIds, _collectedGroups)\n            }\n        }\n    }\n\n    function isGroupInteresting(Grouped.MarketGroup memory _group, AbstractMarketFactoryV3 _marketFactory)\n        private\n        view\n        returns (bool)\n    {\n        for (uint256 i = 0; i < _group.markets.length; i++) {\n            uint256 _marketId = _group.markets[i];\n            if (openOrHasWinningShares(_marketFactory, _marketId)) {\n                return true;\n            }\n        }\n        if (openOrHasWinningShares(_marketFactory, _group.invalidMarket)) {\n            return true;\n        }\n\n        return false;\n    }\n}\n\ncontract GroupedFetcher is GroupFetcher {\n    constructor() Fetcher(\"Grouped\", \"TBD\") {}\n}\n"
    },
    "contracts/turbo/Grouped.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./AbstractMarketFactoryV3.sol\";\nimport \"../libraries/CalculateLinesToBPoolOdds.sol\";\nimport \"./GroupFetcher.sol\";\n\nabstract contract Grouped is AbstractMarketFactoryV3, CalculateLinesToBPoolOdds {\n    event GroupCreated(uint256 indexed id, uint256 endTime, uint256 invalidMarketId, string invalidMarketName);\n    event GroupMarketAdded(uint256 indexed groupId, uint256 marketId, string marketName);\n    event GroupFinalizing(uint256 indexed groupId, uint256 winningMarketIndex);\n    event GroupResolved(uint256 indexed id, bool valid);\n\n    enum GroupStatus {Unknown, Scheduled, Finalizing, Final, Invalid}\n\n    struct MarketGroup {\n        GroupStatus status;\n        string name;\n        uint256[] markets;\n        string[] marketNames;\n        uint256 invalidMarket;\n        string invalidMarketName;\n        uint256 endTime;\n        string category;\n        uint256 winningMarketIndex; // ignore when status is Scheduled. MAX_UINT is invalid\n    }\n    // GroupId => MarketGroup\n    mapping(uint256 => MarketGroup) public marketGroups;\n    uint256[] public listOfMarketGroups;\n\n    // For regular markets, YES means the team won and NO means the team did not win.\n    // For the invalid market, YES means none of the teams won and NO means a team won.\n    uint256 constant OUTCOME_NO = 0;\n    uint256 constant OUTCOME_YES = 1;\n\n    uint256 constant MAX_UINT = 2**256 - 1;\n\n    function groupCount() public view returns (uint256) {\n        return listOfMarketGroups.length;\n    }\n\n    function getGroup(uint256 _groupId) public view returns (MarketGroup memory) {\n        return marketGroups[_groupId];\n    }\n\n    function getGroupByIndex(uint256 _index) public view returns (MarketGroup memory _group, uint256 _groupId) {\n        _groupId = listOfMarketGroups[_index];\n        _group = getGroup(_groupId);\n    }\n\n    function startCreatingMarketGroup(\n        uint256 _groupId,\n        string memory _groupName,\n        uint256 _endTime,\n        string memory _invalidMarketName,\n        string memory _category\n    ) internal {\n        require(marketGroups[_groupId].status == GroupStatus.Unknown, \"group exists\");\n\n        listOfMarketGroups.push(_groupId);\n        marketGroups[_groupId].status = GroupStatus.Scheduled;\n        marketGroups[_groupId].name = _groupName;\n        marketGroups[_groupId].endTime = _endTime;\n        marketGroups[_groupId].category = _category;\n\n        uint256 _invalidMarket = startMarket(msg.sender, buildOutcomesNames(_invalidMarketName), invalidOdds(), true);\n        marketGroups[_groupId].invalidMarket = _invalidMarket;\n        marketGroups[_groupId].invalidMarketName = _invalidMarketName;\n\n        emit GroupCreated(_groupId, _endTime, _invalidMarket, _invalidMarketName);\n        emit GroupMarketAdded(_groupId, _invalidMarket, _invalidMarketName);\n    }\n\n    function addMarketToMarketGroup(\n        uint256 _groupId,\n        string memory _marketName,\n        uint256[] memory _odds\n    ) internal {\n        require(marketGroups[_groupId].status == GroupStatus.Scheduled, \"group must be Scheduled\");\n\n        uint256 _marketId = startMarket(msg.sender, buildOutcomesNames(_marketName), _odds, true);\n        marketGroups[_groupId].markets.push(_marketId);\n        marketGroups[_groupId].marketNames.push(_marketName);\n        emit GroupMarketAdded(_groupId, _marketId, _marketName);\n    }\n\n    // Use MAX_UINT for _winningMarketIndex to indicate INVALID\n    function startResolvingMarketGroup(uint256 _groupId, uint256 _winningMarketIndex) internal {\n        bool _isInvalid = _winningMarketIndex == MAX_UINT;\n        MarketGroup memory _group = marketGroups[_groupId];\n\n        require(_group.status == GroupStatus.Scheduled, \"group not Scheduled\");\n\n        resolveInvalidMarket(_group, _isInvalid);\n        marketGroups[_groupId].status = GroupStatus.Finalizing;\n        marketGroups[_groupId].winningMarketIndex = _winningMarketIndex;\n        emit GroupFinalizing(_groupId, _winningMarketIndex);\n    }\n\n    function resolveFinalizingGroupMarket(uint256 _groupId, uint256 _marketIndex) internal {\n        MarketGroup memory _group = marketGroups[_groupId];\n        require(_group.status == GroupStatus.Finalizing, \"must be finalizing\");\n\n        uint256 _marketId = _group.markets[_marketIndex];\n        bool _wins = _marketIndex == _group.winningMarketIndex;\n        resolveGroupMarket(_marketId, _wins);\n    }\n\n    function finalizeMarketGroup(uint256 _groupId) internal {\n        MarketGroup storage _group = marketGroups[_groupId];\n        require(_group.status == GroupStatus.Finalizing);\n\n        bool _valid = _group.winningMarketIndex != MAX_UINT;\n\n        _group.status = _valid ? GroupStatus.Final : GroupStatus.Invalid;\n\n        emit GroupResolved(_groupId, _valid);\n    }\n\n    function resolveGroupMarket(uint256 _marketId, bool _wins) internal {\n        uint256 _winningOutcome = _wins ? OUTCOME_YES : OUTCOME_NO;\n        endMarket(_marketId, _winningOutcome);\n    }\n\n    function resolveInvalidMarket(MarketGroup memory _group, bool _invalid) private {\n        uint256 _outcomeIndex = _invalid ? OUTCOME_YES : OUTCOME_NO;\n        endMarket(_group.invalidMarket, _outcomeIndex);\n    }\n\n    function buildOutcomesNames(string memory _marketName) internal pure returns (string[] memory _names) {\n        _names = new string[](2);\n        _names[OUTCOME_NO] = string(abi.encodePacked(\"NO - \", _marketName));\n        _names[OUTCOME_YES] = string(abi.encodePacked(\"YES - \", _marketName));\n    }\n\n    function invalidOdds() private pure returns (uint256[] memory _odds) {\n        _odds = new uint256[](2);\n        _odds[OUTCOME_YES] = 1e18;\n        _odds[OUTCOME_NO] = 49e18;\n    }\n}\n"
    },
    "contracts/turbo/GroupedMarketFactoryV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./AbstractMarketFactoryV3.sol\";\nimport \"./FeePot.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/SignedSafeMath.sol\";\nimport \"./Grouped.sol\";\nimport \"../libraries/ManagedByLink.sol\";\nimport \"../libraries/Versioned.sol\";\n\ncontract GroupedMarketFactoryV3 is AbstractMarketFactoryV3, Grouped, ManagedByLink, Versioned {\n    using SafeMath for uint256;\n    using SignedSafeMath for int256;\n\n    constructor(\n        address _owner,\n        IERC20Full _collateral,\n        uint256 _shareFactor,\n        FeePot _feePot,\n        uint256[3] memory _fees,\n        address _protocol,\n        address _linkNode\n    )\n        AbstractMarketFactoryV3(_owner, _collateral, _shareFactor, _feePot, _fees, _protocol)\n        Versioned(\"v1.2.0\")\n        ManagedByLink(_linkNode)\n    {}\n\n    function initializeGroup(\n        uint256 _groupId,\n        string memory _groupName,\n        string memory _invalidMarketName,\n        uint256 _endTime,\n        string memory _category\n    ) public onlyLinkNode {\n        startCreatingMarketGroup(_groupId, _groupName, _endTime, _invalidMarketName, _category);\n    }\n\n    function addOutcomesToGroup(\n        uint256 _groupId,\n        string[] memory _marketNames,\n        uint256[][] memory _odds\n    ) public onlyLinkNode {\n        require(_marketNames.length == _odds.length);\n\n        for (uint256 i = 0; i < _marketNames.length; i++) {\n            addMarketToMarketGroup(_groupId, _marketNames[i], _odds[i]);\n        }\n    }\n\n    // Set _winner to MAX_UINT (2*256 - 1) to indicate invalid\n    function beginResolvingGroup(uint256 _groupId, uint256 _winningMarketIndex) public onlyLinkNode {\n        startResolvingMarketGroup(_groupId, _winningMarketIndex);\n    }\n\n    function resolveMarkets(uint256 _groupId, uint256[] memory _marketIndexes) public onlyLinkNode {\n        MarketGroup memory _group = marketGroups[_groupId];\n        require(_group.status == GroupStatus.Finalizing);\n\n        for (uint256 i = 0; i < _marketIndexes.length; i++) {\n            uint256 _marketIndex = _marketIndexes[i];\n            uint256 _marketId = _group.markets[_marketIndex];\n            if (isMarketResolved(_marketId)) continue; // skip resolved markets\n            resolveFinalizingGroupMarket(_groupId, _marketIndex);\n        }\n    }\n\n    function finalizeGroup(uint256 _groupId) public onlyLinkNode {\n        finalizeMarketGroup(_groupId);\n    }\n\n    // Used when some markets in a group can resolve early as NO.\n    // ex: Teams eliminated early from a tournament cannot win the overall tournament.\n    function resolveMarketAsNo(uint256 _marketId) public onlyLinkNode {\n        require(markets[_marketId].active, \"market inactive\");\n        resolveGroupMarket(_marketId, false);\n    }\n\n    function getRewardEndTime(uint256 _eventId) public view override returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "contracts/turbo/NFLMarketFactoryV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../libraries/IERC20Full.sol\";\nimport \"../balancer/BPool.sol\";\nimport \"./AbstractMarketFactoryV3.sol\";\nimport \"./FeePot.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/SignedSafeMath.sol\";\nimport \"../libraries/Sport.sol\";\nimport \"../libraries/HasHeadToHeadMarket.sol\";\nimport \"../libraries/HasSpreadMarket.sol\";\nimport \"../libraries/HasOverUnderMarket.sol\";\nimport \"../libraries/ResolveByScore.sol\";\nimport \"../libraries/Versioned.sol\";\n\n// NFL is standard except ties are fine: they become NoContestOrDraw.\n// As a consequence, half points are not added to the lines.\ncontract NFLMarketFactoryV3 is\n    AbstractMarketFactoryV3,\n    SportView,\n    HasHeadToHeadMarket,\n    HasSpreadMarket,\n    HasOverUnderMarket,\n    ResolvesByScore,\n    Versioned\n{\n    using SafeMath for uint256;\n    using SignedSafeMath for int256;\n\n    uint256 constant HeadToHead = 0;\n    uint256 constant Spread = 1;\n    uint256 constant OverUnder = 2;\n\n    constructor(\n        address _owner,\n        IERC20Full _collateral,\n        uint256 _shareFactor,\n        FeePot _feePot,\n        uint256[3] memory _fees,\n        address _protocol,\n        address _linkNode\n    )\n        AbstractMarketFactoryV3(_owner, _collateral, _shareFactor, _feePot, _fees, _protocol)\n        Versioned(\"v1.2.0\")\n        ManagedByLink(_linkNode)\n        HasHeadToHeadMarket(HeadToHead, \"No Contest / Draw\")\n        HasSpreadMarket(Spread, \"No Contest\")\n        HasOverUnderMarket(OverUnder, \"No Contest\")\n    {}\n\n    function createEvent(\n        uint256 _eventId,\n        string memory _homeTeamName,\n        uint256 _homeTeamId,\n        string memory _awayTeamName,\n        uint256 _awayTeamId,\n        uint256 _startTimestamp,\n        int256 _homeSpread,\n        int256 _totalScore,\n        int256[2] memory _moneylines // [home,away]\n    ) public onlyLinkNode returns (uint256[] memory _marketIds) {\n        _marketIds = makeMarkets(_moneylines, _homeTeamName, _awayTeamName);\n        makeSportsEvent(\n            _eventId,\n            _marketIds,\n            build3Lines(_homeSpread, _totalScore),\n            _startTimestamp,\n            _homeTeamId,\n            _awayTeamId,\n            _homeTeamName,\n            _awayTeamName\n        );\n    }\n\n    function makeMarkets(\n        int256[2] memory _moneylines,\n        string memory _homeTeamName,\n        string memory _awayTeamName\n    ) internal returns (uint256[] memory _marketIds) {\n        _marketIds = new uint256[](3);\n\n        _marketIds[HeadToHead] = makeHeadToHeadMarket(_moneylines, _homeTeamName, _awayTeamName);\n        _marketIds[Spread] = makeSpreadMarket(_homeTeamName, _awayTeamName);\n        _marketIds[OverUnder] = makeOverUnderMarket();\n    }\n\n    function resolveValidEvent(\n        SportsEvent memory _event,\n        uint256 _homeScore,\n        uint256 _awayScore\n    ) internal override {\n        resolveHeadToHeadMarket(_event.markets[HeadToHead], _homeScore, _awayScore);\n        resolveSpreadMarket(_event.markets[Spread], _event.lines[Spread], _homeScore, _awayScore);\n        resolveOverUnderMarket(_event.markets[OverUnder], _event.lines[OverUnder], _homeScore, _awayScore);\n    }\n}\n"
    },
    "contracts/libraries/HasOverUnderMarket.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../turbo/AbstractMarketFactoryV3.sol\";\nimport \"./Sport.sol\";\nimport \"./CalculateLinesToBPoolOdds.sol\";\n\nabstract contract HasOverUnderMarket is AbstractMarketFactoryV3, Sport, CalculateLinesToBPoolOdds {\n    using SafeMath for uint256;\n    using SignedSafeMath for int256;\n\n    uint256 private overUnderMarketType;\n    string private noContestName;\n\n    uint256 constant Over = 1;\n    uint256 constant Under = 2;\n\n    constructor(uint256 _marketType, string memory _noContestName) {\n        overUnderMarketType = _marketType;\n        noContestName = _noContestName;\n    }\n\n    function makeOverUnderMarket() internal returns (uint256) {\n        string[] memory _outcomeNames = makeOutcomeNames(noContestName);\n        return startMarket(msg.sender, _outcomeNames, evenOdds(true, 2), true);\n    }\n\n    function resolveOverUnderMarket(\n        uint256 _marketId,\n        int256 _line,\n        uint256 _homeScore,\n        uint256 _awayScore\n    ) internal {\n        uint256 _shareTokenIndex = calcOverUnderWinner(_homeScore, _awayScore, _line);\n        endMarket(_marketId, _shareTokenIndex);\n    }\n\n    function calcOverUnderWinner(\n        uint256 _homeScore,\n        uint256 _awayScore,\n        int256 _targetTotal\n    ) internal pure returns (uint256) {\n        int256 _actualTotal = int256(_homeScore).add(int256(_awayScore));\n\n        if (_actualTotal > _targetTotal) {\n            return Over; // total score above than line\n        } else if (_actualTotal < _targetTotal) {\n            return Under; // total score below line\n        } else {\n            return NoContest; // draw / tie; some sports eliminate this with half-points\n        }\n    }\n\n    function makeOutcomeNames(string memory _noContestName) private pure returns (string[] memory _names) {\n        _names = new string[](3);\n        _names[NoContest] = _noContestName;\n        _names[Over] = \"Over\";\n        _names[Under] = \"Under\";\n    }\n}\n"
    },
    "contracts/turbo/NCAAFBMarketFactoryV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../libraries/IERC20Full.sol\";\nimport \"../balancer/BPool.sol\";\nimport \"./AbstractMarketFactoryV3.sol\";\nimport \"./FeePot.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/SignedSafeMath.sol\";\nimport \"../libraries/Sport.sol\";\nimport \"../libraries/HasHeadToHeadMarket.sol\";\nimport \"../libraries/HasSpreadMarket.sol\";\nimport \"../libraries/HasOverUnderMarket.sol\";\nimport \"../libraries/ResolveByScore.sol\";\nimport \"../libraries/Versioned.sol\";\n\n// NCAA-FB is identical to NFL except there are no ties.\n// As a consequence, spread and over-under lines add a half-point,\n// and the invalid outcome is just No Contest.\ncontract NCAAFBMarketFactoryV3 is\n    AbstractMarketFactoryV3,\n    SportView,\n    HasHeadToHeadMarket,\n    HasSpreadMarket,\n    HasOverUnderMarket,\n    ResolvesByScore,\n    Versioned\n{\n    using SafeMath for uint256;\n    using SignedSafeMath for int256;\n\n    uint256 constant HeadToHead = 0;\n    uint256 constant Spread = 1;\n    uint256 constant OverUnder = 2;\n    string constant InvalidName = \"No Contest\";\n\n    constructor(\n        address _owner,\n        IERC20Full _collateral,\n        uint256 _shareFactor,\n        FeePot _feePot,\n        uint256[3] memory _fees,\n        address _protocol,\n        address _linkNode\n    )\n        AbstractMarketFactoryV3(_owner, _collateral, _shareFactor, _feePot, _fees, _protocol)\n        Versioned(\"v1.2.0\")\n        ManagedByLink(_linkNode)\n        HasHeadToHeadMarket(HeadToHead, InvalidName)\n        HasSpreadMarket(Spread, InvalidName)\n        HasOverUnderMarket(OverUnder, InvalidName)\n    {}\n\n    function createEvent(\n        uint256 _eventId,\n        string memory _homeTeamName,\n        uint256 _homeTeamId,\n        string memory _awayTeamName,\n        uint256 _awayTeamId,\n        uint256 _startTimestamp,\n        int256 _homeSpread,\n        int256 _totalScore,\n        int256[2] memory _moneylines // [home,away]\n    ) public onlyLinkNode returns (uint256[] memory _marketIds) {\n        _marketIds = makeMarkets(_moneylines, _homeTeamName, _awayTeamName);\n        makeSportsEvent(\n            _eventId,\n            _marketIds,\n            build3Lines(_homeSpread, _totalScore),\n            _startTimestamp,\n            _homeTeamId,\n            _awayTeamId,\n            _homeTeamName,\n            _awayTeamName\n        );\n    }\n\n    function makeMarkets(\n        int256[2] memory _moneylines,\n        string memory _homeTeamName,\n        string memory _awayTeamName\n    ) internal returns (uint256[] memory _marketIds) {\n        _marketIds = new uint256[](3);\n\n        _marketIds[HeadToHead] = makeHeadToHeadMarket(_moneylines, _homeTeamName, _awayTeamName);\n        _marketIds[Spread] = makeSpreadMarket(_homeTeamName, _awayTeamName);\n        _marketIds[OverUnder] = makeOverUnderMarket();\n    }\n\n    function resolveValidEvent(\n        SportsEvent memory _event,\n        uint256 _homeScore,\n        uint256 _awayScore\n    ) internal override {\n        resolveHeadToHeadMarket(_event.markets[HeadToHead], _homeScore, _awayScore);\n        resolveSpreadMarket(_event.markets[Spread], _event.lines[Spread], _homeScore, _awayScore);\n        resolveOverUnderMarket(_event.markets[OverUnder], _event.lines[OverUnder], _homeScore, _awayScore);\n    }\n}\n"
    },
    "contracts/turbo/TrustedMarketFactoryV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\nimport \"../libraries/IERC20Full.sol\";\nimport \"../balancer/BPool.sol\";\nimport \"./AbstractMarketFactoryV2.sol\";\nimport \"./FeePot.sol\";\nimport \"../libraries/CalculateLinesToBPoolOdds.sol\";\n\n\ncontract TrustedMarketFactoryV2 is AbstractMarketFactoryV2, CalculateLinesToBPoolOdds {\n    using SafeMath for uint256;\n\n    event MarketCreated(uint256 id, address creator, uint256 _endTime, string description, string[] outcomes);\n    event MarketResolved(uint256 id, address winner);\n\n    struct MarketDetails {\n        string description;\n    }\n    MarketDetails[] internal marketDetails;\n\n    constructor(\n        address _owner,\n        IERC20Full _collateral,\n        uint256 _shareFactor,\n        FeePot _feePot,\n        uint256 _stakerFee,\n        uint256 _settlementFee,\n        address _protocol,\n        uint256 _protocolFee\n    )\n        AbstractMarketFactoryV2(\n            _owner,\n            _collateral,\n            _shareFactor,\n            _feePot,\n            _stakerFee,\n            _settlementFee,\n            _protocol,\n            _protocolFee\n        )\n    {}\n\n    function createMarket(\n        address _creator,\n        uint256 _endTime,\n        string calldata _description,\n        string[] calldata _names,\n        string[] calldata _symbols,\n        uint256[] calldata _odds\n    ) public onlyOwner returns (uint256) {\n        require(\n            _names.length == _symbols.length && _symbols.length == _odds.length,\n            \"names, symbols, and odds must be the same length\"\n        );\n\n        uint256 _id = markets.length;\n        markets.push(makeMarket(_creator, _names, _symbols, _endTime, _odds));\n        marketDetails.push(MarketDetails(_description));\n\n        emit MarketCreated(_id, _creator, _endTime, _description, _symbols);\n        return _id;\n    }\n\n    function resolveMarket(uint256) public pure override {\n        require(false, \"Only the TrustedMarketFactory owner can resolve the market, using trustedResolveMarket\");\n    }\n\n    function trustedResolveMarket(uint256 _id, uint256 _winningOutcome) public onlyOwner {\n        OwnedERC20 _winner = markets[_id].shareTokens[_winningOutcome];\n        markets[_id].winner = _winner;\n        emit MarketResolved(_id, address(_winner));\n    }\n\n    function getMarketDetails(uint256 _id) public view returns (MarketDetails memory) {\n        return marketDetails[_id];\n    }\n\n\n\n\n\n}\n"
    },
    "contracts/turbo/AbstractMarketFactoryV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../libraries/IERC20Full.sol\";\nimport \"../balancer/BPool.sol\";\nimport \"./TurboShareTokenFactory.sol\";\nimport \"./FeePot.sol\";\n\nabstract contract AbstractMarketFactoryV2 is TurboShareTokenFactoryV1, Ownable {\n    using SafeMath for uint256;\n\n    // Should always have ID. Others are optional.\n    // event MarketCreated(uint256 id, address settlementAddress, uint256 endTime, ...);\n\n    // Should always have ID. Others are optional.\n    // event MarketResolved(uint256 id, ...);\n\n    event SharesMinted(uint256 id, uint256 amount, address receiver);\n    event SharesBurned(uint256 id, uint256 amount, address receiver);\n    event WinningsClaimed(\n        uint256 id,\n        address winningOutcome,\n        uint256 amount,\n        uint256 settlementFee,\n        uint256 payout,\n        address indexed receiver\n    );\n\n    event SettlementFeeClaimed(address settlementAddress, uint256 amount, address indexed receiver);\n    event ProtocolFeeClaimed(address protocol, uint256 amount);\n\n    event ProtocolChanged(address protocol);\n    event ProtocolFeeChanged(uint256 fee);\n    event SettlementFeeChanged(uint256 fee);\n    event StakerFeeChanged(uint256 fee);\n\n    IERC20Full public collateral;\n    FeePot public feePot;\n\n    // fees are out of 1e18 and only apply to new markets\n    uint256 public stakerFee;\n    uint256 public settlementFee;\n    uint256 public protocolFee;\n\n    address public protocol; // collects protocol fees\n\n    uint256 public accumulatedProtocolFee = 0;\n    // settlement address => amount of collateral\n    mapping(address => uint256) public accumulatedSettlementFees;\n\n    // How many shares equals one collateral.\n    // Necessary to account for math errors from small numbers in balancer.\n    // shares = collateral / shareFactor\n    // collateral = shares * shareFactor\n    uint256 public shareFactor;\n\n    struct Market {\n        address settlementAddress;\n        OwnedERC20[] shareTokens;\n        uint256 endTime;\n        OwnedERC20 winner;\n        uint256 settlementFee;\n        uint256 protocolFee;\n        uint256 stakerFee;\n        uint256 creationTimestamp;\n        uint256[] initialOdds;\n    }\n    Market[] internal markets;\n\n    uint256 private constant MAX_UINT = 2**256 - 1;\n\n    constructor(\n        address _owner,\n        IERC20Full _collateral,\n        uint256 _shareFactor,\n        FeePot _feePot,\n        uint256 _stakerFee,\n        uint256 _settlementFee,\n        address _protocol,\n        uint256 _protocolFee\n    ) {\n        owner = _owner; // controls fees for new markets\n        collateral = _collateral;\n        shareFactor = _shareFactor;\n        feePot = _feePot;\n        stakerFee = _stakerFee;\n        settlementFee = _settlementFee;\n        protocol = _protocol;\n        protocolFee = _protocolFee;\n\n        _collateral.approve(address(_feePot), MAX_UINT);\n\n        // First market is always empty so that marketid zero means \"no market\"\n        makeEmptyMarket();\n    }\n\n    function makeEmptyMarket() internal {\n        string[] memory _noStrings = new string[](0);\n        uint256[] memory _noUint256s = new uint256[](0);\n        markets.push(makeMarket(address(0), _noStrings, _noStrings, 0, _noUint256s));\n    }\n\n    // function createMarket(address _settlementAddress, uint256 _endTime, ...) public returns (uint256);\n\n    function resolveMarket(uint256 _id) public virtual;\n\n    // Returns an empty struct if the market doesn't exist.\n    // Can check market existence before calling this by comparing _id against markets.length.\n    // Can check market existence of the return struct by checking that shareTokens[0] isn't the null address\n    function getMarket(uint256 _id) public view returns (Market memory) {\n        if (_id >= markets.length) {\n            return Market(address(0), new OwnedERC20[](0), 0, OwnedERC20(address(0)), 0, 0, 0, 0, new uint256[](0));\n        } else {\n            return markets[_id];\n        }\n    }\n\n    function marketCount() public view returns (uint256) {\n        return markets.length;\n    }\n\n    // Returns factory-specific details about a market.\n    // function getMarketDetails(uint256 _id) public view returns (MarketDetails memory);\n\n    function mintShares(\n        uint256 _id,\n        uint256 _shareToMint,\n        address _receiver\n    ) public {\n        require(markets.length > _id, \"No such market\");\n        require(!isMarketResolved(_id), \"Cannot mint shares for resolved market\");\n\n        uint256 _cost = calcCost(_shareToMint);\n        collateral.transferFrom(msg.sender, address(this), _cost);\n\n        Market memory _market = markets[_id];\n        for (uint256 _i = 0; _i < _market.shareTokens.length; _i++) {\n            _market.shareTokens[_i].trustedMint(_receiver, _shareToMint);\n        }\n\n        emit SharesMinted(_id, _shareToMint, _receiver);\n    }\n\n    function burnShares(\n        uint256 _id,\n        uint256 _sharesToBurn,\n        address _receiver\n    ) public returns (uint256) {\n        require(markets.length > _id, \"No such market\");\n        require(!isMarketResolved(_id), \"Cannot burn shares for resolved market\");\n\n        Market memory _market = markets[_id];\n        for (uint256 _i = 0; _i < _market.shareTokens.length; _i++) {\n            // errors if sender doesn't have enough shares\n            _market.shareTokens[_i].trustedBurn(msg.sender, _sharesToBurn);\n        }\n\n        uint256 _payout = calcCost(_sharesToBurn);\n        uint256 _protocolFee = _payout.mul(_market.protocolFee).div(10**18);\n        uint256 _stakerFee = _payout.mul(_market.stakerFee).div(10**18);\n        _payout = _payout.sub(_protocolFee).sub(_stakerFee);\n\n        accumulatedProtocolFee += _protocolFee;\n        collateral.transfer(_receiver, _payout);\n        feePot.depositFees(_stakerFee);\n\n        emit SharesBurned(_id, _sharesToBurn, msg.sender);\n        return _payout;\n    }\n\n    function claimWinnings(uint256 _id, address _receiver) public returns (uint256) {\n        if (!isMarketResolved(_id)) {\n            // errors if market does not exist or is not resolved or resolvable\n            resolveMarket(_id);\n        }\n\n        Market memory _market = markets[_id];\n        uint256 _winningShares = _market.winner.trustedBurnAll(msg.sender);\n        _winningShares = (_winningShares / shareFactor) * shareFactor; // remove unusable dust\n\n        uint256 _payout = calcCost(_winningShares); // will fail if there are no winnings to claim\n        uint256 _settlementFee = _payout.mul(_market.settlementFee).div(10**18);\n        _payout = _payout.sub(_settlementFee);\n\n        accumulatedSettlementFees[_market.settlementAddress] += _settlementFee;\n        collateral.transfer(_receiver, _payout);\n\n        emit WinningsClaimed(_id, address(_market.winner), _winningShares, _settlementFee, _payout, _receiver);\n        return _payout;\n    }\n\n    function claimManyWinnings(uint256[] memory _ids, address _receiver) public returns (uint256) {\n        uint256 _totalWinnings = 0;\n        for (uint256 i = 0; i < _ids.length; i++) {\n            _totalWinnings = _totalWinnings.add(claimWinnings(_ids[i], _receiver));\n        }\n        return _totalWinnings;\n    }\n\n    function claimSettlementFees(address _receiver) public returns (uint256) {\n        uint256 _fees = accumulatedSettlementFees[msg.sender];\n        if (_fees > 0) {\n            accumulatedSettlementFees[msg.sender] = 0;\n            collateral.transfer(_receiver, _fees);\n            emit SettlementFeeClaimed(msg.sender, _fees, _receiver);\n        }\n        return _fees;\n    }\n\n    function claimProtocolFees() public returns (uint256) {\n        require(msg.sender == protocol || msg.sender == address(this), \"Only protocol can claim protocol fee\");\n        uint256 _fees = accumulatedProtocolFee;\n        if (_fees > 0) {\n            accumulatedProtocolFee = 0;\n            collateral.transfer(protocol, _fees);\n            emit ProtocolFeeClaimed(protocol, _fees);\n        }\n        return _fees;\n    }\n\n    function setSettlementFee(uint256 _newFee) external onlyOwner {\n        settlementFee = _newFee;\n        emit SettlementFeeChanged(_newFee);\n    }\n\n    function setStakerFee(uint256 _newFee) external onlyOwner {\n        stakerFee = _newFee;\n        emit StakerFeeChanged(_newFee);\n    }\n\n    function setProtocolFee(uint256 _newFee) external onlyOwner {\n        protocolFee = _newFee;\n        emit ProtocolFeeChanged(_newFee);\n    }\n\n    function setProtocol(address _newProtocol, bool _claimFirst) external onlyOwner {\n        if (_claimFirst) {\n            claimProtocolFees();\n        }\n        protocol = _newProtocol;\n        emit ProtocolChanged(_newProtocol);\n    }\n\n    function makeMarket(\n        address _settlementAddress,\n        string[] memory _names,\n        string[] memory _symbols,\n        uint256 _endTime,\n        uint256[] memory _initialOdds\n    ) internal returns (Market memory _market) {\n        _market = Market(\n            _settlementAddress,\n            createShareTokens(_names, _symbols, address(this)),\n            _endTime,\n            OwnedERC20(address(0)),\n            settlementFee,\n            protocolFee,\n            stakerFee,\n            block.timestamp,\n            _initialOdds\n        );\n    }\n\n    function isMarketResolved(uint256 _id) public view returns (bool) {\n        Market memory _market = markets[_id];\n        return _market.winner != OwnedERC20(address(0));\n    }\n\n    // Only usable off-chain. Gas cost can easily eclipse block limit.\n    function listUnresolvedMarkets() public view returns (uint256[] memory) {\n        uint256 _totalUnresolved = 0;\n        for (uint256 i = 0; i < markets.length; i++) {\n            if (!isMarketResolved(i)) {\n                _totalUnresolved++;\n            }\n        }\n\n        uint256[] memory _marketIds = new uint256[](_totalUnresolved);\n\n        uint256 n = 0;\n        for (uint256 i = 0; i < markets.length; i++) {\n            if (n >= _totalUnresolved) break;\n\n            if (!isMarketResolved(i)) {\n                _marketIds[n] = i;\n                n++;\n            }\n        }\n\n        return _marketIds;\n    }\n\n    // shares => collateral\n    function calcCost(uint256 _shares) public view returns (uint256) {\n        require(\n            _shares >= shareFactor && _shares % shareFactor == 0,\n            \"Shares must be both greater than (or equal to) and divisible by shareFactor\"\n        );\n        return _shares / shareFactor;\n    }\n\n    // collateral => shares\n    function calcShares(uint256 _collateralIn) public view returns (uint256) {\n        return _collateralIn * shareFactor;\n    }\n\n    function onTransferOwnership(address, address) internal override {}\n}\n"
    },
    "contracts/turbo/SportsLinkMarketFactoryV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../libraries/IERC20Full.sol\";\nimport \"../balancer/BPool.sol\";\nimport \"./AbstractMarketFactoryV2.sol\";\nimport \"./FeePot.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/SignedSafeMath.sol\";\nimport \"../libraries/CalculateLinesToBPoolOdds.sol\";\n\ncontract SportsLinkMarketFactoryV2 is AbstractMarketFactoryV2, CalculateLinesToBPoolOdds {\n    using SafeMath for uint256;\n    using SignedSafeMath for int256;\n\n    event MarketCreated(\n        uint256 id,\n        address creator,\n        uint256 endTime,\n        MarketType marketType,\n        uint256 indexed eventId,\n        uint256 homeTeamId,\n        uint256 awayTeamId,\n        uint256 estimatedStartTime,\n        int256 score\n    );\n    event MarketResolved(uint256 id, address winner);\n    event LinkNodeChanged(address newLinkNode);\n\n    enum MarketType {HeadToHead, Spread, OverUnder}\n    enum HeadToHeadOutcome {\n        NoContest, // 0\n        Away, // 1\n        Home // 2\n    }\n    enum SpreadOutcome {\n        NoContest, // 0\n        Away, // 1\n        Home // 2\n    }\n    enum OverUnderOutcome {\n        NoContest, // 0\n        Over, // 1\n        Under // 2\n    }\n    struct MarketDetails {\n        uint256 eventId;\n        uint256 homeTeamId;\n        uint256 awayTeamId;\n        uint256 estimatedStartTime;\n        MarketType marketType;\n        EventStatus eventStatus;\n        // This value depends on the marketType.\n        // HeadToHead: ignored\n        // Spread: the home team spread\n        // OverUnder: total score in game\n        int256 value0;\n    }\n    // MarketId => MarketDetails\n    mapping(uint256 => MarketDetails) internal marketDetails;\n\n    enum EventStatus {Unknown, Scheduled, Final, Postponed, Canceled}\n    struct EventDetails {\n        uint256[3] markets;\n        uint256 startTime;\n        uint256 homeScore;\n        uint256 awayScore;\n        EventStatus status;\n        // If there is a resolution time then the market is resolved but not necessarily finalized.\n        // A market is finalized when its last two score updates were identical.\n        // Score updates must occur after a period of time spedcified by resolutionBuffer.\n        // This mechanism exists to reduce the risk of bad scores being sent by the API then later corrected.\n        // The downside is slower resolution.\n        uint256 resolutionTime; // time since last score update\n        bool finalized; // true after event resolves and has stable scores\n    }\n    // EventId => EventDetails\n    mapping(uint256 => EventDetails) public events;\n    uint256[] public listOfEvents;\n\n    address public linkNode;\n    uint256 public sportId;\n\n    constructor(\n        address _owner,\n        IERC20Full _collateral,\n        uint256 _shareFactor,\n        FeePot _feePot,\n        uint256 _stakerFee,\n        uint256 _settlementFee,\n        address _protocol,\n        uint256 _protocolFee,\n        address _linkNode,\n        uint256 _sportId\n    )\n        AbstractMarketFactoryV2(\n            _owner,\n            _collateral,\n            _shareFactor,\n            _feePot,\n            _stakerFee,\n            _settlementFee,\n            _protocol,\n            _protocolFee\n        )\n    {\n        linkNode = _linkNode;\n        sportId = _sportId;\n    }\n\n    function createMarket(\n        uint256 _eventId,\n        uint256 _homeTeamId,\n        uint256 _awayTeamId,\n        uint256 _startTimestamp,\n        int256 _homeSpread,\n        uint256 _totalScore,\n        bool _makeSpread,\n        bool _makeTotalScore,\n        int256[2] memory _moneylines // [home,away]\n    ) public returns (uint256[3] memory _ids) {\n        require(msg.sender == linkNode, \"Only link node can create markets\");\n\n        address _creator = msg.sender;\n        uint256 _endTime = _startTimestamp.add(60 * 8); // 8 hours\n\n        _ids = events[_eventId].markets;\n\n        if (_ids[0] == 0 && _moneylines[0] != 0 && _moneylines[1] != 0) {\n            _ids[0] = createHeadToHeadMarket(\n                _creator,\n                _endTime,\n                _eventId,\n                _homeTeamId,\n                _awayTeamId,\n                _startTimestamp,\n                _moneylines\n            );\n        }\n\n        if (_ids[1] == 0 && _makeSpread) {\n            // spread market hasn't been created and is ready to be created\n            _ids[1] = createSpreadMarket(\n                _creator,\n                _endTime,\n                _eventId,\n                _homeTeamId,\n                _awayTeamId,\n                _startTimestamp,\n                _homeSpread\n            );\n        }\n\n        if (_ids[2] == 0 && _makeTotalScore) {\n            // over-under market hasn't been created and is ready to be created\n            _ids[2] = createOverUnderMarket(\n                _creator,\n                _endTime,\n                _eventId,\n                _homeTeamId,\n                _awayTeamId,\n                _startTimestamp,\n                _totalScore\n            );\n        }\n\n        events[_eventId].status = EventStatus.Scheduled;\n        events[_eventId].startTime = _startTimestamp;\n        events[_eventId].markets = _ids;\n        listOfEvents.push(_eventId);\n    }\n\n    function createHeadToHeadMarket(\n        address _creator,\n        uint256 _endTime,\n        uint256 _eventId,\n        uint256 _homeTeamId,\n        uint256 _awayTeamId,\n        uint256 _startTimestamp,\n        int256[2] memory _moneylines // [home,away]\n    ) internal returns (uint256) {\n        string[] memory _outcomes = new string[](3);\n        _outcomes[uint256(HeadToHeadOutcome.NoContest)] = \"No Contest\";\n        _outcomes[uint256(HeadToHeadOutcome.Away)] = \"Away\";\n        _outcomes[uint256(HeadToHeadOutcome.Home)] = \"Home\";\n\n        uint256 _id = markets.length;\n        // moneylines is [home,away] but the outcomes are listed [NC,away,home] so they must be reversed\n        markets.push(\n            makeMarket(_creator, _outcomes, _outcomes, _endTime, oddsFromLines(_moneylines[1], _moneylines[0]))\n        );\n        marketDetails[_id] = MarketDetails(\n            _eventId,\n            _homeTeamId,\n            _awayTeamId,\n            _startTimestamp,\n            MarketType.HeadToHead,\n            EventStatus.Scheduled,\n            0\n        );\n        emit MarketCreated(\n            _id,\n            _creator,\n            _endTime,\n            MarketType.HeadToHead,\n            _eventId,\n            _homeTeamId,\n            _awayTeamId,\n            _startTimestamp,\n            0\n        );\n        return _id;\n    }\n\n    function createSpreadMarket(\n        address _creator,\n        uint256 _endTime,\n        uint256 _eventId,\n        uint256 _homeTeamId,\n        uint256 _awayTeamId,\n        uint256 _startTimestamp,\n        int256 _homeSpread\n    ) internal returns (uint256) {\n        string[] memory _outcomes = new string[](3);\n        _outcomes[uint256(SpreadOutcome.NoContest)] = \"No Contest\";\n        _outcomes[uint256(SpreadOutcome.Away)] = \"Away\";\n        _outcomes[uint256(SpreadOutcome.Home)] = \"Home\";\n\n        // The spread is a quantity of tenths. So 55 is 5.5 and -6 is -60.\n        // If the spread is a whole number then make it a half point more extreme, to eliminate ties.\n        // So 50 becomes 55, -60 becomes -65, and 0 becomes 5.\n        if (_homeSpread >= 0 && _homeSpread % 10 == 0) {\n            _homeSpread += 5;\n        } else if (_homeSpread < 0 && (-_homeSpread) % 10 == 0) {\n            _homeSpread -= 5;\n        }\n\n        uint256 _id = markets.length;\n        markets.push(makeMarket(_creator, _outcomes, _outcomes, _endTime, evenOdds(true, 2)));\n        marketDetails[_id] = MarketDetails(\n            _eventId,\n            _homeTeamId,\n            _awayTeamId,\n            _startTimestamp,\n            MarketType.Spread,\n            EventStatus.Scheduled,\n            _homeSpread\n        );\n        emit MarketCreated(\n            _id,\n            _creator,\n            _endTime,\n            MarketType.Spread,\n            _eventId,\n            _homeTeamId,\n            _awayTeamId,\n            _startTimestamp,\n            _homeSpread\n        );\n        return _id;\n    }\n\n    function createOverUnderMarket(\n        address _creator,\n        uint256 _endTime,\n        uint256 _eventId,\n        uint256 _homeTeamId,\n        uint256 _awayTeamId,\n        uint256 _startTimestamp,\n        uint256 _overUnderTotal\n    ) internal returns (uint256) {\n        string[] memory _outcomes = new string[](3);\n        _outcomes[uint256(OverUnderOutcome.NoContest)] = \"No Contest\";\n        _outcomes[uint256(OverUnderOutcome.Over)] = \"Over\";\n        _outcomes[uint256(OverUnderOutcome.Under)] = \"Under\";\n\n        // The total is a quantity of tenths. So 55 is 5.5 and -6 is -60.\n        // If the total is a whole number then make it a half point higher, to eliminate ties.\n        // So 50 becomes 55 and 0 becomes 5.\n        if (_overUnderTotal >= 0 && _overUnderTotal % 10 == 0) {\n            _overUnderTotal += 5;\n        }\n\n        uint256 _id = markets.length;\n        markets.push(makeMarket(_creator, _outcomes, _outcomes, _endTime, evenOdds(true, 2)));\n        marketDetails[_id] = MarketDetails(\n            _eventId,\n            _homeTeamId,\n            _awayTeamId,\n            _startTimestamp,\n            MarketType.OverUnder,\n            EventStatus.Scheduled,\n            int256(_overUnderTotal)\n        );\n        emit MarketCreated(\n            _id,\n            _creator,\n            _endTime,\n            MarketType.OverUnder,\n            _eventId,\n            _homeTeamId,\n            _awayTeamId,\n            _startTimestamp,\n            int256(_overUnderTotal)\n        );\n        return _id;\n    }\n\n    function resolveMarket(uint256) public pure override {\n        require(false, \"Only the link node can resolve the market, using trustedResolveMarkets\");\n    }\n\n    function trustedResolveMarkets(\n        uint256 _eventId,\n        uint256 _eventStatus,\n        uint256 _homeScore,\n        uint256 _awayScore\n    ) public {\n        require(msg.sender == linkNode, \"Only link node can resolve markets\");\n\n        EventDetails storage _event = events[_eventId];\n        uint256[3] memory _ids = _event.markets;\n\n        require(_ids[0] != 0 || _ids[1] != 0 || _ids[2] != 0, \"Cannot resolve markets that weren't created\");\n\n        require(EventStatus(_eventStatus) != EventStatus.Scheduled, \"cannot resolve SCHEDULED markets\");\n\n        // resolve markets as No Contest\n        if (EventStatus(_eventStatus) != EventStatus.Final) {\n            for (uint256 i = 0; i < _ids.length; i++) {\n                uint256 _id = _ids[i];\n                if (_id == 0) continue; // skip non-created markets\n                OwnedERC20 _winner = markets[_id].shareTokens[0]; // 0th outcome is No Contest for all market types\n                markets[_id].winner = _winner;\n                emit MarketResolved(_id, address(_winner));\n            }\n            return;\n        }\n\n        // only resolve markets that were created\n        if (_ids[0] != 0) {\n            resolveHeadToHeadMarket(_ids[0], _homeScore, _awayScore);\n        }\n        if (_ids[1] != 0) {\n            resolveSpreadMarket(_ids[1], _homeScore, _awayScore);\n        }\n        if (_ids[2] != 0) {\n            resolveOverUnderMarket(_ids[2], _homeScore, _awayScore);\n        }\n    }\n\n    function resolveHeadToHeadMarket(\n        uint256 _id,\n        uint256 _homeScore,\n        uint256 _awayScore\n    ) internal {\n        OwnedERC20 _winner;\n        if (_homeScore > _awayScore) {\n            _winner = markets[_id].shareTokens[uint256(HeadToHeadOutcome.Home)]; // home team won\n        } else if (_homeScore < _awayScore) {\n            _winner = markets[_id].shareTokens[uint256(HeadToHeadOutcome.Away)]; // away team won\n        } else {\n            _winner = markets[_id].shareTokens[uint256(HeadToHeadOutcome.NoContest)]; // no contest\n        }\n\n        markets[_id].winner = _winner;\n        emit MarketResolved(_id, address(_winner));\n    }\n\n    function resolveSpreadMarket(\n        uint256 _id,\n        uint256 _homeScore,\n        uint256 _awayScore\n    ) internal {\n        MarketDetails memory _details = marketDetails[_id];\n        int256 _targetSpread = _details.value0;\n\n        int256 _actualSpread = int256(_homeScore).sub(int256(_awayScore));\n\n        OwnedERC20 _winner;\n        if (_actualSpread > _targetSpread) {\n            _winner = markets[_id].shareTokens[uint256(SpreadOutcome.Home)]; // home spread greater\n        } else if (_actualSpread < _targetSpread) {\n            _winner = markets[_id].shareTokens[uint256(SpreadOutcome.Away)]; // home spread lesser\n        } else {\n            _winner = markets[_id].shareTokens[uint256(SpreadOutcome.NoContest)]; // no contest\n        }\n\n        markets[_id].winner = _winner;\n        emit MarketResolved(_id, address(_winner));\n    }\n\n    function resolveOverUnderMarket(\n        uint256 _id,\n        uint256 _homeScore,\n        uint256 _awayScore\n    ) internal {\n        MarketDetails memory _details = marketDetails[_id];\n        int256 _targetTotal = _details.value0;\n\n        int256 _actualTotal = int256(_homeScore).add(int256(_awayScore));\n\n        OwnedERC20 _winner;\n        if (_actualTotal > _targetTotal) {\n            _winner = markets[_id].shareTokens[uint256(OverUnderOutcome.Over)]; // over\n        } else if (_actualTotal < _targetTotal) {\n            _winner = markets[_id].shareTokens[uint256(OverUnderOutcome.Under)]; // under\n        } else {\n            _winner = markets[_id].shareTokens[uint256(OverUnderOutcome.NoContest)]; // no contest\n        }\n\n        markets[_id].winner = _winner;\n        emit MarketResolved(_id, address(_winner));\n    }\n\n    function getMarketDetails(uint256 _marketId) public view returns (MarketDetails memory) {\n        return marketDetails[_marketId];\n    }\n\n    function setLinkNode(address _newLinkNode) external onlyOwner {\n        linkNode = _newLinkNode;\n        emit LinkNodeChanged(_newLinkNode);\n    }\n\n    function getEventMarkets(uint256 _eventId) external view returns (uint256[3] memory) {\n        uint256[3] memory _event = events[_eventId].markets;\n        return _event;\n    }\n\n    // Events can be partially registered, by only creating some markets.\n    // This returns true only if an event is fully registered.\n    function isEventRegistered(uint256 _eventId) public view returns (bool) {\n        uint256[3] memory _event = events[_eventId].markets;\n        return _event[0] != 0 && _event[1] != 0 && _event[2] != 0;\n    }\n\n    function isEventResolved(uint256 _eventId) public view returns (bool) {\n        // check the event's head-to-head market since it will always exist if the event's markets exist\n        uint256 _marketId = events[_eventId].markets[0];\n        return isMarketResolved(_marketId);\n    }\n\n    // Only usable off-chain. Gas cost can easily eclipse block limit.\n    // Lists all events that could be resolved with a call to resolveEvent.\n    // Not all will be resolvable because this does not ensure the game ended.\n    function listResolvableEvents() external view returns (uint256[] memory) {\n        uint256 _totalResolvable = countResolvableEvents();\n        uint256[] memory _resolvableEvents = new uint256[](_totalResolvable);\n\n        uint256 n = 0;\n        for (uint256 i = 0; i < listOfEvents.length; i++) {\n            if (n > _totalResolvable) break;\n            uint256 _eventId = listOfEvents[i];\n            if (isEventResolvable(_eventId)) {\n                _resolvableEvents[n] = _eventId;\n                n++;\n            }\n        }\n\n        return _resolvableEvents;\n    }\n\n    function countResolvableEvents() internal view returns (uint256) {\n        uint256 _totalResolvable = 0;\n        for (uint256 i = 0; i < listOfEvents.length; i++) {\n            uint256 _eventId = listOfEvents[i];\n            if (isEventResolvable(_eventId)) {\n                _totalResolvable++;\n            }\n        }\n        return _totalResolvable;\n    }\n\n    // Returns true if a call to resolveEvent is potentially useful.\n    function isEventResolvable(uint256 _eventId) internal view returns (bool) {\n        EventDetails memory _event = events[_eventId];\n\n        bool _unresolved = false; // default because non-existing markets aren't resolvable\n        for (uint256 i = 0; i < _event.markets.length; i++) {\n            uint256 _marketId = _event.markets[i];\n            if (_marketId != 0 && !isMarketResolved(_marketId)) {\n                _unresolved = true;\n                break;\n            }\n        }\n\n        return _unresolved;\n    }\n}\n"
    },
    "contracts/turbo/SportsLinkMarketFactoryV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../libraries/IERC20Full.sol\";\nimport \"../balancer/BPool.sol\";\nimport \"./AbstractMarketFactoryV1.sol\";\nimport \"./FeePot.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/SignedSafeMath.sol\";\n\ncontract SportsLinkMarketFactoryV1 is AbstractMarketFactoryV1 {\n    using SafeMath for uint256;\n    using SignedSafeMath for int256;\n\n    event MarketCreated(\n        uint256 id,\n        address creator,\n        uint256 endTime,\n        MarketType marketType,\n        uint256 indexed eventId,\n        uint256 homeTeamId,\n        uint256 awayTeamId,\n        uint256 estimatedStartTime,\n        int256 score\n    );\n    event MarketResolved(uint256 id, address winner);\n    event LinkNodeChanged(address newLinkNode);\n\n    enum MarketType {HeadToHead, Spread, OverUnder}\n    enum HeadToHeadOutcome {\n        NoContest, // 0\n        Away, // 1\n        Home // 2\n    }\n    enum SpreadOutcome {\n        NoContest, // 0\n        Away, // 1\n        Home // 2\n    }\n    enum OverUnderOutcome {\n        NoContest, // 0\n        Over, // 1\n        Under // 2\n    }\n    struct MarketDetails {\n        uint256 eventId;\n        uint256 homeTeamId;\n        uint256 awayTeamId;\n        uint256 estimatedStartTime;\n        MarketType marketType;\n        EventStatus eventStatus;\n        // This value depends on the marketType.\n        // HeadToHead: ignored\n        // Spread: the home team spread\n        // OverUnder: total score in game\n        int256 value0;\n    }\n    // MarketId => MarketDetails\n    mapping(uint256 => MarketDetails) internal marketDetails;\n\n    enum EventStatus {Unknown, Scheduled, Final, Postponed, Canceled}\n    struct EventDetails {\n        uint256[3] markets;\n        uint256 startTime;\n        uint256 homeScore;\n        uint256 awayScore;\n        EventStatus status;\n        // If there is a resolution time then the market is resolved but not necessarily finalized.\n        // A market is finalized when its last two score updates were identical.\n        // Score updates must occur after a period of time spedcified by resolutionBuffer.\n        // This mechanism exists to reduce the risk of bad scores being sent by the API then later corrected.\n        // The downside is slower resolution.\n        uint256 resolutionTime; // time since last score update\n        bool finalized; // true after event resolves and has stable scores\n    }\n    // EventId => EventDetails\n    mapping(uint256 => EventDetails) public events;\n    uint256[] public listOfEvents;\n\n    address public linkNode;\n    uint256 public sportId;\n\n    constructor(\n        address _owner,\n        IERC20Full _collateral,\n        uint256 _shareFactor,\n        FeePot _feePot,\n        uint256 _stakerFee,\n        uint256 _settlementFee,\n        address _protocol,\n        uint256 _protocolFee,\n        address _linkNode,\n        uint256 _sportId\n    )\n        AbstractMarketFactoryV1(\n            _owner,\n            _collateral,\n            _shareFactor,\n            _feePot,\n            _stakerFee,\n            _settlementFee,\n            _protocol,\n            _protocolFee\n        )\n    {\n        linkNode = _linkNode;\n        sportId = _sportId;\n    }\n\n    function createMarket(\n        uint256 _eventId,\n        uint256 _homeTeamId,\n        uint256 _awayTeamId,\n        uint256 _startTimestamp,\n        int256 _homeSpread,\n        uint256 _totalScore,\n        bool _makeSpread,\n        bool _makeTotalScore\n    ) public returns (uint256[3] memory _ids) {\n        require(msg.sender == linkNode, \"Only link node can create markets\");\n\n        address _creator = msg.sender;\n        uint256 _endTime = _startTimestamp.add(60 * 8); // 8 hours\n\n        _ids = events[_eventId].markets;\n\n        if (_ids[0] == 0) {\n            _ids[0] = createHeadToHeadMarket(_creator, _endTime, _eventId, _homeTeamId, _awayTeamId, _startTimestamp);\n        }\n\n        if (_ids[1] == 0 && _makeSpread) {\n            // spread market hasn't been created and is ready to be created\n            _ids[1] = createSpreadMarket(\n                _creator,\n                _endTime,\n                _eventId,\n                _homeTeamId,\n                _awayTeamId,\n                _startTimestamp,\n                _homeSpread\n            );\n        }\n\n        if (_ids[2] == 0 && _makeTotalScore) {\n            // over-under market hasn't been created and is ready to be created\n            _ids[2] = createOverUnderMarket(\n                _creator,\n                _endTime,\n                _eventId,\n                _homeTeamId,\n                _awayTeamId,\n                _startTimestamp,\n                _totalScore\n            );\n        }\n\n        events[_eventId].status = EventStatus.Scheduled;\n        events[_eventId].startTime = _startTimestamp;\n        events[_eventId].markets = _ids;\n        listOfEvents.push(_eventId);\n    }\n\n    function createHeadToHeadMarket(\n        address _creator,\n        uint256 _endTime,\n        uint256 _eventId,\n        uint256 _homeTeamId,\n        uint256 _awayTeamId,\n        uint256 _startTimestamp\n    ) internal returns (uint256) {\n        string[] memory _outcomes = new string[](3);\n        _outcomes[uint256(HeadToHeadOutcome.NoContest)] = \"No Contest\";\n        _outcomes[uint256(HeadToHeadOutcome.Away)] = \"Away\";\n        _outcomes[uint256(HeadToHeadOutcome.Home)] = \"Home\";\n\n        uint256 _id = markets.length;\n        markets.push(makeMarket(_creator, _outcomes, _outcomes, _endTime));\n        marketDetails[_id] = MarketDetails(\n            _eventId,\n            _homeTeamId,\n            _awayTeamId,\n            _startTimestamp,\n            MarketType.HeadToHead,\n            EventStatus.Scheduled,\n            0\n        );\n        emit MarketCreated(\n            _id,\n            _creator,\n            _endTime,\n            MarketType.HeadToHead,\n            _eventId,\n            _homeTeamId,\n            _awayTeamId,\n            _startTimestamp,\n            0\n        );\n        return _id;\n    }\n\n    function createSpreadMarket(\n        address _creator,\n        uint256 _endTime,\n        uint256 _eventId,\n        uint256 _homeTeamId,\n        uint256 _awayTeamId,\n        uint256 _startTimestamp,\n        int256 _homeSpread\n    ) internal returns (uint256) {\n        string[] memory _outcomes = new string[](3);\n        _outcomes[uint256(SpreadOutcome.NoContest)] = \"No Contest\";\n        _outcomes[uint256(SpreadOutcome.Away)] = \"Away\";\n        _outcomes[uint256(SpreadOutcome.Home)] = \"Home\";\n\n        // The spread is a quantity of tenths. So 55 is 5.5 and -6 is -60.\n        // If the spread is a whole number then make it a half point more extreme, to eliminate ties.\n        // So 50 becomes 55, -60 becomes -65, and 0 becomes 5.\n        if (_homeSpread >= 0 && _homeSpread % 10 == 0) {\n            _homeSpread += 5;\n        } else if (_homeSpread < 0 && (-_homeSpread) % 10 == 0) {\n            _homeSpread -= 5;\n        }\n\n        uint256 _id = markets.length;\n        markets.push(makeMarket(_creator, _outcomes, _outcomes, _endTime));\n        marketDetails[_id] = MarketDetails(\n            _eventId,\n            _homeTeamId,\n            _awayTeamId,\n            _startTimestamp,\n            MarketType.Spread,\n            EventStatus.Scheduled,\n            _homeSpread\n        );\n        emit MarketCreated(\n            _id,\n            _creator,\n            _endTime,\n            MarketType.Spread,\n            _eventId,\n            _homeTeamId,\n            _awayTeamId,\n            _startTimestamp,\n            _homeSpread\n        );\n        return _id;\n    }\n\n    function createOverUnderMarket(\n        address _creator,\n        uint256 _endTime,\n        uint256 _eventId,\n        uint256 _homeTeamId,\n        uint256 _awayTeamId,\n        uint256 _startTimestamp,\n        uint256 _overUnderTotal\n    ) internal returns (uint256) {\n        string[] memory _outcomes = new string[](3);\n        _outcomes[uint256(OverUnderOutcome.NoContest)] = \"No Contest\";\n        _outcomes[uint256(OverUnderOutcome.Over)] = \"Over\";\n        _outcomes[uint256(OverUnderOutcome.Under)] = \"Under\";\n\n        // The total is a quantity of tenths. So 55 is 5.5 and -6 is -60.\n        // If the total is a whole number then make it a half point higher, to eliminate ties.\n        // So 50 becomes 55 and 0 becomes 5.\n        if (_overUnderTotal >= 0 && _overUnderTotal % 10 == 0) {\n            _overUnderTotal += 5;\n        }\n\n        uint256 _id = markets.length;\n        markets.push(makeMarket(_creator, _outcomes, _outcomes, _endTime));\n        marketDetails[_id] = MarketDetails(\n            _eventId,\n            _homeTeamId,\n            _awayTeamId,\n            _startTimestamp,\n            MarketType.OverUnder,\n            EventStatus.Scheduled,\n            int256(_overUnderTotal)\n        );\n        emit MarketCreated(\n            _id,\n            _creator,\n            _endTime,\n            MarketType.OverUnder,\n            _eventId,\n            _homeTeamId,\n            _awayTeamId,\n            _startTimestamp,\n            int256(_overUnderTotal)\n        );\n        return _id;\n    }\n\n    function resolveMarket(uint256) public pure override {\n        require(false, \"Only the link node can resolve the market, using trustedResolveMarkets\");\n    }\n\n    function trustedResolveMarkets(\n        uint256 _eventId,\n        uint256 _eventStatus,\n        uint256 _homeScore,\n        uint256 _awayScore\n    ) public {\n        require(msg.sender == linkNode, \"Only link node can resolve markets\");\n\n        EventDetails storage _event = events[_eventId];\n        uint256[3] memory _ids = _event.markets;\n\n        require(_ids[0] != 0 || _ids[1] != 0 || _ids[2] != 0, \"Cannot resolve markets that weren't created\");\n\n        require(EventStatus(_eventStatus) != EventStatus.Scheduled, \"cannot resolve SCHEDULED markets\");\n\n        // resolve markets as No Contest\n        if (EventStatus(_eventStatus) != EventStatus.Final) {\n            for (uint256 i = 0; i < _ids.length; i++) {\n                uint256 _id = _ids[i];\n                if (_id == 0) continue; // skip non-created markets\n                OwnedERC20 _winner = markets[_id].shareTokens[0]; // 0th outcome is No Contest for all market types\n                markets[_id].winner = _winner;\n                emit MarketResolved(_id, address(_winner));\n            }\n            return;\n        }\n\n        // only resolve markets that were created\n        if (_ids[0] != 0) {\n            resolveHeadToHeadMarket(_ids[0], _homeScore, _awayScore);\n        }\n        if (_ids[1] != 0) {\n            resolveSpreadMarket(_ids[1], _homeScore, _awayScore);\n        }\n        if (_ids[2] != 0) {\n            resolveOverUnderMarket(_ids[2], _homeScore, _awayScore);\n        }\n    }\n\n    function resolveHeadToHeadMarket(\n        uint256 _id,\n        uint256 _homeScore,\n        uint256 _awayScore\n    ) internal {\n        OwnedERC20 _winner;\n        if (_homeScore > _awayScore) {\n            _winner = markets[_id].shareTokens[uint256(HeadToHeadOutcome.Home)]; // home team won\n        } else if (_homeScore < _awayScore) {\n            _winner = markets[_id].shareTokens[uint256(HeadToHeadOutcome.Away)]; // away team won\n        } else {\n            _winner = markets[_id].shareTokens[uint256(HeadToHeadOutcome.NoContest)]; // no contest\n        }\n\n        markets[_id].winner = _winner;\n        emit MarketResolved(_id, address(_winner));\n    }\n\n    function resolveSpreadMarket(\n        uint256 _id,\n        uint256 _homeScore,\n        uint256 _awayScore\n    ) internal {\n        MarketDetails memory _details = marketDetails[_id];\n        int256 _targetSpread = _details.value0;\n\n        int256 _actualSpread = int256(_homeScore).sub(int256(_awayScore));\n\n        OwnedERC20 _winner;\n        if (_actualSpread > _targetSpread) {\n            _winner = markets[_id].shareTokens[uint256(SpreadOutcome.Home)]; // home spread greater\n        } else if (_actualSpread < _targetSpread) {\n            _winner = markets[_id].shareTokens[uint256(SpreadOutcome.Away)]; // home spread lesser\n        } else {\n            _winner = markets[_id].shareTokens[uint256(SpreadOutcome.NoContest)]; // no contest\n        }\n\n        markets[_id].winner = _winner;\n        emit MarketResolved(_id, address(_winner));\n    }\n\n    function resolveOverUnderMarket(\n        uint256 _id,\n        uint256 _homeScore,\n        uint256 _awayScore\n    ) internal {\n        MarketDetails memory _details = marketDetails[_id];\n        int256 _targetTotal = _details.value0;\n\n        int256 _actualTotal = int256(_homeScore).add(int256(_awayScore));\n\n        OwnedERC20 _winner;\n        if (_actualTotal > _targetTotal) {\n            _winner = markets[_id].shareTokens[uint256(OverUnderOutcome.Over)]; // over\n        } else if (_actualTotal < _targetTotal) {\n            _winner = markets[_id].shareTokens[uint256(OverUnderOutcome.Under)]; // under\n        } else {\n            _winner = markets[_id].shareTokens[uint256(OverUnderOutcome.NoContest)]; // no contest\n        }\n\n        markets[_id].winner = _winner;\n        emit MarketResolved(_id, address(_winner));\n    }\n\n    function getMarketDetails(uint256 _marketId) public view returns (MarketDetails memory) {\n        return marketDetails[_marketId];\n    }\n\n    function setLinkNode(address _newLinkNode) external onlyOwner {\n        linkNode = _newLinkNode;\n        emit LinkNodeChanged(_newLinkNode);\n    }\n\n    function getEventMarkets(uint256 _eventId) external view returns (uint256[3] memory) {\n        uint256[3] memory _event = events[_eventId].markets;\n        return _event;\n    }\n\n    // Events can be partially registered, by only creating some markets.\n    // This returns true only if an event is fully registered.\n    function isEventRegistered(uint256 _eventId) public view returns (bool) {\n        uint256[3] memory _event = events[_eventId].markets;\n        return _event[0] != 0 && _event[1] != 0 && _event[2] != 0;\n    }\n\n    function isEventResolved(uint256 _eventId) public view returns (bool) {\n        // check the event's head-to-head market since it will always exist if the event's markets exist\n        uint256 _marketId = events[_eventId].markets[0];\n        return isMarketResolved(_marketId);\n    }\n\n    // Only usable off-chain. Gas cost can easily eclipse block limit.\n    // Lists all events that could be resolved with a call to resolveEvent.\n    // Not all will be resolvable because this does not ensure the game ended.\n    function listResolvableEvents() external view returns (uint256[] memory) {\n        uint256 _totalResolvable = countResolvableEvents();\n        uint256[] memory _resolvableEvents = new uint256[](_totalResolvable);\n\n        uint256 n = 0;\n        for (uint256 i = 0; i < listOfEvents.length; i++) {\n            if (n > _totalResolvable) break;\n            uint256 _eventId = listOfEvents[i];\n            if (isEventResolvable(_eventId)) {\n                _resolvableEvents[n] = _eventId;\n                n++;\n            }\n        }\n\n        return _resolvableEvents;\n    }\n\n    function countResolvableEvents() internal view returns (uint256) {\n        uint256 _totalResolvable = 0;\n        for (uint256 i = 0; i < listOfEvents.length; i++) {\n            uint256 _eventId = listOfEvents[i];\n            if (isEventResolvable(_eventId)) {\n                _totalResolvable++;\n            }\n        }\n        return _totalResolvable;\n    }\n\n    // Returns true if a call to resolveEvent is potentially useful.\n    function isEventResolvable(uint256 _eventId) internal view returns (bool) {\n        EventDetails memory _event = events[_eventId];\n\n        bool _unresolved = false; // default because non-existing markets aren't resolvable\n        for (uint256 i = 0; i < _event.markets.length; i++) {\n            uint256 _marketId = _event.markets[i];\n            if (_marketId != 0 && !isMarketResolved(_marketId)) {\n                _unresolved = true;\n                break;\n            }\n        }\n\n        return _unresolved;\n    }\n}\n"
    },
    "contracts/turbo/AbstractMarketFactoryV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../libraries/IERC20Full.sol\";\nimport \"../balancer/BPool.sol\";\nimport \"./TurboShareTokenFactory.sol\";\nimport \"./FeePot.sol\";\n\nabstract contract AbstractMarketFactoryV1 is TurboShareTokenFactoryV1, Ownable {\n    using SafeMath for uint256;\n\n    // Should always have ID. Others are optional.\n    // event MarketCreated(uint256 id, address settlementAddress, uint256 endTime, ...);\n\n    // Should always have ID. Others are optional.\n    // event MarketResolved(uint256 id, ...);\n\n    event SharesMinted(uint256 id, uint256 amount, address receiver);\n    event SharesBurned(uint256 id, uint256 amount, address receiver);\n    event WinningsClaimed(\n        uint256 id,\n        address winningOutcome,\n        uint256 amount,\n        uint256 settlementFee,\n        uint256 payout,\n        address indexed receiver\n    );\n\n    event SettlementFeeClaimed(address settlementAddress, uint256 amount, address indexed receiver);\n    event ProtocolFeeClaimed(address protocol, uint256 amount);\n\n    event ProtocolChanged(address protocol);\n    event ProtocolFeeChanged(uint256 fee);\n    event SettlementFeeChanged(uint256 fee);\n    event StakerFeeChanged(uint256 fee);\n\n    IERC20Full public collateral;\n    FeePot public feePot;\n\n    // fees are out of 1e18 and only apply to new markets\n    uint256 public stakerFee;\n    uint256 public settlementFee;\n    uint256 public protocolFee;\n\n    address public protocol; // collects protocol fees\n\n    uint256 public accumulatedProtocolFee = 0;\n    // settlement address => amount of collateral\n    mapping(address => uint256) public accumulatedSettlementFees;\n\n    // How many shares equals one collateral.\n    // Necessary to account for math errors from small numbers in balancer.\n    // shares = collateral / shareFactor\n    // collateral = shares * shareFactor\n    uint256 public shareFactor;\n\n    struct Market {\n        address settlementAddress;\n        OwnedERC20[] shareTokens;\n        uint256 endTime;\n        OwnedERC20 winner;\n        uint256 settlementFee;\n        uint256 protocolFee;\n        uint256 stakerFee;\n        uint256 creationTimestamp;\n    }\n    Market[] internal markets;\n\n    uint256 private constant MAX_UINT = 2**256 - 1;\n\n    constructor(\n        address _owner,\n        IERC20Full _collateral,\n        uint256 _shareFactor,\n        FeePot _feePot,\n        uint256 _stakerFee,\n        uint256 _settlementFee,\n        address _protocol,\n        uint256 _protocolFee\n    ) {\n        owner = _owner; // controls fees for new markets\n        collateral = _collateral;\n        shareFactor = _shareFactor;\n        feePot = _feePot;\n        stakerFee = _stakerFee;\n        settlementFee = _settlementFee;\n        protocol = _protocol;\n        protocolFee = _protocolFee;\n\n        _collateral.approve(address(_feePot), MAX_UINT);\n\n        // First market is always empty so that marketid zero means \"no market\"\n        string[] memory _nothing = new string[](0);\n        markets.push(makeMarket(address(0), _nothing, _nothing, 0));\n    }\n\n    // function createMarket(address _settlementAddress, uint256 _endTime, ...) public returns (uint256);\n\n    function resolveMarket(uint256 _id) public virtual;\n\n    // Returns an empty struct if the market doesn't exist.\n    // Can check market existence before calling this by comparing _id against markets.length.\n    // Can check market existence of the return struct by checking that shareTokens[0] isn't the null address\n    function getMarket(uint256 _id) public view returns (Market memory) {\n        if (_id >= markets.length) {\n            return Market(address(0), new OwnedERC20[](0), 0, OwnedERC20(address(0)), 0, 0, 0, 0);\n        } else {\n            return markets[_id];\n        }\n    }\n\n    function marketCount() public view returns (uint256) {\n        return markets.length;\n    }\n\n    // Returns factory-specific details about a market.\n    // function getMarketDetails(uint256 _id) public view returns (MarketDetails memory);\n\n    function mintShares(\n        uint256 _id,\n        uint256 _shareToMint,\n        address _receiver\n    ) public {\n        require(markets.length > _id, \"No such market\");\n        require(!isMarketResolved(_id), \"Cannot mint shares for resolved market\");\n\n        uint256 _cost = calcCost(_shareToMint);\n        collateral.transferFrom(msg.sender, address(this), _cost);\n\n        Market memory _market = markets[_id];\n        for (uint256 _i = 0; _i < _market.shareTokens.length; _i++) {\n            _market.shareTokens[_i].trustedMint(_receiver, _shareToMint);\n        }\n\n        emit SharesMinted(_id, _shareToMint, _receiver);\n    }\n\n    function burnShares(\n        uint256 _id,\n        uint256 _sharesToBurn,\n        address _receiver\n    ) public returns (uint256) {\n        require(markets.length > _id, \"No such market\");\n        require(!isMarketResolved(_id), \"Cannot burn shares for resolved market\");\n\n        Market memory _market = markets[_id];\n        for (uint256 _i = 0; _i < _market.shareTokens.length; _i++) {\n            // errors if sender doesn't have enough shares\n            _market.shareTokens[_i].trustedBurn(msg.sender, _sharesToBurn);\n        }\n\n        uint256 _payout = calcCost(_sharesToBurn);\n        uint256 _protocolFee = _payout.mul(_market.protocolFee).div(10**18);\n        uint256 _stakerFee = _payout.mul(_market.stakerFee).div(10**18);\n        _payout = _payout.sub(_protocolFee).sub(_stakerFee);\n\n        accumulatedProtocolFee += _protocolFee;\n        collateral.transfer(_receiver, _payout);\n        feePot.depositFees(_stakerFee);\n\n        emit SharesBurned(_id, _sharesToBurn, msg.sender);\n        return _payout;\n    }\n\n    function claimWinnings(uint256 _id, address _receiver) public returns (uint256) {\n        if (!isMarketResolved(_id)) {\n            // errors if market does not exist or is not resolved or resolvable\n            resolveMarket(_id);\n        }\n\n        Market memory _market = markets[_id];\n        uint256 _winningShares = _market.winner.trustedBurnAll(msg.sender);\n        _winningShares = (_winningShares / shareFactor) * shareFactor; // remove unusable dust\n\n        uint256 _payout = calcCost(_winningShares); // will fail if there are no winnings to claim\n        uint256 _settlementFee = _payout.mul(_market.settlementFee).div(10**18);\n        _payout = _payout.sub(_settlementFee);\n\n        accumulatedSettlementFees[_market.settlementAddress] += _settlementFee;\n        collateral.transfer(_receiver, _payout);\n\n        emit WinningsClaimed(_id, address(_market.winner), _winningShares, _settlementFee, _payout, _receiver);\n        return _payout;\n    }\n\n    function claimManyWinnings(uint256[] memory _ids, address _receiver) public returns (uint256) {\n        uint256 _totalWinnings = 0;\n        for (uint256 i = 0; i < _ids.length; i++) {\n            _totalWinnings = _totalWinnings.add(claimWinnings(_ids[i], _receiver));\n        }\n        return _totalWinnings;\n    }\n\n    function claimSettlementFees(address _receiver) public returns (uint256) {\n        uint256 _fees = accumulatedSettlementFees[msg.sender];\n        if (_fees > 0) {\n            accumulatedSettlementFees[msg.sender] = 0;\n            collateral.transfer(_receiver, _fees);\n            emit SettlementFeeClaimed(msg.sender, _fees, _receiver);\n        }\n        return _fees;\n    }\n\n    function claimProtocolFees() public returns (uint256) {\n        require(msg.sender == protocol || msg.sender == address(this), \"Only protocol can claim protocol fee\");\n        uint256 _fees = accumulatedProtocolFee;\n        if (_fees > 0) {\n            accumulatedProtocolFee = 0;\n            collateral.transfer(protocol, _fees);\n            emit ProtocolFeeClaimed(protocol, _fees);\n        }\n        return _fees;\n    }\n\n    function setSettlementFee(uint256 _newFee) external onlyOwner {\n        settlementFee = _newFee;\n        emit SettlementFeeChanged(_newFee);\n    }\n\n    function setStakerFee(uint256 _newFee) external onlyOwner {\n        stakerFee = _newFee;\n        emit StakerFeeChanged(_newFee);\n    }\n\n    function setProtocolFee(uint256 _newFee) external onlyOwner {\n        protocolFee = _newFee;\n        emit ProtocolFeeChanged(_newFee);\n    }\n\n    function setProtocol(address _newProtocol, bool _claimFirst) external onlyOwner {\n        if (_claimFirst) {\n            claimProtocolFees();\n        }\n        protocol = _newProtocol;\n        emit ProtocolChanged(_newProtocol);\n    }\n\n    function makeMarket(\n        address _settlementAddress,\n        string[] memory _names,\n        string[] memory _symbols,\n        uint256 _endTime\n    ) internal returns (Market memory _market) {\n        _market = Market(\n            _settlementAddress,\n            createShareTokens(_names, _symbols, address(this)),\n            _endTime,\n            OwnedERC20(address(0)),\n            settlementFee,\n            protocolFee,\n            stakerFee,\n            block.timestamp\n        );\n    }\n\n    function isMarketResolved(uint256 _id) public view returns (bool) {\n        Market memory _market = markets[_id];\n        return _market.winner != OwnedERC20(address(0));\n    }\n\n    // Only usable off-chain. Gas cost can easily eclipse block limit.\n    function listUnresolvedMarkets() public view returns (uint256[] memory) {\n        uint256 _totalUnresolved = 0;\n        for (uint256 i = 0; i < markets.length; i++) {\n            if (!isMarketResolved(i)) {\n                _totalUnresolved++;\n            }\n        }\n\n        uint256[] memory _marketIds = new uint256[](_totalUnresolved);\n\n        uint256 n = 0;\n        for (uint256 i = 0; i < markets.length; i++) {\n            if (n >= _totalUnresolved) break;\n\n            if (!isMarketResolved(i)) {\n                _marketIds[n] = i;\n                n++;\n            }\n        }\n\n        return _marketIds;\n    }\n\n    // shares => collateral\n    function calcCost(uint256 _shares) public view returns (uint256) {\n        require(\n            _shares >= shareFactor && _shares % shareFactor == 0,\n            \"Shares must be both greater than (or equal to) and divisible by shareFactor\"\n        );\n        return _shares / shareFactor;\n    }\n\n    // collateral => shares\n    function calcShares(uint256 _collateralIn) public view returns (uint256) {\n        return _collateralIn * shareFactor;\n    }\n\n    function onTransferOwnership(address, address) internal override {}\n}\n"
    },
    "contracts/turbo/NFLMarketFactoryV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../libraries/IERC20Full.sol\";\nimport \"../balancer/BPool.sol\";\nimport \"./AbstractMarketFactoryV2.sol\";\nimport \"./FeePot.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/SignedSafeMath.sol\";\nimport \"../libraries/CalculateLinesToBPoolOdds.sol\";\n\ncontract NFLMarketFactoryV2 is AbstractMarketFactoryV2, CalculateLinesToBPoolOdds {\n    using SafeMath for uint256;\n    using SignedSafeMath for int256;\n\n    event MarketCreated(\n        uint256 id,\n        address creator,\n        uint256 endTime,\n        MarketType marketType,\n        uint256 indexed eventId,\n        string homeTeamName,\n        uint256 homeTeamId,\n        string awayTeamName,\n        uint256 awayTeamId,\n        uint256 estimatedStartTime,\n        int256 score\n    );\n    event MarketResolved(uint256 id, address winner);\n    event LinkNodeChanged(address newLinkNode);\n\n    enum MarketType {HeadToHead, Spread, OverUnder}\n    enum HeadToHeadOutcome {\n        NoContest, // 0\n        Away, // 1\n        Home // 2\n    }\n    enum SpreadOutcome {\n        NoContest, // 0\n        Away, // 1\n        Home // 2\n    }\n    enum OverUnderOutcome {\n        NoContest, // 0\n        Over, // 1\n        Under // 2\n    }\n    struct MarketDetails {\n        uint256 eventId;\n        string homeTeamName;\n        uint256 homeTeamId;\n        string awayTeamName;\n        uint256 awayTeamId;\n        uint256 estimatedStartTime;\n        MarketType marketType;\n        EventStatus eventStatus;\n        // This value depends on the marketType.\n        // HeadToHead: ignored\n        // Spread: the home team spread\n        // OverUnder: total score in game\n        int256 value0;\n    }\n    // MarketId => MarketDetails\n    mapping(uint256 => MarketDetails) internal marketDetails;\n\n    enum EventStatus {Unknown, Scheduled, Final, Postponed, Canceled}\n    struct EventDetails {\n        uint256[3] markets;\n        uint256 startTime;\n        uint256 homeScore;\n        uint256 awayScore;\n        EventStatus status;\n        // If there is a resolution time then the market is resolved but not necessarily finalized.\n        // A market is finalized when its last two score updates were identical.\n        // Score updates must occur after a period of time specified by resolutionBuffer.\n        // This mechanism exists to reduce the risk of bad scores being sent by the API then later corrected.\n        // The downside is slower resolution.\n        uint256 resolutionTime; // time since last score update\n        bool finalized; // true after event resolves and has stable scores\n    }\n    // EventId => EventDetails\n    mapping(uint256 => EventDetails) public events;\n    uint256[] public listOfEvents;\n\n    address public linkNode;\n    uint256 public sportId;\n\n    constructor(\n        address _owner,\n        IERC20Full _collateral,\n        uint256 _shareFactor,\n        FeePot _feePot,\n        uint256 _stakerFee,\n        uint256 _settlementFee,\n        address _protocol,\n        uint256 _protocolFee,\n        address _linkNode,\n        uint256 _sportId\n    )\n        AbstractMarketFactoryV2(\n            _owner,\n            _collateral,\n            _shareFactor,\n            _feePot,\n            _stakerFee,\n            _settlementFee,\n            _protocol,\n            _protocolFee\n        )\n    {\n        linkNode = _linkNode;\n        sportId = _sportId;\n    }\n\n    function createMarket(\n        uint256 _eventId,\n        string memory _homeTeamName,\n        uint256 _homeTeamId,\n        string memory _awayTeamName,\n        uint256 _awayTeamId,\n        uint256 _startTimestamp,\n        int256 _homeSpread,\n        uint256 _totalScore,\n        bool _makeSpread,\n        bool _makeTotalScore,\n        int256[2] memory _moneylines // [home,away]\n    ) public returns (uint256[3] memory _ids) {\n        require(msg.sender == linkNode, \"Only link node can create markets\");\n\n        uint256 _endTime = _startTimestamp.add(60 * 8); // 8 hours\n\n        _ids = events[_eventId].markets;\n\n        if (_ids[0] == 0 && _moneylines[0] != 0 && _moneylines[1] != 0) {\n            _ids[0] = createHeadToHeadMarket(\n                msg.sender,\n                _endTime,\n                _eventId,\n                _homeTeamName,\n                _homeTeamId,\n                _awayTeamName,\n                _awayTeamId,\n                _startTimestamp,\n                _moneylines\n            );\n        }\n\n        if (_ids[1] == 0 && _makeSpread) {\n            // spread market hasn't been created and is ready to be created\n            _ids[1] = createSpreadMarket(\n                msg.sender,\n                _endTime,\n                _eventId,\n                _homeTeamName,\n                _homeTeamId,\n                _awayTeamName,\n                _awayTeamId,\n                _startTimestamp,\n                _homeSpread\n            );\n        }\n\n        if (_ids[2] == 0 && _makeTotalScore) {\n            // over-under market hasn't been created and is ready to be created\n            _ids[2] = createOverUnderMarket(\n                msg.sender,\n                _endTime,\n                _eventId,\n                _homeTeamName,\n                _homeTeamId,\n                _awayTeamName,\n                _awayTeamId,\n                _startTimestamp,\n                _totalScore\n            );\n        }\n\n        events[_eventId].status = EventStatus.Scheduled;\n        events[_eventId].startTime = _startTimestamp;\n        events[_eventId].markets = _ids;\n        listOfEvents.push(_eventId);\n    }\n\n    function createHeadToHeadMarket(\n        address _creator,\n        uint256 _endTime,\n        uint256 _eventId,\n        string memory _homeTeamName,\n        uint256 _homeTeamId,\n        string memory _awayTeamName,\n        uint256 _awayTeamId,\n        uint256 _startTimestamp,\n        int256[2] memory _moneylines // [home,away]\n    ) internal returns (uint256) {\n        string[] memory _outcomes = new string[](3);\n        _outcomes[uint256(HeadToHeadOutcome.NoContest)] = \"No Contest / Draw\";\n        _outcomes[uint256(HeadToHeadOutcome.Away)] = _awayTeamName;\n        _outcomes[uint256(HeadToHeadOutcome.Home)] = _homeTeamName;\n\n        uint256 _id = markets.length;\n        // moneylines is [home,away] but the outcomes are listed [NC,away,home] so they must be reversed\n        markets.push(\n            makeMarket(_creator, _outcomes, _outcomes, _endTime, oddsFromLines(_moneylines[1], _moneylines[0]))\n        );\n        marketDetails[_id] = MarketDetails(\n            _eventId,\n            _homeTeamName,\n            _homeTeamId,\n            _awayTeamName,\n            _awayTeamId,\n            _startTimestamp,\n            MarketType.HeadToHead,\n            EventStatus.Scheduled,\n            0\n        );\n        emit MarketCreated(\n            _id,\n            _creator,\n            _endTime,\n            MarketType.HeadToHead,\n            _eventId,\n            _homeTeamName,\n            _homeTeamId,\n            _awayTeamName,\n            _awayTeamId,\n            _startTimestamp,\n            0\n        );\n        return _id;\n    }\n\n    function createSpreadMarket(\n        address _creator,\n        uint256 _endTime,\n        uint256 _eventId,\n        string memory _homeTeamName,\n        uint256 _homeTeamId,\n        string memory _awayTeamName,\n        uint256 _awayTeamId,\n        uint256 _startTimestamp,\n        int256 _homeSpread\n    ) internal returns (uint256) {\n        string[] memory _outcomes = new string[](3);\n        _outcomes[uint256(SpreadOutcome.NoContest)] = \"No Contest\";\n        _outcomes[uint256(SpreadOutcome.Away)] = _awayTeamName;\n        _outcomes[uint256(SpreadOutcome.Home)] = _homeTeamName;\n\n        // The spread is a quantity of tenths. So 55 is 5.5 and -6 is -60.\n        // If the spread is a whole number then make it a half point more extreme, to eliminate ties.\n        // So 50 becomes 55, -60 becomes -65, and 0 becomes 5.\n        if (_homeSpread >= 0 && _homeSpread % 10 == 0) {\n            _homeSpread += 5;\n        } else if (_homeSpread < 0 && (-_homeSpread) % 10 == 0) {\n            _homeSpread -= 5;\n        }\n\n        uint256 _id = markets.length;\n        markets.push(makeMarket(_creator, _outcomes, _outcomes, _endTime, evenOdds(true, 2)));\n        marketDetails[_id] = MarketDetails(\n            _eventId,\n            _homeTeamName,\n            _homeTeamId,\n            _awayTeamName,\n            _awayTeamId,\n            _startTimestamp,\n            MarketType.Spread,\n            EventStatus.Scheduled,\n            _homeSpread\n        );\n        emit MarketCreated(\n            _id,\n            _creator,\n            _endTime,\n            MarketType.Spread,\n            _eventId,\n            _homeTeamName,\n            _homeTeamId,\n            _awayTeamName,\n            _awayTeamId,\n            _startTimestamp,\n            _homeSpread\n        );\n        return _id;\n    }\n\n    function createOverUnderMarket(\n        address _creator,\n        uint256 _endTime,\n        uint256 _eventId,\n        string memory _homeTeamName,\n        uint256 _homeTeamId,\n        string memory _awayTeamName,\n        uint256 _awayTeamId,\n        uint256 _startTimestamp,\n        uint256 _overUnderTotal\n    ) internal returns (uint256) {\n        string[] memory _outcomes = new string[](3);\n        _outcomes[uint256(OverUnderOutcome.NoContest)] = \"No Contest\";\n        _outcomes[uint256(OverUnderOutcome.Over)] = \"Over\";\n        _outcomes[uint256(OverUnderOutcome.Under)] = \"Under\";\n\n        // The total is a quantity of tenths. So 55 is 5.5 and -6 is -60.\n        // If the total is a whole number then make it a half point higher, to eliminate ties.\n        // So 50 becomes 55 and 0 becomes 5.\n        if (_overUnderTotal >= 0 && _overUnderTotal % 10 == 0) {\n            _overUnderTotal += 5;\n        }\n\n        uint256 _id = markets.length;\n        markets.push(makeMarket(_creator, _outcomes, _outcomes, _endTime, evenOdds(true, 2)));\n        marketDetails[_id] = MarketDetails(\n            _eventId,\n            _homeTeamName,\n            _homeTeamId,\n            _awayTeamName,\n            _awayTeamId,\n            _startTimestamp,\n            MarketType.OverUnder,\n            EventStatus.Scheduled,\n            int256(_overUnderTotal)\n        );\n        emit MarketCreated(\n            _id,\n            _creator,\n            _endTime,\n            MarketType.OverUnder,\n            _eventId,\n            _homeTeamName,\n            _homeTeamId,\n            _awayTeamName,\n            _awayTeamId,\n            _startTimestamp,\n            int256(_overUnderTotal)\n        );\n        return _id;\n    }\n\n    function resolveMarket(uint256) public pure override {\n        require(false, \"Only the link node can resolve the market, using trustedResolveMarkets\");\n    }\n\n    function trustedResolveMarkets(\n        uint256 _eventId,\n        uint256 _eventStatus,\n        uint256 _homeScore,\n        uint256 _awayScore\n    ) public {\n        require(msg.sender == linkNode, \"Only link node can resolve markets\");\n\n        EventDetails storage _event = events[_eventId];\n        uint256[3] memory _ids = _event.markets;\n\n        require(_ids[0] != 0 || _ids[1] != 0 || _ids[2] != 0, \"Cannot resolve markets that weren't created\");\n\n        require(EventStatus(_eventStatus) != EventStatus.Scheduled, \"cannot resolve SCHEDULED markets\");\n\n        // resolve markets as No Contest\n        if (EventStatus(_eventStatus) != EventStatus.Final) {\n            for (uint256 i = 0; i < _ids.length; i++) {\n                uint256 _id = _ids[i];\n                if (_id == 0) continue; // skip non-created markets\n                OwnedERC20 _winner = markets[_id].shareTokens[0]; // 0th outcome is No Contest for all market types\n                markets[_id].winner = _winner;\n                emit MarketResolved(_id, address(_winner));\n            }\n            return;\n        }\n\n        // only resolve markets that were created\n        if (_ids[0] != 0) {\n            resolveHeadToHeadMarket(_ids[0], _homeScore, _awayScore);\n        }\n        if (_ids[1] != 0) {\n            resolveSpreadMarket(_ids[1], _homeScore, _awayScore);\n        }\n        if (_ids[2] != 0) {\n            resolveOverUnderMarket(_ids[2], _homeScore, _awayScore);\n        }\n    }\n\n    function resolveHeadToHeadMarket(\n        uint256 _id,\n        uint256 _homeScore,\n        uint256 _awayScore\n    ) internal {\n        OwnedERC20 _winner;\n        if (_homeScore > _awayScore) {\n            _winner = markets[_id].shareTokens[uint256(HeadToHeadOutcome.Home)]; // home team won\n        } else if (_homeScore < _awayScore) {\n            _winner = markets[_id].shareTokens[uint256(HeadToHeadOutcome.Away)]; // away team won\n        } else {\n            _winner = markets[_id].shareTokens[uint256(HeadToHeadOutcome.NoContest)]; // no contest\n        }\n\n        markets[_id].winner = _winner;\n        emit MarketResolved(_id, address(_winner));\n    }\n\n    function resolveSpreadMarket(\n        uint256 _id,\n        uint256 _homeScore,\n        uint256 _awayScore\n    ) internal {\n        MarketDetails memory _details = marketDetails[_id];\n        int256 _targetSpread = _details.value0;\n\n        int256 _actualSpread = int256(_homeScore).sub(int256(_awayScore));\n\n        OwnedERC20 _winner;\n        if (_actualSpread > _targetSpread) {\n            _winner = markets[_id].shareTokens[uint256(SpreadOutcome.Home)]; // home spread greater\n        } else if (_actualSpread < _targetSpread) {\n            _winner = markets[_id].shareTokens[uint256(SpreadOutcome.Away)]; // home spread lesser\n        } else {\n            _winner = markets[_id].shareTokens[uint256(SpreadOutcome.NoContest)]; // no contest\n        }\n\n        markets[_id].winner = _winner;\n        emit MarketResolved(_id, address(_winner));\n    }\n\n    function resolveOverUnderMarket(\n        uint256 _id,\n        uint256 _homeScore,\n        uint256 _awayScore\n    ) internal {\n        MarketDetails memory _details = marketDetails[_id];\n        int256 _targetTotal = _details.value0;\n\n        int256 _actualTotal = int256(_homeScore).add(int256(_awayScore));\n\n        OwnedERC20 _winner;\n        if (_actualTotal > _targetTotal) {\n            _winner = markets[_id].shareTokens[uint256(OverUnderOutcome.Over)]; // over\n        } else if (_actualTotal < _targetTotal) {\n            _winner = markets[_id].shareTokens[uint256(OverUnderOutcome.Under)]; // under\n        } else {\n            _winner = markets[_id].shareTokens[uint256(OverUnderOutcome.NoContest)]; // no contest\n        }\n\n        markets[_id].winner = _winner;\n        emit MarketResolved(_id, address(_winner));\n    }\n\n    function getMarketDetails(uint256 _marketId) public view returns (MarketDetails memory) {\n        return marketDetails[_marketId];\n    }\n\n    function setLinkNode(address _newLinkNode) external onlyOwner {\n        linkNode = _newLinkNode;\n        emit LinkNodeChanged(_newLinkNode);\n    }\n\n    function getEventMarkets(uint256 _eventId) external view returns (uint256[3] memory) {\n        uint256[3] memory _event = events[_eventId].markets;\n        return _event;\n    }\n\n    // Events can be partially registered, by only creating some markets.\n    // This returns true only if an event is fully registered.\n    function isEventRegistered(uint256 _eventId) public view returns (bool) {\n        uint256[3] memory _event = events[_eventId].markets;\n        return _event[0] != 0 && _event[1] != 0 && _event[2] != 0;\n    }\n\n    function isEventResolved(uint256 _eventId) public view returns (bool) {\n        // check the event's head-to-head market since it will always exist if the event's markets exist\n        uint256 _marketId = events[_eventId].markets[0];\n        return isMarketResolved(_marketId);\n    }\n\n    // Only usable off-chain. Gas cost can easily eclipse block limit.\n    // Lists all events that could be resolved with a call to resolveEvent.\n    // Not all will be resolvable because this does not ensure the game ended.\n    function listResolvableEvents() external view returns (uint256[] memory) {\n        uint256 _totalResolvable = countResolvableEvents();\n        uint256[] memory _resolvableEvents = new uint256[](_totalResolvable);\n\n        uint256 n = 0;\n        for (uint256 i = 0; i < listOfEvents.length; i++) {\n            if (n > _totalResolvable) break;\n            uint256 _eventId = listOfEvents[i];\n            if (isEventResolvable(_eventId)) {\n                _resolvableEvents[n] = _eventId;\n                n++;\n            }\n        }\n\n        return _resolvableEvents;\n    }\n\n    function countResolvableEvents() internal view returns (uint256) {\n        uint256 _totalResolvable = 0;\n        for (uint256 i = 0; i < listOfEvents.length; i++) {\n            uint256 _eventId = listOfEvents[i];\n            if (isEventResolvable(_eventId)) {\n                _totalResolvable++;\n            }\n        }\n        return _totalResolvable;\n    }\n\n    // Returns true if a call to resolveEvent is potentially useful.\n    function isEventResolvable(uint256 _eventId) internal view returns (bool) {\n        EventDetails memory _event = events[_eventId];\n\n        bool _unresolved = false; // default because non-existing markets aren't resolvable\n        for (uint256 i = 0; i < _event.markets.length; i++) {\n            uint256 _marketId = _event.markets[i];\n            if (_marketId != 0 && !isMarketResolved(_marketId)) {\n                _unresolved = true;\n                break;\n            }\n        }\n\n        return _unresolved;\n    }\n}\n"
    },
    "contracts/turbo/MMALinkMarketFactoryV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../libraries/IERC20Full.sol\";\nimport \"../balancer/BPool.sol\";\nimport \"./AbstractMarketFactoryV2.sol\";\nimport \"./FeePot.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/SignedSafeMath.sol\";\nimport \"../libraries/CalculateLinesToBPoolOdds.sol\";\n\ncontract MMALinkMarketFactoryV2 is AbstractMarketFactoryV2, CalculateLinesToBPoolOdds {\n    using SafeMath for uint256;\n    using SignedSafeMath for int256;\n\n    event MarketCreated(\n        uint256 id,\n        address creator,\n        uint256 endTime,\n        MarketType marketType,\n        uint256 indexed eventId,\n        string homeFighterName,\n        uint256 homeFighterId,\n        string awayFighterName,\n        uint256 awayFighterId,\n        uint256 estimatedStartTime\n    );\n    event MarketResolved(uint256 id, address winner);\n    event LinkNodeChanged(address newLinkNode);\n\n    enum MarketType {HeadToHead}\n    enum HeadToHeadOutcome {\n        NoContest, // 0\n        Away, // 1\n        Home // 2\n    }\n\n    struct MarketDetails {\n        uint256 eventId;\n        string homeFighterName;\n        uint256 homeFighterId;\n        string awayFighterName;\n        uint256 awayFighterId;\n        uint256 estimatedStartTime;\n        MarketType marketType;\n        EventStatus eventStatus;\n    }\n    // MarketId => MarketDetails\n    mapping(uint256 => MarketDetails) internal marketDetails;\n\n    enum EventStatus {Unknown, Scheduled, Final, Postponed, Canceled}\n    struct EventDetails {\n        uint256[1] markets;\n        uint256 homeFighterId;\n        uint256 awayFighterId;\n        uint256 startTime;\n        EventStatus eventStatus;\n    }\n\n    // EventId => EventDetails\n    mapping(uint256 => EventDetails) public events;\n    uint256[] public listOfEvents;\n\n    address public linkNode;\n    uint256 public sportId;\n\n    constructor(\n        address _owner,\n        IERC20Full _collateral,\n        uint256 _shareFactor,\n        FeePot _feePot,\n        uint256 _stakerFee,\n        uint256 _settlementFee,\n        address _protocol,\n        uint256 _protocolFee,\n        address _linkNode,\n        uint256 _sportId\n    )\n        AbstractMarketFactoryV2(\n            _owner,\n            _collateral,\n            _shareFactor,\n            _feePot,\n            _stakerFee,\n            _settlementFee,\n            _protocol,\n            _protocolFee\n        )\n    {\n        linkNode = _linkNode;\n        sportId = _sportId;\n    }\n\n    function createMarket(\n        uint256 _eventId,\n        string memory _homeFighterName,\n        uint256 _homeFighterId,\n        string memory _awayFighterName,\n        uint256 _awayFighterId,\n        uint256 _startTimestamp,\n        int256[2] memory _moneylines // [home,away]\n    ) public {\n        require(msg.sender == linkNode, \"Only link node can create markets\");\n\n        address _creator = msg.sender;\n        uint256 _endTime = _startTimestamp.add(60 * 8); // 8 hours\n\n        uint256[1] memory _ids = events[_eventId].markets;\n        // require(_ids[0] == 0, \"This event was already used to create markets\");\n\n        _ids[0] = createHeadToHeadMarket(\n            _creator,\n            _endTime,\n            _eventId,\n            _homeFighterName,\n            _homeFighterId,\n            _awayFighterName,\n            _awayFighterId,\n            _startTimestamp,\n            _moneylines\n        );\n\n        events[_eventId].markets = _ids;\n        events[_eventId].homeFighterId = _homeFighterId;\n        events[_eventId].awayFighterId = _awayFighterId;\n        events[_eventId].startTime = _startTimestamp;\n        events[_eventId].eventStatus = EventStatus.Scheduled;\n        listOfEvents.push(_eventId);\n    }\n\n    function createHeadToHeadMarket(\n        address _creator,\n        uint256 _endTime,\n        uint256 _eventId,\n        string memory _homeTeamName,\n        uint256 _homeFighterId,\n        string memory _awayTeamName,\n        uint256 _awayFighterId,\n        uint256 _startTimestamp,\n        int256[2] memory _moneylines // [home,away]\n    ) internal returns (uint256) {\n        string[] memory _outcomes = new string[](3);\n        _outcomes[uint256(HeadToHeadOutcome.NoContest)] = \"No Contest\";\n        _outcomes[uint256(HeadToHeadOutcome.Away)] = _awayTeamName;\n        _outcomes[uint256(HeadToHeadOutcome.Home)] = _homeTeamName;\n\n        uint256 _id = markets.length;\n        // moneylines is [home,away] but the outcomes are listed [NC,away,home] so they must be reversed\n        markets.push(\n            makeMarket(_creator, _outcomes, _outcomes, _endTime, oddsFromLines(_moneylines[1], _moneylines[0]))\n        );\n        marketDetails[_id] = MarketDetails(\n            _eventId,\n            _homeTeamName,\n            _homeFighterId,\n            _awayTeamName,\n            _awayFighterId,\n            _startTimestamp,\n            MarketType.HeadToHead,\n            EventStatus.Scheduled\n        );\n        emit MarketCreated(\n            _id,\n            _creator,\n            _endTime,\n            MarketType.HeadToHead,\n            _eventId,\n            _homeTeamName,\n            _homeFighterId,\n            _awayTeamName,\n            _awayFighterId,\n            _startTimestamp\n        );\n        return _id;\n    }\n\n    enum WhoWon {Unknown, Home, Away, Draw}\n\n    function trustedResolveMarkets(\n        uint256 _eventId,\n        EventStatus _eventStatus,\n        uint256 _homeFighterId,\n        uint256 _awayFighterId,\n        WhoWon _whoWon\n    ) public {\n        require(msg.sender == linkNode, \"Only link node can resolve markets\");\n\n        EventDetails memory _event = events[_eventId];\n        require(_event.markets[0] != 0, \"Cannot resolve markets that weren't created\");\n        require(EventStatus(_eventStatus) != EventStatus.Scheduled, \"Cannot resolve SCHEDULED markets\");\n\n        if (eventIsNoContest(_event, _eventStatus, _homeFighterId, _awayFighterId, _whoWon)) {\n            resolveMarketsAsNoContest(_eventId);\n        } else {\n            resolveHeadToHeadMarket(_event.markets[0], _whoWon);\n        }\n\n        events[_eventId].eventStatus = _eventStatus;\n    }\n\n    function eventIsNoContest(\n        EventDetails memory _event,\n        EventStatus _eventStatus,\n        uint256 _homeFighterId,\n        uint256 _awayFighterId,\n        WhoWon _whoWon\n    ) internal pure returns (bool) {\n        bool _draw = _whoWon == WhoWon.Draw;\n        bool _notFinal = _eventStatus != EventStatus.Final;\n        bool _unstableHomeFighterId = _event.homeFighterId != _homeFighterId;\n        bool _unstableAwayFighterId = _event.awayFighterId != _awayFighterId;\n        return _draw || _notFinal || _unstableHomeFighterId || _unstableAwayFighterId;\n    }\n\n    function resolveMarketsAsNoContest(uint256 _eventId) internal {\n        uint256[1] memory _marketIds = events[_eventId].markets;\n        for (uint256 i = 0; i < _marketIds.length; i++) {\n            uint256 _marketId = _marketIds[i];\n            if (_marketId == 0) continue; // skip non-created markets\n            OwnedERC20 _winner = markets[_marketId].shareTokens[0]; // 0th outcome is No Contest for all market types\n            markets[_marketId].winner = _winner;\n            emit MarketResolved(_marketId, address(_winner));\n        }\n    }\n\n    function resolveHeadToHeadMarket(uint256 _marketId, WhoWon _whoWon) internal {\n        OwnedERC20 _winner;\n        if (WhoWon.Home == _whoWon) {\n            _winner = markets[_marketId].shareTokens[uint256(HeadToHeadOutcome.Home)];\n        } else if (WhoWon.Away == _whoWon) {\n            _winner = markets[_marketId].shareTokens[uint256(HeadToHeadOutcome.Away)];\n        } else {\n            require(false, \"Bad market resolution choice\");\n        }\n\n        markets[_marketId].winner = _winner;\n        emit MarketResolved(_marketId, address(_winner));\n    }\n\n    function getMarketDetails(uint256 _marketId) public view returns (MarketDetails memory) {\n        return marketDetails[_marketId];\n    }\n\n    // Only usable off-chain. Gas cost can easily eclipse block limit.\n    // Lists all events that could be resolved with a call to resolveEvent.\n    // Not all will be resolvable because this does not ensure the game ended.\n    function listResolvableEvents() external view returns (uint256[] memory) {\n        uint256 _totalResolvable = countResolvableEvents();\n        uint256[] memory _resolvableEvents = new uint256[](_totalResolvable);\n\n        uint256 n = 0;\n        for (uint256 i = 0; i < listOfEvents.length; i++) {\n            if (n > _totalResolvable) break;\n            uint256 _eventId = listOfEvents[i];\n            if (isEventResolvable(_eventId)) {\n                _resolvableEvents[n] = _eventId;\n                n++;\n            }\n        }\n\n        return _resolvableEvents;\n    }\n\n    function countResolvableEvents() internal view returns (uint256) {\n        uint256 _totalResolvable = 0;\n        for (uint256 i = 0; i < listOfEvents.length; i++) {\n            uint256 _eventId = listOfEvents[i];\n            if (isEventResolvable(_eventId)) {\n                _totalResolvable++;\n            }\n        }\n        return _totalResolvable;\n    }\n\n    // Returns true if a call to resolveEvent is potentially useful.\n    function isEventResolvable(uint256 _eventId) internal view returns (bool) {\n        EventDetails memory _event = events[_eventId];\n\n        bool _unresolved = false; // default because non-existing markets aren't resolvable\n        for (uint256 i = 0; i < _event.markets.length; i++) {\n            uint256 _marketId = _event.markets[i];\n            if (_marketId != 0 && !isMarketResolved(_marketId)) {\n                _unresolved = true;\n                break;\n            }\n        }\n\n        return _unresolved;\n    }\n\n    function getEvent(uint256 _eventId) external view returns (EventDetails memory _event) {\n        _event = events[_eventId];\n    }\n\n    function setLinkNode(address _newLinkNode) external onlyOwner {\n        linkNode = _newLinkNode;\n        emit LinkNodeChanged(_newLinkNode);\n    }\n\n    function resolveMarket(uint256) public pure override {\n        require(false, \"Only the link node can resolve the market, using trustedResolveMarkets\");\n    }\n}\n"
    },
    "contracts/turbo/MLBMarketFactoryV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../libraries/IERC20Full.sol\";\nimport \"../balancer/BPool.sol\";\nimport \"./AbstractMarketFactoryV3.sol\";\nimport \"./FeePot.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/SignedSafeMath.sol\";\nimport \"../libraries/Sport.sol\";\nimport \"../libraries/HasHeadToHeadMarket.sol\";\nimport \"../libraries/ResolveByScore.sol\";\nimport \"../libraries/Versioned.sol\";\n\ncontract MLBMarketFactoryV3 is AbstractMarketFactoryV3, SportView, HasHeadToHeadMarket, ResolvesByScore, Versioned {\n    using SafeMath for uint256;\n    using SignedSafeMath for int256;\n\n    uint256 constant HeadToHead = 0;\n    string constant InvalidName = \"No Contest\";\n\n    constructor(\n        address _owner,\n        IERC20Full _collateral,\n        uint256 _shareFactor,\n        FeePot _feePot,\n        uint256[3] memory _fees,\n        address _protocol,\n        address _linkNode\n    )\n        AbstractMarketFactoryV3(_owner, _collateral, _shareFactor, _feePot, _fees, _protocol)\n        Versioned(\"v1.4.0\")\n        ManagedByLink(_linkNode)\n        HasHeadToHeadMarket(HeadToHead, InvalidName)\n    {}\n\n    function createEvent(\n        uint256 _eventId,\n        string memory _homeTeamName,\n        uint256 _homeTeamId,\n        string memory _awayTeamName,\n        uint256 _awayTeamId,\n        uint256 _startTimestamp,\n        int256[2] memory _moneylines // [home,away]\n    ) public onlyLinkNode returns (uint256[] memory _marketIds) {\n        _marketIds = makeMarkets(_moneylines, _homeTeamName, _awayTeamName);\n        makeSportsEvent(\n            _eventId,\n            _marketIds,\n            build1Line(),\n            _startTimestamp,\n            _homeTeamId,\n            _awayTeamId,\n            _homeTeamName,\n            _awayTeamName\n        );\n    }\n\n    function makeMarkets(\n        int256[2] memory _moneylines,\n        string memory _homeTeamName,\n        string memory _awayTeamName\n    ) internal returns (uint256[] memory _marketIds) {\n        _marketIds = new uint256[](1);\n        _marketIds[HeadToHead] = makeHeadToHeadMarket(_moneylines, _homeTeamName, _awayTeamName);\n    }\n\n    function resolveValidEvent(\n        SportsEvent memory _event,\n        uint256 _homeScore,\n        uint256 _awayScore\n    ) internal override {\n        resolveHeadToHeadMarket(_event.markets[HeadToHead], _homeScore, _awayScore);\n    }\n}\n"
    },
    "contracts/turbo/CryptoMarketFactoryV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../libraries/IERC20Full.sol\";\nimport \"../balancer/BPool.sol\";\nimport \"./AbstractMarketFactoryV2.sol\";\nimport \"./FeePot.sol\";\nimport \"@openzeppelin/contracts/utils/math/SignedSafeMath.sol\";\n\nimport \"../utils/AggregatorV3Interface.sol\";\nimport \"../libraries/CalculateLinesToBPoolOdds.sol\";\n\ncontract CryptoMarketFactoryV2 is AbstractMarketFactoryV2, CalculateLinesToBPoolOdds {\n    using SafeMath for uint256;\n    using SignedSafeMath for int256;\n\n    event MarketCreated(\n        uint256 id,\n        address creator,\n        uint256 indexed endTime,\n        MarketType marketType,\n        uint256 indexed coinIndex,\n        uint256 price\n    );\n    event MarketResolved(uint256 id, address winner);\n\n    struct Coin {\n        string name;\n        AggregatorV3Interface priceFeed;\n        uint256 price;\n        uint8 imprecision; // how many decimals to truncate\n        uint256[1] currentMarkets;\n    }\n    Coin[] public coins;\n\n    enum MarketType {\n        PriceUpDown // 0\n    }\n    enum PriceUpDownOutcome {\n        Above, // 0\n        NotAbove // 1\n    }\n    struct MarketDetails {\n        MarketType marketType;\n        uint256 coinIndex;\n        uint256 creationPrice;\n        uint256 resolutionPrice;\n    }\n    // MarketId => MarketDetails\n    mapping(uint256 => MarketDetails) internal marketDetails;\n\n    address public linkNode; // market creator and resolver\n\n    uint256 public nextResolutionTime;\n\n    constructor(\n        address _owner,\n        IERC20Full _collateral,\n        uint256 _shareFactor,\n        FeePot _feePot,\n        uint256 _stakerFee,\n        uint256 _settlementFee,\n        address _protocol,\n        uint256 _protocolFee,\n        address _linkNode\n    )\n        AbstractMarketFactoryV2(\n            _owner,\n            _collateral,\n            _shareFactor,\n            _feePot,\n            _stakerFee,\n            _settlementFee,\n            _protocol,\n            _protocolFee\n        )\n    {\n        linkNode = _linkNode;\n\n        string memory _name = \"\";\n        coins.push(makeCoin(_name, AggregatorV3Interface(address(0)), 0));\n    }\n\n    function getMarketDetails(uint256 _marketId) public view returns (MarketDetails memory) {\n        return marketDetails[_marketId];\n    }\n\n    // NOTE: Trusts the owner not to add a coin twice.\n    // Returns the coin index.\n    function addCoin(\n        string calldata _name,\n        AggregatorV3Interface _priceFeed,\n        uint8 _imprecision\n    ) external onlyOwner returns (uint256 _coinIndex) {\n        Coin memory _coin = makeCoin(_name, _priceFeed, _imprecision);\n        _coinIndex = coins.length;\n        coins.push(_coin);\n    }\n\n    function getCoin(uint256 _coinIndex) public view returns (Coin memory _coin) {\n        _coin = coins[_coinIndex];\n    }\n\n    function getCoins() public view returns (Coin[] memory _coins) {\n        _coins = new Coin[](coins.length);\n        // Skip first coin because it's always the zeroed-out fake coin.\n        for (uint256 i = 1; i < coins.length; i++) {\n            _coins[i] = coins[i];\n        }\n    }\n\n    // Iterates over all coins.\n    // If markets do not exist for coin, create them.\n    // Unless _nextResolutionTime is zero; then do not create new markets.\n    // If markets for coin exist and are ready to resolve, resolve them and create new markets.\n    // Else, error.\n    //\n    // Assume that _roundIds has a dummy value at index 0, and is 1 indexed like the\n    // coins array.\n    function createAndResolveMarkets(uint80[] calldata _roundIds, uint256 _nextResolutionTime) public {\n        require(msg.sender == linkNode, \"Only link node can create markets\");\n        // If market creation was stopped then it can be started again.\n        // If market creation wasn't stopped then you must wait for market end time to resolve.\n        require(block.timestamp >= nextResolutionTime, \"Must wait for market resolution\");\n        require(_roundIds.length == coins.length, \"Must specify one roundId for each coin\");\n\n        uint256 _resolutionTime = nextResolutionTime;\n        nextResolutionTime = _nextResolutionTime;\n\n        // Start at 1 to skip the fake Coin in the 0 index\n        for (uint256 i = 1; i < coins.length; i++) {\n            createAndResolveMarketsForCoin(i, _resolutionTime, _roundIds[i]);\n        }\n    }\n\n    function createAndResolveMarketsForCoin(\n        uint256 _coinIndex,\n        uint256 _resolutionTime,\n        uint80 _roundId\n    ) internal {\n        Coin memory _coin = coins[_coinIndex];\n        (uint256 _fullPrice, uint256 _newPrice) = getPrice(_coin, _roundId, _resolutionTime);\n\n        // resolve markets\n        if (_coin.currentMarkets[uint256(MarketType.PriceUpDown)] != 0) {\n            resolvePriceUpDownMarket(_coin, _newPrice, _fullPrice);\n        }\n\n        // update price only AFTER resolution\n        coins[_coinIndex].price = _newPrice;\n\n        // link node sets nextResolutionTime to zero to signify \"do not create markets after resolution\"\n        if (nextResolutionTime == 0) {\n            return;\n        }\n\n        // create markets\n        coins[_coinIndex].currentMarkets[uint256(MarketType.PriceUpDown)] = createPriceUpDownMarket(\n            _coinIndex,\n            linkNode,\n            _newPrice\n        );\n    }\n\n    function resolvePriceUpDownMarket(\n        Coin memory _coin,\n        uint256 _newPrice,\n        uint256 _fullPrice\n    ) internal {\n        uint256 _marketId = _coin.currentMarkets[uint256(MarketType.PriceUpDown)];\n\n        OwnedERC20 _winner;\n        if (_newPrice > _coin.price) {\n            _winner = markets[_marketId].shareTokens[uint256(PriceUpDownOutcome.Above)];\n        } else {\n            _winner = markets[_marketId].shareTokens[uint256(PriceUpDownOutcome.NotAbove)];\n        }\n\n        markets[_marketId].winner = _winner;\n        marketDetails[_marketId].resolutionPrice = _fullPrice;\n        emit MarketResolved(_marketId, address(_winner));\n    }\n\n    function createPriceUpDownMarket(\n        uint256 _coinIndex,\n        address _creator,\n        uint256 _newPrice\n    ) internal returns (uint256 _id) {\n        string[] memory _outcomes = new string[](2);\n        _outcomes[uint256(PriceUpDownOutcome.Above)] = \"Above\";\n        _outcomes[uint256(PriceUpDownOutcome.NotAbove)] = \"Not Above\";\n\n        uint256 _nextResolutionTime = nextResolutionTime;\n        _id = markets.length;\n        markets.push(makeMarket(_creator, _outcomes, _outcomes, _nextResolutionTime, evenOdds(false, 2)));\n        marketDetails[_id] = MarketDetails(MarketType.PriceUpDown, _coinIndex, _newPrice, 0);\n        emit MarketCreated(_id, _creator, _nextResolutionTime, MarketType.PriceUpDown, _coinIndex, _newPrice);\n    }\n\n    // Returns the price based on a few factors.\n    // If _roundId is zero then it returns the latest price.\n    // Else, it returns the price for that round,\n    //       but errors if that isn't the first round after the resolution time.\n    // The price is then altered to match the desired precision.\n    function getPrice(\n        Coin memory _coin,\n        uint80 _roundId,\n        uint256 _resolutionTime\n    ) internal view returns (uint256 _fullPrice, uint256 _truncatedPrice) {\n        if (_roundId == 0) {\n            (, int256 _rawPrice, , , ) = _coin.priceFeed.latestRoundData();\n            require(_rawPrice >= 0, \"Price from feed is negative\");\n            _fullPrice = uint256(_rawPrice);\n        } else {\n            (, int256 _rawPrice, , uint256 updatedAt, ) = _coin.priceFeed.getRoundData(_roundId);\n            require(_rawPrice >= 0, \"Price from feed is negative\");\n            require(updatedAt >= _resolutionTime, \"Price hasn't been updated yet\");\n\n            // if resolution time is zero then market creation was stopped, so the previous round doesn't matter\n            if (_resolutionTime != 0) {\n                (, , , uint256 _previousRoundTime, ) = _coin.priceFeed.getRoundData(previousRound(_roundId));\n                require(_previousRoundTime < _resolutionTime, \"Must use first round after resolution time\");\n            }\n\n            _fullPrice = uint256(_rawPrice);\n        }\n\n        // The precision is how many decimals the price has. Zero is dollars, 2 includes cents, 3 is tenths of a cent, etc.\n        // Our resolution rules want a certain precision. Like BTC is to the dollar and MATIC is to the cent.\n        // If somehow the decimals are larger than the desired precision then add zeroes to the end to meet the precision.\n        // This does not change the resolution outcome but does guard against decimals() changing and therefore altering the basis.\n\n        uint8 _precision = _coin.priceFeed.decimals(); // probably constant but that isn't guaranteed, so query each time\n        if (_precision > _coin.imprecision) {\n            uint8 _truncate = _precision - _coin.imprecision;\n            _truncatedPrice = _fullPrice / (10**_truncate);\n        } else if (_precision < _coin.imprecision) {\n            uint8 _greaten = _coin.imprecision - _precision;\n            _truncatedPrice = _fullPrice * (10**_greaten);\n        } else {\n            _truncatedPrice = _fullPrice;\n        }\n\n        // Round up because that cleanly fits Above/Not-Above.\n        if (_truncatedPrice != _fullPrice) {\n            _truncatedPrice += 1;\n        }\n    }\n\n    function makeCoin(\n        string memory _name,\n        AggregatorV3Interface _priceFeed,\n        uint8 _imprecision\n    ) internal pure returns (Coin memory _coin) {\n        uint256[1] memory _currentMarkets = [uint256(0)];\n        _coin = Coin(_name, _priceFeed, 0, _imprecision, _currentMarkets);\n    }\n\n    function resolveMarket(uint256) public pure override {\n        require(false, \"Use createAndResolveMarkets\");\n    }\n\n    // The roundId is the encoding of two parts: the phase and the phase-specific round id.\n    // To find the previous roundId:\n    // 1. extract the phase and phase-specific round (I call these _phaseId and _roundId)\n    // 2. decrement the phase-specific round\n    // 3. re-encode the phase and phase-specific round.\n    uint256 private constant PHASE_OFFSET = 64;\n\n    function previousRound(uint80 _fullRoundId) internal pure returns (uint80) {\n        uint256 _phaseId = uint256(uint16(_fullRoundId >> PHASE_OFFSET));\n        uint64 _roundId = uint64(_fullRoundId) - 1;\n        return uint80((_phaseId << PHASE_OFFSET) | _roundId);\n    }\n}\n"
    },
    "contracts/libraries/FakePriceFeed.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../utils/AggregatorV3Interface.sol\";\n\ncontract FakePriceFeed is AggregatorV3Interface {\n    uint8 decimals_;\n    string description_;\n    uint256 version_;\n\n    struct Round {\n        uint80 roundId;\n        int256 answer;\n        uint256 startedAt;\n        uint256 updatedAt;\n        uint80 answeredInRound;\n    }\n    mapping(uint80 => Round) rounds;\n    uint80 latestRoundId;\n\n    constructor(\n        uint8 _decimals,\n        string memory _description,\n        uint256 _version\n    ) {\n        decimals_ = _decimals;\n        description_ = _description;\n        version_ = _version;\n    }\n\n    function decimals() external view override returns (uint8) {\n        return decimals_;\n    }\n\n    function description() external view override returns (string memory) {\n        return description_;\n    }\n\n    function version() external view override returns (uint256) {\n        return version_;\n    }\n\n    // getRoundData and latestRoundData should both raise \"No data present\"\n    // if they do not have data to report, instead of returning unset values\n    // which could be misinterpreted as actual reported values.\n    function getRoundData(uint80 roundId_)\n        public\n        view\n        override\n        returns (\n            uint80 _roundId,\n            int256 _answer,\n            uint256 _startedAt,\n            uint256 _updatedAt,\n            uint80 _answeredInRound\n        )\n    {\n        Round memory _round = rounds[roundId_];\n        _roundId = _round.roundId;\n        _answer = _round.answer;\n        _startedAt = _round.startedAt;\n        _updatedAt = _round.updatedAt;\n        _answeredInRound = _round.answeredInRound;\n    }\n\n    function latestRoundData()\n        public\n        view\n        override\n        returns (\n            uint80 _roundId,\n            int256 _answer,\n            uint256 _startedAt,\n            uint256 _updatedAt,\n            uint80 _answeredInRound\n        )\n    {\n        return getRoundData(latestRoundId);\n    }\n\n    function addRound(\n        uint80 _roundId,\n        int256 _answer,\n        uint256 _startedAt,\n        uint256 _updatedAt,\n        uint80 _answeredInRound\n    ) external {\n        rounds[_roundId] = Round(_roundId, _answer, _startedAt, _updatedAt, _answeredInRound);\n        latestRoundId = _roundId;\n    }\n}\n"
    },
    "contracts/stablecoin/indexCDS.sol": {
      "content": "pragma solidity ^0.8.4; \n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n//import \"../ERC20/IERC20.sol\";\n\nimport \"../turbo/AMMFactory.sol\"; \nimport \"../turbo/OwnedShareToken.sol\"; \nimport \"hardhat/console.sol\";\n\ncontract IndexCDS is ERC721, ReentrancyGuard{\n\n\t//For each lockID\n \tstruct Index{\n \t\tuint256 value;\n \t\tuint256[] amounts; \n \t\taddress[] tokens; \n \t\t\n \t}\n\n \tstruct Index_info{\n \t\tuint256[] token_amounts;\n \t\tuint256[] marketIds; \n \t\tuint256[] outcomes; \n \t\tuint256 lockId; \n \t}\n\n \tstruct Variable{\n \t\tuint256 amount;\n \t\tuint256 marketId;\n \t\tuint256 outcome;\n \t}\n\n \tuint256 public totalNumMints;\n \tuint256 num_outcomes = 2; //TODO this is only for binary outcomes \n \tmapping(uint256=> Index_info) index_infos; //lockid to indiexinfo\n \tmapping(uint256 => Index) indexes; \n \tmapping(address=>uint256[]) address_to_id;\n\n \tconstructor()\n        ERC721(\"IndexCDS\", \"iCDS\"){\n\n        }\n  \n \t//TODO Call to amm factory\n \tfunction getPrice(address token) internal view returns(uint256){\n \t\treturn 1; \n \t}\n\n \t//TODO Returns the maximum return of this nft including and excluding longCDS tokens\n \tfunction getAPR(address holder) public view returns(uint256){\n \t\treturn 1; \n \t}\n\n \t// function curValue(address holder) public view returns(uint256){\n \t// \tuint256 lockID = address_to_id[holder]; \n \t// \taddress[] memory tokens_ = indexes[lockID].tokens; \n \t// \tuint256[] memory amounts = indexes[lockID].amounts; \n\n \t// \tuint256 num_tokens = tokens_.length;\n \t// \tuint256 price; \n \t// \tuint256 value;\n \t// //\tuint256[] memory prices; \n \t// \tfor (uint256 i=0; i< num_tokens; i++){ \n \t// \t\tprice = getPrice(tokens_[i]); \n \t// \t\tvalue = value + (price * amounts[i]); \n \t// \t}\n\n\n \t// }\n\n \t//Mints nft for current price of each cds \n \t//Token addresses are for CDS(sharetokens in marketfactory) tokens \n \tfunction mintIndex(address recipient,  bool from_recipient, \n \t\t\t\t\t   uint256[] memory prices,\n \t\t\t\t\t   uint256[] memory amounts, //this is token amount, not collateral\n \t\t\t\t\t   address[] memory tokens_addresses \n \t\t\t\t\t   ) internal returns(uint256){\n \t\tuint256 lockID = ++totalNumMints; \n\n \t\tuint256 num_tokens = prices.length;\n \t\tuint256 value; \n \t\tfor (uint256 i=0; i< num_tokens; i++){ \n \t\t\tvalue = value + (prices[i] * amounts[i]);\n\n \t\t\tif (from_recipient){\n \t\t\t\tOwnedERC20(tokens_addresses[i]).transferFrom(recipient, address(this), amounts[i]);\n \t\t\t}//else each sharetokens are already owned by this contract \n\n \t\t}\n\n \t\tIndex memory index = Index(value,amounts, tokens_addresses); \n \t\tindexes[lockID] = index; \n \t\taddress_to_id[recipient].push(lockID); \n\n\t\t_safeMint(recipient, lockID); \n\n\t\treturn lockID; \n\n\n \t}\n\n \t\n \tfunction redeemIndex(address recipient, uint256 lockID, bool from_recipient) internal {\n \t\t\n \t\tIndex memory index = indexes[lockID]; \n \t\tuint256 num_tokens = index.amounts.length;\n\n \t\tif (from_recipient){\n\t \t\tfor (uint256 i=0; i< num_tokens; i++){\n\t \t\t\tSafeERC20.safeTransfer(IERC20(index.tokens[i]), recipient, index.amounts[i]); \n\t \t\t}\n \t\t}\n\n \t\t_burn(lockID); \n \t\tdelete indexes[lockID]; \n\n\n } \t\n\n\n\n \tfunction getVariable(\n \t\tuint256[] memory marketIds, \n \t\tuint256[] memory outcomes, \n \t\tuint256[] memory amounts) internal returns(Variable[] memory){\n\n \t\tVariable[] memory variables = new Variable[](marketIds.length);\n \t\tfor (uint256 i=0; i< marketIds.length; i++){\n \t\t\tvariables[i] = Variable(amounts[i], marketIds[i], outcomes[i]); \t\t\t\n \t\t}\n \t\treturn variables; \n \t}\n\n \t//Public View Functions\n \tfunction getUserLockId(address user) public view returns(uint256[] memory){\n \t\treturn address_to_id[user];\n \t}\n\n \t// function getUserIndexInfo(address user) public view returns(Index_info memory){\n \t// \tuint256[] memory lockId = address_to_id[user]; \n \t// \treturn index_infos[lockId];\n \t// }\n\n \t// function getUserCDSBalance() public view returns(uint256[] memory){\n \t// \tuint256[] memory lockIds = address_to_id[user]; //nfts that this user has \n\n\n \t// \tIndex memory index = indexes[lockId]; \n \t// \taddress[] memory tokens = index.tokens; \n \t// \tuint256[] memory balance; \n \t// \tfor (i=0; i< tokens.length; i++){\n \t// \t\tbalance[i] = tokens[i].balanceOf(address(this)); \n\n \t// \t}\n \t// \treturn balance; \n \t// }\n\n \tfunction getUserTotalBalance(address user) public view returns(Index_info[] memory){\n \t\tuint256[] memory lockIds = address_to_id[user];\n \t\tIndex_info[] memory user_infos = new Index_info[](lockIds.length);\n \t\tfor (uint256 i=0; i<lockIds.length; i++){\n \t\t\tuser_infos[i] = index_infos[lockIds[i]]; \n \t\t}\n\n \t\treturn user_infos; \n\n \t}\n\n\n\n \t//State Changing Functions\n\n\n \t/* This is the function called by contract calls, it first transfers the DS\n \tfrom the msg.sender to this contract, and this contract will buy all the sharetokens\n \tin behalf. It will then mint the nft and give it back to msg.sender\n \tdoes the minting nft as well.\n \tUser gives collateral to this contract, this contract buys sharetokens + mints nft and gives back\n \t*/\n \tfunction buyBulk(address recipient,  \n \t\taddress marketFactoryAddress, \n \t\taddress ammFactoryAddress, \n \t\tuint256[] memory marketIds,\n \t\tuint256[] memory outcomes, \n \t\tuint256[] memory amounts) external returns(uint256){\n\n \t\tuint256 num_buys = marketIds.length; \n \t\tAMMFactory amm = AMMFactory(ammFactoryAddress); \n \t\tAbstractMarketFactoryV3 marketFactory = AbstractMarketFactoryV3(marketFactoryAddress);\n \t\tIERC20 collateral = marketFactory.collateral(); //DS\n\n \t\tuint256[] memory prices = new uint256[](num_buys); \n \t\tuint256[] memory token_amounts = new uint256[](num_buys); \n \t\taddress[] memory outcometokens = new address[](num_buys); \n\n \t\tVariable[] memory variable = getVariable(marketIds, outcomes, amounts);\n \t\t//Iterate over all chosen markets \n \t\tfor (uint256 i=0; i<num_buys; i++){\n \t\t\t//Should transfer collateral all at once to save gas \n \t\t\t//This allows this contract to now have the sharetokens for each outcome \n\n \t\t\ttoken_amounts[i] = executeBuy(marketFactory,amm,\n \t\t\t collateral, msg.sender, variable[i]); \n\n \t\t\toutcometokens[i] = getOutcomeToken(marketFactory,variable[i]);\n \t\t\tprices[i] = getPrice(outcometokens[i]); //TODO find how to calculate prices \n\n \t\t}\n\n \t\tuint256 lockId = mintIndex(msg.sender,false, prices, token_amounts, outcometokens  );\n \t\tindex_infos[lockId] = Index_info(token_amounts, marketIds, outcomes, lockId);\n \t\t\n \t\treturn lockId;\n \t}\n\n \tfunction getOutcomeToken(AbstractMarketFactoryV3 marketFactory,\n \t\tVariable memory variable ) internal returns(address){\n \t\tAbstractMarketFactoryV3.Market memory _market =  marketFactory.getMarket(variable.marketId); \n\n \t\treturn address(_market.shareTokens[variable.outcome]); \n \t}\n\n \tfunction executeBuy(AbstractMarketFactoryV3 marketFactory, \n \t\tAMMFactory amm, \n \t\tIERC20 collateral, \n \t\taddress recipient, \n \t\tVariable memory variable) internal returns(uint256){\n\n\n \t\tcollateral.transferFrom(recipient, address(this), variable.amount); \n \t\tcollateral.approve(address(amm), variable.amount); \n\n \t\treturn amm.buy(marketFactory, variable.marketId,\n \t\t\tvariable.outcome,variable.amount, 0);\n \t}\n\n\n \t//User gives id of its NFT to this contract, it then burns the NFT and sell the underlying tokens, \n \t//and gives the collateral back to the user. For now it will sell all tokens and give the collateral\n \t//for all tokens back. Users will have to rebuy if they want to just get rid of one token \n \tfunction sellBulk(address recipient, \n \t\tuint256 lockID, \n \t\taddress marketFactoryAddress, \n \t\taddress ammFactoryAddress) external {\n\n \t\tAMMFactory amm = AMMFactory(ammFactoryAddress); \n \t\tAbstractMarketFactoryV3 marketFactory = AbstractMarketFactoryV3(marketFactoryAddress);\n \t\tIERC20 collateral = marketFactory.collateral(); \n\n \t\tIndex_info memory info = index_infos[lockID]; \n\n \t\tuint256[] memory shareTokensIn = new uint256[](num_outcomes); \n \t\tuint256 total_collateral_out = 0; \n \t\tuint256 num_sells = info.marketIds.length; \n\n\n \t\tfor (uint256 i=0; i< num_sells; i++){\n\n \t\t\tfor(uint256 j=0; j<num_outcomes; j++){\n \t\t\t\t//outcome[i] is 0 or 1 (if it is binary)\n \t\t\t\t//0 if outcome[i] != j, info.token_amounts[i] otherwise\n \t\t\t\t//bool isZero = (info.outcomes[i] != j);\n \t\t\t\t//shareTokensIn[j] = isZero ? 0: info.token_amounts[i];\n \t\t\t\tshareTokensIn[j] = info.token_amounts[i];\n \t\t\t}\n \t\t\t//need to approve amm for the sharetokens; \n \t\t\tsell_approve(marketFactory, amm, info.marketIds[i], info.outcomes[i], shareTokensIn); \n\n \t\t\ttotal_collateral_out = total_collateral_out + amm.sellForCollateral(\n \t\t\t\tmarketFactory, \n \t\t\t\tinfo.marketIds[i],\n \t\t\t\tinfo.outcomes[i], \n \t\t\t\tshareTokensIn, \n \t\t\t\t0);\n \t\t\t//Now this contract holds the collateral, so should give it back to msg.sender\n \t\t}\n\n \t\tredeemIndex( recipient,  lockID,  false); \n \t\tcollateral.transfer(msg.sender, total_collateral_out ); \n\n\n\n \t}\n\n \tfunction sell_approve(AbstractMarketFactoryV3 marketFactory, \n \t\tAMMFactory amm ,\n \t\tuint256 marketId, \n \t\tuint256 outcome, \n \t\tuint256[] memory shareTokensIn ) private {\n \t\trequire(shareTokensIn[outcome] > 0); \n \t\t AbstractMarketFactoryV3.Market memory _market = marketFactory.getMarket(marketId);\n \t\t _market.shareTokens[outcome].approve(address(amm), shareTokensIn[outcome]); \n \t}\n\n\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./extensions/IERC721Metadata.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/Strings.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: address zero is not a valid owner\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: invalid token ID\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not token owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner nor approved\");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), \"ERC721: invalid token ID\");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/vaults/vault_tranche/tVault.sol": {
      "content": "pragma solidity ^0.8.4;\n\n\nimport {Auth} from \"../auth/Auth.sol\";\nimport {ERC4626} from \"../mixins/ERC4626.sol\";\n\nimport {SafeCastLib} from \"../utils/SafeCastLib.sol\";\nimport {SafeTransferLib} from \"../utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"../utils/FixedPointMathLib.sol\";\n\nimport {ERC20} from \"../tokens/ERC20.sol\";\nimport {Instrument} from \"../instrument.sol\";\nimport {Vault} from \"../vault.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {TrancheFactory} from \"./tranchemaster.sol\"; \nimport \"hardhat/console.sol\";\n\n/// @notice super vault that accepts any combinations of ERC4626 instruments at initialization, and will\n/// automatically invest/divest when minting/redeeming \n/// @dev instance is generated for every splitter\ncontract tVault is ERC4626{\n\tusing SafeCastLib for uint256; \n  using SafeTransferLib for ERC20;\n  using FixedPointMathLib for uint256;\n\n  uint256 num_instrument; \n  uint256[] ratios; \n  address[] instruments; \n  uint256 init_time; \n  uint256 junior_weight; \n  uint256 promisedReturn; \n  uint256 time_to_maturity; \n  ERC20 want; \n\n  mapping(address=>uint256) addressToIndex; \n\n  uint256[] initial_exchange_rates; \n\n  uint256 public PRICE_PRECISION; \n\n  /// @notice when intialized, will take in a few ERC4626 instruments (address) as base instruments\n  /// param _want is the base assets for all the instruments e.g usdc\n  /// param _instruments are ERC4626 addresses that will comprise this super vault\n  /// param _ratios are the weight of value invested for each instruments, should sum to 1 \n  /// param _junior_weight is the allocation between junior/senior tranche (senior is 1-junior)\n  /// param _time_to_maturity is time until the tranche tokens redemption price will be determined\n  /// and tranche tokens can be redeemed separately \n  /// param _promisedReturn is the promised senior return gauranteed by junior holders \n  constructor(\n    TrancheFactory.InitParams memory param)\n    ERC4626(\n        ERC20(param._want),\n        string(abi.encodePacked(\"super \", ERC20(param._want).name(), \" Vault\")),\n        string(abi.encodePacked(\"t\", ERC20(param._want).symbol()))\n    )  \n\t//Vault(address(_want))\n{\n    want = ERC20(param._want); \n    instruments = param._instruments; \n    num_instrument = param._instruments.length; \n    ratios = param._ratios; \n    junior_weight = param._junior_weight; \n    promisedReturn = param._promisedReturn; \n    time_to_maturity = param._time_to_maturity; \n    init_time = block.timestamp; \n\n    initial_exchange_rates = new uint[](num_instrument); \n    PRICE_PRECISION = 10**want.decimals(); \n\n    //need to get initial exchange rate between the instruments and want \n    for (uint i=0; i< num_instrument; i++){\n        addressToIndex[instruments[i]] = i; \n        initial_exchange_rates[i] = get_exchange_rate(instruments[i]); \n    }\n  }\n\n\n  /// @notice get the amount of shares for the instrument one would obtain\n  /// by depositing one want token \n  function get_exchange_rate(address instrument) internal view returns(uint256){\n  \treturn ERC4626(instrument).previewDeposit(PRICE_PRECISION); \n  }\n\n  /// @notice will automatically invest into the ERC4626 instruments and give out \n  /// vault tokens as share\n  function mint(uint256 shares, address receiver) public override returns(uint assets)  {\n    assets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\n    console.log('here', msg.sender);\n\n    asset.safeTransferFrom(msg.sender, address(this), assets);\n    console.log('assets', assets, shares); \n    invest(shares); \n\n    _mint(receiver, shares);\n    emit Deposit(msg.sender, receiver, assets, shares);\n    afterDeposit(assets, shares);\n\n  }\n\n\n  /// @notice will automatically divest from the instruments\n  function redeem(\n    uint256 shares,\n    address receiver,\n    address owner\n) public override returns(uint assets){\n    if (msg.sender != owner) {\n        uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n    }\n\n    // Check for rounding error since we round down in previewRedeem.\n    require((assets = previewRedeem(shares)) != 0, \"ZERO_ASSETS\");\n    divest(assets); \n\n    beforeWithdraw(assets, shares);\n    _burn(owner, shares);\n    emit Withdraw(msg.sender, receiver, owner, assets, shares);\n    asset.safeTransfer(receiver, assets);\n\n  }\n\n  /// @notice will invest into the current instruments, which is equivalent to minting erc4626\n  /// @param shares are denominated in vault token, in PRICE_PRECISION\n  function invest(uint256 shares) internal {\n  \t\n  \tuint num_asset_for_this; \n  \tfor (uint i=0; i< num_instrument; i++){\n  \t\tnum_asset_for_this = ERC4626(instruments[i]).convertToAssets((shares*ratios[i])/PRICE_PRECISION);  \n      asset.safeApprove(instruments[i], num_asset_for_this); \n      uint a = asset.balanceOf(address(this));\n      console.log('balance',a, ratios[0]); \n      console.log('shares', num_asset_for_this, shares); \n  \t\tuint receivedShares = ERC4626(instruments[i]).deposit(num_asset_for_this, address(this)); //will mint the instrument to this contract\n  \t}\n  }\n\n  /// @notice will divest from current instruments, which is equivalent to redeeming erc4626\n  /// @param assets are denominated in underlying token\n  function divest(uint256 assets) internal{\n  \tuint num_assets_for_this; \n  \tfor (uint i=0; i< num_instrument; i++){\n  \t\tnum_assets_for_this = (assets* ratios[i]/PRICE_PRECISION); \n  \t\tERC4626(instruments[i]).withdraw(num_assets_for_this, address(this), address(this)); \n  \t}\n\n  }\n\n\n  function isMatured() public view returns(bool){\n  \treturn (block.timestamp - init_time) > time_to_maturity; \n  }\n\n  function getUnderlying() public view returns(address){\n  \treturn address(want); \n  }\n\n  function getJuniorWeight() public view returns(uint256){\n  \treturn junior_weight; \n  }\n\n  function getPromisedReturn() public view returns(uint256){\n  \treturn promisedReturn; \n  }\n  function getInitialExchangeRates() public view returns(uint[] memory){\n      return initial_exchange_rates; \n  }\n\n  /// @notice get average real returns collected by the vault in this supervault until now  \n  /// real return is computed by (final_value_of_vault/initial_value_of_vault) - 1\n  function getCurrentRealReturn() public view returns(uint256){\n  \tuint256[] memory real_returns = new uint256[](num_instrument); \n  \tuint256 sum_return; \n  \tfor (uint i=0; i< num_instrument; i++){\n  \t\treal_returns[i] = (get_exchange_rate(instruments[i])/initial_exchange_rates[i])*PRICE_PRECISION;\n  \t\tsum_return += real_returns[i] - PRICE_PRECISION; \n\t}\n\n\treturn (sum_return/num_instrument); \n\t\n  }\n\n  /// @notice sums over all assets in want tokens \n  function totalAssets() public view override returns (uint256){\n    uint sumAssets; \n    for (uint i=0; i< num_instrument; i++){\n        sumAssets += ERC4626(instruments[i]).totalAssets(); \n    }\n    return sumAssets; \n\n  }\n\n\n \n\n}\n"
    },
    "contracts/vaults/auth/Auth.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Provides a flexible and updatable auth pattern which is completely separate from application logic.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Auth.sol)\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)\nabstract contract Auth {\n    event OwnerUpdated(address indexed user, address indexed newOwner);\n\n    event AuthorityUpdated(address indexed user, Authority indexed newAuthority);\n\n    address public owner;\n\n    Authority public authority;\n    mapping(address=>bool) Authorized; \n\n    constructor(address _owner) {\n        owner = _owner;\n\n        emit OwnerUpdated(msg.sender, _owner);\n    }\n\n    modifier requiresAuth() virtual {\n        require(isAuthorized(msg.sender, msg.sig), \"UNAUTHORIZED\");\n\n        _;\n    }\n\n    function isAuthorized(address user, bytes4 functionSig) internal view virtual returns (bool) {\n        //Authority auth = authority; // Memoizing authority saves us a warm SLOAD, around 100 gas.\n\n        // Checking if the caller is the owner only after calling the authority saves gas in most cases, but be\n        // aware that this makes protected functions uncallable even to the owner if the authority is out of order.\n        return(user == owner || Authorized[user]);\n        //return (address(auth) != address(0) && auth.canCall(user, address(this), functionSig)) || user == owner;\n    }\n\n    function setNewAuthority(address newAuthority) public {\n        require(msg.sender == owner );\n        Authorized[newAuthority] = true; \n\n    }\n\n    function setAuthority(Authority newAuthority) public virtual {\n        // We check if the caller is the owner first because we want to ensure they can\n        // always swap out the authority even if it's reverting or using up a lot of gas.\n        require(msg.sender == owner || authority.canCall(msg.sender, address(this), msg.sig));\n\n        authority = newAuthority;\n\n        emit AuthorityUpdated(msg.sender, newAuthority);\n    }\n\n    function setOwner(address newOwner) public virtual requiresAuth {\n        owner = newOwner;\n\n        emit OwnerUpdated(msg.sender, newOwner);\n    }\n}\n\n/// @notice A generic interface for a contract which provides authorization data to an Auth instance.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Auth.sol)\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)\ninterface Authority {\n    function canCall(\n        address user,\n        address target,\n        bytes4 functionSig\n    ) external view returns (bool);\n}\n"
    },
    "contracts/vaults/mixins/ERC4626.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"../tokens/ERC20.sol\";\n// import {ERC20} from \"../../ERC20/ERC20.sol\";\nimport \"hardhat/console.sol\";\nimport {SafeTransferLib} from \"../utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"../utils/FixedPointMathLib.sol\";\n\n/// @notice Minimal ERC4626 tokenized Vault implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/mixins/ERC4626.sol)\nabstract contract ERC4626 is ERC20 {\n    using SafeTransferLib for ERC20;\n    using FixedPointMathLib for uint256;\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Deposit(address indexed caller, address indexed owner, uint256 assets, uint256 shares);\n\n    event Withdraw(\n        address indexed caller,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /*//////////////////////////////////////////////////////////////\n                               IMMUTABLES\n    //////////////////////////////////////////////////////////////*/\n\n    ERC20 public immutable asset;\n\n    constructor(\n        ERC20 _asset,\n        string memory _name,\n        string memory _symbol\n    ) ERC20(_name, _symbol, _asset.decimals()) {\n        asset = _asset;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        DEPOSIT/WITHDRAWAL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function deposit(uint256 assets, address receiver) public virtual returns (uint256 shares) {\n        // Check for rounding error since we round down in previewDeposit.\n        require((shares = previewDeposit(assets)) != 0, \"ZERO_SHARES\");\n\n        // Need to transfer before minting or ERC777s could reenter.\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        afterDeposit(assets, shares);\n    }\n\n    function mint(uint256 shares, address receiver) public virtual returns (uint256 assets) {\n        assets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\n\n        // Need to transfer before minting or ERC777s could reenter.\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n   \n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        afterDeposit(assets, shares);\n    }\n\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public virtual returns (uint256 shares) {\n        shares = previewWithdraw(assets); // No need to check for rounding error, previewWithdraw rounds up.\n\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        beforeWithdraw(assets, shares);\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        asset.safeTransfer(receiver, assets);\n    }\n\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public virtual returns (uint256 assets) {\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        // Check for rounding error since we round down in previewRedeem.\n        require((assets = previewRedeem(shares)) != 0, \"ZERO_ASSETS\");\n\n        beforeWithdraw(assets, shares);\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        asset.safeTransfer(receiver, assets);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function totalAssets() public view virtual returns (uint256);\n\n    function convertToShares(uint256 assets) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());\n    }\n\n    function convertToAssets(uint256 shares) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? shares : shares.mulDivDown(totalAssets(), supply);\n    }\n\n    function previewDeposit(uint256 assets) public view virtual returns (uint256) {\n        return convertToShares(assets);\n    }\n\n    function previewMint(uint256 shares) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? shares : shares.mulDivUp(totalAssets(), supply);\n    }\n\n    function previewWithdraw(uint256 assets) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? assets : assets.mulDivUp(supply, totalAssets());\n    }\n\n    function previewRedeem(uint256 shares) public view virtual returns (uint256) {\n        return convertToAssets(shares);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                     DEPOSIT/WITHDRAWAL LIMIT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function maxDeposit(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function maxMint(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function maxWithdraw(address owner) public view virtual returns (uint256) {\n        return convertToAssets(balanceOf[owner]);\n    }\n\n    function maxRedeem(address owner) public view virtual returns (uint256) {\n        return balanceOf[owner];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          INTERNAL HOOKS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function beforeWithdraw(uint256 assets, uint256 shares) internal virtual {}\n\n    function afterDeposit(uint256 assets, uint256 shares) internal virtual {}\n}\n"
    },
    "contracts/vaults/utils/SafeCastLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Safe unsigned integer casting library that reverts on overflow.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeCastLib.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeCast.sol)\nlibrary SafeCastLib {\n    function safeCastTo248(uint256 x) internal pure returns (uint248 y) {\n        require(x < 1 << 248);\n\n        y = uint248(x);\n    }\n\n    function safeCastTo224(uint256 x) internal pure returns (uint224 y) {\n        require(x < 1 << 224);\n\n        y = uint224(x);\n    }\n\n    function safeCastTo192(uint256 x) internal pure returns (uint192 y) {\n        require(x < 1 << 192);\n\n        y = uint192(x);\n    }\n\n    function safeCastTo160(uint256 x) internal pure returns (uint160 y) {\n        require(x < 1 << 160);\n\n        y = uint160(x);\n    }\n\n    function safeCastTo128(uint256 x) internal pure returns (uint128 y) {\n        require(x < 1 << 128);\n\n        y = uint128(x);\n    }\n\n    function safeCastTo96(uint256 x) internal pure returns (uint96 y) {\n        require(x < 1 << 96);\n\n        y = uint96(x);\n    }\n\n    function safeCastTo64(uint256 x) internal pure returns (uint64 y) {\n        require(x < 1 << 64);\n\n        y = uint64(x);\n    }\n\n    function safeCastTo32(uint256 x) internal pure returns (uint32 y) {\n        require(x < 1 << 32);\n\n        y = uint32(x);\n    }\n\n    function safeCastTo24(uint256 x) internal pure returns (uint24 y) {\n        require(x < 1 << 24);\n\n        y = uint24(x);\n    }\n\n    function safeCastTo8(uint256 x) internal pure returns (uint8 y) {\n        require(x < 1 << 8);\n\n        y = uint8(x);\n    }\n}\n"
    },
    "contracts/vaults/utils/SafeTransferLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"../tokens/ERC20.sol\";\n\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\nlibrary SafeTransferLib {\n    /*//////////////////////////////////////////////////////////////\n                             ETH OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferETH(address to, uint256 amount) internal {\n        bool success;\n\n        assembly {\n            // Transfer the ETH and store if it succeeded or not.\n            success := call(gas(), to, amount, 0, 0, 0, 0)\n        }\n\n        require(success, \"ETH_TRANSFER_FAILED\");\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ERC20 OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferFrom(\n        ERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), from) // Append the \"from\" argument.\n            mstore(add(freeMemoryPointer, 36), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\n            )\n        }\n\n        require(success, \"TRANSFER_FROM_FAILED\");\n    }\n\n    function safeTransfer(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        require(success, \"TRANSFER_FAILED\");\n    }\n\n    function safeApprove(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        require(success, \"APPROVE_FAILED\");\n    }\n}\n"
    },
    "contracts/vaults/utils/FixedPointMathLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Arithmetic library with operations for fixed-point numbers.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\nlibrary FixedPointMathLib {\n    /*//////////////////////////////////////////////////////////////\n                    SIMPLIFIED FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\n\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\n    }\n\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\n    }\n\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\n    }\n\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                    LOW LEVEL FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function mulDivDown(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        assembly {\n            // Store x * y in z for now.\n            z := mul(x, y)\n\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\n                revert(0, 0)\n            }\n\n            // Divide z by the denominator.\n            z := div(z, denominator)\n        }\n    }\n\n    function mulDivUp(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        assembly {\n            // Store x * y in z for now.\n            z := mul(x, y)\n\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\n                revert(0, 0)\n            }\n\n            // First, divide z - 1 by the denominator and add 1.\n            // We allow z - 1 to underflow if z is 0, because we multiply the\n            // end result by 0 if z is zero, ensuring we return 0 if z is zero.\n            z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))\n        }\n    }\n\n    function rpow(\n        uint256 x,\n        uint256 n,\n        uint256 scalar\n    ) internal pure returns (uint256 z) {\n        assembly {\n            switch x\n            case 0 {\n                switch n\n                case 0 {\n                    // 0 ** 0 = 1\n                    z := scalar\n                }\n                default {\n                    // 0 ** n = 0\n                    z := 0\n                }\n            }\n            default {\n                switch mod(n, 2)\n                case 0 {\n                    // If n is even, store scalar in z for now.\n                    z := scalar\n                }\n                default {\n                    // If n is odd, store x in z for now.\n                    z := x\n                }\n\n                // Shifting right by 1 is like dividing by 2.\n                let half := shr(1, scalar)\n\n                for {\n                    // Shift n right by 1 before looping to halve it.\n                    n := shr(1, n)\n                } n {\n                    // Shift n right by 1 each iteration to halve it.\n                    n := shr(1, n)\n                } {\n                    // Revert immediately if x ** 2 would overflow.\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\n                    if shr(128, x) {\n                        revert(0, 0)\n                    }\n\n                    // Store x squared.\n                    let xx := mul(x, x)\n\n                    // Round to the nearest number.\n                    let xxRound := add(xx, half)\n\n                    // Revert if xx + half overflowed.\n                    if lt(xxRound, xx) {\n                        revert(0, 0)\n                    }\n\n                    // Set x to scaled xxRound.\n                    x := div(xxRound, scalar)\n\n                    // If n is even:\n                    if mod(n, 2) {\n                        // Compute z * x.\n                        let zx := mul(z, x)\n\n                        // If z * x overflowed:\n                        if iszero(eq(div(zx, x), z)) {\n                            // Revert if x is non-zero.\n                            if iszero(iszero(x)) {\n                                revert(0, 0)\n                            }\n                        }\n\n                        // Round to the nearest number.\n                        let zxRound := add(zx, half)\n\n                        // Revert if zx + half overflowed.\n                        if lt(zxRound, zx) {\n                            revert(0, 0)\n                        }\n\n                        // Return properly scaled zxRound.\n                        z := div(zxRound, scalar)\n                    }\n                }\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        GENERAL NUMBER UTILITIES\n    //////////////////////////////////////////////////////////////*/\n\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\n        assembly {\n            // Start off with z at 1.\n            z := 1\n\n            // Used below to help find a nearby power of 2.\n            let y := x\n\n            // Find the lowest power of 2 that is at least sqrt(x).\n            if iszero(lt(y, 0x100000000000000000000000000000000)) {\n                y := shr(128, y) // Like dividing by 2 ** 128.\n                z := shl(64, z) // Like multiplying by 2 ** 64.\n            }\n            if iszero(lt(y, 0x10000000000000000)) {\n                y := shr(64, y) // Like dividing by 2 ** 64.\n                z := shl(32, z) // Like multiplying by 2 ** 32.\n            }\n            if iszero(lt(y, 0x100000000)) {\n                y := shr(32, y) // Like dividing by 2 ** 32.\n                z := shl(16, z) // Like multiplying by 2 ** 16.\n            }\n            if iszero(lt(y, 0x10000)) {\n                y := shr(16, y) // Like dividing by 2 ** 16.\n                z := shl(8, z) // Like multiplying by 2 ** 8.\n            }\n            if iszero(lt(y, 0x100)) {\n                y := shr(8, y) // Like dividing by 2 ** 8.\n                z := shl(4, z) // Like multiplying by 2 ** 4.\n            }\n            if iszero(lt(y, 0x10)) {\n                y := shr(4, y) // Like dividing by 2 ** 4.\n                z := shl(2, z) // Like multiplying by 2 ** 2.\n            }\n            if iszero(lt(y, 0x8)) {\n                // Equivalent to 2 ** z.\n                z := shl(1, z)\n            }\n\n            // Shifting right by 1 is like dividing by 2.\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n\n            // Compute a rounded down version of z.\n            let zRoundDown := div(x, z)\n\n            // If zRoundDown is smaller, use it.\n            if lt(zRoundDown, z) {\n                z := zRoundDown\n            }\n        }\n    }\n}\n"
    },
    "contracts/vaults/tokens/ERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\nabstract contract ERC20 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*//////////////////////////////////////////////////////////////\n                            METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*//////////////////////////////////////////////////////////////\n                            EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address => uint256) public nonces;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n}\n"
    },
    "contracts/vaults/instrument.sol": {
      "content": "\n// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.4;\n\nimport \"./vault.sol\";\nimport {ERC20} from \"./tokens/ERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"../prb/PRBMathUD60x18.sol\";\n\n\n/// @notice Minimal interface for Vault compatible strategies.\nabstract contract Instrument {\n\n    modifier onlyUtilizer() {\n        require(msg.sender == Utilizer, \"!Utilizer\");\n        _;\n    }\n\n    modifier onlyAuthorized() {\n        require(msg.sender == Utilizer || msg.sender == vault.owner(), \"!authorized\");\n        _;\n    }\n\n\n    ERC20 public underlying;\n    Vault public vault; \n    uint256 private constant MAX_UINT = 2**256 - 1;\n\n    /// @notice address of user who submits the liquidity proposal \n    address Utilizer; \n\n    /// @notice initializes a new Instrument \n    function _initialize(\n        address _vault,\n        address _Utilizer\n    ) internal {\n        vault = Vault(_vault);\n        underlying = ERC20(vault.UNDERLYING());\n        underlying.approve(_vault, MAX_UINT); // Give Vault unlimited access \n        Utilizer = _Utilizer;\n\n    }\n\n    /**\n     @notice hooks for approval logic that are specific to each instrument type, called by controller for approval/default logic\n     */\n    function onMarketApproval() virtual external;\n\n    /// called by anyone.\n    function checkStatus() virtual external;\n\n    function _resolveMarket(\n        bool atLoss,\n        uint256 extra_gain,\n        uint256 total_loss\n    ) internal {\n        vault.resolveMarket(atLoss, extra_gain, total_loss);\n    }\n\n\n    function setUtilizer(address _Utilizer) external onlyAuthorized {\n        require(_Utilizer != address(0));\n        Utilizer = _Utilizer;\n    }\n\n\n    /// @notice Withdraws a specific amount of underlying tokens from the Instrument.\n    /// @param amount The amount of underlying tokens to withdraw.\n    /// @return An error code, or 0 if the withdrawal was successful.\n    function redeemUnderlying(uint256 amount) external  returns (bool){\n        return underlying.transfer(address(vault), amount); \n    }\n\n    /// @notice Returns a user's Instrument balance in underlying tokens.\n    /// @param user The user to get the underlying balance of.\n    /// @return The user's Instrument balance in underlying tokens.\n    /// @dev May mutate the state of the Instrument by accruing interest.\n    function balanceOfUnderlying(address user) external view returns (uint256){\n        return underlying.balanceOf(user); \n        }\n}\n\n\n\n/// @notice Simple Instrument that provides USDC on stableswap 3pool \n// contract Curve3pool_Instrument is Instrument{\n\n//     /// @notice invests amount into Instrument \n//     function invest(uint256 amount ) external \n//     //onlyGuardian \n//     {   \n//         require(this.balanceOfUnderlying(address(this)) >= amount);\n//         _invest(amount);  \n\n//     }\n\n//     function _invest(uint256 _amount) internal {\n\n//     }\n\n\n\n// }\n\n\n/// @notice Instrument that a) lends usdc fix rate at notional.finance and get zcb\n/// b) use that zcb as collateral to borrow fiat from fiatdao, c) swap fiat dao to usdc\n/// d) repeat\n// contract LeveragedFixedRate_Instrument is Instrument{\n\n// }\n\n// /// @notice Instrument that lends to risky collateral in fuse pools\n// contract RariLend_Instrument is Instrument{\n\n// }\n\n\n\n \n/// @notice Contract for unsecured loans, each instance will be associated to a borrower+marketId\n/// approved borrowers will interact with this contract to borrow, repay. \n/// and vault will supply principal and harvest principal/interest \ncontract CreditLine is Instrument {\n    using PRBMathUD60x18 for uint256;\n\n    //  variables initiated at creation\n    uint256  principal;\n    uint256  interestAPR; \n    uint256  faceValue; //total amount due, i.e principal+interest\n    uint256  duration; \n\n    // Modify-able Variables during repayments, borrow\n    uint256 totalOwed; \n    uint256 principalOwed; \n    uint256 interestOwed; \n    uint256 maturityDate;\n\n    constructor(\n        address vault,\n        address borrower, \n        uint256 _principal,\n        uint256 _interestAPR, \n        uint256 _duration,\n        uint256 _faceValue\n    ) public {\n        initialize(vault, borrower, _principal, _interestAPR, _duration, _faceValue);\n    }\n\n    /// @notice CreditLine contract is initiated at proposal \n    /// @dev include any Instrument specific initialization logic  \n    /// @param _borrower stored as Utilizer \n    function initialize(\n        address _vault,\n        address _borrower,         \n        uint256 _principal,\n        uint256 _interestAPR, \n        uint256 _duration, \n        uint256 _faceValue\n    ) internal {\n        _initialize(_vault, _borrower); \n\n        principal = _principal; \n        interestAPR = _interestAPR; \n        duration = _duration;   \n        faceValue = _faceValue; \n\n        interestOwed = faceValue - principal; // getOwedInterest(_interestAPR, _duration); \n    }\n\n    /// @notice use APR and duration to get total owed interest \n    function getOwedInterest(uint256 APR, uint256 duration) internal pure returns(uint256 owed){\n        return APR; \n    }\n\n    function getMaturityDate() external view returns (uint256 result) {\n        result = maturityDate;\n    }\n\n    function onMarketApproval() external override {\n        maturityDate = block.timestamp + duration;\n    }\n\n    /// @notice Allows a borrower to borrow on their creditline.\n    function drawdown(uint256 amount) external onlyUtilizer{\n        require(vault.isTrusted(this), \"Not approved\");\n        require(underlying.balanceOf(address(this)) > amount, \"Exceeds Credit\");\n        require(block.timestamp <= maturityDate, \"Instrument must not have matured\");\n        totalOwed += amount; \n        principalOwed += amount; \n        underlying.transfer(msg.sender, amount);\n    }\n\n    /// @notice allows a borrower to repay their loan\n    function repay(uint256 repay_principal, uint256 repay_interest) external onlyUtilizer{\n        require(vault.isTrusted(this), \"Not approved\");\n        require(block.timestamp <= maturityDate, \"Instrument must not have matured\");\n        underlying.transferFrom(msg.sender, address(this), repay_principal + repay_interest);\n        handleRepay(repay_principal, repay_interest); \n    }   \n\n    /// @notice updates balances after repayment\n    function handleRepay(uint256 repay_principal, uint256 repay_interest) internal {\n        totalOwed -= Math.min((repay_principal + repay_interest), totalOwed); \n        principalOwed -= Math.min(repay_principal, principalOwed);\n        interestOwed -= Math.min(repay_interest, interestOwed);\n    }\n\n    /**\n     @notice called by anyone to check if the loan is past maturity\n     */\n    function checkStatus() external override {\n        if (maturityDate >= block.timestamp) {\n            \n            if (principalOwed == 0 && interestOwed == 0) {\n                _resolveMarket(false, 0, 0);\n            } else if (principalOwed > 0 || interestOwed > 0) {\n                _resolveMarket(true, 0, principalOwed + interestOwed);\n            }\n        }\n    }\n}\n\n\n\n\n\n"
    },
    "contracts/vaults/vault.sol": {
      "content": "pragma solidity ^0.8.4;\n\nimport {Auth} from \"./auth/Auth.sol\";\nimport {ERC4626} from \"./mixins/ERC4626.sol\";\n\nimport {SafeCastLib} from \"./utils/SafeCastLib.sol\";\nimport {SafeTransferLib} from \"./utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"./utils/FixedPointMathLib.sol\";\n\nimport {ERC20} from \"./tokens/ERC20.sol\";\nimport {Instrument} from \"./instrument.sol\";\nimport {Controller} from \"../stablecoin/controller.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\n\ncontract Vault is ERC4626, Auth{\n\tusing SafeCastLib for uint256; \n    using SafeTransferLib for ERC20;\n    using FixedPointMathLib for uint256;\n\n\n    event InstrumentDeposit(address indexed user, Instrument indexed instrument, uint256 underlyingAmount);\n    event InstrumentWithdrawal(address indexed user, Instrument indexed instrument, uint256 underlyingAmount);\n    event InstrumentTrusted(address indexed user, Instrument indexed instrument);\n    event InstrumentDistrusted(address indexed user, Instrument indexed instrument);\n\n    /*///////////////////////////////////////////////////////////////\n                                 CONSTANTS\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal BASE_UNIT;\n    uint256 totalInstrumentHoldings; //total holdings deposited into all Instruments \n    ERC20 public immutable UNDERLYING;\n    Controller private controller;\n\n    mapping(Instrument => InstrumentData) public getInstrumentData;\n    mapping(address => uint256) public  num_proposals;\n    mapping(uint256=> Instrument) Instruments; //marketID-> Instrument\n\n    enum InstrumentType {\n        CreditLine,\n        Other\n    }\n\n    /// @param trusted Whether the Instrument is trusted.\n    /// @param balance The amount of underlying tokens held in the Instrument.\n    struct InstrumentData {\n        // Used to determine if the Vault will operate on a Instrument.\n        bool trusted;\n        // Balance of the contract denominated in Underlying, \n        // used to determine profit and loss during harvests of the Instrument.  \n        // represents the amount of debt the Instrument has incurred from this vault   \n        uint248 balance; // in underlying\n        uint256 faceValue; // in underlying\n        uint256 marketId;\n    \tuint256 principal; //this is total available allowance in underlying\n        uint256 expectedYield; // total interest paid over duration in underlying\n        uint256 duration;\n        string description;\n        address Instrument_address;\n        InstrumentType instrument_type;\n    }\n\n    constructor(\n        address _UNDERLYING,\n        address _controller\n    )\n        ERC4626(\n            ERC20(_UNDERLYING),\n            string(abi.encodePacked(\"debita \", ERC20(_UNDERLYING).name(), \" Vault\")),\n            string(abi.encodePacked(\"db\", ERC20(_UNDERLYING).symbol()))\n        )  Auth(msg.sender)\n\n    {\n        UNDERLYING = ERC20(_UNDERLYING);\n        BASE_UNIT = 10**ERC20(_UNDERLYING).decimals();\n        controller = Controller(_controller);\n\n        //totalSupply = type(uint256).max;\n    }\n    \n    modifier onlyController(){\n        require(address(controller) == msg.sender || msg.sender == owner ,  \"is not controller\"); \n        _;\n    }\n\n    /// @notice called by controller at maturity \n    function controller_burn(uint256 amount, address bc_address) external onlyController {\n        _burn(bc_address,amount); \n    }\n    /// @notice called by controller at maturity, since redeem amount > balance in bc\n    function controller_mint(uint256 amount, address to) external onlyController {\n        _mint(to , amount); \n    }\n\n\n\n    /// @notice Harvest a trusted Instrument, records profit/loss \n    function harvest(Instrument instrument) external requiresAuth {\n        require(getInstrumentData[instrument].trusted, \"UNTRUSTED_Instrument\");\n    \tuint256 oldTotalInstrumentHoldings = totalInstrumentHoldings; \n        uint256 balanceLastHarvest = getInstrumentData[instrument].balance;\n        uint256 balanceThisHarvest = instrument.balanceOfUnderlying(address(instrument));\n        \n        getInstrumentData[instrument].balance = balanceThisHarvest.safeCastTo248();\n        uint256 profit = balanceThisHarvest - balanceLastHarvest; \n\n        totalInstrumentHoldings = oldTotalInstrumentHoldings + profit; \n\n    }\n\n    /// @notice Deposit a specific amount of float into a trusted Instrument.\n   \t/// Called when market is approved. \n   \t/// Also has the role of granting a credit line to a credit-based Instrument like uncol.loans \n    function depositIntoInstrument(Instrument instrument, uint256 underlyingAmount) external requiresAuth{\n    \trequire(getInstrumentData[instrument].trusted, \"UNTRUSTED Instrument\");\n    \ttotalInstrumentHoldings += underlyingAmount; \n\n        getInstrumentData[instrument].balance += underlyingAmount.safeCastTo248();\n\n        UNDERLYING.transfer(address(instrument), underlyingAmount);\n        emit InstrumentDeposit(msg.sender, instrument, underlyingAmount);\n\n    }\n\n    /// @notice Withdraw a specific amount of underlying tokens from a Instrument.\n    function withdrawFromInstrument(Instrument instrument, uint256 underlyingAmount) external requiresAuth{\n    \trequire(getInstrumentData[instrument].trusted, \"UNTRUSTED Instrument\");\n        getInstrumentData[instrument].balance -= underlyingAmount.safeCastTo248();\n        totalInstrumentHoldings -= underlyingAmount;\n        require(instrument.redeemUnderlying(underlyingAmount), \"REDEEM_FAILED\");\n        emit InstrumentWithdrawal(msg.sender, instrument, underlyingAmount);\n\n    }\n\n\n    /// @notice Withdraws all underyling balance from the Instrument to the vault \n    function withdrawAllFromInstrument(Instrument instrument) external requiresAuth{\n    \tuint248 total_Instrument_balance = instrument.balanceOfUnderlying(address(instrument)).safeCastTo248();\n    \tuint248 current_balance =  getInstrumentData[instrument].balance;\n    \tgetInstrumentData[instrument].balance -= Math.min(total_Instrument_balance, current_balance).safeCastTo248();\n    \tinstrument.redeemUnderlying(total_Instrument_balance);\n\n    }\n\n    /// @notice Stores a Instrument as trusted when its approved\n    function trustInstrument(Instrument instrument) external requiresAuth{\n    \tgetInstrumentData[instrument].trusted = true;\n\n    }\n\n    /// @notice Stores a Instrument as untrusted\n    function distrustInstrument(Instrument instrument) external requiresAuth{\n    \tgetInstrumentData[instrument].trusted = false; \n    }\n\n\n    /// @notice returns true if Instrument is approved\n    function isTrusted(Instrument instrument) public view returns(bool){\n    \treturn getInstrumentData[instrument].trusted; \n    }\n\n    /// @notice Calculates the total amount of underlying tokens the Vault holds, excluding profit \n    function totalAssets() public view override returns(uint256){\n    \treturn totalInstrumentHoldings + totalFloat();\n    }\n\n   \t\n    function totalFloat() public view returns (uint256) {\n        return UNDERLYING.balanceOf(address(this));\n    }\n\n    function fetchInstrumentData(uint256 marketId) public view returns(InstrumentData memory){\n        return getInstrumentData[Instruments[marketId]];\n    }\n\n    function onMarketApproval(uint256 marketId) external requiresAuth {\n        Instruments[marketId].onMarketApproval();\n    }\n\n    /// @notice add instrument proposal created by the Utilizer \n    /// @dev Instrument instance should be created before this is called \n    function addProposal(\n        InstrumentData memory data\n    ) external {\n        require(data.principal > 0, \"principal must be greater than 0\");\n        require(data.duration > 0, \"duration must be greater than 0\");\n        require(data.faceValue > 0, \"faceValue must be greater than 0\");\n        require(data.principal >= BASE_UNIT, \"Needs to be in decimal format\"); // should be collateral address, not DS. Can't be less than 1.0 X?\n   \n\n        num_proposals[msg.sender] ++; \n        getInstrumentData[Instrument(data.Instrument_address)] = (\n        \tInstrumentData(\n        \t\tfalse, \n                0, \n                data.faceValue, \n                data.marketId, \n                data.principal, \n                data.expectedYield, \n                data.duration, \n                data.description, \n                data.Instrument_address,\n                data.instrument_type\n            )\n        \t); \n\n        Instruments[data.marketId] = Instrument(data.Instrument_address);\n    }\n\n    /**\n     @notice called by instrument on resolution\n     */\n    function resolveMarket(\n        bool atLoss,\n        uint256 extra_gain,\n        uint256 total_loss\n    ) external {\n        require(getInstrumentData[Instrument(msg.sender)].marketId != 0, \"caller is not active instrument\");\n        controller.resolveMarket(getInstrumentData[Instrument(msg.sender)].marketId, atLoss, extra_gain, total_loss);\n    }\n}"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. It the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`.\n        // We also know that `k`, the position of the most significant bit, is such that `msb(a) = 2**k`.\n        // This gives `2**k < a <= 2**(k+1)` → `2**(k/2) <= sqrt(a) < 2 ** (k/2+1)`.\n        // Using an algorithm similar to the msb conmputation, we are able to compute `result = 2**(k/2)` which is a\n        // good first aproximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1;\n        uint256 x = a;\n        if (x >> 128 > 0) {\n            x >>= 128;\n            result <<= 64;\n        }\n        if (x >> 64 > 0) {\n            x >>= 64;\n            result <<= 32;\n        }\n        if (x >> 32 > 0) {\n            x >>= 32;\n            result <<= 16;\n        }\n        if (x >> 16 > 0) {\n            x >>= 16;\n            result <<= 8;\n        }\n        if (x >> 8 > 0) {\n            x >>= 8;\n            result <<= 4;\n        }\n        if (x >> 4 > 0) {\n            x >>= 4;\n            result <<= 2;\n        }\n        if (x >> 2 > 0) {\n            result <<= 1;\n        }\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = sqrt(a);\n        if (rounding == Rounding.Up && result * result < a) {\n            result += 1;\n        }\n        return result;\n    }\n}\n"
    },
    "contracts/vaults/vault_tranche/tranchemaster.sol": {
      "content": "pragma solidity ^0.8.4;\n\n\nimport {Auth} from \"../auth/Auth.sol\";\nimport {ERC4626} from \"../mixins/ERC4626.sol\";\n\nimport {SafeCastLib} from \"../utils/SafeCastLib.sol\";\nimport {SafeTransferLib} from \"../utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"../utils/FixedPointMathLib.sol\";\n\nimport {ERC20} from \"../tokens/ERC20.sol\";\nimport {Splitter} from \"./splitter.sol\";\nimport {tVault} from \"./tVault.sol\";\nimport {StableSwap} from \"./stableswap.sol\"; \nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\n/// @notice have to separate factories because of code size limit \ncontract TrancheAMMFactory{\n\n\taddress base_factory;\n\tmapping(address=>bool) _isPool; \n\tconstructor(){\n\t\tbase_factory = msg.sender; \n\t}\n\tfunction newPool(address token1, address token2) external returns(StableSwap){\n\t\tStableSwap amm = new StableSwap(token1, token2); \n\t\t_isPool[address(amm)] = true; \n\t\treturn amm; \n\t}\n\tfunction isPool(address pooladd) public view returns(bool){\n\t\treturn _isPool[pooladd]; \n\t}\n} \n\n\n/// @notice contract that stores the contracts and liquidity for each tranches \ncontract TrancheFactory{\n\n\tuint256 numVaults; \n  address owner; \n\n  TrancheAMMFactory ammFactory; \n\n\t/// @notice initialization parameters for the vault\n\tstruct InitParams{\n\t\taddress _want; \n    \taddress[]  _instruments;\n    \tuint256[]  _ratios;\n    \tuint256 _junior_weight; \n    \tuint256 _promisedReturn; \n    \tuint256 _time_to_maturity;\n    \tuint256 vaultId; \n\t}\n\n\tstruct Contracts{\n\t\taddress vault; \n\t\taddress splitter; \n\t\taddress amm; \n\t\tInitParams param; \n\t}\n\n\tmapping(uint256=>Contracts) vaultContracts;\n\tmapping(uint256=>mapping(address=>uint256)) lp_holdings;  //vaultId-> LP holdings for providrers\n\n    constructor(\n        address _owner, \n        address ammFactory_address\n    ) public {\n        owner = _owner;\n        ammFactory = TrancheAMMFactory(ammFactory_address); \n\n    }\n\n\n\n\t/// @notice adds vaults, spllitters, and amms when tranche bids are filled \n\t/// Bidders have to specify the \n\t/// param want: underlying token for all the vaults e.g(usdc,eth)\n\t/// param instruments: addresses of all vaults for the want they want exposure to\n\t/// param ratios: how much they want to split between the instruments \n\t/// param junior weight: how much the juniors are allocated; lower means higher leverage for juniors but lower safety for seniors\n\t/// param promisedReturn: how much fixed income seniors are getting paid primarily, \n\t/// param timetomaturity: when the tVault matures and tranche token holders can redeem their tranche for tVault \n\t/// @dev a bid is filled when liquidity provider agrees to provide initial liq for senior/junior or vice versa.  \n\t/// so initial liq should be provided nonetheless \n\tfunction createVault(InitParams memory param) public {\n\n\t\ttVault newvault = new tVault(param); \n\t\tSplitter splitter = new Splitter(newvault);\n\t\taddress[] memory tokens = splitter.getTrancheTokens(); \n\t\tStableSwap amm = ammFactory.newPool(tokens[0], tokens[1]); \n\n\t\tuint vaultId = param.vaultId; \n\t\tContracts storage contracts = vaultContracts[vaultId]; \n\t\tcontracts.vault = address(newvault); \n\t\tcontracts.splitter = address(splitter);\n\t\tcontracts.amm = address(amm); \n\t\tcontracts.param = param;\n\n\t\tnumVaults++; \n\t}\t\n\n\n\t/// @notice lp token balance is stored in this contract\n\tfunction increaseLPTokenBalance(address to, uint vaultId, uint lpshares) external{\n\t\tlp_holdings[vaultId][to] += lpshares; \n\t}\n\tfunction decreaseLPTokenBalance(address to, uint vaultId, uint lpshares) external{\n\t\tlp_holdings[vaultId][to] -= lpshares; \n\t}\n\n\tfunction getContracts(uint vaultId) external view returns(Contracts memory){\n\t\treturn vaultContracts[vaultId]; \n\t}\n\n\tfunction getLPTokenBalance(address to, uint vaultId) external view returns(uint256){\n\t\treturn lp_holdings[vaultId][to]; \n\t}\n\n\tfunction getSuperVault(uint vaultId) external view returns(tVault){\n\t\treturn tVault(vaultContracts[vaultId].vault); \n\t}\n\tfunction getSplitter(uint vaultId) external view returns(Splitter){\n\t\treturn Splitter(vaultContracts[vaultId].splitter); \n\t}\n\tfunction getAmm(uint vaultId) external view returns(StableSwap){\n\t\treturn StableSwap(vaultContracts[vaultId].amm); \n\t}\n\t//function getNumVaults\n\t// function getVaultId(InitParams memory param) external view returns(uint){\n\t// \treturn vaultIdMapping[param]; \n\t// }\n\n\n}\n\n/// @notice handles all trading related stuff \ncontract TrancheMaster{\n\n\tTrancheFactory tFactory;\n\n\tconstructor(TrancheFactory _tFactory){\n\t\ttFactory = _tFactory; \n\t}\n\n\n\t/// @notice adds liquidity to pool with vaultId\n\t/// @dev amount is denominated in want of the tVault, so want-> mint tVault-> split -> provide \n\tfunction addLiquidity(\n\t\taddress provider,\n\t\t uint amount, \n\t\t uint vaultId) external \n\t{\t\n\n\t\tTrancheFactory.Contracts memory contracts = tFactory.getContracts(vaultId); \n\t\tERC20 want = ERC20(contracts.param._want); \n\t\ttVault vault = tVault(contracts.vault); \n\t\tStableSwap amm = StableSwap(contracts.amm); \n\t\tSplitter splitter = Splitter(contracts.splitter); \n\n\t\t//Mint tVault\n\t\twant.transferFrom(provider, address(this), amount); \n\t\twant.approve(address(vault), amount ); \n\t\tuint shares = vault.convertToShares(amount);\n\t\tvault.mint(shares, address(this)); \n\n\t\t//Split \n\t\tvault.approve(address(splitter), shares);\n\t\t(uint ja, uint sa) = splitter.split(vault, shares); \n\n\t\t//provide(same amount to get a balanced pool)\n\t\tuint[2] memory amounts; \n\t\tamounts[0] = ja; \n\t\tamounts[1] = ja; \n\t\taddress[] memory tranches = splitter.getTrancheTokens(); \n\t\tERC20(tranches[0]).approve(address(amm), ja); \n\t\tERC20(tranches[1]).approve(address(amm), ja); \n\t\tuint lpshares = amm.addLiquidity(amounts, 0); \n\n\t\t//Transfer\n\t\ttFactory.increaseLPTokenBalance(provider, vaultId, lpshares);\n\n\t}\n\n\t/// @notice remove liquidity from the pool, and gives back merged token\n\tfunction removeLiquidity(\n\t\taddress taker, \n\t\tuint shares, \n\t\tuint vaultId) external \n\t{\n\t\tTrancheFactory.Contracts memory contracts = tFactory.getContracts(vaultId); \n\t\tERC20 want = ERC20(contracts.param._want); \n\t\ttVault vault = tVault(contracts.vault); \n\t\tStableSwap amm = StableSwap(contracts.amm); \n\t\tSplitter splitter = Splitter(contracts.splitter); \n\n\t\t//Transfer\n\t\ttFactory.decreaseLPTokenBalance(taker, vaultId, shares); \n\n\t\t//Remove\n\t\tuint[2] memory minAmounts;\n\t\tminAmounts[0] =0;\n\t\tminAmounts[1] =0;\n\t\tuint[2] memory amountsOut = amm.removeLiquidity(shares,minAmounts);\n\t\tuint junioramount = amountsOut[1]; \n\n\t\t//Merge-> junior and senior in, tVault out to this address\n\t\tuint merged_token_amount = splitter.merge(vault, junioramount); \n\n\t\t//Redeem vault \n\t\tvault.redeem(merged_token_amount, taker, address(this)); \n\n\n\t}\n\n\n\n\t/// @notice buy tranche token in one tx from underlying tVault collatera; \n\t/// @param amount is collateral in \n\t/// @dev 1.Mints vault token\n\t/// 2. Splits Vault token from splitter \n\t/// 3. Swap unwanted tToken to wanted tToken\n\t/// 4. Transfer wanted tToken to user \n\tfunction buy_tranche(\n\t\tuint vaultId, \n\t\tuint amount, \n\t\tbool isSenior\n\t\t) external \n\t{\n\t\tTrancheFactory.Contracts memory contracts = tFactory.getContracts(vaultId); \n\t\tERC20 want = ERC20(contracts.param._want); \n\t\ttVault vault = tVault(contracts.vault); \n\t\tStableSwap amm = StableSwap(contracts.amm); \n\t\tSplitter splitter = Splitter(contracts.splitter); \n\n\t\t//1.Mint\n\t\twant.transferFrom(msg.sender, address(this), amount); \n\t\twant.approve(address(vault), amount); \n\t\tuint shares = vault.convertToShares(amount); \n\t\tvault.mint(shares, address(this));\n\n\t\t//2. Split\n\t\tvault.approve(address(splitter), shares); \n\t\t(uint ja, uint sa) = splitter.split(vault, shares); //junior and senior now minted to this address \n\n\t\t//Senior tokens are indexed at 0 in each amm \n\t\tuint tokenIn = isSenior? 0 : 1;\n\t\tuint tokenOut = 1-tokenIn; \n\t\tuint tokenInAmount = isSenior? sa: ja; \n\t\taddress[] memory tranches = splitter.getTrancheTokens(); \n\n\t\t//3. Swap \n\t\tERC20(tranches[tokenIn]).approve(address(amm), tokenInAmount); \n\t\tuint tokenOutAmount = amm.swap(tokenIn, tokenOut, tokenInAmount, 0); //this will give this contract tokenOut\n\n\t\t//4. Transfer \n\t\tERC20(tranches[tokenOut]).transfer(msg.sender, tokenOutAmount); \n\n\t}\n\n\t/// @notice sell tranche token for collateral in one tx\n\t/// 1. Transfer tToken \n\t/// 2. Swap tTokens to get in correct ratio\n\tfunction sell_tranche(\n\t\tuint vaultId, \n\t\tuint amount, \n\t\tbool isSenior \n\t\t) external \n\t{\n\t\tTrancheFactory.Contracts memory contracts = tFactory.getContracts(vaultId); \n\t\tERC20 want = ERC20(contracts.param._want); \n\t\ttVault vault = tVault(contracts.vault); \n\t\tStableSwap amm = StableSwap(contracts.amm); \n\t\tSplitter splitter = Splitter(contracts.splitter); \n\n\t\t//1. Transfer tToken to this contract\n\t\taddress[] memory tranches = splitter.getTrancheTokens(); \n\t\tuint tokenIn = isSenior? 0:1; \n\t\tERC20(tranches[tokenIn]).transfer(msg.sender, amount); \n\n\t\t//2. Swap to get correct ratio, if intoken is senior then need junior, \n\t\t(uint pairTokenAmount, uint swappedTokenAmount) = swapToRatio(amount, !isSenior, tranches, vault, amm); \n\t\tuint amountAfterSwap =  amount - swappedTokenAmount; \n\t\t//amountAfterSwap, pairTokenAmount should be the amount of tranche tokens in ratio \n\n\t\t//3.Merge the tokens (merged tVault token will be directed to this contract)\n\t\tuint junior_amount = isSenior? pairTokenAmount: swappedTokenAmount;  \n\t\tuint totalAmountMerged = splitter.merge(vault, junior_amount); \n\n\t\t//4.Redeem merged token in tVault  \n\t\tvault.redeem(totalAmountMerged, msg.sender, address(this)); \n\n\n\t}\n\n\t/// @notice swap portion of tToken to another to get the correct ratio\n\t/// e.x 100 junior-> 30 senior, 70 junior, when ratio is 3:7\n\tfunction swapToRatio(\n\t\tuint tokenInAmount, \n\t\tbool needSenior,\n\t\taddress[] memory tranches,\n\t\ttVault vault, \n\t\tStableSwap amm) internal returns(uint, uint){\n\t\n\t\t//get swapping Token index; if senior is needed swap junior\n\t\tuint tokenInIndex = needSenior? 1:0;\n\t\tuint tokenOutIndex = 1- tokenInIndex; \n\t\taddress neededToken = tranches[tokenOutIndex]; \n\t\taddress swappingToken = tranches[tokenInIndex]; \n\t\tuint junior_weight = vault.getJuniorWeight();\n\t\tuint PRICE_PRECISION = vault.PRICE_PRECISION();   \n\t\t\n\t\t//ex. 100j -> 30j, 70s (determined by ratio)\n\t\t// need x amount of juniors for 70s \n\t\tuint neededTokenOutAmount; \n\t\tif (needSenior)  neededTokenOutAmount = (PRICE_PRECISION - junior_weight) * tokenInAmount; \n\t\telse  neededTokenOutAmount = junior_weight * tokenInAmount; \n\n\t\t//Get how much tokenInAmount I need to get needed tokenoutAmount \n\t\tuint neededTokenInAmount = amm.getDx(neededTokenOutAmount, tokenInIndex); \n\t\tuint TokenOutAmount = amm.swap(tokenInIndex, tokenOutIndex, neededTokenInAmount,0 ); \n\t\t//Now this contract has the neededTokenAmountOut tokens\n\n\t\treturn (TokenOutAmount, neededTokenInAmount);\n\t}\n\n\n\n}"
    },
    "contracts/prb/PRBMathUD60x18.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.4;\n\nimport \"./PRBMath.sol\";\n\n/// @title PRBMathUD60x18\n/// @author Paul Razvan Berg\n/// @notice Smart contract library for advanced fixed-point math that works with uint256 numbers considered to have 18\n/// trailing decimals. We call this number representation unsigned 60.18-decimal fixed-point, since there can be up to 60\n/// digits in the integer part and up to 18 decimals in the fractional part. The numbers are bound by the minimum and the\n/// maximum values permitted by the Solidity type uint256.\nlibrary PRBMathUD60x18 {\n    /// @dev Half the SCALE number.\n    uint256 internal constant HALF_SCALE = 5e17;\n\n    /// @dev log2(e) as an unsigned 60.18-decimal fixed-point number.\n    uint256 internal constant LOG2_E = 1_442695040888963407;\n\n    /// @dev The maximum value an unsigned 60.18-decimal fixed-point number can have.\n    uint256 internal constant MAX_UD60x18 =\n        115792089237316195423570985008687907853269984665640564039457_584007913129639935;\n\n    /// @dev The maximum whole value an unsigned 60.18-decimal fixed-point number can have.\n    uint256 internal constant MAX_WHOLE_UD60x18 =\n        115792089237316195423570985008687907853269984665640564039457_000000000000000000;\n\n    /// @dev How many trailing decimals can be represented.\n    uint256 internal constant SCALE = 1e18;\n\n    /// @notice Calculates the arithmetic average of x and y, rounding down.\n    /// @param x The first operand as an unsigned 60.18-decimal fixed-point number.\n    /// @param y The second operand as an unsigned 60.18-decimal fixed-point number.\n    /// @return result The arithmetic average as an unsigned 60.18-decimal fixed-point number.\n    function avg(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        // The operations can never overflow.\n        unchecked {\n            // The last operand checks if both x and y are odd and if that is the case, we add 1 to the result. We need\n            // to do this because if both numbers are odd, the 0.5 remainder gets truncated twice.\n            result = (x >> 1) + (y >> 1) + (x & y & 1);\n        }\n    }\n\n    /// @notice Yields the least unsigned 60.18 decimal fixed-point number greater than or equal to x.\n    ///\n    /// @dev Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts.\n    /// See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\n    ///\n    /// Requirements:\n    /// - x must be less than or equal to MAX_WHOLE_UD60x18.\n    ///\n    /// @param x The unsigned 60.18-decimal fixed-point number to ceil.\n    /// @param result The least integer greater than or equal to x, as an unsigned 60.18-decimal fixed-point number.\n    function ceil(uint256 x) internal pure returns (uint256 result) {\n        if (x > MAX_WHOLE_UD60x18) {\n            revert PRBMathUD60x18__CeilOverflow(x);\n        }\n        assembly {\n            // Equivalent to \"x % SCALE\" but faster.\n            let remainder := mod(x, SCALE)\n\n            // Equivalent to \"SCALE - remainder\" but faster.\n            let delta := sub(SCALE, remainder)\n\n            // Equivalent to \"x + delta * (remainder > 0 ? 1 : 0)\" but faster.\n            result := add(x, mul(delta, gt(remainder, 0)))\n        }\n    }\n\n    /// @notice Divides two unsigned 60.18-decimal fixed-point numbers, returning a new unsigned 60.18-decimal fixed-point number.\n    ///\n    /// @dev Uses mulDiv to enable overflow-safe multiplication and division.\n    ///\n    /// Requirements:\n    /// - The denominator cannot be zero.\n    ///\n    /// @param x The numerator as an unsigned 60.18-decimal fixed-point number.\n    /// @param y The denominator as an unsigned 60.18-decimal fixed-point number.\n    /// @param result The quotient as an unsigned 60.18-decimal fixed-point number.\n    function div(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        result = PRBMath.mulDiv(x, SCALE, y);\n    }\n\n    /// @notice Returns Euler's number as an unsigned 60.18-decimal fixed-point number.\n    /// @dev See https://en.wikipedia.org/wiki/E_(mathematical_constant).\n    function e() internal pure returns (uint256 result) {\n        result = 2_718281828459045235;\n    }\n\n    /// @notice Calculates the natural exponent of x.\n    ///\n    /// @dev Based on the insight that e^x = 2^(x * log2(e)).\n    ///\n    /// Requirements:\n    /// - All from \"log2\".\n    /// - x must be less than 133.084258667509499441.\n    ///\n    /// @param x The exponent as an unsigned 60.18-decimal fixed-point number.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\n    function exp(uint256 x) internal pure returns (uint256 result) {\n        // Without this check, the value passed to \"exp2\" would be greater than 192.\n        if (x >= 133_084258667509499441) {\n            revert PRBMathUD60x18__ExpInputTooBig(x);\n        }\n\n        // Do the fixed-point multiplication inline to save gas.\n        unchecked {\n            uint256 doubleScaleProduct = x * LOG2_E;\n            result = exp2((doubleScaleProduct + HALF_SCALE) / SCALE);\n        }\n    }\n\n    /// @notice Calculates the binary exponent of x using the binary fraction method.\n    ///\n    /// @dev See https://ethereum.stackexchange.com/q/79903/24693.\n    ///\n    /// Requirements:\n    /// - x must be 192 or less.\n    /// - The result must fit within MAX_UD60x18.\n    ///\n    /// @param x The exponent as an unsigned 60.18-decimal fixed-point number.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\n    function exp2(uint256 x) internal pure returns (uint256 result) {\n        // 2^192 doesn't fit within the 192.64-bit format used internally in this function.\n        if (x >= 192e18) {\n            revert PRBMathUD60x18__Exp2InputTooBig(x);\n        }\n\n        unchecked {\n            // Convert x to the 192.64-bit fixed-point format.\n            uint256 x192x64 = (x << 64) / SCALE;\n\n            // Pass x to the PRBMath.exp2 function, which uses the 192.64-bit fixed-point number representation.\n            result = PRBMath.exp2(x192x64);\n        }\n    }\n\n    /// @notice Yields the greatest unsigned 60.18 decimal fixed-point number less than or equal to x.\n    /// @dev Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts.\n    /// See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\n    /// @param x The unsigned 60.18-decimal fixed-point number to floor.\n    /// @param result The greatest integer less than or equal to x, as an unsigned 60.18-decimal fixed-point number.\n    function floor(uint256 x) internal pure returns (uint256 result) {\n        assembly {\n            // Equivalent to \"x % SCALE\" but faster.\n            let remainder := mod(x, SCALE)\n\n            // Equivalent to \"x - remainder * (remainder > 0 ? 1 : 0)\" but faster.\n            result := sub(x, mul(remainder, gt(remainder, 0)))\n        }\n    }\n\n    /// @notice Yields the excess beyond the floor of x.\n    /// @dev Based on the odd function definition https://en.wikipedia.org/wiki/Fractional_part.\n    /// @param x The unsigned 60.18-decimal fixed-point number to get the fractional part of.\n    /// @param result The fractional part of x as an unsigned 60.18-decimal fixed-point number.\n    function frac(uint256 x) internal pure returns (uint256 result) {\n        assembly {\n            result := mod(x, SCALE)\n        }\n    }\n\n    /// @notice Converts a number from basic integer form to unsigned 60.18-decimal fixed-point representation.\n    ///\n    /// @dev Requirements:\n    /// - x must be less than or equal to MAX_UD60x18 divided by SCALE.\n    ///\n    /// @param x The basic integer to convert.\n    /// @param result The same number in unsigned 60.18-decimal fixed-point representation.\n    function fromUint(uint256 x) internal pure returns (uint256 result) {\n        unchecked {\n            if (x > MAX_UD60x18 / SCALE) {\n                revert PRBMathUD60x18__FromUintOverflow(x);\n            }\n            result = x * SCALE;\n        }\n    }\n\n    /// @notice Calculates geometric mean of x and y, i.e. sqrt(x * y), rounding down.\n    ///\n    /// @dev Requirements:\n    /// - x * y must fit within MAX_UD60x18, lest it overflows.\n    ///\n    /// @param x The first operand as an unsigned 60.18-decimal fixed-point number.\n    /// @param y The second operand as an unsigned 60.18-decimal fixed-point number.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\n    function gm(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        if (x == 0) {\n            return 0;\n        }\n\n        unchecked {\n            // Checking for overflow this way is faster than letting Solidity do it.\n            uint256 xy = x * y;\n            if (xy / x != y) {\n                revert PRBMathUD60x18__GmOverflow(x, y);\n            }\n\n            // We don't need to multiply by the SCALE here because the x*y product had already picked up a factor of SCALE\n            // during multiplication. See the comments within the \"sqrt\" function.\n            result = PRBMath.sqrt(xy);\n        }\n    }\n\n    /// @notice Calculates 1 / x, rounding toward zero.\n    ///\n    /// @dev Requirements:\n    /// - x cannot be zero.\n    ///\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the inverse.\n    /// @return result The inverse as an unsigned 60.18-decimal fixed-point number.\n    function inv(uint256 x) internal pure returns (uint256 result) {\n        unchecked {\n            // 1e36 is SCALE * SCALE.\n            result = 1e36 / x;\n        }\n    }\n\n    /// @notice Calculates the natural logarithm of x.\n    ///\n    /// @dev Based on the insight that ln(x) = log2(x) / log2(e).\n    ///\n    /// Requirements:\n    /// - All from \"log2\".\n    ///\n    /// Caveats:\n    /// - All from \"log2\".\n    /// - This doesn't return exactly 1 for 2.718281828459045235, for that we would need more fine-grained precision.\n    ///\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the natural logarithm.\n    /// @return result The natural logarithm as an unsigned 60.18-decimal fixed-point number.\n    function ln(uint256 x) internal pure returns (uint256 result) {\n        // Do the fixed-point multiplication inline to save gas. This is overflow-safe because the maximum value that log2(x)\n        // can return is 196205294292027477728.\n        unchecked {\n            result = (log2(x) * SCALE) / LOG2_E;\n        }\n    }\n\n    /// @notice Calculates the common logarithm of x.\n    ///\n    /// @dev First checks if x is an exact power of ten and it stops if yes. If it's not, calculates the common\n    /// logarithm based on the insight that log10(x) = log2(x) / log2(10).\n    ///\n    /// Requirements:\n    /// - All from \"log2\".\n    ///\n    /// Caveats:\n    /// - All from \"log2\".\n    ///\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the common logarithm.\n    /// @return result The common logarithm as an unsigned 60.18-decimal fixed-point number.\n    function log10(uint256 x) internal pure returns (uint256 result) {\n        if (x < SCALE) {\n            revert PRBMathUD60x18__LogInputTooSmall(x);\n        }\n\n        // Note that the \"mul\" in this block is the assembly multiplication operation, not the \"mul\" function defined\n        // in this contract.\n        // prettier-ignore\n        assembly {\n            switch x\n            case 1 { result := mul(SCALE, sub(0, 18)) }\n            case 10 { result := mul(SCALE, sub(1, 18)) }\n            case 100 { result := mul(SCALE, sub(2, 18)) }\n            case 1000 { result := mul(SCALE, sub(3, 18)) }\n            case 10000 { result := mul(SCALE, sub(4, 18)) }\n            case 100000 { result := mul(SCALE, sub(5, 18)) }\n            case 1000000 { result := mul(SCALE, sub(6, 18)) }\n            case 10000000 { result := mul(SCALE, sub(7, 18)) }\n            case 100000000 { result := mul(SCALE, sub(8, 18)) }\n            case 1000000000 { result := mul(SCALE, sub(9, 18)) }\n            case 10000000000 { result := mul(SCALE, sub(10, 18)) }\n            case 100000000000 { result := mul(SCALE, sub(11, 18)) }\n            case 1000000000000 { result := mul(SCALE, sub(12, 18)) }\n            case 10000000000000 { result := mul(SCALE, sub(13, 18)) }\n            case 100000000000000 { result := mul(SCALE, sub(14, 18)) }\n            case 1000000000000000 { result := mul(SCALE, sub(15, 18)) }\n            case 10000000000000000 { result := mul(SCALE, sub(16, 18)) }\n            case 100000000000000000 { result := mul(SCALE, sub(17, 18)) }\n            case 1000000000000000000 { result := 0 }\n            case 10000000000000000000 { result := SCALE }\n            case 100000000000000000000 { result := mul(SCALE, 2) }\n            case 1000000000000000000000 { result := mul(SCALE, 3) }\n            case 10000000000000000000000 { result := mul(SCALE, 4) }\n            case 100000000000000000000000 { result := mul(SCALE, 5) }\n            case 1000000000000000000000000 { result := mul(SCALE, 6) }\n            case 10000000000000000000000000 { result := mul(SCALE, 7) }\n            case 100000000000000000000000000 { result := mul(SCALE, 8) }\n            case 1000000000000000000000000000 { result := mul(SCALE, 9) }\n            case 10000000000000000000000000000 { result := mul(SCALE, 10) }\n            case 100000000000000000000000000000 { result := mul(SCALE, 11) }\n            case 1000000000000000000000000000000 { result := mul(SCALE, 12) }\n            case 10000000000000000000000000000000 { result := mul(SCALE, 13) }\n            case 100000000000000000000000000000000 { result := mul(SCALE, 14) }\n            case 1000000000000000000000000000000000 { result := mul(SCALE, 15) }\n            case 10000000000000000000000000000000000 { result := mul(SCALE, 16) }\n            case 100000000000000000000000000000000000 { result := mul(SCALE, 17) }\n            case 1000000000000000000000000000000000000 { result := mul(SCALE, 18) }\n            case 10000000000000000000000000000000000000 { result := mul(SCALE, 19) }\n            case 100000000000000000000000000000000000000 { result := mul(SCALE, 20) }\n            case 1000000000000000000000000000000000000000 { result := mul(SCALE, 21) }\n            case 10000000000000000000000000000000000000000 { result := mul(SCALE, 22) }\n            case 100000000000000000000000000000000000000000 { result := mul(SCALE, 23) }\n            case 1000000000000000000000000000000000000000000 { result := mul(SCALE, 24) }\n            case 10000000000000000000000000000000000000000000 { result := mul(SCALE, 25) }\n            case 100000000000000000000000000000000000000000000 { result := mul(SCALE, 26) }\n            case 1000000000000000000000000000000000000000000000 { result := mul(SCALE, 27) }\n            case 10000000000000000000000000000000000000000000000 { result := mul(SCALE, 28) }\n            case 100000000000000000000000000000000000000000000000 { result := mul(SCALE, 29) }\n            case 1000000000000000000000000000000000000000000000000 { result := mul(SCALE, 30) }\n            case 10000000000000000000000000000000000000000000000000 { result := mul(SCALE, 31) }\n            case 100000000000000000000000000000000000000000000000000 { result := mul(SCALE, 32) }\n            case 1000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 33) }\n            case 10000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 34) }\n            case 100000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 35) }\n            case 1000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 36) }\n            case 10000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 37) }\n            case 100000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 38) }\n            case 1000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 39) }\n            case 10000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 40) }\n            case 100000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 41) }\n            case 1000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 42) }\n            case 10000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 43) }\n            case 100000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 44) }\n            case 1000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 45) }\n            case 10000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 46) }\n            case 100000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 47) }\n            case 1000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 48) }\n            case 10000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 49) }\n            case 100000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 50) }\n            case 1000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 51) }\n            case 10000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 52) }\n            case 100000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 53) }\n            case 1000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 54) }\n            case 10000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 55) }\n            case 100000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 56) }\n            case 1000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 57) }\n            case 10000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 58) }\n            case 100000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 59) }\n            default {\n                result := MAX_UD60x18\n            }\n        }\n\n        if (result == MAX_UD60x18) {\n            // Do the fixed-point division inline to save gas. The denominator is log2(10).\n            unchecked {\n                result = (log2(x) * SCALE) / 3_321928094887362347;\n            }\n        }\n    }\n\n    /// @notice Calculates the binary logarithm of x.\n    ///\n    /// @dev Based on the iterative approximation algorithm.\n    /// https://en.wikipedia.org/wiki/Binary_logarithm#Iterative_approximation\n    ///\n    /// Requirements:\n    /// - x must be greater than or equal to SCALE, otherwise the result would be negative.\n    ///\n    /// Caveats:\n    /// - The results are nor perfectly accurate to the last decimal, due to the lossy precision of the iterative approximation.\n    ///\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the binary logarithm.\n    /// @return result The binary logarithm as an unsigned 60.18-decimal fixed-point number.\n    function log2(uint256 x) internal pure returns (uint256 result) {\n        if (x < SCALE) {\n            revert PRBMathUD60x18__LogInputTooSmall(x);\n        }\n        unchecked {\n            // Calculate the integer part of the logarithm and add it to the result and finally calculate y = x * 2^(-n).\n            uint256 n = PRBMath.mostSignificantBit(x / SCALE);\n\n            // The integer part of the logarithm as an unsigned 60.18-decimal fixed-point number. The operation can't overflow\n            // because n is maximum 255 and SCALE is 1e18.\n            result = n * SCALE;\n\n            // This is y = x * 2^(-n).\n            uint256 y = x >> n;\n\n            // If y = 1, the fractional part is zero.\n            if (y == SCALE) {\n                return result;\n            }\n\n            // Calculate the fractional part via the iterative approximation.\n            // The \"delta >>= 1\" part is equivalent to \"delta /= 2\", but shifting bits is faster.\n            for (uint256 delta = HALF_SCALE; delta > 0; delta >>= 1) {\n                y = (y * y) / SCALE;\n\n                // Is y^2 > 2 and so in the range [2,4)?\n                if (y >= 2 * SCALE) {\n                    // Add the 2^(-m) factor to the logarithm.\n                    result += delta;\n\n                    // Corresponds to z/2 on Wikipedia.\n                    y >>= 1;\n                }\n            }\n        }\n    }\n\n    /// @notice Multiplies two unsigned 60.18-decimal fixed-point numbers together, returning a new unsigned 60.18-decimal\n    /// fixed-point number.\n    /// @dev See the documentation for the \"PRBMath.mulDivFixedPoint\" function.\n    /// @param x The multiplicand as an unsigned 60.18-decimal fixed-point number.\n    /// @param y The multiplier as an unsigned 60.18-decimal fixed-point number.\n    /// @return result The product as an unsigned 60.18-decimal fixed-point number.\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        result = PRBMath.mulDivFixedPoint(x, y);\n    }\n\n    /// @notice Returns PI as an unsigned 60.18-decimal fixed-point number.\n    function pi() internal pure returns (uint256 result) {\n        result = 3_141592653589793238;\n    }\n\n    /// @notice Raises x to the power of y.\n    ///\n    /// @dev Based on the insight that x^y = 2^(log2(x) * y).\n    ///\n    /// Requirements:\n    /// - All from \"exp2\", \"log2\" and \"mul\".\n    ///\n    /// Caveats:\n    /// - All from \"exp2\", \"log2\" and \"mul\".\n    /// - Assumes 0^0 is 1.\n    ///\n    /// @param x Number to raise to given power y, as an unsigned 60.18-decimal fixed-point number.\n    /// @param y Exponent to raise x to, as an unsigned 60.18-decimal fixed-point number.\n    /// @return result x raised to power y, as an unsigned 60.18-decimal fixed-point number.\n    function pow(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        if (x == 0) {\n            result = y == 0 ? SCALE : uint256(0);\n        } else {\n            result = exp2(mul(log2(x), y));\n        }\n    }\n\n    /// @notice Raises x (unsigned 60.18-decimal fixed-point number) to the power of y (basic unsigned integer) using the\n    /// famous algorithm \"exponentiation by squaring\".\n    ///\n    /// @dev See https://en.wikipedia.org/wiki/Exponentiation_by_squaring\n    ///\n    /// Requirements:\n    /// - The result must fit within MAX_UD60x18.\n    ///\n    /// Caveats:\n    /// - All from \"mul\".\n    /// - Assumes 0^0 is 1.\n    ///\n    /// @param x The base as an unsigned 60.18-decimal fixed-point number.\n    /// @param y The exponent as an uint256.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\n    function powu(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        // Calculate the first iteration of the loop in advance.\n        result = y & 1 > 0 ? x : SCALE;\n\n        // Equivalent to \"for(y /= 2; y > 0; y /= 2)\" but faster.\n        for (y >>= 1; y > 0; y >>= 1) {\n            x = PRBMath.mulDivFixedPoint(x, x);\n\n            // Equivalent to \"y % 2 == 1\" but faster.\n            if (y & 1 > 0) {\n                result = PRBMath.mulDivFixedPoint(result, x);\n            }\n        }\n    }\n\n    /// @notice Returns 1 as an unsigned 60.18-decimal fixed-point number.\n    function scale() internal pure returns (uint256 result) {\n        result = SCALE;\n    }\n\n    /// @notice Calculates the square root of x, rounding down.\n    /// @dev Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\n    ///\n    /// Requirements:\n    /// - x must be less than MAX_UD60x18 / SCALE.\n    ///\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the square root.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point .\n    function sqrt(uint256 x) internal pure returns (uint256 result) {\n        unchecked {\n            if (x > MAX_UD60x18 / SCALE) {\n                revert PRBMathUD60x18__SqrtOverflow(x);\n            }\n            // Multiply x by the SCALE to account for the factor of SCALE that is picked up when multiplying two unsigned\n            // 60.18-decimal fixed-point numbers together (in this case, those two numbers are both the square root).\n            result = PRBMath.sqrt(x * SCALE);\n        }\n    }\n\n    /// @notice Converts a unsigned 60.18-decimal fixed-point number to basic integer form, rounding down in the process.\n    /// @param x The unsigned 60.18-decimal fixed-point number to convert.\n    /// @return result The same number in basic integer form.\n    function toUint(uint256 x) internal pure returns (uint256 result) {\n        unchecked {\n            result = x / SCALE;\n        }\n    }\n}"
    },
    "contracts/stablecoin/controller.sol": {
      "content": "pragma solidity ^0.8.4;\nimport \"./IController.sol\";\nimport \"../turbo/TrustedMarketFactoryV3.sol\";\nimport {MarketManager} from \"./marketmanager.sol\";\nimport {ReputationNFT} from \"./reputationtoken.sol\";\nimport {OwnedERC20} from \"../turbo/OwnedShareToken.sol\";\nimport {LinearBondingCurve} from \"../bonds/LinearBondingCurve.sol\";\nimport {BondingCurve} from \"../bonds/bondingcurve.sol\";\nimport {Vault} from \"../vaults/vault.sol\";\nimport {Instrument} from \"../vaults/instrument.sol\";\nimport {Strings} from \"@openzeppelin/contracts/utils/Strings.sol\";\nimport {FixedPointMathLib} from \"solmate/src/utils/FixedPointMathLib.sol\";\n\nimport \"hardhat/console.sol\";\nimport \"@interep/contracts/IInterep.sol\";\n\n// Controller contract responsible for providing initial liquidity to the\n// borrower cds market, collect winnings when default, and burn the corresponding DS\ncontract Controller {\n    using SafeMath for uint256;\n    using FixedPointMathLib for uint256;\n\n    struct MarketData {\n        address instrument_address;\n        address recipient;\n    }\n\n    event MarketInitiated(uint256 marketId, address recipient);\n\n    mapping(address => bool) public  validators; \n    mapping(address => bool) public  verified;\n    mapping(uint256 => MarketData) public market_data; // id => recipient\n    mapping(address=> uint256) public ad_to_id; //utilizer address to marketId, only one market ID per address at given moment, can generalize later\n\n    address[] validators_array;\n\n    address creator_address;\n\n    IInterep interep;\n    TrustedMarketFactoryV3 marketFactory;\n    MarketManager marketManager;\n    Vault public vault;\n    ReputationNFT repNFT; \n\n    uint256 constant TWITTER_UNRATED_GROUP_ID = 16106950158033643226105886729341667676405340206102109927577753383156646348711;\n    bytes32 constant private signal = bytes32(\"twitter-unrated\");\n    uint256 insurance_constant = 5e5; //1 is 1e6, also needs to be able to be changed \n    uint256 constant PRICE_PRECISION = 1e18; \n    \n    // Bond Curve Name\n    string constant baseName = \"Bond\";\n    string constant baseSymbol = \"B\";\n    uint256 nonce = 0;\n\n    /* ========== MODIFIERS ========== */\n    modifier onlyValidator() {\n        require(validators[msg.sender] == true || msg.sender == creator_address, \"Only Validators can call this function\");\n        _;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == creator_address, \"Only Owner can call this function\");\n        _;\n    }\n    modifier onlyManager() {\n        require(msg.sender == address(marketManager) || msg.sender == creator_address, \"Only Manager can call this function\");\n        _;\n    }\n\n    constructor (\n        address _creator_address,\n        address _interep_address\n    ) {\n        creator_address = _creator_address;\n        interep = IInterep(_interep_address);\n    }\n\n    /*----Setup Functions----*/\n\n    function setMarketManager(address _marketManager) public onlyOwner {\n        require(_marketManager != address(0));\n        marketManager = MarketManager(_marketManager);\n    }\n\n    function setVault(address _vault) public onlyOwner {\n        require(_vault != address(0));\n        vault = Vault(_vault);\n    }\n\n    function setMarketFactory(address _marketFactory) public onlyOwner {\n        require(_marketFactory != address(0));\n        marketFactory = TrustedMarketFactoryV3(_marketFactory);\n    }\n\n    function setReputationNFT(address NFT_address) public onlyOwner{\n        repNFT = ReputationNFT(NFT_address); \n    }\n\n\n    /// @notice curveparams for linear bonds \n    /// b is a initial price parameter we choose i.e 0.9, a is a function of b\n    /// a = (1-b) **2 / 2* interest \n    /// @dev both principal/interest should be in price precision\n    /// @param interest is amount of interest in dollars, not percentage,\n    /// returns a,b is both in 18 price_precision\n    function getCurveParams(uint256 principal, uint256 interest) internal view returns (uint256, uint256){\n\n      uint256 price_precision = 1e18; \n      uint256 interest_ = interest * (10**12); \n      uint256 principal_ = principal * (10**12); \n\n      uint256 b = (2*principal_).divWadDown(principal_+interest_) - price_precision; \n      uint256 a = (price_precision -b).divWadDown(principal_+interest_); \n\n      return (a,b);\n\n\n  }\n\n    function verifyAddress(\n        uint256 nullifier_hash, \n        uint256 external_nullifier,\n        uint256[8] calldata proof\n    ) external  {\n        //require(!verified[msg.sender], \"address already verified\");\n        //interep.verifyProof(TWITTER_UNRATED_GROUP_ID, signal, nullifier_hash, external_nullifier, proof);\n        verified[msg.sender] = true;\n\n    }\n\n\n    function mintRepNFT(\n      address NFT_address,\n      address trader\n      ) external  {\n      ReputationNFT(NFT_address).mint(msg.sender);\n  }\n\n\n\n    //Validator should be added for each borrower\n    function addValidator(address validator_address) external  {\n      require(validator_address != address(0), \"Zero address detected\");\n      require(validators[validator_address] == false, \"Address already exists\");\n\n      validators[validator_address] = true; \n      validators_array.push(validator_address);\n  }\n\n\n    /**\n     @dev initiates market, called by frontend loan proposal or instrument form submit button.\n     @param recipient is the \n     @dev a and b must be 60.18 format\n     */\n    function initiateMarket(\n        address recipient,\n        Vault.InstrumentData memory instrumentData // marketId should be set to zero, no way of knowing.\n    ) external  {\n \n      (uint256 a, uint256 b) = getCurveParams(instrumentData.principal, instrumentData.expectedYield);\n      console.log('a,b', a,b); \n      string memory name = string(abi.encodePacked(baseName, \"-\", Strings.toString(nonce)));\n      string memory symbol = string(abi.encodePacked(baseSymbol, Strings.toString(nonce)));\n      nonce++;\n\n      OwnedERC20 zcb = new LinearBondingCurve(\n          name,\n          symbol,\n          address(marketManager), // owner\n          address(vault), \n          a,\n          b\n      );\n\n\n      uint256[] memory odds = new uint256[](2); //TODO get rid of this \n      odds[0] = 0;\n      odds[1] = 0; \n\n      uint256 marketId = marketFactory.createZCBMarket(\n          address(this), // controller is the settlement address\n          instrumentData.description,\n          odds,\n          zcb\n      );\n\n\n      ad_to_id[recipient] = marketId; \n      instrumentData.marketId = marketId;\n\n\n      vault.addProposal(\n          instrumentData\n      );\n\n      market_data[marketId] = MarketData(address(instrumentData.Instrument_address), recipient);\n      marketManager.setAssessmentPhase(marketId, true, true);  \n\n      emit MarketInitiated(marketId, recipient);\n  }\n \n    \n   \n    /**\n    @notice main function called at maturity OR premature resolve of instrument(from early default)\n    @dev triggered by resolve Loan \n    @param atLoss: when actual returns lower than expected \n    @param principal_loss: if total returned less than principal, principal-total returned, this is total loss\n\n    When market finishes at maturity, need to \n    1. burn all vault tokens in bc \n    2. mint all incoming redeeming vault tokens \n    */\n  function resolveMarket(\n      uint256 marketId,\n      bool atLoss,\n      uint256 extra_gain,\n      uint256 principal_loss\n  ) external  {\n      marketManager.update_redemption_price(marketId, atLoss, extra_gain, principal_loss); \n      marketManager.handle_maturity(marketId, atLoss, principal_loss); \n      marketManager.deactivateMarket(marketId, atLoss);\n      \n      //Burn all vault tokens in BC\n      address bc_ad = getZCB_ad( marketId); \n      uint256 bc_vault_balance = vault.balanceOf(bc_ad); \n      vault.controller_burn(bc_vault_balance,bc_ad); \n\n      uint256 winning_outcome = 0; //TODO  \n      marketFactory.trustedResolveMarket(marketId, winning_outcome);\n    }\n\n    /// @notice called by the validator when market conditions are met\n    function approveMarket( \n      uint256 marketId\n      ) external onlyValidator{\n      if (!marketManager.marketCondition(marketId)) revert(\"Market Condition Not met\"); \n      require(!marketManager.onlyReputable(marketId), \"Market Phase err\"); \n      marketManager.setAssessmentPhase(marketId, false, false); \n      trustInstrument(marketId); \n\n      // Deposit to the instrument contract\n      uint256 principal = vault.fetchInstrumentData(marketId).principal; \n      //maybe this should be separated to prevent attacks \n      vault.depositIntoInstrument(Instrument(market_data[marketId].instrument_address), principal );\n      vault.onMarketApproval(marketId);\n    }\n\n    /*\n    Market is denied by validator or automatically if conditions are not met \n    */\n    function denyMarket(\n        uint256 marketId\n    ) external  onlyValidator {\n      marketManager.denyMarket(marketId);\n        //TrustedMarketFactoryV3 marketFactory = TrustedMarketFactoryV3(marketInfo.marketFactoryAddress);\n      uint256 winning_outcome = 0; //TODO  \n      marketFactory.trustedResolveMarket(marketId, winning_outcome);\n    }\n\n\n    function trustInstrument(uint256 marketId) private  {\n      vault.trustInstrument(Instrument(market_data[marketId].instrument_address));\n    }\n\n    function redeem_mint(uint256 amount, address to) external onlyManager{\n      vault.controller_mint(amount,to); \n    }\n\n\n\n\n\n                        /* --------VIEW FUNCTIONS---------  */\n    function getMarketId(address recipient) public view returns(uint256){\n      return ad_to_id[recipient];\n    }\n\n    function getZCB(uint256 marketId) public view returns (OwnedERC20){\n      AbstractMarketFactoryV3.Market memory market = marketFactory.getZCBMarket(marketId);\n      return OwnedERC20(market.shareTokens[0]);\n    }\n    function getZCB_ad(uint256 marketId) public view returns (address){\n      AbstractMarketFactoryV3.Market memory market = marketFactory.getZCBMarket(marketId);\n      return address(OwnedERC20(market.shareTokens[0]));\n    }\n    function canBeApproved(uint256 marketId) public view returns (bool) {\n        //TODO\n      return true;\n    }\n\n    function isVerified(address addr) view public returns (bool) {\n      return verified[addr];\n    }\n}\n\n"
    },
    "contracts/prb/PRBMath.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.4;\n\n/// @notice Emitted when the result overflows uint256.\nerror PRBMath__MulDivFixedPointOverflow(uint256 prod1);\n\n/// @notice Emitted when the result overflows uint256.\nerror PRBMath__MulDivOverflow(uint256 prod1, uint256 denominator);\n\n/// @notice Emitted when one of the inputs is type(int256).min.\nerror PRBMath__MulDivSignedInputTooSmall();\n\n/// @notice Emitted when the intermediary absolute result overflows int256.\nerror PRBMath__MulDivSignedOverflow(uint256 rAbs);\n\n/// @notice Emitted when the input is MIN_SD59x18.\nerror PRBMathSD59x18__AbsInputTooSmall();\n\n/// @notice Emitted when ceiling a number overflows SD59x18.\nerror PRBMathSD59x18__CeilOverflow(int256 x);\n\n/// @notice Emitted when one of the inputs is MIN_SD59x18.\nerror PRBMathSD59x18__DivInputTooSmall();\n\n/// @notice Emitted when one of the intermediary unsigned results overflows SD59x18.\nerror PRBMathSD59x18__DivOverflow(uint256 rAbs);\n\n/// @notice Emitted when the input is greater than 133.084258667509499441.\nerror PRBMathSD59x18__ExpInputTooBig(int256 x);\n\n/// @notice Emitted when the input is greater than 192.\nerror PRBMathSD59x18__Exp2InputTooBig(int256 x);\n\n/// @notice Emitted when flooring a number underflows SD59x18.\nerror PRBMathSD59x18__FloorUnderflow(int256 x);\n\n/// @notice Emitted when converting a basic integer to the fixed-point format overflows SD59x18.\nerror PRBMathSD59x18__FromIntOverflow(int256 x);\n\n/// @notice Emitted when converting a basic integer to the fixed-point format underflows SD59x18.\nerror PRBMathSD59x18__FromIntUnderflow(int256 x);\n\n/// @notice Emitted when the product of the inputs is negative.\nerror PRBMathSD59x18__GmNegativeProduct(int256 x, int256 y);\n\n/// @notice Emitted when multiplying the inputs overflows SD59x18.\nerror PRBMathSD59x18__GmOverflow(int256 x, int256 y);\n\n/// @notice Emitted when the input is less than or equal to zero.\nerror PRBMathSD59x18__LogInputTooSmall(int256 x);\n\n/// @notice Emitted when one of the inputs is MIN_SD59x18.\nerror PRBMathSD59x18__MulInputTooSmall();\n\n/// @notice Emitted when the intermediary absolute result overflows SD59x18.\nerror PRBMathSD59x18__MulOverflow(uint256 rAbs);\n\n/// @notice Emitted when the intermediary absolute result overflows SD59x18.\nerror PRBMathSD59x18__PowuOverflow(uint256 rAbs);\n\n/// @notice Emitted when the input is negative.\nerror PRBMathSD59x18__SqrtNegativeInput(int256 x);\n\n/// @notice Emitted when the calculating the square root overflows SD59x18.\nerror PRBMathSD59x18__SqrtOverflow(int256 x);\n\n/// @notice Emitted when addition overflows UD60x18.\nerror PRBMathUD60x18__AddOverflow(uint256 x, uint256 y);\n\n/// @notice Emitted when ceiling a number overflows UD60x18.\nerror PRBMathUD60x18__CeilOverflow(uint256 x);\n\n/// @notice Emitted when the input is greater than 133.084258667509499441.\nerror PRBMathUD60x18__ExpInputTooBig(uint256 x);\n\n/// @notice Emitted when the input is greater than 192.\nerror PRBMathUD60x18__Exp2InputTooBig(uint256 x);\n\n/// @notice Emitted when converting a basic integer to the fixed-point format format overflows UD60x18.\nerror PRBMathUD60x18__FromUintOverflow(uint256 x);\n\n/// @notice Emitted when multiplying the inputs overflows UD60x18.\nerror PRBMathUD60x18__GmOverflow(uint256 x, uint256 y);\n\n/// @notice Emitted when the input is less than 1.\nerror PRBMathUD60x18__LogInputTooSmall(uint256 x);\n\n/// @notice Emitted when the calculating the square root overflows UD60x18.\nerror PRBMathUD60x18__SqrtOverflow(uint256 x);\n\n/// @notice Emitted when subtraction underflows UD60x18.\nerror PRBMathUD60x18__SubUnderflow(uint256 x, uint256 y);\n\n/// @dev Common mathematical functions used in both PRBMathSD59x18 and PRBMathUD60x18. Note that this shared library\n/// does not always assume the signed 59.18-decimal fixed-point or the unsigned 60.18-decimal fixed-point\n/// representation. When it does not, it is explicitly mentioned in the NatSpec documentation.\nlibrary PRBMath {\n    /// STRUCTS ///\n\n    struct SD59x18 {\n        int256 value;\n    }\n\n    struct UD60x18 {\n        uint256 value;\n    }\n\n    /// STORAGE ///\n\n    /// @dev How many trailing decimals can be represented.\n    uint256 internal constant SCALE = 1e18;\n\n    /// @dev Largest power of two divisor of SCALE.\n    uint256 internal constant SCALE_LPOTD = 262144;\n\n    /// @dev SCALE inverted mod 2^256.\n    uint256 internal constant SCALE_INVERSE =\n        78156646155174841979727994598816262306175212592076161876661_508869554232690281;\n\n    /// FUNCTIONS ///\n\n    /// @notice Calculates the binary exponent of x using the binary fraction method.\n    /// @dev Has to use 192.64-bit fixed-point numbers.\n    /// See https://ethereum.stackexchange.com/a/96594/24693.\n    /// @param x The exponent as an unsigned 192.64-bit fixed-point number.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\n    function exp2(uint256 x) internal pure returns (uint256 result) {\n        unchecked {\n            // Start from 0.5 in the 192.64-bit fixed-point format.\n            result = 0x800000000000000000000000000000000000000000000000;\n\n            // Multiply the result by root(2, 2^-i) when the bit at position i is 1. None of the intermediary results overflows\n            // because the initial result is 2^191 and all magic factors are less than 2^65.\n            if (x & 0x8000000000000000 > 0) {\n                result = (result * 0x16A09E667F3BCC909) >> 64;\n            }\n            if (x & 0x4000000000000000 > 0) {\n                result = (result * 0x1306FE0A31B7152DF) >> 64;\n            }\n            if (x & 0x2000000000000000 > 0) {\n                result = (result * 0x1172B83C7D517ADCE) >> 64;\n            }\n            if (x & 0x1000000000000000 > 0) {\n                result = (result * 0x10B5586CF9890F62A) >> 64;\n            }\n            if (x & 0x800000000000000 > 0) {\n                result = (result * 0x1059B0D31585743AE) >> 64;\n            }\n            if (x & 0x400000000000000 > 0) {\n                result = (result * 0x102C9A3E778060EE7) >> 64;\n            }\n            if (x & 0x200000000000000 > 0) {\n                result = (result * 0x10163DA9FB33356D8) >> 64;\n            }\n            if (x & 0x100000000000000 > 0) {\n                result = (result * 0x100B1AFA5ABCBED61) >> 64;\n            }\n            if (x & 0x80000000000000 > 0) {\n                result = (result * 0x10058C86DA1C09EA2) >> 64;\n            }\n            if (x & 0x40000000000000 > 0) {\n                result = (result * 0x1002C605E2E8CEC50) >> 64;\n            }\n            if (x & 0x20000000000000 > 0) {\n                result = (result * 0x100162F3904051FA1) >> 64;\n            }\n            if (x & 0x10000000000000 > 0) {\n                result = (result * 0x1000B175EFFDC76BA) >> 64;\n            }\n            if (x & 0x8000000000000 > 0) {\n                result = (result * 0x100058BA01FB9F96D) >> 64;\n            }\n            if (x & 0x4000000000000 > 0) {\n                result = (result * 0x10002C5CC37DA9492) >> 64;\n            }\n            if (x & 0x2000000000000 > 0) {\n                result = (result * 0x1000162E525EE0547) >> 64;\n            }\n            if (x & 0x1000000000000 > 0) {\n                result = (result * 0x10000B17255775C04) >> 64;\n            }\n            if (x & 0x800000000000 > 0) {\n                result = (result * 0x1000058B91B5BC9AE) >> 64;\n            }\n            if (x & 0x400000000000 > 0) {\n                result = (result * 0x100002C5C89D5EC6D) >> 64;\n            }\n            if (x & 0x200000000000 > 0) {\n                result = (result * 0x10000162E43F4F831) >> 64;\n            }\n            if (x & 0x100000000000 > 0) {\n                result = (result * 0x100000B1721BCFC9A) >> 64;\n            }\n            if (x & 0x80000000000 > 0) {\n                result = (result * 0x10000058B90CF1E6E) >> 64;\n            }\n            if (x & 0x40000000000 > 0) {\n                result = (result * 0x1000002C5C863B73F) >> 64;\n            }\n            if (x & 0x20000000000 > 0) {\n                result = (result * 0x100000162E430E5A2) >> 64;\n            }\n            if (x & 0x10000000000 > 0) {\n                result = (result * 0x1000000B172183551) >> 64;\n            }\n            if (x & 0x8000000000 > 0) {\n                result = (result * 0x100000058B90C0B49) >> 64;\n            }\n            if (x & 0x4000000000 > 0) {\n                result = (result * 0x10000002C5C8601CC) >> 64;\n            }\n            if (x & 0x2000000000 > 0) {\n                result = (result * 0x1000000162E42FFF0) >> 64;\n            }\n            if (x & 0x1000000000 > 0) {\n                result = (result * 0x10000000B17217FBB) >> 64;\n            }\n            if (x & 0x800000000 > 0) {\n                result = (result * 0x1000000058B90BFCE) >> 64;\n            }\n            if (x & 0x400000000 > 0) {\n                result = (result * 0x100000002C5C85FE3) >> 64;\n            }\n            if (x & 0x200000000 > 0) {\n                result = (result * 0x10000000162E42FF1) >> 64;\n            }\n            if (x & 0x100000000 > 0) {\n                result = (result * 0x100000000B17217F8) >> 64;\n            }\n            if (x & 0x80000000 > 0) {\n                result = (result * 0x10000000058B90BFC) >> 64;\n            }\n            if (x & 0x40000000 > 0) {\n                result = (result * 0x1000000002C5C85FE) >> 64;\n            }\n            if (x & 0x20000000 > 0) {\n                result = (result * 0x100000000162E42FF) >> 64;\n            }\n            if (x & 0x10000000 > 0) {\n                result = (result * 0x1000000000B17217F) >> 64;\n            }\n            if (x & 0x8000000 > 0) {\n                result = (result * 0x100000000058B90C0) >> 64;\n            }\n            if (x & 0x4000000 > 0) {\n                result = (result * 0x10000000002C5C860) >> 64;\n            }\n            if (x & 0x2000000 > 0) {\n                result = (result * 0x1000000000162E430) >> 64;\n            }\n            if (x & 0x1000000 > 0) {\n                result = (result * 0x10000000000B17218) >> 64;\n            }\n            if (x & 0x800000 > 0) {\n                result = (result * 0x1000000000058B90C) >> 64;\n            }\n            if (x & 0x400000 > 0) {\n                result = (result * 0x100000000002C5C86) >> 64;\n            }\n            if (x & 0x200000 > 0) {\n                result = (result * 0x10000000000162E43) >> 64;\n            }\n            if (x & 0x100000 > 0) {\n                result = (result * 0x100000000000B1721) >> 64;\n            }\n            if (x & 0x80000 > 0) {\n                result = (result * 0x10000000000058B91) >> 64;\n            }\n            if (x & 0x40000 > 0) {\n                result = (result * 0x1000000000002C5C8) >> 64;\n            }\n            if (x & 0x20000 > 0) {\n                result = (result * 0x100000000000162E4) >> 64;\n            }\n            if (x & 0x10000 > 0) {\n                result = (result * 0x1000000000000B172) >> 64;\n            }\n            if (x & 0x8000 > 0) {\n                result = (result * 0x100000000000058B9) >> 64;\n            }\n            if (x & 0x4000 > 0) {\n                result = (result * 0x10000000000002C5D) >> 64;\n            }\n            if (x & 0x2000 > 0) {\n                result = (result * 0x1000000000000162E) >> 64;\n            }\n            if (x & 0x1000 > 0) {\n                result = (result * 0x10000000000000B17) >> 64;\n            }\n            if (x & 0x800 > 0) {\n                result = (result * 0x1000000000000058C) >> 64;\n            }\n            if (x & 0x400 > 0) {\n                result = (result * 0x100000000000002C6) >> 64;\n            }\n            if (x & 0x200 > 0) {\n                result = (result * 0x10000000000000163) >> 64;\n            }\n            if (x & 0x100 > 0) {\n                result = (result * 0x100000000000000B1) >> 64;\n            }\n            if (x & 0x80 > 0) {\n                result = (result * 0x10000000000000059) >> 64;\n            }\n            if (x & 0x40 > 0) {\n                result = (result * 0x1000000000000002C) >> 64;\n            }\n            if (x & 0x20 > 0) {\n                result = (result * 0x10000000000000016) >> 64;\n            }\n            if (x & 0x10 > 0) {\n                result = (result * 0x1000000000000000B) >> 64;\n            }\n            if (x & 0x8 > 0) {\n                result = (result * 0x10000000000000006) >> 64;\n            }\n            if (x & 0x4 > 0) {\n                result = (result * 0x10000000000000003) >> 64;\n            }\n            if (x & 0x2 > 0) {\n                result = (result * 0x10000000000000001) >> 64;\n            }\n            if (x & 0x1 > 0) {\n                result = (result * 0x10000000000000001) >> 64;\n            }\n\n            // We're doing two things at the same time:\n            //\n            //   1. Multiply the result by 2^n + 1, where \"2^n\" is the integer part and the one is added to account for\n            //      the fact that we initially set the result to 0.5. This is accomplished by subtracting from 191\n            //      rather than 192.\n            //   2. Convert the result to the unsigned 60.18-decimal fixed-point format.\n            //\n            // This works because 2^(191-ip) = 2^ip / 2^191, where \"ip\" is the integer part \"2^n\".\n            result *= SCALE;\n            result >>= (191 - (x >> 64));\n        }\n    }\n\n    /// @notice Finds the zero-based index of the first one in the binary representation of x.\n    /// @dev See the note on msb in the \"Find First Set\" Wikipedia article https://en.wikipedia.org/wiki/Find_first_set\n    /// @param x The uint256 number for which to find the index of the most significant bit.\n    /// @return msb The index of the most significant bit as an uint256.\n    function mostSignificantBit(uint256 x) internal pure returns (uint256 msb) {\n        if (x >= 2**128) {\n            x >>= 128;\n            msb += 128;\n        }\n        if (x >= 2**64) {\n            x >>= 64;\n            msb += 64;\n        }\n        if (x >= 2**32) {\n            x >>= 32;\n            msb += 32;\n        }\n        if (x >= 2**16) {\n            x >>= 16;\n            msb += 16;\n        }\n        if (x >= 2**8) {\n            x >>= 8;\n            msb += 8;\n        }\n        if (x >= 2**4) {\n            x >>= 4;\n            msb += 4;\n        }\n        if (x >= 2**2) {\n            x >>= 2;\n            msb += 2;\n        }\n        if (x >= 2**1) {\n            // No need to shift x any more.\n            msb += 1;\n        }\n    }\n\n    /// @notice Calculates floor(x*y÷denominator) with full precision.\n    ///\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv.\n    ///\n    /// Requirements:\n    /// - The denominator cannot be zero.\n    /// - The result must fit within uint256.\n    ///\n    /// Caveats:\n    /// - This function does not work with fixed-point numbers.\n    ///\n    /// @param x The multiplicand as an uint256.\n    /// @param y The multiplier as an uint256.\n    /// @param denominator The divisor as an uint256.\n    /// @return result The result as an uint256.\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n        // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n        // variables such that product = prod1 * 2^256 + prod0.\n        uint256 prod0; // Least significant 256 bits of the product\n        uint256 prod1; // Most significant 256 bits of the product\n        assembly {\n            let mm := mulmod(x, y, not(0))\n            prod0 := mul(x, y)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n\n        // Handle non-overflow cases, 256 by 256 division.\n        if (prod1 == 0) {\n            unchecked {\n                result = prod0 / denominator;\n            }\n            return result;\n        }\n\n        // Make sure the result is less than 2^256. Also prevents denominator == 0.\n        if (prod1 >= denominator) {\n            revert PRBMath__MulDivOverflow(prod1, denominator);\n        }\n\n        ///////////////////////////////////////////////\n        // 512 by 256 division.\n        ///////////////////////////////////////////////\n\n        // Make division exact by subtracting the remainder from [prod1 prod0].\n        uint256 remainder;\n        assembly {\n            // Compute remainder using mulmod.\n            remainder := mulmod(x, y, denominator)\n\n            // Subtract 256 bit number from 512 bit number.\n            prod1 := sub(prod1, gt(remainder, prod0))\n            prod0 := sub(prod0, remainder)\n        }\n\n        // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n        // See https://cs.stackexchange.com/q/138556/92363.\n        unchecked {\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 lpotdod = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by lpotdod.\n                denominator := div(denominator, lpotdod)\n\n                // Divide [prod1 prod0] by lpotdod.\n                prod0 := div(prod0, lpotdod)\n\n                // Flip lpotdod such that it is 2^256 / lpotdod. If lpotdod is zero, then it becomes one.\n                lpotdod := add(div(sub(0, lpotdod), lpotdod), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * lpotdod;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /// @notice Calculates floor(x*y÷1e18) with full precision.\n    ///\n    /// @dev Variant of \"mulDiv\" with constant folding, i.e. in which the denominator is always 1e18. Before returning the\n    /// final result, we add 1 if (x * y) % SCALE >= HALF_SCALE. Without this, 6.6e-19 would be truncated to 0 instead of\n    /// being rounded to 1e-18.  See \"Listing 6\" and text above it at https://accu.org/index.php/journals/1717.\n    ///\n    /// Requirements:\n    /// - The result must fit within uint256.\n    ///\n    /// Caveats:\n    /// - The body is purposely left uncommented; see the NatSpec comments in \"PRBMath.mulDiv\" to understand how this works.\n    /// - It is assumed that the result can never be type(uint256).max when x and y solve the following two equations:\n    ///     1. x * y = type(uint256).max * SCALE\n    ///     2. (x * y) % SCALE >= SCALE / 2\n    ///\n    /// @param x The multiplicand as an unsigned 60.18-decimal fixed-point number.\n    /// @param y The multiplier as an unsigned 60.18-decimal fixed-point number.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\n    function mulDivFixedPoint(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        uint256 prod0;\n        uint256 prod1;\n        assembly {\n            let mm := mulmod(x, y, not(0))\n            prod0 := mul(x, y)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n\n        if (prod1 >= SCALE) {\n            revert PRBMath__MulDivFixedPointOverflow(prod1);\n        }\n\n        uint256 remainder;\n        uint256 roundUpUnit;\n        assembly {\n            remainder := mulmod(x, y, SCALE)\n            roundUpUnit := gt(remainder, 499999999999999999)\n        }\n\n        if (prod1 == 0) {\n            unchecked {\n                result = (prod0 / SCALE) + roundUpUnit;\n                return result;\n            }\n        }\n\n        assembly {\n            result := add(\n                mul(\n                    or(\n                        div(sub(prod0, remainder), SCALE_LPOTD),\n                        mul(sub(prod1, gt(remainder, prod0)), add(div(sub(0, SCALE_LPOTD), SCALE_LPOTD), 1))\n                    ),\n                    SCALE_INVERSE\n                ),\n                roundUpUnit\n            )\n        }\n    }\n\n    /// @notice Calculates floor(x*y÷denominator) with full precision.\n    ///\n    /// @dev An extension of \"mulDiv\" for signed numbers. Works by computing the signs and the absolute values separately.\n    ///\n    /// Requirements:\n    /// - None of the inputs can be type(int256).min.\n    /// - The result must fit within int256.\n    ///\n    /// @param x The multiplicand as an int256.\n    /// @param y The multiplier as an int256.\n    /// @param denominator The divisor as an int256.\n    /// @return result The result as an int256.\n    function mulDivSigned(\n        int256 x,\n        int256 y,\n        int256 denominator\n    ) internal pure returns (int256 result) {\n        if (x == type(int256).min || y == type(int256).min || denominator == type(int256).min) {\n            revert PRBMath__MulDivSignedInputTooSmall();\n        }\n\n        // Get hold of the absolute values of x, y and the denominator.\n        uint256 ax;\n        uint256 ay;\n        uint256 ad;\n        unchecked {\n            ax = x < 0 ? uint256(-x) : uint256(x);\n            ay = y < 0 ? uint256(-y) : uint256(y);\n            ad = denominator < 0 ? uint256(-denominator) : uint256(denominator);\n        }\n\n        // Compute the absolute value of (x*y)÷denominator. The result must fit within int256.\n        uint256 rAbs = mulDiv(ax, ay, ad);\n        if (rAbs > uint256(type(int256).max)) {\n            revert PRBMath__MulDivSignedOverflow(rAbs);\n        }\n\n        // Get the signs of x, y and the denominator.\n        uint256 sx;\n        uint256 sy;\n        uint256 sd;\n        assembly {\n            sx := sgt(x, sub(0, 1))\n            sy := sgt(y, sub(0, 1))\n            sd := sgt(denominator, sub(0, 1))\n        }\n\n        // XOR over sx, sy and sd. This is checking whether there are one or three negative signs in the inputs.\n        // If yes, the result should be negative.\n        result = sx ^ sy ^ sd == 0 ? -int256(rAbs) : int256(rAbs);\n    }\n\n    /// @notice Calculates the square root of x, rounding down.\n    /// @dev Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\n    ///\n    /// Caveats:\n    /// - This function does not work with fixed-point numbers.\n    ///\n    /// @param x The uint256 number for which to calculate the square root.\n    /// @return result The result as an uint256.\n    function sqrt(uint256 x) internal pure returns (uint256 result) {\n        if (x == 0) {\n            return 0;\n        }\n\n        // Set the initial guess to the least power of two that is greater than or equal to sqrt(x).\n        uint256 xAux = uint256(x);\n        result = 1;\n        if (xAux >= 0x100000000000000000000000000000000) {\n            xAux >>= 128;\n            result <<= 64;\n        }\n        if (xAux >= 0x10000000000000000) {\n            xAux >>= 64;\n            result <<= 32;\n        }\n        if (xAux >= 0x100000000) {\n            xAux >>= 32;\n            result <<= 16;\n        }\n        if (xAux >= 0x10000) {\n            xAux >>= 16;\n            result <<= 8;\n        }\n        if (xAux >= 0x100) {\n            xAux >>= 8;\n            result <<= 4;\n        }\n        if (xAux >= 0x10) {\n            xAux >>= 4;\n            result <<= 2;\n        }\n        if (xAux >= 0x4) {\n            result <<= 1;\n        }\n\n        // The operations can never overflow because the result is max 2^127 when it enters this block.\n        unchecked {\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1; // Seven iterations should be enough\n            uint256 roundedDownResult = x / result;\n            return result >= roundedDownResult ? roundedDownResult : result;\n        }\n    }\n}"
    },
    "contracts/stablecoin/IController.sol": {
      "content": "pragma solidity ^0.8.4;\n\n\n//controller contract responsible for providing initial liquidity to the\n//borrower cds market, collect winnings when default, and burn the corresponding DS\ninterface IController  {\n    struct MarketInfo {\n        address borrower;\n        address ammFactoryAddress; \n        address marketFactoryAddress;\n        uint256 liquidityAmountUSD;\n        uint256 marketID;\n        string description;\n        string[] names;\n        uint256[] odds;\n    }\n    \n    function verifyAddress(\n        uint256 nullifier_hash, \n        uint256 external_nullifier,\n        uint256[8] calldata proof\n    ) external;\n\n    function mintRepNFT(address NFT_address, address trader) external;\n\n    function addValidator(address validator_address) external;\n\n    function validators(address addr) external returns (bool);\n    \n    function verified(address addr) external returns (bool);\n\n\n    function initiateMarket_(\n        MarketInfo memory marketData, // marketID shouldn't be set. Everything else should be though\n        address recipient,\n        bytes32 loanID, \n        address bonding_curve_address, \n        address market_manager_address\n    ) external;\n\n\n    function resolveMarket_(\n        address recipient,\n        bytes32 loanID,\n        bool atLoss,\n        uint256 extra_gain, \n        uint256 principal_loss, \n        address market_manager_address\n    ) external;\n\n    function denyMarket(\n        address recipient,\n        bytes32 loanID,\n        uint256 marketId, \n        address market_manager_address\n    ) external;\n\n    function approveLoan(address recipient, bytes32 id, address marketFactory) external;\n\n    function canBeApproved(address borrower, \n        bytes32 loanID, \n        address marketFactoryAddress ) external returns(bool);\n\n    \n\n}"
    },
    "contracts/stablecoin/marketmanager.sol": {
      "content": "pragma solidity ^0.8.4;\n\nimport \"./owned.sol\";\nimport \"../turbo/AMMFactory.sol\"; \nimport \"./reputationtoken.sol\"; \nimport {BondingCurve} from \"../bonds/bondingcurve.sol\";\nimport {Controller} from \"./controller.sol\";\nimport \"./IMarketManager.sol\";\nimport \"hardhat/console.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../prb/PRBMathUD60x18.sol\";\n\n\n\ncontract MarketManager is Owned {\n\t/*Wrapper contract for bondingcurve markets, trades are restricted/funneled through here\n\t\tTypes of restrictions are \n\t\t1) Being verified \n\t\t2) reputation to buy early \n\n\t\t4) Restriction to quantity \n\n\tMisc. \n\t\ta) To avoid securitization, enforce selling Fee  \n\t*/\n\tusing PRBMathUD60x18 for uint256;\n\n    uint256 private constant PRICE_PRECISION = 1e6; \n\n\tReputationNFT rep;\n  Controller controller;\n\n  mapping(uint256=>uint256) private redemption_prices; //redemption price for each market, set when market resolves \n  mapping(uint256=>mapping(address=>uint256)) private assessment_collaterals;  //marketId-> trader->collateralIn\n  mapping(uint256=>mapping(address=>uint256)) private assessment_prices; \n  mapping(uint256=>mapping(address=>bool)) private assessment_trader; \n\tmapping(uint256=> MarketPhaseData) restriction_data; // market ID => restriction data\n\tmapping(uint256=> uint256) collateral_pot; // marketID => total collateral recieved (? isn't this redundant bc bonding curves fundsperBonds)\n\tmapping(uint256=> CDP) private debt_pools; // marketID => debt info\n\n\tstruct CDP{\n\t\tmapping(address=>address) collateral_address; \n\t\tmapping(address=>uint256) collateral_amount;\n\t\tmapping(address=>uint256) borrowed_amount; \n\t\tuint256 total_debt; \n\t\tuint256 total_collateral; //only usdc \n\t}\n\n\tstruct MarketPhaseData {\n\t\tbool duringMarketAssessment;\n\t\tbool onlyReputable;\n\t\tbool marketDenied;\n\t\tuint256 min_rep_score;\n\t\tbool atLoss; \n\t\t// buy threshold should be the max quantity of bond tokesn bought\n\t}\n\n\tuint256 private INSURANCE_CONSTANT = 5 * 10**5; // 0.5 for DS decimal format.\n\tuint256 private REPUTATION_CONSTANT = 3 * 10**5; \n\tuint256 private base_budget; \n\n  modifier onlyController(){\n      require(address(controller) == msg.sender || msg.sender == owner || msg.sender == address(this), \"is not controller\"); \n      _;\n  }\n\n\tconstructor(\n\t\taddress _creator_address,\n\t\taddress reputationNFTaddress,  \n\t\taddress _controllerAddress\n\t) Owned(_creator_address){\n\t\trep = ReputationNFT(reputationNFTaddress);\n\t\tcontroller = Controller(_controllerAddress);\n\t\tbase_budget = 100*PRICE_PRECISION; \n\t}\n\n\t/*----Phase Functions----*/\n\n\t/*\n\t1.When Market is intialized, set both params as true\n\t2.When reputation constant bought, change _onlyReputable to false \n\t3.When validator approves, set _duringMarketAssessment to false\n\t*/\n\tfunction setAssessmentPhase(\n\t\tuint256 marketId, \n\t\tbool _duringMarketAssessment,\n\t\tbool _onlyReputable\n\t) external  onlyController {\n\t\tMarketPhaseData storage data = restriction_data[marketId]; \n\t\tdata.onlyReputable = _onlyReputable; \n\t\tdata.duringMarketAssessment = _duringMarketAssessment; \n\t}\n\n\t/* \n\tCalled when market should end, a) when denied b) when maturity \n\t*/\n\tfunction deactivateMarket(uint256 marketId, bool atLoss) external  onlyController{\n\t\trestriction_data[marketId].marketDenied = true; \n\t\trestriction_data[marketId].atLoss = atLoss; \n\n\t}\n\n\n\t/**\n\t@dev Sets reputation score requirements and for the market, called by the controller when\n\tmarket is initiated. Buy threshold is set after the assessment is completed \n\t */\n\tfunction setMarketRestrictionData(\n\t\tbool _duringMarketAssessment,\n\t\tbool _onlyReputable, \n\t\tuint256 marketId, \n\t\tuint256 min_rep_score\n\t) external  onlyController {\n\t\tmin_rep_score = getMinRepScore(marketId);\n\t\trestriction_data[marketId] = MarketPhaseData(\n\t\t\t_duringMarketAssessment, \n\t\t\t_onlyReputable,\n\t\t\tfalse,\n\t\t\tmin_rep_score, \n\t\t\tfalse\n\t\t);\n\t}\n\n\t/*---View Functions---*/\n\n\t/* \n\tReturns Minimal reputation score to participate in the onlyReputation phase\n\tTODO\n\t*/\n\tfunction getMinRepScore(uint256 marketId) internal view returns(uint256){\n\t\treturn restriction_data[marketId].min_rep_score;\n\t}\n\n\t/* Conditions */\n \t\n\t/**\n\t @dev verification of trader initializes reputation score at 0, to gain reputation need to participate in markets.\n\t */\n\tfunction isVerified(address trader) public view returns(bool){\n\t\treturn (controller.isVerified(trader) || trader == owner);\n\t\t//return (rep.balanceOf(trader) >= 1 || trader == owner); \n\t}\n\n\n\tfunction isReputable(address trader, uint256 marketId) public view returns(bool){\n\t\treturn (restriction_data[marketId].min_rep_score <= rep.getReputationScore(trader) || trader == owner); \n\t}\n\n\t/*\n\tReturns true if during risk assessment phase\n\t*/\n\tfunction duringMarketAssessment(\n\t\tuint256 marketId) public view returns(bool){\n\t\treturn restriction_data[marketId].duringMarketAssessment; \n\t}\n\n\t/*\n\tReturns true when market only allows reputable traders\n\t*/\n\tfunction onlyReputable(\n\t\tuint256 marketId\n\t\t) public view returns(bool){\n\t\treturn restriction_data[marketId].onlyReputable; \n\n\t}\n\n\tfunction isMarketApproved(uint256 marketId) public view returns(bool){\n\t\treturn(!restriction_data[marketId].duringMarketAssessment && !restriction_data[marketId].marketDenied); \n\t\t\n\t}\n\n\t//TODO Need to find out if the given market has enough (liquidity-required liq)\n\tfunction exposureSet(address trader, address ammFactoryAddress, address marketId) internal view returns(bool){\n\t\treturn true; \n\t}\n\n\tfunction marketActive(uint256 marketId) public view returns(bool){\n\t\treturn !restriction_data[marketId].marketDenied; \n\t}\n\n\t/// @notice returns true if amount bought is greater than the insurance threshold\n\tfunction marketCondition(uint256 marketId) public view returns(bool){\n\t\tuint256 principal = controller.vault().fetchInstrumentData(marketId).principal;\n\t\tuint256 total_bought = BondingCurve(address(controller.getZCB(marketId))).getTotalCollateral();\n\t\treturn (total_bought >= (principal * INSURANCE_CONSTANT)/PRICE_PRECISION); \n\t}\n\n\n\tfunction getDebtPosition(address trader, uint256 marketId) public view returns(uint256, uint256){\n\t\tCDP storage cdp = debt_pools[marketId];\n\t\treturn (cdp.collateral_amount[trader], cdp.borrowed_amount[trader]);\n\t}\n\n\t/// @notice get trade budget = f(reputation)\n\t/// sqrt for now \n\tfunction getTraderBudget(address trader) public view returns(uint256){\n\t\tuint256 repscore = rep.getReputationScore(trader); \n\t\treturn sqrt(repscore) + base_budget; \n  \t\n\t}\n \t\n \t/// @notice computes the price for ZCB one needs to short at to completely\n \t/// hedge for the case of maximal loss, function of principal and interest\n\tfunction getHedgePrice(uint256 marketId) public view returns(uint256){\n\t\tuint256 principal = controller.vault().fetchInstrumentData(marketId).principal; \n\t\tuint256 yield = controller.vault().fetchInstrumentData(marketId).expectedYield; \n\n\t\tuint256 den = (principal * (PRICE_PRECISION - INSURANCE_CONSTANT))/PRICE_PRECISION; \n\t\treturn PRICE_PRECISION -  (yield*PRICE_PRECISION)/den;\n\n\t}\n\n\t/// @notice computes maximum amount of quantity that trader can short while being hedged\n\t/// such that when he loses his loss will be offset by his gains  \n\tfunction getHedgeQuantity(address trader, uint256 marketId) public view returns(uint256){\n\t\tuint256 principal = controller.vault().fetchInstrumentData(marketId).principal; \n\t\tuint256 holdings =  controller.vault().balanceOf(trader);\n\t\tuint256 marketCap = controller.vault().totalSupply(); \n\t\tuint num = (principal * (PRICE_PRECISION - INSURANCE_CONSTANT)/PRICE_PRECISION) * holdings; \n\t\treturn num/marketCap; \n\t}\t\n\n\t\n\tfunction canBuy(\n\t\taddress trader,\n\t\tuint256 amount, //this is in DS with decimals.\n\t\tuint256 marketId\n\t) public returns(bool, uint) {\n\t\trequire(marketActive(marketId), \"Market Not Active\"); \n\t\tbool _duringMarketAssessment = duringMarketAssessment(marketId);\n\t\tbool _onlyReputable =  onlyReputable(marketId);\n\n\t\tif (_duringMarketAssessment){\n\t\t\tif (!isVerified(trader) || !(getTraderBudget(trader)>= amount)) return (false, 0); \n\t\n\t\t}\n\n  \t\t//During the early risk assessment phase only reputable can buy \n\t\tif (_onlyReputable){\n\t\t\trequire(_duringMarketAssessment, \"Market needs to be in assessment phase\"); \n\t\t\tif (!isReputable(trader, marketId)) return (false, 1); \n\t\t}\n\n\t\t//If after assessment there is a set buy threshold, people can't buy above this threshold\n\t\tif (!_duringMarketAssessment){\n\t\t\n\t\t\tBondingCurve zcb = BondingCurve(address(controller.getZCB(marketId)));\n\t\t\tuint256 tokens_bought = zcb.calculatePurchaseReturn(amount);\n\t\t\tuint256 price_after_trade = zcb.calculateExpectedPrice(tokens_bought);\n\t\t\tuint256 price_upper_bound = zcb.getUpperBound();\n\t\t\trequire(price_upper_bound > 0, \"Restrictions need to be set\"); \n\t\t\tif (price_upper_bound > price_after_trade) return (false, 2); \n\t\t}\n\n\t\treturn (true, 0); \n\t\t// require(_duringMarketAssessment, \"Sells not allowed during assessments\");\n\t\t// require(exposureset(trader, ammFactoryAddress, marketId), \"Not enough liquidity\");\n\n\t}\n\n\tfunction canSell(\n\t\taddress trader,\n\t\tuint256 amount, \n\t\tuint256 marketId\n\t) internal view returns(bool) {\n\t\trequire(marketActive(marketId), \"Market Not Active\"); \n\t\tbool _duringMarketAssessment = duringMarketAssessment( marketId);\n\t\tif (_duringMarketAssessment){\n\t\t\trequire(isVerified(trader), \"User Not Verified\");\n\t\t}\n\t\treturn true; \n\t}\n\n\t\n\n\t/// @notice During assessment phase, need to log the trader's \n\t/// total collateral when he bought zcb. Trader can only redeem collateral in \n\t/// when market is not approved \n\t/// @param priceOut is the price of the zcb after the trader made his trade\n\tfunction log_assessment_trade(\n\t\tuint256 marketId, \n\t\taddress trader, \n\t\tuint256 amountOut, \n\t\tuint256 collateralIn,\n\t\tuint256 priceOut)\n\t\tinternal \n\t{\t\n\t\tassessment_trader[marketId][trader] = true; \n\t\tassessment_collaterals[marketId][trader] = collateralIn;\n\t\tassessment_prices[marketId][trader] = priceOut; \n\n\t}\n\n\t/* \n\tAfter market is denied, redeem every zcb trader has for his collateral \n\t*/\n\tfunction redeemPostAssessment(\n\t\tuint256 marketId, \n\t\taddress trader \n\t) public {\n\t\trequire(restriction_data[marketId].marketDenied, \"Market Still During Assessment\");\n\t\tuint256 collateral_amount = assessment_collaterals[marketId][trader]; \n\t\tBondingCurve zcb = BondingCurve(address(controller.getZCB(marketId))); // SOMEHOW GET ZCB\n\t\tzcb.redeemPostAssessment(trader, collateral_amount); // SOMEHOW GET ZCB\n\t}\n\n\t/// @notice denies market from validator \n\tfunction denyMarket(\n\t\tuint256 marketId\n\t) external  onlyController {\n\t\trequire(marketActive(marketId), \"Market Not Active\"); \n\t\trequire(restriction_data[marketId].duringMarketAssessment, \"Not in assessment\"); \n\t\tMarketPhaseData storage data = restriction_data[marketId]; \n\t\tdata.marketDenied = true; \n\t\tdata.duringMarketAssessment = false; \n\t}\n\n\n\n\tfunction buy(\n        uint256 _marketId,\n        uint256 _collateralIn\n    ) external  returns (uint256){\n\t\t(bool canbuy, uint256 error) = canBuy(msg.sender, _collateralIn, _marketId); \n\t\trequire(canbuy,\"Trade Restricted\");\n\n\n\t\tBondingCurve zcb = BondingCurve(address(controller.getZCB(_marketId))); // SOMEHOW GET ZCB\n\t\tuint256 amountOut = zcb.trustedBuy(msg.sender, _collateralIn);\n \n \t\t//Need to log assessment trades for updating reputation scores or returning collateral\n \t\t//when market denied \n\t\tif (duringMarketAssessment(_marketId)){\n\t\t\tuint256 priceOut = zcb.calculateExpectedPrice(0); \n\t\t\tlog_assessment_trade(_marketId, msg.sender, amountOut, _collateralIn, priceOut);\n\n\t\t\t//  keeps track of amount bought during reputation phase\n\t\t\t// and make transitions from onlyReputation true->false\n\t\t\tuint256 principal = controller.vault().fetchInstrumentData(_marketId).principal;\n\t\t\tuint256 total_bought = zcb.getTotalCollateral();\n\n\t\t\tif (onlyReputable(_marketId)){\n\n\t\t\t\tif (total_bought > (REPUTATION_CONSTANT * principal)/PRICE_PRECISION){\n\t\t\t\t\tthis.setAssessmentPhase(_marketId, true, false); \n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn amountOut; \n\t}\n\n\n\tfunction sell(\n        uint256 _marketId,\n        uint256 _zcb_amount_in\n    ) external  returns (uint256){\n\n\t\trequire(canSell(msg.sender, \n\t\t \t_zcb_amount_in, \n\t\t \t_marketId),\"Trade Restricted\");\n\n\t\tBondingCurve zcb = BondingCurve(address(controller.getZCB(_marketId))); // SOMEHOW GET ZCB\n\t\tuint256 amountOut = zcb.trustedSell(msg.sender, _zcb_amount_in);\n\n\t}\n\n\n\t/* \n\tFor now only allow collateral to be ds\n\t*/\n\tfunction borrow_with_collateral(\n\t\tuint256 _marketId, \n\t\tuint256 requested_zcb, \n\t\taddress trader\n\t\t) external {\n\t\t//1.Use 100 ds as collateral to borrow 100zcb 1:1, only this for now \n\t\t//2.use 0.1eth(170) as collateral to borrow 100zcb =>100/170 collateral ratio\n\t\tBondingCurve zcb = BondingCurve(address(controller.getZCB(_marketId))); // SOMEHOW GET ZCB\n\t\taddress collateral_address = zcb.getCollateral();\n\t\tSafeERC20.safeTransferFrom(IERC20(collateral_address), trader, address(zcb), requested_zcb);\n\n\t\t// SafeERC20.safeTransferFrom(IERC20(collateral_address), trader, address(this), requested_zcb); \n\t\tuint256 _collateralIn = requested_zcb; \n\n\t\tCDP storage cdp = debt_pools[_marketId];\n\t\tcdp.collateral_amount[trader] += _collateralIn; \n\t\tcdp.borrowed_amount[trader] += requested_zcb;  \n\t\tcdp.total_debt += requested_zcb; \n\t\tcdp.total_collateral += _collateralIn; //only ds \n\t\tcollateral_pot[_marketId] += _collateralIn; //Total ds collateral \n\n\t\tzcb.trustedMint(trader, requested_zcb);\n\t}\n\n\t/*\n\tTrader provides zcb and receives back collateral \n\t */\n\tfunction repay_for_collateral(\n\t\tuint256 _marketId, \n\t\tuint256 repaying_zcb, \n\t\taddress trader\n\t) external {\n\t\tBondingCurve zcb = BondingCurve(address(controller.getZCB(_marketId)));\n\t\taddress collateral_address = zcb.getCollateral();\n\t\tzcb.trustedBurn(trader, repaying_zcb);\n\n\t\tuint256 _collateralOut = repaying_zcb; \n\n\t\tCDP storage cdp = debt_pools[_marketId];\n\t\tcdp.collateral_amount[trader] -= _collateralOut;\n\t\tcdp.borrowed_amount[trader] -= repaying_zcb;\n\t\tcdp.total_debt -= repaying_zcb;\n\t\tcdp.total_collateral -= _collateralOut;\n\t\tcollateral_pot[_marketId] -= _collateralOut;\n\n\t\t// SafeERC20.safeTransfer(IERC20(collateral_address), trader, _collateralOut);\n\t\t// zcb needs to approve transfer from itself to trader.\n\t\tzcb.trustedApproveCollateralTransfer(trader, _collateralOut);\n\t\tSafeERC20.safeTransferFrom(IERC20(collateral_address), address(zcb), trader, _collateralOut);\n\t}\n\n\n\n\t/*Maturity Functions */\n\n\n\tfunction get_redemption_price(uint256 marketId) public view returns(uint256){\n\t\treturn redemption_prices[marketId]; \n\t}\n\n\t/**\n\t@dev Redemption price, as calculated at maturity,\n\tdepends on total_repayed/(principal + predetermined yield)\n\tIf total_repayed = 0, redemption price is 0\n\t@param atLoss: defines circumstances where expected returns are higher than actual\n\t@param principal_loss: principal - returned amount => non-negative always?\n\t@param extra_gain: any extra yield not factored during assessment. Is 0 yield is as expected\n\t */\n\tfunction update_redemption_price(\n\t\tuint256 marketId,\n\t\tbool atLoss, \n\t\tuint256 extra_gain, \n\t\tuint256 principal_loss\n\t) external  onlyController {\t\n\n\t\tBondingCurve zcb = BondingCurve(address(controller.getZCB(marketId))); // SOMEHOW GET ZCB\n\t\tuint256 total_bought_collateral = zcb.getTotalCollateral();\n\t\tuint256 total_bought_bonds = zcb.getTotalZCB();\n\n\t\tif (atLoss){\n\t\t\tif (total_bought_collateral - principal_loss > 0){\n\t\t\t\tredemption_prices[marketId] = PRICE_PRECISION - (principal_loss*PRICE_PRECISION/total_bought_bonds);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tredemption_prices[marketId] = 0; \n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\trequire(extra_gain >= 0 && principal_loss ==0,  \"loss err\"); \n\t\t\tuint256 num_shorts = debt_pools[marketId].total_debt; //For now assume that every zcb borrowed is used to short\n\t\t\tredemption_prices[marketId] = PRICE_PRECISION + (extra_gain*PRICE_PRECISION/(total_bought_bonds+num_shorts)); \n\t\t}\t\n\n\t\t\tconsole.log('redemption_price', redemption_prices[marketId]); \n\t\t}\n\n\n\t/* \n\tHandles maturity. Includes default/no defaults\n\tCalled by controller after redemption price has been set \n\t\n\tif default: need to burn the underlying tokens used as collateral to buy the zcb as first loss\n\t*/\n\tfunction handle_maturity(\n\t\tuint256 marketId, \n\t\tbool atLoss, \n\t\tuint256 principal_loss\n\t) external  onlyController {\n\n\t\tBondingCurve zcb =  BondingCurve(address(controller.getZCB(marketId)));\n\n\t\tuint256 redemption_price = get_redemption_price(marketId); \n\t\trequire(redemption_price > 0, \"Need to set redemption price\"); // what if redemption price is set to zero?\n\t\tuint256 total_bought_bonds = zcb.getTotalZCB();\n\t\tuint256 total_bought_collateral = zcb.getTotalCollateral();\n\n\t\tif (atLoss){\n\n\t\t\tuint256 burnamount = total_bought_collateral - ((redemption_price * total_bought_bonds)/PRICE_PRECISION);\n\t\t\tconsole.log('burnamounts', burnamount);\n\n\t\t\tif(principal_loss >0){\n\t\t\t\trequire(burnamount>0,\"burn amount err\"); \n\t\t\t\tzcb.burnFirstLoss(burnamount);\n\n\t\t\t}\n\t\t\n\t\t}\n\n\t}\n\n\t/* \n\t@notice trader will redeem entire balance of ZCB\n\tNeeds to be called at maturity, market needs to be resolved first(from controller)\n\t*/\n\tfunction redeem(\n\t\tuint256 marketId,\n\t \taddress receiver \n\t) public returns(uint256){\n\t\trequire(!marketActive(marketId), \"Market Active\"); \n\t\tBondingCurve zcb = BondingCurve(address(controller.getZCB(marketId)));\n\t\tuint256 zcb_redeem_amount = zcb.balanceOf(msg.sender); \n\t\tzcb.trustedBurn(msg.sender, zcb_redeem_amount); \n\n\t\tuint256 redemption_price = get_redemption_price(marketId); \n\t\trequire(redemption_price > 0, \"Redeem price is 0\");\n\t\tuint256 zcb_redeem_amount_prec = zcb_redeem_amount/(10**12); \n\t\tuint256 collateral_redeem_amount = (redemption_price * zcb_redeem_amount_prec)/PRICE_PRECISION; \n\n\t\tcontroller.redeem_mint(collateral_redeem_amount, msg.sender); \n\n\t\treturn collateral_redeem_amount; \n\n\t}\n\n\n\t/// @notice when market is resolved(maturity/early default), calculates score\n\t/// and update each assessment phase trader's reputation, called by individual traders\n\tfunction updateReputation(uint256 marketId) external  {\n\t\trequire(restriction_data[marketId].marketDenied, \"Market not resolved\"); \t\n\t\trequire(assessment_trader[marketId][msg.sender], \"Not manager\"); \n\n\t\tbool atLoss = restriction_data[marketId].atLoss; \n\t\tuint256 priceOut = assessment_prices[marketId][msg.sender]/(10**12); \n\t\tuint256 collateralIn = assessment_collaterals[marketId][msg.sender]; \n\t\tuint256 traderBudget = getTraderBudget(msg.sender); \n\t\tuint256 num_bonds_bought = (collateralIn * priceOut)/PRICE_PRECISION; \n\n\t\tuint256 scoreToAdd; \n\t\t// if (!atLoss) scoreToAdd = (((num_bonds_bought*PRICE_PRECISION/traderBudget) * (PRICE_PRECISION - priceOut))/PRICE_PRECISION)*(num_bonds_bought)/PRICE_PRECISION;\n\t\t// console.log('num_bonds_bought'); \n\t\tif(!atLoss) scoreToAdd = num_bonds_bought; \n\t\telse scoreToAdd = (num_bonds_bought/traderBudget) * priceOut * num_bonds_bought; \n\n\t\trep.addScore(msg.sender, scoreToAdd, !atLoss); \n\t}\n\n\n\tfunction max(uint256 a, uint256 b) internal pure returns (uint256) {\n\t    return a >= b ? a : b;\n\t}\n\n\tfunction sqrt(uint y) internal pure returns (uint z) {\n\t    if (y > 3) {\n\t        z = y;\n\t        uint x = y / 2 + 1;\n\t        while (x < z) {\n\t            z = x;\n\t            x = (y / x + x) / 2;\n\t        }\n\t    } else if (y != 0) {\n\t        z = 1;\n\t    }\n\t}\n\n\n}\n\n"
    },
    "contracts/stablecoin/reputationtoken.sol": {
      "content": "pragma solidity ^0.8.4; \n//https://github.com/poap-xyz/poap-contracts/tree/master/contracts\nimport {ERC721} from \"solmate/src/tokens/ERC721.sol\";\nimport {Controller} from \"./controller.sol\";\nimport {IReputationNFT} from \"./IReputationNFT.sol\";\nimport {BondingCurve} from \"../bonds/bondingcurve.sol\";\nimport \"hardhat/console.sol\";\n\n\n\ncontract ReputationNFT is IReputationNFT, ERC721 {\n  mapping(uint256 => ReputationData) internal _reputation; // id to reputation\n  mapping(address => uint256) internal _ownerToId;\n  mapping(uint256 => TraderData[]) internal _marketData; // **MarketId to Market's data needed for calculating brier score.\n\n  uint256 private nonce = 1;\n  Controller controller;\n  uint256 SCALE = 1e18;\n\n\n  struct ReputationData {\n    uint256 n; // number of markets participated in => regular uint256\n    uint256 score; // averaged reputation score => 60.18\n  }\n\n  struct TraderData { // for each market\n    address trader;\n    uint256 tokensBought;\n  }\n\n  modifier onlyController() {\n    require(msg.sender == address(controller));\n    _;\n  }\n\n  constructor (\n    address _controller\n  ) ERC721(\"Debita Reputation Token\", \"DRT\") {\n    console.log(\"here\");\n    controller = Controller(_controller);\n  }\n\n  function _baseURI() internal pure returns (string memory baseURI) {\n    baseURI = \"\";\n  }\n\n  function tokenURI(uint256 id) public view override returns (string memory) {\n    require(_ownerOf[id] != address(0), \"Invalid Identifier\");\n\n    string memory baseURI = _baseURI();\n    return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, id)) : \"\";\n  }\n\n  function mint(address to) external {\n    require(_ownerToId[to] == uint256(0), \"can only mint one reputation token\");\n    super._mint(to, nonce);\n    _ownerToId[to] = nonce;\n    nonce++;\n  }\n\n  function getReputationScore(address owner) view external returns (uint256){\n    require(_ownerToId[owner] != uint256(0), \"No Id found\");\n    return _reputation[_ownerToId[owner]].score;\n  }\n\n\n\n  /**\n   @notice calculates average of scores added.\n   @param score: 60.18 format\n   */\n  function addScore(address to, uint256 score, bool atLoss) external  {\n    require(_ownerToId[to] != uint256(0), \"No Id found\");\n\n    ReputationData storage data = _reputation[_ownerToId[to]];\n    \n    if (data.n == 0) {\n      data.score = score;\n    } else {\n      //data.score = ((data.score / data.n) + score) / (data.n + 1);\n      data.score = (data.score / data.n + score) / (data.n + 1);\n    }\n\n    data.n++;\n  }\n\n  /**\n   @notice reset scores\n   */\n  function resetScore(address to) external {\n    require(_ownerToId[to] != uint256(0), \"No Id found\");\n    delete _reputation[_ownerToId[to]];\n\n  }\n}"
    },
    "@interep/contracts/IInterep.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @title Interep interface.\n/// @dev Interface of a Interep contract.\ninterface IInterep {\n    struct Verifier {\n        address contractAddress;\n        uint8 merkleTreeDepth;\n    }\n\n    struct Group {\n        bytes32 provider;\n        bytes32 name;\n        uint256 root;\n        uint8 depth;\n    }\n\n    /// @dev Emitted when a Semaphore proof is verified.\n    /// @param groupId: Id of the group.\n    /// @param signal: Semaphore signal.\n    event ProofVerified(uint256 indexed groupId, bytes32 signal);\n\n    /// @dev Emitted when an Interep group is updated.\n    /// @param groupId: Id of the group.\n    /// @param provider: Provider of the group.\n    /// @param name: Name of the group.\n    /// @param root: Root hash of the tree.\n    /// @param depth: Depth of the tree.\n    event GroupUpdated(\n        uint256 groupId,\n        bytes32 indexed provider,\n        bytes32 indexed name,\n        uint256 root,\n        uint8 indexed depth\n    );\n\n    /// @dev Updates the Interep groups.\n    /// @param groups: List of Interep groups.\n    function updateGroups(Group[] calldata groups) external;\n\n    /// @dev Saves the nullifier hash to avoid double signaling and emits an event\n    /// if the zero-knowledge proof is valid.\n    /// @param groupId: Id of the group.\n    /// @param signal: Semaphore signal.\n    /// @param nullifierHash: Nullifier hash.\n    /// @param externalNullifier: External nullifier.\n    /// @param proof: Zero-knowledge proof.\n    function verifyProof(\n        uint256 groupId,\n        bytes32 signal,\n        uint256 nullifierHash,\n        uint256 externalNullifier,\n        uint256[8] calldata proof\n    ) external;\n\n    /// @dev Returns the root hash of an Interep group.\n    /// @param groupId: Id of the group.\n    /// @return Root hash of the group.\n    function getRoot(uint256 groupId) external view returns (uint256);\n\n    /// @dev Returns the tree depth of an Interep group.\n    /// @param groupId: Id of the group.\n    /// @return Tree depth of the group.\n    function getDepth(uint256 groupId) external view returns (uint8);\n}\n"
    },
    "contracts/stablecoin/owned.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.4;\n\n// https://docs.synthetix.io/contracts/Owned\ncontract Owned {\n    address public owner;\n    address public nominatedOwner;\n\n    constructor (address _owner) public {\n        require(_owner != address(0), \"Owner address cannot be 0\");\n        owner = _owner;\n        emit OwnerChanged(address(0), _owner);\n    }\n\n    function nominateNewOwner(address _owner) external onlyOwner {\n        nominatedOwner = _owner;\n        emit OwnerNominated(_owner);\n    }\n\n    function acceptOwnership() external {\n        require(msg.sender == nominatedOwner, \"You must be nominated before you can accept ownership\");\n        emit OwnerChanged(owner, nominatedOwner);\n        owner = nominatedOwner;\n        nominatedOwner = address(0);\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner, \"Only the contract owner may perform this action\");\n        _;\n    }\n\n    event OwnerNominated(address newOwner);\n    event OwnerChanged(address oldOwner, address newOwner);\n}"
    },
    "contracts/stablecoin/IMarketManager.sol": {
      "content": "pragma solidity ^0.8.4;\n\nimport \"./owned.sol\";\nimport \"../turbo/AMMFactory.sol\"; \nimport \"./reputationtoken.sol\"; \nimport \"../bonds/Ibondingcurve.sol\"; \n\n\ninterface IMarketManager {\n\t/**\n\t@dev initializes bonding curve for given market.\n\t */\n\tfunction initiate_bonding_curve(uint256 marketId) \n\t\texternal;\n\n\n\tfunction setMarketRestrictionData(\t\n\t\tbool _duringMarketAssessment,\n\t\tbool _onlyReputable,  \n\t\tuint256 marketId,\n\t\tuint256 min_rep_score)\n\t\texternal; \n\n \tfunction deactivateMarket(uint256 marketId) external; \n\n\tfunction setAssessmentPhase(\n\t\tuint256 marketId, \n\t\tbool _duringMarketAssessment,\n\t\tbool _onlyReputable) \n\t\texternal;\n\t\n\n\tfunction canBuy(\n\t\taddress trader,\n\t\taddress ammFactoryAddress, \n\t\taddress marketFactoryAddress, \n\t\tuint256 amount,//this is in DS with decimals \n\t\tuint256 marketId) external view returns(bool);\n\n\n\n\tfunction buy(\n\t\tAMMFactory ammFactory, \n\t\tAbstractMarketFactoryV3 marketFactory, \n        uint256 _marketId,\n        uint256 _collateralIn\n        ) external returns (uint256);\n\n\tfunction sell(\n\t\tAMMFactory ammFactory, \n\t\tAbstractMarketFactoryV3 marketFactory, \n        uint256 _marketId,\n        uint256 _zcb_amount_in\n        ) external returns (uint256); \n\t\n\n\tfunction update_redemption_price(\n\t\tuint256 marketId,\n\t\tbool atLoss, \n\t\tuint256 extra_gain, \n\t\tuint256 principal_loss) \n\t\texternal;\n\n\tfunction handle_maturity(\n\t\tuint256 marketId, \n\t\tbool atLoss, \n\t\tuint256 principal_loss) \n\t\texternal; \n\n\tfunction denyMarket(\n\t\tuint256 marketId)\n\t\texternal; \n\n\tfunction borrow_with_collateral(\n\t\tuint256 _marketId, \n\t\tuint256 requested_zcb, \n\t\taddress trader\n\t\t) external; \n\n\tfunction repay_for_collateral(\n\t\tuint256 _marketId, \n\t\tuint256 repaying_zcb, \n\t\taddress trader\n\t\t) external;\n}\n\n"
    },
    "solmate/src/tokens/ERC721.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\nabstract contract ERC721 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /*//////////////////////////////////////////////////////////////\n                         METADATA STORAGE/LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n\n    /*//////////////////////////////////////////////////////////////\n                      ERC721 BALANCE/OWNER STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(uint256 => address) internal _ownerOf;\n\n    mapping(address => uint256) internal _balanceOf;\n\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\n        require((owner = _ownerOf[id]) != address(0), \"NOT_MINTED\");\n    }\n\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        require(owner != address(0), \"ZERO_ADDRESS\");\n\n        return _balanceOf[owner];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         ERC721 APPROVAL STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(uint256 => address) public getApproved;\n\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC721 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 id) public virtual {\n        address owner = _ownerOf[id];\n\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \"NOT_AUTHORIZED\");\n\n        getApproved[id] = spender;\n\n        emit Approval(owner, spender, id);\n    }\n\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        require(from == _ownerOf[id], \"WRONG_FROM\");\n\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n            \"NOT_AUTHORIZED\"\n        );\n\n        // Underflow of the sender's balance is impossible because we check for\n        // ownership above and the recipient's balance can't realistically overflow.\n        unchecked {\n            _balanceOf[from]--;\n\n            _balanceOf[to]++;\n        }\n\n        _ownerOf[id] = to;\n\n        delete getApproved[id];\n\n        emit Transfer(from, to, id);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes calldata data\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(_ownerOf[id] == address(0), \"ALREADY_MINTED\");\n\n        // Counter overflow is incredibly unrealistic.\n        unchecked {\n            _balanceOf[to]++;\n        }\n\n        _ownerOf[id] = to;\n\n        emit Transfer(address(0), to, id);\n    }\n\n    function _burn(uint256 id) internal virtual {\n        address owner = _ownerOf[id];\n\n        require(owner != address(0), \"NOT_MINTED\");\n\n        // Ownership check above ensures no underflow.\n        unchecked {\n            _balanceOf[owner]--;\n        }\n\n        delete _ownerOf[id];\n\n        delete getApproved[id];\n\n        emit Transfer(owner, address(0), id);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL SAFE MINT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function _safeMint(\n        address to,\n        uint256 id,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n}\n\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\nabstract contract ERC721TokenReceiver {\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return ERC721TokenReceiver.onERC721Received.selector;\n    }\n}\n"
    },
    "contracts/stablecoin/IReputationNFT.sol": {
      "content": "pragma solidity ^0.8.4; \n\n\ninterface IReputationNFT {\n  \n}"
    },
    "contracts/vaults/vault_tranche/splitter.sol": {
      "content": "pragma solidity ^0.8.4;\n\n\nimport {Auth} from \"../auth/Auth.sol\";\nimport {ERC4626} from \"../mixins/ERC4626.sol\";\n\nimport {SafeCastLib} from \"../utils/SafeCastLib.sol\";\nimport {SafeTransferLib} from \"../utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"../utils/FixedPointMathLib.sol\";\n\nimport {ERC20} from \"../tokens/ERC20.sol\";\nimport {Instrument} from \"../instrument.sol\";\nimport {tVault} from \"./tVault.sol\"; \nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\n\n\n\n/// @notice tokens for junior/senior tranches \ncontract tToken is ERC20{\n\n\tmodifier onlySplitter() {\n    require(msg.sender == splitter, \"!Splitter\");\n     _;\n  }\n\n  address splitter; \n  ERC20 asset; \n\n  /// @notice asset is the tVault  \n  constructor(\n      ERC20 _asset, \n      string memory _name,\n      string memory _symbol, \n      address _splitter\n  ) ERC20(_name, _symbol, _asset.decimals()) {\n      asset = _asset;\n      splitter = _splitter; \n  }\n\n  function mint(address to, uint256 amount) external onlySplitter{\n  \t_mint(to, amount); \n  }\n\n  function burn(address from, uint256 amount) external onlySplitter{\n  \t_burn(from, amount);\n  }\n\n\n}\n\n/// @notice Accepts ERC20 and splits them into senior/junior tokens\n/// Will hold the ERC20 token in this contract\n/// Before maturity, redemption only allowed for a pair, \n/// After maturity, redemption allowed for individual tranche tokens, with the determined conversion rate\n/// @dev new instance is generated for each vault\ncontract Splitter{\n\tusing SafeCastLib for uint256; \n  using SafeTransferLib for ERC20;\n  using FixedPointMathLib for uint256;\n\n  tVault underlying; \n  tToken senior;\n  tToken junior;  \n\n  //weight is in PRICE_PRECISION 6, i.e 5e5 = 0.5\n  uint256 junior_weight; \n  uint256 PRICE_PRECISION; \n  uint promised_return; \n\n\n  //Redemption Prices \n  uint256 s_r; \n  uint256 j_r; \n\n  constructor(\n  \ttVault _underlying //underlying vault token to split \n  \t){\n  \tunderlying = _underlying; \n  \tsenior = new tToken(_underlying, \"senior\", string(abi.encodePacked(\"se_\", _underlying.symbol())), address(this));\n  \tjunior = new tToken(_underlying, \"junior\", string(abi.encodePacked(\"ju_\", _underlying.symbol())), address(this));\n\n  \tjunior_weight = underlying.getJuniorWeight(); \n  \tpromised_return = underlying.getPromisedReturn(); \n  \tPRICE_PRECISION = underlying.PRICE_PRECISION(); \n  }\n\n\t/// @notice accepts token_to_split and mints s,j tokens\n\t/// ex. 1 vault token-> 0.3 junior and 0.7 senior for weight of 0.3, 0.7\n\tfunction split(ERC20 token_to_split, uint256 amount) external returns(uint, uint) {\n\t\trequire(token_to_split == underlying, \"Wrong Splitter\");\n\n\t\ttoken_to_split.safeTransferFrom(msg.sender, address(this), amount); \n\n\t\tuint junior_token_mint_amount = (amount * junior_weight)/PRICE_PRECISION;  \n\t\tuint senior_token_mint_amount = amount - junior_token_mint_amount; \n\n\t\tjunior.mint(msg.sender, junior_token_mint_amount); \n\t\tsenior.mint(msg.sender, senior_token_mint_amount);\n\n\t\treturn (junior_token_mint_amount, senior_token_mint_amount); \n\n\t}\n\n\t/// @notice aceepts junior and senior token and gives back token_to_merge(tVault tokens)\n\t/// Function to call when redeeming before maturity\n\t/// @param token_to_merge is the valut token\n\t/// @param junior_amount is amount of junior tokens user want to redeem\n\t/// @dev senior amount is automiatically computed when given junior amount \n\tfunction merge(ERC20 token_to_merge, uint256 junior_amount) external returns(uint){\n\t\trequire(token_to_merge == underlying, \"Wrong Splitter\");\n\t\tuint senior_multiplier = (PRICE_PRECISION *(PRICE_PRECISION - junior_weight))/junior_weight; //ex 2.3e6\n\t\tuint senior_amount = (senior_multiplier * junior_amount)/PRICE_PRECISION; \n\t\trequire(senior.balanceOf(msg.sender) >= senior_amount, \"Not enough senior tokens\"); \n\n\t\tjunior.burn(msg.sender, junior_amount);\n\t\tsenior.burn(msg.sender, senior_amount);\n\t\tunderlying.transfer(msg.sender, junior_amount+senior_amount); \n\t\treturn junior_amount + senior_amount; \n\t}\n\n\n\t/// @notice only can called after set maturity by tranche token holders\n\tfunction redeem_after_maturity(tToken _tToken, uint256 amount) external {\n\t\trequire(underlying.isMatured(), \"Vault not matured\");\n\t\trequire(address(_tToken) == address(senior) || address(_tToken) == address(junior), \"Wrong Tranche Token\");\n\t\tbool isSenior = (address(_tToken) == address(senior)) ? true : false; \n\t\tuint redemption_price = isSenior? s_r: j_r; \n\t\tuint token_redeem_amount = (redemption_price * amount)/PRICE_PRECISION; \n\n\t\t_tToken.burn(msg.sender, amount); \n\t\tunderlying.transfer(msg.sender, token_redeem_amount); \n\t\t\n\t}\n\n\n\t/// @notice calculate and store redemption Price for post maturity \n\t/// @dev should be only called once right after tToken matures, as totalSupply changes when redeeming \n\tfunction calcRedemptionPrice() private {\n\t\tuint promised_return = underlying.getPromisedReturn(); //in 1e6 decimals i.e 5000 is 0.05\n\t\tuint real_return = underlying.getCurrentRealReturn(); \n\t\tuint _s_r = ((PRICE_PRECISION + promised_return)/(PRICE_PRECISION+real_return)) * PRICE_PRECISION; \n\t\tuint max_s_r = (PRICE_PRECISION/(PRICE_PRECISION - junior_weight)) *PRICE_PRECISION; \n\t\t\n\t\ts_r = min(_s_r, max_s_r);\n\t\t//total supply right after tVault matures \n\t\tj_r = (underlying.totalSupply() - (senior.totalSupply() * s_r/PRICE_PRECISION))/(junior.totalSupply()); \n\n\t}\n\n\t/// @dev need to return in list format to index it easily \n\t/// 0 is always senior \n\tfunction getTrancheTokens() public view returns(address[] memory){\n \t\taddress[] memory addresses = new address[](2);\n \t\taddresses[0] =  address(senior); \n \t\taddresses[1] =  address(junior); \n\t\treturn addresses; \n\t}\n\n\n\tfunction max(uint256 a, uint256 b) internal pure returns (uint256) {\n    \treturn a >= b ? a : b;\n\t}\n\n\tfunction min(uint256 a, uint256 b) internal pure returns (uint256) {\n    \treturn a <= b ? a : b;\n\t}\n}"
    },
    "contracts/vaults/vault_tranche/stableswap.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8;\n\n/*\nInvariant - price of trade and amount of liquidity are determined by this equation\n\nAn^n sum(x_i) + D = ADn^n + D^(n + 1) / (n^n prod(x_i))\n\nTopics\n0. Newton's method x_(n + 1) = x_n - f(x_n) / f'(x_n)\n1. Invariant\n2. Swap\n   - Calculate Y\n   - Calculate D\n3. Get virtual price\n4. Add liquidity\n   - Imbalance fee\n5. Remove liquidity\n6. Remove liquidity one token\n   - Calculate withdraw one token\n   - getYD\nTODO: test?\n*/\n\nlibrary Math {\n    function abs(uint x, uint y) internal pure returns (uint) {\n        return x >= y ? x - y : y - x;\n    }\n}\n\ncontract StableSwap {\n  // Number of tokens\n  uint private constant N = 2;\n  // Amplification coefficient multiplied by N^(N - 1)\n  // Higher value makes the curve more flat\n  // Lower value makes the curve more like constant product AMM\n  uint private constant A = 1000 * (N**(N - 1));\n  // 0.03%\n  uint private constant SWAP_FEE = 300;\n  // Liquidity fee is derived from 2 constraints\n  // 1. Fee is 0 for adding / removing liquidity that results in a balanced pool\n  // 2. Swapping in a balanced pool is like adding and then removing liquidity\n  //    from a balanced pool\n  // swap fee = add liquidity fee + remove liquidity fee\n  uint private constant LIQUIDITY_FEE = (SWAP_FEE * N) / (4 * (N - 1));\n  uint private constant FEE_DENOMINATOR = 1e6;\n\n  address[N] public tokens;\n  // Normalize each token to 18 decimals\n  // Example - DAI (18 decimals), USDC (6 decimals), USDT (6 decimals)\n  //uint[N] private multipliers = [1, 1e12, 1e12];\n  uint[N] private multipliers = [1, 1];\n\n  uint[N] public balances;\n\n  // 1 share = 1e18, 18 decimals\n  uint private constant DECIMALS = 18;\n  uint public totalSupply;\n\n  address factory; \n  mapping(address => uint) public balanceOf;\n  constructor(address token1, address token2){\n    factory = msg.sender; \n    tokens[0] = token1;\n    tokens[1] = token2; \n  }\n\n  function _mint(address _to, uint _amount) private {\n      balanceOf[_to] += _amount;\n      totalSupply += _amount;\n  }\n\n  function _burn(address _from, uint _amount) private {\n      balanceOf[_from] -= _amount;\n      totalSupply -= _amount;\n  }\n\n\n  // Return precision-adjusted balances, adjusted to 18 decimals\n  function _xp() private view returns (uint[N] memory xp) {\n      for (uint i; i < N; ++i) {\n          xp[i] = balances[i] * multipliers[i];\n      }\n  }\n\n  /**\n   * @notice Calculate D, sum of balances in a perfectly balanced pool\n   * If balances of x_0, x_1, ... x_(n-1) then sum(x_i) = D\n   * @param xp Precision-adjusted balances\n   * @return D\n   */\n  function _getD(uint[N] memory xp) private pure returns (uint) {\n    /*\n    Newton's method to compute D\n    -----------------------------\n    f(D) = ADn^n + D^(n + 1) / (n^n prod(x_i)) - An^n sum(x_i) - D \n    f'(D) = An^n + (n + 1) D^n / (n^n prod(x_i)) - 1\n\n                 (as + np)D_n\n    D_(n+1) = -----------------------\n              (a - 1)D_n + (n + 1)p\n\n    a = An^n\n    s = sum(x_i)\n    p = (D_n)^(n + 1) / (n^n prod(x_i))\n    */\n    uint a = A * N; // An^n\n\n    uint s; // x_0 + x_1 + ... + x_(n-1)\n    for (uint i; i < N; ++i) {\n        s += xp[i];\n    }\n\n    // Newton's method\n    // Initial guess, d <= s\n    uint d = s;\n    uint d_prev;\n    for (uint i; i < 255; ++i) {\n        // p = D^(n + 1) / (n^n * x_0 * ... * x_(n-1))\n        uint p = d;\n        for (uint j; j < N; ++j) {\n            p = (p * d) / (N * xp[j]);\n        }\n        d_prev = d;\n        d = ((a * s + N * p) * d) / ((a - 1) * d + (N + 1) * p);\n\n        if (Math.abs(d, d_prev) <= 1) {\n            return d;\n        }\n    }\n    revert(\"D didn't converge\");\n  }\n\n\n /**\n  * @notice Calculate required dx to get dy\n  * @param indexX is the index of the tokenIn\n  * @dev only works in binary settins for now, indexX is 0 if senior, 1 if junior \n  * y is tokenOut, so dy should be subtracted, x is tokenIn, so should be added\n  */\n\n  function getDx(\n      uint dy,\n      uint indexX\n      ) \n  public view returns(uint){\n    uint[N] memory xp = _xp(); \n    uint xamount = xp[indexX]; \n    uint yamount = xp[1-indexX]; \n\n    uint new_yamount = yamount - dy; \n\n    uint new_xamount = _getY(1-indexX, indexX, new_yamount, xp); \n    uint dx = new_xamount - xamount; \n    return dx; \n  }\n\n  /**\n   * @notice Calculate the new balance of token j given the new balance of token i\n   * @param i Index of token in\n   * @param j Index of token out\n   * @param x New balance of token i\n   * @param xp Current precision-adjusted balances\n   */\n  function _getY(\n    uint i,\n    uint j,\n    uint x,\n    uint[N] memory xp\n) private pure returns (uint) {\n    /*\n    Newton's method to compute y\n    -----------------------------\n    y = x_j\n\n    f(y) = y^2 + y(b - D) - c\n\n                y_n^2 + c\n    y_(n+1) = --------------\n               2y_n + b - D\n\n    where\n    s = sum(x_k), k != j\n    p = prod(x_k), k != j\n    b = s + D / (An^n)\n    c = D^(n + 1) / (n^n * p * An^n)\n    */\n    uint a = A * N;\n    uint d = _getD(xp);\n    uint s;\n    uint c = d;\n\n    uint _x;\n    for (uint k; k < N; ++k) {\n        if (k == i) {\n            _x = x;\n        } else if (k == j) {\n            continue;\n        } else {\n            _x = xp[k];\n        }\n\n        s += _x;\n        c = (c * d) / (N * _x);\n    }\n    c = (c * d) / (N * a);\n    uint b = s + d / a;\n\n    // Newton's method\n    uint y_prev;\n    // Initial guess, y <= d\n    uint y = d;\n    for (uint _i; _i < 255; ++_i) {\n        y_prev = y;\n        y = (y * y + c) / (2 * y + b - d);\n        if (Math.abs(y, y_prev) <= 1) {\n            return y;\n        }\n    }\n    revert(\"y didn't converge\");\n  }\n\n  /**\n   * @notice Calculate the new balance of token i given precision-adjusted\n   * balances xp and liquidity d\n   * @dev Equation is calculate y is same as _getY\n   * @param i Index of token to calculate the new balance\n   * @param xp Precision-adjusted balances\n   * @param d Liquidity d\n   * @return New balance of token i\n   */\n  function _getYD(\n    uint i,\n    uint[N] memory xp,\n    uint d\n) private pure returns (uint) {\n    uint a = A * N;\n    uint s;\n    uint c = d;\n\n    uint _x;\n    for (uint k; k < N; ++k) {\n        if (k != i) {\n            _x = xp[k];\n        } else {\n            continue;\n        }\n\n        s += _x;\n        c = (c * d) / (N * _x);\n    }\n    c = (c * d) / (N * a);\n    uint b = s + d / a;\n\n    // Newton's method\n    uint y_prev;\n    // Initial guess, y <= d\n    uint y = d;\n    for (uint _i; _i < 255; ++_i) {\n        y_prev = y;\n        y = (y * y + c) / (2 * y + b - d);\n        if (Math.abs(y, y_prev) <= 1) {\n            return y;\n        }\n    }\n    revert(\"y didn't converge\");\n  }\n\n  // Estimate value of 1 share\n  // How many tokens is one share worth?\n  function getVirtualPrice() external view returns (uint) {\n      uint d = _getD(_xp());\n      uint _totalSupply = totalSupply;\n      if (_totalSupply > 0) {\n          return (d * 10**DECIMALS) / _totalSupply;\n      }\n      return 0;\n  }\n\n  /**\n   * @notice Swap dx amount of token i for token j\n   * @param i Index of token in\n   * @param j Index of token out\n   * @param dx Token in amount\n   * @param minDy Minimum token out\n   */\n  function swap(\n      uint i,\n      uint j,\n      uint dx,\n      uint minDy\n  ) external returns (uint dy) {\n    require(i != j, \"i = j\");\n\n    IERC20(tokens[i]).transferFrom(msg.sender, address(this), dx);\n\n    // Calculate dy\n    uint[N] memory xp = _xp();\n    uint x = xp[i] + dx * multipliers[i];\n\n    uint y0 = xp[j];\n    uint y1 = _getY(i, j, x, xp);\n    // y0 must be >= y1, since x has increased\n    // -1 to round down\n    dy = (y0 - y1 - 1) / multipliers[j];\n\n    // Subtract fee from dy\n    uint fee = (dy * SWAP_FEE) / FEE_DENOMINATOR;\n    dy -= fee;\n    require(dy >= minDy, \"dy < min\");\n\n    balances[i] += dx;\n    balances[j] -= dy;\n\n    IERC20(tokens[j]).transfer(msg.sender, dy);\n}\n\nfunction addLiquidity(uint[N] calldata amounts, uint minShares)\n    external\n    returns (uint shares)\n{\n    // calculate current liquidity d0\n    uint _totalSupply = totalSupply;\n    uint d0;\n    uint[N] memory old_xs = _xp();\n    if (_totalSupply > 0) {\n        d0 = _getD(old_xs);\n    }\n\n    // Transfer tokens in\n    uint[N] memory new_xs;\n    for (uint i; i < N; ++i) {\n        uint amount = amounts[i];\n        if (amount > 0) {\n            IERC20(tokens[i]).transferFrom(msg.sender, address(this), amount);\n            new_xs[i] = old_xs[i] + amount * multipliers[i];\n        } else {\n            new_xs[i] = old_xs[i];\n        }\n    }\n\n    // Calculate new liquidity d1\n    uint d1 = _getD(new_xs);\n    require(d1 > d0, \"liquidity didn't increase\");\n\n    // Reccalcuate D accounting for fee on imbalance\n    uint d2;\n    if (_totalSupply > 0) {\n        for (uint i; i < N; ++i) {\n            // TODO: why old_xs[i] * d1 / d0? why not d1 / N?\n            uint idealBalance = (old_xs[i] * d1) / d0;\n            uint diff = Math.abs(new_xs[i], idealBalance);\n            new_xs[i] -= (LIQUIDITY_FEE * diff) / FEE_DENOMINATOR;\n        }\n\n        d2 = _getD(new_xs);\n    } else {\n        d2 = d1;\n    }\n\n    // Update balances\n    for (uint i; i < N; ++i) {\n        balances[i] += amounts[i];\n    }\n\n    // Shares to mint = (d2 - d0) / d0 * total supply\n    // d1 >= d2 >= d0\n    if (_totalSupply > 0) {\n        shares = ((d2 - d0) * _totalSupply) / d0;\n    } else {\n        shares = d2;\n    }\n    require(shares >= minShares, \"shares < min\");\n    _mint(msg.sender, shares);\n}\n\n  function removeLiquidity(uint shares, uint[N] calldata minAmountsOut)\n      external\n      returns (uint[N] memory amountsOut)\n  {\n      uint _totalSupply = totalSupply;\n\n      for (uint i; i < N; ++i) {\n          uint amountOut = (balances[i] * shares) / _totalSupply;\n          require(amountOut >= minAmountsOut[i], \"out < min\");\n\n          balances[i] -= amountOut;\n          amountsOut[i] = amountOut;\n\n          IERC20(tokens[i]).transfer(msg.sender, amountOut);\n      }\n\n      _burn(msg.sender, shares);\n  }\n\n  /**\n   * @notice Calculate amount of token i to receive for shares\n   * @param shares Shares to burn\n   * @param i Index of token to withdraw\n   * @return dy Amount of token i to receive\n   *         fee Fee for withdraw. Fee already included in dy\n   */\n  function _calcWithdrawOneToken(uint shares, uint i)\n      private\n      view\n      returns (uint dy, uint fee)\n  {\n      uint _totalSupply = totalSupply;\n      uint[N] memory xp = _xp();\n\n      // Calculate d0 and d1\n      uint d0 = _getD(xp);\n      uint d1 = d0 - (d0 * shares) / _totalSupply;\n\n      // Calculate reduction in y if D = d1\n      uint y0 = _getYD(i, xp, d1);\n      // d1 <= d0 so y must be <= xp[i]\n      uint dy0 = (xp[i] - y0) / multipliers[i];\n\n      // Calculate imbalance fee, update xp with fees\n      uint dx;\n      for (uint j; j < N; ++j) {\n          if (j == i) {\n              dx = (xp[j] * d1) / d0 - y0;\n          } else {\n              // d1 / d0 <= 1\n              dx = xp[j] - (xp[j] * d1) / d0;\n          }\n          xp[j] -= (LIQUIDITY_FEE * dx) / FEE_DENOMINATOR;\n      }\n\n      // Recalculate y with xp including imbalance fees\n      uint y1 = _getYD(i, xp, d1);\n      // - 1 to round down\n      dy = (xp[i] - y1 - 1) / multipliers[i];\n      fee = dy0 - dy;\n  }\n\n  function calcWithdrawOneToken(uint shares, uint i)\n      external\n      view\n      returns (uint dy, uint fee)\n  {\n      return _calcWithdrawOneToken(shares, i);\n  }\n\n  /**\n   * @notice Withdraw liquidity in token i\n   * @param shares Shares to burn\n   * @param i Token to withdraw\n   * @param minAmountOut Minimum amount of token i that must be withdrawn\n   */\n  function removeLiquidityOneToken(\n      uint shares,\n      uint i,\n      uint minAmountOut\n  ) external returns (uint amountOut) {\n      (amountOut, ) = _calcWithdrawOneToken(shares, i);\n      require(amountOut >= minAmountOut, \"out < min\");\n\n      balances[i] -= amountOut;\n      _burn(msg.sender, shares);\n\n      IERC20(tokens[i]).transfer(msg.sender, amountOut);\n  }\n\n\n\n\n\n  function xp() public view returns(uint[N] memory){\n      return _xp(); \n  }\n\n\n\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint);\n\n    function balanceOf(address account) external view returns (uint);\n\n    function transfer(address recipient, uint amount) external returns (bool);\n\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint amount) external returns (bool);\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint amount\n    ) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint amount);\n    event Approval(address indexed owner, address indexed spender, uint amount);\n}"
    },
    "contracts/vaults/vault_tranche/testVaults.sol": {
      "content": "pragma solidity ^0.8.4;\n\n\nimport {Auth} from \"../auth/Auth.sol\";\nimport {ERC4626} from \"../mixins/ERC4626.sol\";\n\nimport {SafeCastLib} from \"../utils/SafeCastLib.sol\";\nimport {SafeTransferLib} from \"../utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"../utils/FixedPointMathLib.sol\";\n\nimport {ERC20} from \"../tokens/ERC20.sol\";\nimport {Instrument} from \"../instrument.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\n\ncontract testVault is ERC4626, Auth{\n\tusing SafeCastLib for uint256; \n    using SafeTransferLib for ERC20;\n    using FixedPointMathLib for uint256;\n\n\n    event InstrumentDeposit(address indexed user, Instrument indexed instrument, uint256 underlyingAmount);\n    event InstrumentWithdrawal(address indexed user, Instrument indexed instrument, uint256 underlyingAmount);\n    event InstrumentTrusted(address indexed user, Instrument indexed instrument);\n    event InstrumentDistrusted(address indexed user, Instrument indexed instrument);\n\n    /*///////////////////////////////////////////////////////////////\n                                 CONSTANTS\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal BASE_UNIT;\n    uint256 totalInstrumentHoldings; //total holdings deposited into all Instruments \n    ERC20 public immutable UNDERLYING;\n\n    mapping(Instrument => InstrumentData) public getInstrumentData;\n    mapping(address => uint256) public  num_proposals;\n    mapping(uint256=> Instrument) Instruments; //marketID-> Instrument \n\n    /// @param trusted Whether the Instrument is trusted.\n    /// @param balance The amount of underlying tokens held in the Instrument.\n    struct InstrumentData {\n        // Used to determine if the Vault will operate on a Instrument.\n        bool trusted;\n        // Balance of the contract denominated in Underlying, \n        // used to determine profit and loss during harvests of the Instrument.  \n        // represents the amount of debt the Instrument has incurred from this vault   \n        uint248 balance;\n        uint256 faceValue;\n        uint256 marketId;\n    \tuint256 principal; //this is total available allowance\n        uint256 expectedYield; // total interest paid over duration\n        uint256 duration;\n        string description;\n        address Instrument_address;    \n    }\n\n    constructor(address _UNDERLYING)\n        ERC4626(\n            ERC20(_UNDERLYING),\n            string(abi.encodePacked(\"debita \", ERC20(_UNDERLYING).name(), \" Vault\")),\n            string(abi.encodePacked(\"db\", ERC20(_UNDERLYING).symbol()))\n        )  Auth(msg.sender)\n\n    {\n        UNDERLYING = ERC20(_UNDERLYING);\n        BASE_UNIT = 10**ERC20(_UNDERLYING).decimals();\n\n        //totalSupply = type(uint256).max;\n    }\n\n\n    /// @notice Harvest a trusted Instrument, records profit/loss \n    function harvest(Instrument instrument) external requiresAuth{\n        require(getInstrumentData[instrument].trusted, \"UNTRUSTED_Instrument\");\n    \tuint256 oldTotalInstrumentHoldings = totalInstrumentHoldings; \n        uint256 balanceLastHarvest = getInstrumentData[instrument].balance;\n        uint256 balanceThisHarvest = instrument.balanceOfUnderlying(address(instrument));\n        \n        getInstrumentData[instrument].balance = balanceThisHarvest.safeCastTo248();\n        uint256 profit = balanceThisHarvest - balanceLastHarvest; \n\n        totalInstrumentHoldings = oldTotalInstrumentHoldings + profit; \n\n    }\n\n    /// @notice Deposit a specific amount of float into a trusted Instrument.\n   \t/// Called when market is approved. \n   \t/// Also has the role of granting a credit line to a credit-based Instrument like uncol.loans \n    function depositIntoInstrument(Instrument instrument, uint256 underlyingAmount) external requiresAuth{\n    \trequire(getInstrumentData[instrument].trusted, \"UNTRUSTED Instrument\");\n    \ttotalInstrumentHoldings += underlyingAmount; \n\n        getInstrumentData[instrument].balance += underlyingAmount.safeCastTo248();\n\n        UNDERLYING.transfer(address(instrument), underlyingAmount);\n        emit InstrumentDeposit(msg.sender, instrument, underlyingAmount);\n\n    }\n\n    /// @notice Withdraw a specific amount of underlying tokens from a Instrument.\n    function withdrawFromInstrument(Instrument instrument, uint256 underlyingAmount) external requiresAuth{\n    \trequire(getInstrumentData[instrument].trusted, \"UNTRUSTED Instrument\");\n        getInstrumentData[instrument].balance -= underlyingAmount.safeCastTo248();\n        totalInstrumentHoldings -= underlyingAmount;\n        require(instrument.redeemUnderlying(underlyingAmount), \"REDEEM_FAILED\");\n        emit InstrumentWithdrawal(msg.sender, instrument, underlyingAmount);\n\n    }\n\n\n    /// @notice Withdraws all underyling balance from the Instrument to the vault \n    function withdrawAllFromInstrument(Instrument instrument) external requiresAuth{\n    \tuint248 total_Instrument_balance = instrument.balanceOfUnderlying(address(instrument)).safeCastTo248();\n    \tuint248 current_balance =  getInstrumentData[instrument].balance;\n    \tgetInstrumentData[instrument].balance -= Math.min(total_Instrument_balance, current_balance).safeCastTo248();\n    \tinstrument.redeemUnderlying(total_Instrument_balance);\n\n    }\n\n\n\n    /// @notice Stores a Instrument as trusted when its approved\n    function trustInstrument(Instrument instrument) external requiresAuth{\n    \tgetInstrumentData[instrument].trusted = true;\n\n    }\n\n    /// @notice Stores a Instrument as untrusted\n    function distrustInstrument(Instrument instrument) external requiresAuth{\n    \tgetInstrumentData[instrument].trusted = false; \n    }\n\n\n    /// @notice returns true if Instrument is approved\n    function isTrusted(Instrument instrument) public view returns(bool){\n    \treturn getInstrumentData[instrument].trusted; \n    }\n\n    /// @notice Calculates the total amount of underlying tokens the Vault holds, excluding profit \n    function totalAssets() public view override returns(uint256){\n    \treturn totalInstrumentHoldings + totalFloat();\n    }\n\n   \t\n    function totalFloat() public view returns (uint256) {\n        return UNDERLYING.balanceOf(address(this));\n    }\n\n    function fetchInstrumentData(uint256 marketId) public view returns(InstrumentData memory){\n        return getInstrumentData[Instruments[marketId]];\n    }\n\n    /// @notice add instrument proposal created by the Utilizer \n    /// @dev Instrument instance should be created before this is called \n    function addProposal(\n        InstrumentData memory data\n    ) external {\n        require(data.principal > 0, \"principal must be greater than 0\");\n        require(data.duration > 0, \"duration must be greater than 0\");\n        require(data.faceValue > 0, \"faceValue must be greater than 0\");\n        require(data.principal >= BASE_UNIT, \"Needs to be in decimal format\"); // should be collateral address, not DS. Can't be less than 1.0 X?\n   \n\n        num_proposals[msg.sender] ++; \n        getInstrumentData[Instrument(data.Instrument_address)] = (\n        \tInstrumentData(\n        \t\tfalse, \n                0, \n                data.faceValue, \n                data.marketId, \n                data.principal, \n                data.expectedYield, \n                data.duration, \n                data.description, \n                data.Instrument_address)\n        \t); \n\n        Instruments[data.marketId] = Instrument(data.Instrument_address);\n    }\n}"
    },
    "contracts/vaults/tokens/WETH.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"./ERC20.sol\";\n\nimport {SafeTransferLib} from \"../utils/SafeTransferLib.sol\";\n\n/// @notice Minimalist and modern Wrapped Ether implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/WETH.sol)\n/// @author Inspired by WETH9 (https://github.com/dapphub/ds-weth/blob/master/src/weth9.sol)\ncontract WETH is ERC20(\"Wrapped Ether\", \"WETH\", 18) {\n    using SafeTransferLib for address;\n\n    event Deposit(address indexed from, uint256 amount);\n\n    event Withdrawal(address indexed to, uint256 amount);\n\n    function deposit() public payable virtual {\n        _mint(msg.sender, msg.value);\n\n        emit Deposit(msg.sender, msg.value);\n    }\n\n    function withdraw(uint256 amount) public virtual {\n        _burn(msg.sender, amount);\n\n        emit Withdrawal(msg.sender, amount);\n\n        msg.sender.safeTransferETH(amount);\n    }\n\n    receive() external payable virtual {\n        deposit();\n    }\n}\n"
    },
    "contracts/vaults/auth/authorities/RolesAuthority.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {Auth, Authority} from \"../Auth.sol\";\n\n/// @notice Role based Authority that supports up to 256 roles.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/authorities/RolesAuthority.sol)\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-roles/blob/master/src/roles.sol)\ncontract RolesAuthority is Auth, Authority {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event UserRoleUpdated(address indexed user, uint8 indexed role, bool enabled);\n\n    event PublicCapabilityUpdated(address indexed target, bytes4 indexed functionSig, bool enabled);\n\n    event RoleCapabilityUpdated(uint8 indexed role, address indexed target, bytes4 indexed functionSig, bool enabled);\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(address _owner, Authority _authority) Auth(_owner) {}\n\n    /*//////////////////////////////////////////////////////////////\n                            ROLE/USER STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(address => bytes32) public getUserRoles;\n\n    mapping(address => mapping(bytes4 => bool)) public isCapabilityPublic;\n\n    mapping(address => mapping(bytes4 => bytes32)) public getRolesWithCapability;\n\n    function doesUserHaveRole(address user, uint8 role) public view virtual returns (bool) {\n        return (uint256(getUserRoles[user]) >> role) & 1 != 0;\n    }\n\n    function doesRoleHaveCapability(\n        uint8 role,\n        address target,\n        bytes4 functionSig\n    ) public view virtual returns (bool) {\n        return (uint256(getRolesWithCapability[target][functionSig]) >> role) & 1 != 0;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                           AUTHORIZATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function canCall(\n        address user,\n        address target,\n        bytes4 functionSig\n    ) public view virtual override returns (bool) {\n        return\n            isCapabilityPublic[target][functionSig] ||\n            bytes32(0) != getUserRoles[user] & getRolesWithCapability[target][functionSig];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                   ROLE CAPABILITY CONFIGURATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setPublicCapability(\n        address target,\n        bytes4 functionSig,\n        bool enabled\n    ) public virtual requiresAuth {\n        isCapabilityPublic[target][functionSig] = enabled;\n\n        emit PublicCapabilityUpdated(target, functionSig, enabled);\n    }\n\n    function setRoleCapability(\n        uint8 role,\n        address target,\n        bytes4 functionSig,\n        bool enabled\n    ) public virtual requiresAuth {\n        if (enabled) {\n            getRolesWithCapability[target][functionSig] |= bytes32(1 << role);\n        } else {\n            getRolesWithCapability[target][functionSig] &= ~bytes32(1 << role);\n        }\n\n        emit RoleCapabilityUpdated(role, target, functionSig, enabled);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                       USER ROLE ASSIGNMENT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setUserRole(\n        address user,\n        uint8 role,\n        bool enabled\n    ) public virtual requiresAuth {\n        if (enabled) {\n            getUserRoles[user] |= bytes32(1 << role);\n        } else {\n            getUserRoles[user] &= ~bytes32(1 << role);\n        }\n\n        emit UserRoleUpdated(user, role, enabled);\n    }\n}\n"
    },
    "contracts/vaults/auth/authorities/MultiRolesAuthority.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {Auth, Authority} from \"../Auth.sol\";\n\n/// @notice Flexible and target agnostic role based Authority that supports up to 256 roles.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/authorities/MultiRolesAuthority.sol)\ncontract MultiRolesAuthority is Auth, Authority {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event UserRoleUpdated(address indexed user, uint8 indexed role, bool enabled);\n\n    event PublicCapabilityUpdated(bytes4 indexed functionSig, bool enabled);\n\n    event RoleCapabilityUpdated(uint8 indexed role, bytes4 indexed functionSig, bool enabled);\n\n    event TargetCustomAuthorityUpdated(address indexed target, Authority indexed authority);\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(address _owner, Authority _authority) Auth(_owner) {}\n\n    /*//////////////////////////////////////////////////////////////\n                     CUSTOM TARGET AUTHORITY STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(address => Authority) public getTargetCustomAuthority;\n\n    /*//////////////////////////////////////////////////////////////\n                            ROLE/USER STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(address => bytes32) public getUserRoles;\n\n    mapping(bytes4 => bool) public isCapabilityPublic;\n\n    mapping(bytes4 => bytes32) public getRolesWithCapability;\n\n    function doesUserHaveRole(address user, uint8 role) public view virtual returns (bool) {\n        return (uint256(getUserRoles[user]) >> role) & 1 != 0;\n    }\n\n    function doesRoleHaveCapability(uint8 role, bytes4 functionSig) public view virtual returns (bool) {\n        return (uint256(getRolesWithCapability[functionSig]) >> role) & 1 != 0;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                           AUTHORIZATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function canCall(\n        address user,\n        address target,\n        bytes4 functionSig\n    ) public view virtual override returns (bool) {\n        Authority customAuthority = getTargetCustomAuthority[target];\n\n        if (address(customAuthority) != address(0)) return customAuthority.canCall(user, target, functionSig);\n\n        return\n            isCapabilityPublic[functionSig] || bytes32(0) != getUserRoles[user] & getRolesWithCapability[functionSig];\n    }\n\n    /*///////////////////////////////////////////////////////////////\n               CUSTOM TARGET AUTHORITY CONFIGURATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setTargetCustomAuthority(address target, Authority customAuthority) public virtual requiresAuth {\n        getTargetCustomAuthority[target] = customAuthority;\n\n        emit TargetCustomAuthorityUpdated(target, customAuthority);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                  PUBLIC CAPABILITY CONFIGURATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setPublicCapability(bytes4 functionSig, bool enabled) public virtual requiresAuth {\n        isCapabilityPublic[functionSig] = enabled;\n\n        emit PublicCapabilityUpdated(functionSig, enabled);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                       USER ROLE ASSIGNMENT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setUserRole(\n        address user,\n        uint8 role,\n        bool enabled\n    ) public virtual requiresAuth {\n        if (enabled) {\n            getUserRoles[user] |= bytes32(1 << role);\n        } else {\n            getUserRoles[user] &= ~bytes32(1 << role);\n        }\n\n        emit UserRoleUpdated(user, role, enabled);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                   ROLE CAPABILITY CONFIGURATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setRoleCapability(\n        uint8 role,\n        bytes4 functionSig,\n        bool enabled\n    ) public virtual requiresAuth {\n        if (enabled) {\n            getRolesWithCapability[functionSig] |= bytes32(1 << role);\n        } else {\n            getRolesWithCapability[functionSig] &= ~bytes32(1 << role);\n        }\n\n        emit RoleCapabilityUpdated(role, functionSig, enabled);\n    }\n}\n"
    },
    "contracts/interep/Interep.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n// only used for testing purposes.\n\nimport \"@interep/contracts/IInterep.sol\";\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@appliedzkp/semaphore-contracts/interfaces/IVerifier.sol\";\nimport \"@appliedzkp/semaphore-contracts/base/Verifier.sol\";\nimport \"@appliedzkp/semaphore-contracts/base/SemaphoreCore.sol\";\nimport \"@appliedzkp/semaphore-contracts/base/SemaphoreConstants.sol\";\n\n/// @title Interep\n/// @dev Interep is a collection of reputation Semaphore groups in which members\n/// can prove their Web2 reputation (or their membership in a group) without revealing their identity.\n/// Each Interep group is actually a Merkle tree, whose leaves represent the members of the group.\n/// Interep groups are saved off-chain but the Merkle tree roots of those groups are saved on-chain\n/// at regular intervals, so that users can verify their Semaphore ZK proof on-chain with this contract.\ncontract Interep is IInterep, Ownable, SemaphoreCore {\n    /// @dev Gets a tree depth and returns its verifier address.\n    mapping(uint8 => IVerifier) public verifiers;\n\n    /// @dev Gets a group id and returns the group data.\n    mapping(uint256 => Group) public groups;\n\n    /// @dev Checks if there is a verifier for the given tree depth.\n    /// @param depth: Depth of the tree.\n    modifier onlySupportedDepth(uint8 depth) {\n        require(address(verifiers[depth]) != address(0), \"Interep: tree depth is not supported\");\n        _;\n    }\n\n    /// @dev Initializes the Semaphore verifiers used to verify the user's ZK proofs.\n    /// @param _verifiers: List of Semaphore verifiers (address and related Merkle tree depth).\n    constructor(Verifier[] memory _verifiers) {\n        for (uint8 i = 0; i < _verifiers.length; i++) {\n            verifiers[_verifiers[i].merkleTreeDepth] = IVerifier(_verifiers[i].contractAddress);\n        }\n    }\n\n    /// @dev See {IInterep-updateGroups}.\n    function updateGroups(Group[] calldata _groups) external override onlyOwner {\n        for (uint8 i = 0; i < _groups.length; i++) {\n            uint256 groupId = uint256(keccak256(abi.encodePacked(_groups[i].provider, _groups[i].name))) %\n                SNARK_SCALAR_FIELD;\n\n            _updateGroup(groupId, _groups[i]);\n        }\n    }\n\n    /// @dev See {IInterep-verifyProof}.\n    function verifyProof(\n        uint256 groupId,\n        bytes32 signal,\n        uint256 nullifierHash,\n        uint256 externalNullifier,\n        uint256[8] calldata proof\n    ) external override {\n        uint256 root = getRoot(groupId);\n        uint8 depth = getDepth(groupId);\n\n        require(depth != 0, \"Interep: group does not exist\");\n\n        IVerifier verifier = verifiers[depth];\n\n        _verifyProof(signal, root, nullifierHash, externalNullifier, proof, verifier);\n\n        _saveNullifierHash(nullifierHash);\n\n        emit ProofVerified(groupId, signal);\n    }\n\n    /// @dev See {IInterep-getRoot}.\n    function getRoot(uint256 groupId) public view override returns (uint256) {\n        return groups[groupId].root;\n    }\n\n    /// @dev See {IInterep-getDepth}.\n    function getDepth(uint256 groupId) public view override returns (uint8) {\n        return groups[groupId].depth;\n    }\n\n    /// @dev Updates an Interep group.\n    /// @param groupId: Id of the group.\n    /// @param group: Group data.\n    function _updateGroup(uint256 groupId, Group calldata group) private onlySupportedDepth(group.depth) {\n        groups[groupId] = group;\n\n        emit GroupUpdated(groupId, group.provider, group.name, group.root, group.depth);\n    }\n}"
    },
    "@appliedzkp/semaphore-contracts/interfaces/IVerifier.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @title Verifier interface.\n/// @dev Interface of Verifier contract.\ninterface IVerifier {\n  function verifyProof(\n    uint256[2] memory a,\n    uint256[2][2] memory b,\n    uint256[2] memory c,\n    uint256[4] memory input\n  ) external view;\n}\n"
    },
    "@appliedzkp/semaphore-contracts/base/Verifier.sol": {
      "content": "//\n// Copyright 2017 Christian Reitwiessner\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n//\n// 2019 OKIMS\n//      ported to solidity 0.6\n//      fixed linter warnings\n//      added requiere error messages\n//\n// 2021 Remco Bloemen\n//       cleaned up code\n//       added InvalidProve() error\n//       always revert with InvalidProof() on invalid proof\n//       make Pairing strict\n//\n// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.4;\n\nlibrary Pairing {\n  error InvalidProof();\n\n  // The prime q in the base field F_q for G1\n  uint256 constant BASE_MODULUS = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\n\n  // The prime moludus of the scalar field of G1.\n  uint256 constant SCALAR_MODULUS = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n\n  struct G1Point {\n    uint256 X;\n    uint256 Y;\n  }\n\n  // Encoding of field elements is: X[0] * z + X[1]\n  struct G2Point {\n    uint256[2] X;\n    uint256[2] Y;\n  }\n\n  /// @return the generator of G1\n  function P1() internal pure returns (G1Point memory) {\n    return G1Point(1, 2);\n  }\n\n  /// @return the generator of G2\n  function P2() internal pure returns (G2Point memory) {\n    return\n      G2Point(\n        [\n          11559732032986387107991004021392285783925812861821192530917403151452391805634,\n          10857046999023057135944570762232829481370756359578518086990519993285655852781\n        ],\n        [\n          4082367875863433681332203403145435568316851327593401208105741076214120093531,\n          8495653923123431417604973247489272438418190587263600148770280649306958101930\n        ]\n      );\n  }\n\n  /// @return r the negation of p, i.e. p.addition(p.negate()) should be zero.\n  function negate(G1Point memory p) internal pure returns (G1Point memory r) {\n    if (p.X == 0 && p.Y == 0) return G1Point(0, 0);\n    // Validate input or revert\n    if (p.X >= BASE_MODULUS || p.Y >= BASE_MODULUS) revert InvalidProof();\n    // We know p.Y > 0 and p.Y < BASE_MODULUS.\n    return G1Point(p.X, BASE_MODULUS - p.Y);\n  }\n\n  /// @return r the sum of two points of G1\n  function addition(G1Point memory p1, G1Point memory p2) internal view returns (G1Point memory r) {\n    // By EIP-196 all input is validated to be less than the BASE_MODULUS and form points\n    // on the curve.\n    uint256[4] memory input;\n    input[0] = p1.X;\n    input[1] = p1.Y;\n    input[2] = p2.X;\n    input[3] = p2.Y;\n    bool success;\n    // solium-disable-next-line security/no-inline-assembly\n    assembly {\n      success := staticcall(sub(gas(), 2000), 6, input, 0xc0, r, 0x60)\n    }\n    if (!success) revert InvalidProof();\n  }\n\n  /// @return r the product of a point on G1 and a scalar, i.e.\n  /// p == p.scalar_mul(1) and p.addition(p) == p.scalar_mul(2) for all points p.\n  function scalar_mul(G1Point memory p, uint256 s) internal view returns (G1Point memory r) {\n    // By EIP-196 the values p.X and p.Y are verified to less than the BASE_MODULUS and\n    // form a valid point on the curve. But the scalar is not verified, so we do that explicitelly.\n    if (s >= SCALAR_MODULUS) revert InvalidProof();\n    uint256[3] memory input;\n    input[0] = p.X;\n    input[1] = p.Y;\n    input[2] = s;\n    bool success;\n    // solium-disable-next-line security/no-inline-assembly\n    assembly {\n      success := staticcall(sub(gas(), 2000), 7, input, 0x80, r, 0x60)\n    }\n    if (!success) revert InvalidProof();\n  }\n\n  /// Asserts the pairing check\n  /// e(p1[0], p2[0]) *  .... * e(p1[n], p2[n]) == 1\n  /// For example pairing([P1(), P1().negate()], [P2(), P2()]) should succeed\n  function pairingCheck(G1Point[] memory p1, G2Point[] memory p2) internal view {\n    // By EIP-197 all input is verified to be less than the BASE_MODULUS and form elements in their\n    // respective groups of the right order.\n    if (p1.length != p2.length) revert InvalidProof();\n    uint256 elements = p1.length;\n    uint256 inputSize = elements * 6;\n    uint256[] memory input = new uint256[](inputSize);\n    for (uint256 i = 0; i < elements; i++) {\n      input[i * 6 + 0] = p1[i].X;\n      input[i * 6 + 1] = p1[i].Y;\n      input[i * 6 + 2] = p2[i].X[0];\n      input[i * 6 + 3] = p2[i].X[1];\n      input[i * 6 + 4] = p2[i].Y[0];\n      input[i * 6 + 5] = p2[i].Y[1];\n    }\n    uint256[1] memory out;\n    bool success;\n    // solium-disable-next-line security/no-inline-assembly\n    assembly {\n      success := staticcall(sub(gas(), 2000), 8, add(input, 0x20), mul(inputSize, 0x20), out, 0x20)\n    }\n    if (!success || out[0] != 1) revert InvalidProof();\n  }\n}\n\ncontract Verifier {\n  using Pairing for *;\n\n  struct VerifyingKey {\n    Pairing.G1Point alfa1;\n    Pairing.G2Point beta2;\n    Pairing.G2Point gamma2;\n    Pairing.G2Point delta2;\n    Pairing.G1Point[] IC;\n  }\n\n  struct Proof {\n    Pairing.G1Point A;\n    Pairing.G2Point B;\n    Pairing.G1Point C;\n  }\n\n  function verifyingKey() internal pure returns (VerifyingKey memory vk) {\n    vk.alfa1 = Pairing.G1Point(\n      20491192805390485299153009773594534940189261866228447918068658471970481763042,\n      9383485363053290200918347156157836566562967994039712273449902621266178545958\n    );\n\n    vk.beta2 = Pairing.G2Point(\n      [\n        4252822878758300859123897981450591353533073413197771768651442665752259397132,\n        6375614351688725206403948262868962793625744043794305715222011528459656738731\n      ],\n      [\n        21847035105528745403288232691147584728191162732299865338377159692350059136679,\n        10505242626370262277552901082094356697409835680220590971873171140371331206856\n      ]\n    );\n    vk.gamma2 = Pairing.G2Point(\n      [\n        11559732032986387107991004021392285783925812861821192530917403151452391805634,\n        10857046999023057135944570762232829481370756359578518086990519993285655852781\n      ],\n      [\n        4082367875863433681332203403145435568316851327593401208105741076214120093531,\n        8495653923123431417604973247489272438418190587263600148770280649306958101930\n      ]\n    );\n    vk.delta2 = Pairing.G2Point(\n      [\n        12599857379517512478445603412764121041984228075771497593287716170335433683702,\n        7912208710313447447762395792098481825752520616755888860068004689933335666613\n      ],\n      [\n        11502426145685875357967720478366491326865907869902181704031346886834786027007,\n        21679208693936337484429571887537508926366191105267550375038502782696042114705\n      ]\n    );\n    vk.IC = new Pairing.G1Point[](5);\n\n    vk.IC[0] = Pairing.G1Point(\n      19918517214839406678907482305035208173510172567546071380302965459737278553528,\n      7151186077716310064777520690144511885696297127165278362082219441732663131220\n    );\n\n    vk.IC[1] = Pairing.G1Point(\n      690581125971423619528508316402701520070153774868732534279095503611995849608,\n      21271996888576045810415843612869789314680408477068973024786458305950370465558\n    );\n\n    vk.IC[2] = Pairing.G1Point(\n      16461282535702132833442937829027913110152135149151199860671943445720775371319,\n      2814052162479976678403678512565563275428791320557060777323643795017729081887\n    );\n\n    vk.IC[3] = Pairing.G1Point(\n      4319780315499060392574138782191013129592543766464046592208884866569377437627,\n      13920930439395002698339449999482247728129484070642079851312682993555105218086\n    );\n\n    vk.IC[4] = Pairing.G1Point(\n      3554830803181375418665292545416227334138838284686406179598687755626325482686,\n      5951609174746846070367113593675211691311013364421437923470787371738135276998\n    );\n  }\n\n  /// @dev Verifies a Semaphore proof. Reverts with InvalidProof if the proof is invalid.\n  function verifyProof(\n    uint256[2] memory a,\n    uint256[2][2] memory b,\n    uint256[2] memory c,\n    uint256[4] memory input\n  ) public view {\n    // If the values are not in the correct range, the Pairing contract will revert.\n    Proof memory proof;\n    proof.A = Pairing.G1Point(a[0], a[1]);\n    proof.B = Pairing.G2Point([b[0][0], b[0][1]], [b[1][0], b[1][1]]);\n    proof.C = Pairing.G1Point(c[0], c[1]);\n\n    VerifyingKey memory vk = verifyingKey();\n\n    // Compute the linear combination vk_x of inputs times IC\n    if (input.length + 1 != vk.IC.length) revert Pairing.InvalidProof();\n    Pairing.G1Point memory vk_x = vk.IC[0];\n    vk_x = Pairing.addition(vk_x, Pairing.scalar_mul(vk.IC[1], input[0]));\n    vk_x = Pairing.addition(vk_x, Pairing.scalar_mul(vk.IC[2], input[1]));\n    vk_x = Pairing.addition(vk_x, Pairing.scalar_mul(vk.IC[3], input[2]));\n    vk_x = Pairing.addition(vk_x, Pairing.scalar_mul(vk.IC[4], input[3]));\n\n    // Check pairing\n    Pairing.G1Point[] memory p1 = new Pairing.G1Point[](4);\n    Pairing.G2Point[] memory p2 = new Pairing.G2Point[](4);\n    p1[0] = Pairing.negate(proof.A);\n    p2[0] = proof.B;\n    p1[1] = vk.alfa1;\n    p2[1] = vk.beta2;\n    p1[2] = vk_x;\n    p2[2] = vk.gamma2;\n    p1[3] = proof.C;\n    p2[3] = vk.delta2;\n    Pairing.pairingCheck(p1, p2);\n  }\n}\n"
    },
    "@appliedzkp/semaphore-contracts/base/SemaphoreCore.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../interfaces/ISemaphoreCore.sol\";\nimport \"../interfaces/IVerifier.sol\";\n\n/// @title Semaphore core contract.\n/// @notice Minimal code to allow users to signal their endorsement of an arbitrary string.\n/// @dev The following code verifies that the proof is correct and saves the hash of the\n/// nullifier to prevent double-signaling. External nullifier and Merkle trees (i.e. groups) must be\n/// managed externally.\ncontract SemaphoreCore is ISemaphoreCore {\n  /// @dev Gets a nullifier hash and returns true or false.\n  /// It is used to prevent double-signaling.\n  mapping(uint256 => bool) internal nullifierHashes;\n\n  /// @dev Asserts that no nullifier already exists and if the zero-knowledge proof is valid.\n  /// Otherwise it reverts.\n  /// @param signal: Semaphore signal.\n  /// @param root: Root of the Merkle tree.\n  /// @param nullifierHash: Nullifier hash.\n  /// @param externalNullifier: External nullifier.\n  /// @param proof: Zero-knowledge proof.\n  /// @param verifier: Verifier address.\n  function _verifyProof(\n    bytes32 signal,\n    uint256 root,\n    uint256 nullifierHash,\n    uint256 externalNullifier,\n    uint256[8] calldata proof,\n    IVerifier verifier\n  ) internal view {\n    require(!nullifierHashes[nullifierHash], \"SemaphoreCore: you cannot use the same nullifier twice\");\n\n    uint256 signalHash = _hashSignal(signal);\n\n    verifier.verifyProof(\n      [proof[0], proof[1]],\n      [[proof[2], proof[3]], [proof[4], proof[5]]],\n      [proof[6], proof[7]],\n      [root, nullifierHash, signalHash, externalNullifier]\n    );\n  }\n\n  /// @dev Stores the nullifier hash to prevent double-signaling.\n  /// Attention! Remember to call it when you verify a proof if you\n  /// need to prevent double-signaling.\n  /// @param nullifierHash: Semaphore nullifier hash.\n  function _saveNullifierHash(uint256 nullifierHash) internal {\n    nullifierHashes[nullifierHash] = true;\n  }\n\n  /// @dev Creates a keccak256 hash of the signal.\n  /// @param signal: Semaphore signal.\n  /// @return Hash of the signal.\n  function _hashSignal(bytes32 signal) private pure returns (uint256) {\n    return uint256(keccak256(abi.encodePacked(signal))) >> 8;\n  }\n}\n"
    },
    "@appliedzkp/semaphore-contracts/base/SemaphoreConstants.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nuint256 constant SNARK_SCALAR_FIELD = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n"
    },
    "@appliedzkp/semaphore-contracts/interfaces/ISemaphoreCore.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @title SemaphoreCore interface.\n/// @dev Interface of SemaphoreCore contract.\ninterface ISemaphoreCore {\n  /// @notice Emitted when a proof is verified correctly and a new nullifier hash is added.\n  /// @param nullifierHash: Hash of external and identity nullifiers.\n  event NullifierHashAdded(uint256 nullifierHash);\n}\n"
    },
    "contracts/staking/voting.sol": {
      "content": "pragma solidity ^0.8.4;\n\nimport \"../stablecoin/DSS.sol\";\nimport \"hardhat/console.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\n//Code borrowed and adapted from Tokemak \n\n/// @notice Vote payload to be submitted to Vote Tracker\nstruct UserVotePayload {\n    address account;\n    bytes32 voteSessionKey;\n    uint256 nonce;\n    uint256 chainId;\n    uint256 totalVotes;\n    UserVoteAllocationItem[] allocations;\n}\n\n/// @notice Individual allocation to an asset, exchange, or asset-pair\nstruct UserVoteAllocationItem {\n    bytes32 reactorKey;\n    uint256 amount; //18 Decimals\n}\n\n\nstruct UserVoteDetails {\n    uint256 totalUsedVotes;\n    uint256 totalAvailableVotes;\n}\ncontract VoteTracker {\n    using SafeMath for uint256;\n\n\tDSS public dss;\n\n\n\tmapping(address => UserVoteDetails) userVoteDetails;\n    mapping(address => bytes32[]) public userVoteKeys;\n    mapping(address => mapping(bytes32 => uint256)) public userVoteItems;\n    mapping(bytes32 => uint256) public systemAggregations;\n\n    /// @dev Stores the users next valid vote nonce\n    EnumerableSet.Bytes32Set private allowedreactorKeys;\n\tmapping(address => uint256) public  userNonces; \n\n\tconstructor (address dss_address) public{\n\t\tdss = DSS(dss_address);\n\t}\n\n\n\n    //single user will call this vote function from UI, vote allocation for \n    //each potential borrowers \n\tfunction vote(bytes32 _voteSessionKey, uint256 _nonce, uint256 _totalVotes,\n        bytes32[] memory reactorKeys, uint256[] memory amounts)\n\texternal  {\n        uint256 key_lengths = reactorKeys.length; \n        UserVoteAllocationItem[] memory _allocations = new UserVoteAllocationItem[](key_lengths); \n\n\n        for (uint256 i=0; i < key_lengths; i++){\n            _allocations[i] = UserVoteAllocationItem({\n                reactorKey : reactorKeys[i], \n                amount: amounts[i]\n                });\n\n        }\n\n\n        UserVotePayload memory payload  = UserVotePayload({\n            account : msg.sender, \n            voteSessionKey : _voteSessionKey, \n            nonce: _nonce, \n            chainId : 0, \n            totalVotes: _totalVotes, \n            allocations: _allocations\n            }); \n\n        _vote(payload);\n\n\t}\n\n\n    function _removeUserVoteKey(address account, bytes32 reactorKey) internal  {\n        for (uint256 i = 0; i < userVoteKeys[account].length; i++) {\n            if (userVoteKeys[account][i] == reactorKey) {\n                userVoteKeys[account][i] = userVoteKeys[account][userVoteKeys[account].length - 1];\n                userVoteKeys[account].pop();\n                break;\n            }\n        }\n    }\n\n    \n\n\tfunction _vote(UserVotePayload memory userVotePayload) internal  {\n\t\taddress account = userVotePayload.account; \n\t\tuint256 totalUsedVotes = userVoteDetails[account].totalUsedVotes;\n\n        console.log('nonce', userNonces[account]);\n\t\trequire(userNonces[account] == userVotePayload.nonce, \"INVALID_NONCE\");\n\n\t\t// Ensure the message cannot be replayed\n        userNonces[account] = userNonces[account].add(1);\n\n\t\tfor (uint256 i = 0; i < userVotePayload.allocations.length; i++) {\n\t\t\tbytes32 reactorKey = userVotePayload.allocations[i].reactorKey;\n\t\t\tuint256 amount = userVotePayload.allocations[i].amount; \n\n            //Ensure where they are voting is allowed\n\t\t\t//require(allowedreactorKeys.contains(reactorKey),  \"PLACEMENT_NOT_ALLOWED\"); \n\n            // check if user has already voted for this reactor\n\t\t\tif (userVoteItems[account][reactorKey]>0){\n\t\t\t\tif (amount ==0){\n\t\t\t\t\t_removeUserVoteKey(account, reactorKey);\n\t\t\t\t}\n\n\t\t\t\tuint256 currentAmount = userVoteItems[account][reactorKey];\n\n            }\n\n            else{\n                \n\t\t\t\tif(amount>0){\n\t\t\t\t\tuserVoteKeys[account].push(reactorKey);\n\t\t\t\t\tuserVoteItems[account][reactorKey] = amount; \n\t\t\t\t\tsystemAggregations[reactorKey] = systemAggregations[reactorKey].add(amount);\n\t\t\t\t\ttotalUsedVotes = totalUsedVotes.add(amount);\n\t\t\t\t}\n\n            }\n\n\t\t\t\n\t\t}\n\n        console.log('totalusedvotes',totalUsedVotes,  userVotePayload.totalVotes);\n\t\trequire(totalUsedVotes == userVotePayload.totalVotes, \"VOTE_TOTAL_MISMATCH\");\n\n        uint256 totalAvailableVotes = getMaxVoteBalance(account);\n     //   require(totalUsedVotes <= totalAvailableVotes, \"NOT_ENOUGH_VOTES\");\n\n        userVoteDetails[account] = UserVoteDetails({\n        \ttotalUsedVotes: totalUsedVotes,\n            totalAvailableVotes: totalAvailableVotes\n        \t}); \n\n\n\n\t}\n\n\n\n    function getMaxVoteBalance(address account) public view returns (uint256) {\n    \tuint256 dssbalance = dss.balanceOf(account); \n\n        return _getVotingPower(dssbalance);\n    }\n\n    function _getVotingPower(uint256 balance) private view returns (uint256) {\n\t\treturn balance; \n    }\n\n\n    //get vote for one borrower \n    function getVotes(bytes32 reactorKey) public view returns (uint256){\n        return systemAggregations[reactorKey]; \n    }\n\n\n}"
    },
    "contracts/stablecoin/DSS.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\nimport \"../ERC20/ERC20Custom.sol\";\nimport \"../Common/AccessControl.sol\";\nimport \"../Common/Ownable.sol\";\n\ncontract DSS is ERC20Custom, AccessControl, Ownable {\n    /* ========== STATE VARIABLES ========== */\n    \n    address[] public pools_array;\n    mapping(address => bool) pools;\n    \n    address public creator_address;\n    address timelock_address;\n    address public DEFAULT_ADMIN_ADDRESS;\n    uint256 constant genesis_supply = 1000000e18;\n\n    \n    /* ========== MODIFIERS ========== */\n    modifier onlyPools() {\n        require(pools[msg.sender] == true, \"Only pools can call this function\");\n        _;\n    }\n\n    constructor (\n        address _creator_address,\n        address _timelock_address\n    )  ERC20Custom(\"Debita Stablecoin Share\",\"DSS\") Ownable(_creator_address)\n    {\n        _mint(_creator_address, genesis_supply);\n        creator_address = _creator_address;\n        timelock_address = _timelock_address;\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n        DEFAULT_ADMIN_ADDRESS = _msgSender();\n        _grantRole(DEFAULT_ADMIN_ROLE, _creator_address);\n    }\n\n    function addPool(address pool_address) public onlyOwner {\n        require(pool_address != address(0), \"Zero address detected\");\n\n        require(pools[pool_address] == false, \"Address already exists\");\n        pools[pool_address] = true; \n        pools_array.push(pool_address);\n\n        //emit PoolAdded(pool_address);\n    }\n    \n    // Used by pools when user redeems\n    function pool_burn(address b_address, uint256 b_amount) public onlyPools {\n        super._burn(b_address, b_amount);\n    }\n\n    function pool_mint(address m_address, uint256 m_amount) public onlyPools {\n        super._mint(m_address, m_amount);\n    }\n\n    function dss_price() public view returns(uint256){\n        return 1e6; \n    }\n\n    function get_collateral_ratio() public view returns(uint256){\n        return 1e6;\n    }\n}"
    },
    "contracts/ERC20/ERC20Custom.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\n\nimport \"./IERC20.sol\";\nimport \"../Common/Context.sol\";\n\ncontract ERC20Custom is Context, IERC20 {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 6;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}"
    },
    "contracts/Common/AccessControl.sol": {
      "content": "pragma solidity ^0.8.4;\n\nimport \"./IAccessControl.sol\";\nimport \"./Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(account),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}"
    },
    "contracts/Common/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.4;\n\nimport \"./Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor(address creator_address) {\n        _transferOwnership(creator_address);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}"
    },
    "contracts/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.4;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}"
    },
    "contracts/Common/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.4;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}"
    },
    "contracts/Common/IAccessControl.sol": {
      "content": "pragma solidity ^0.8.4;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}"
    },
    "contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\n\npragma solidity ^0.8.4;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}"
    },
    "contracts/utils/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.4;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}"
    },
    "contracts/utils/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.4;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}"
    },
    "contracts/stablecoin/lendingpool.sol": {
      "content": "pragma solidity ^0.8.4;\n\nimport \"./owned.sol\";\nimport \"./DS.sol\";\nimport \"./DSS.sol\";\nimport \"../ERC20/IERC20.sol\";\nimport \"../ERC20/SafeERC20.sol\";\nimport \"hardhat/console.sol\";\nimport \"./ILendingPool.sol\";\nimport \"./IController.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\n//borrowers borrow and repay from this lendingpool\ncontract LendingPool is ILendingPool, Owned {\n    using SafeERC20 for IERC20;\n    using Address for address;\n\n    // addresses\n    address private collateral_address;\n    address private creator_address;\n    address private timelock_address;\n    IController private controller; \n    DS private DScontract;\n    DSS private DSScontract;\n\n    // pool parameters\n    uint256 pool_ceiling;\n    uint256 bonus_rate;\n    uint256 redemption_delay;\n    uint256 minting_fee;\n    uint256 redemption_fee;\n    uint256 buyback_fee;\n    uint256 recollat_fee;\n    uint256 missing_decimals;\n    uint256 private constant PRICE_PRECISION = 1e6;\n    uint256 public total_borrowed_amount;\n    uint256 public accrued_interest;\n    uint256 immutable public MAX_LOANS = 20;\n    uint256 immutable public MAX_PROPOSALS = 20;\n\n    // mint/redeem\n    mapping(address => uint256) public redeemDSSBalances;\n    mapping(address => uint256) public redeemCollateralBalances;\n    uint256 public unclaimedPoolCollateral;\n    uint256 public unclaimedPoolDSS;\n    mapping(address => uint256) public lastRedeemed;\n\n    // loan\n    mapping(address => bool) public override is_borrower;\n    mapping(address => uint256) public override borrower_allowance; // borrower total allowance\n    mapping(address => uint256) public override amount_borrowed; // borrower total amount borrowed\n    mapping(address => LoanMetadata[]) public current_loan_data; // current pending proposals and active loans for each user.\n    mapping(address => uint256) public override num_loans;\n    mapping(address => uint256) public override num_proposals;\n    address[] public borrowers_array;\n    mapping(bytes32 => bool) id_taken;\n\n    modifier onlyByOwnGov() {\n        require(msg.sender == timelock_address || msg.sender == owner, \"Not owner or timelock\");\n        _;\n    }\n\n    modifier onlyController() {\n        require(address(controller) == msg.sender, \"is not controller\");\n        _;\n    }\n\n    modifier onlyBorrower() {\n        require(is_borrower[msg.sender], \"is not borrower\");\n        _;\n    }\n\n    modifier onlyVerified() {\n        //require(controller.verified(msg.sender), \"address not verified\");\n        _;\n    }\n\n    modifier onlyValidator() {\n        require(controller.validators(msg.sender), \"address must be validator\");\n        _;\n    }\n\n    modifier onlyContract() {\n        require(address(msg.sender).isContract(), \"is not smart contract\");\n        _;\n    }\n\n    constructor(\n        address _ds_address,\n        address _dss_address,\n        address _collateral_address,\n        address _creator_address,\n        address _timelock_address\n    ) public Owned(_creator_address) {\n        require(\n            (_ds_address != address(0)) &&\n                (_dss_address != address(0)) &&\n                (_collateral_address != address(0)) &&\n                (_creator_address != address(0)) &&\n                (_timelock_address != address(0)),\n            \"Zero address detected\"\n        );\n\n        DScontract = DS(_ds_address);\n        DSScontract = DSS(_dss_address);\n        collateral_address = _collateral_address;\n        creator_address = _creator_address;\n        timelock_address = _timelock_address;\n        missing_decimals = uint256(0);\n    }\n\n    //Currently ds decimals is 6, same as USDC, so collateral amount should also be decimal 6\n    function mintDS(uint256 collateral_amount, uint256 DS_out_min) external override {\n        uint256 collateral_amount_d18 = collateral_amount * (10**missing_decimals);\n\n        uint256 DS_amount_18 = collateral_amount_d18; //1to1\n        DS_amount_18 = (DS_amount_18 * (1e6 - minting_fee)) / 1e6; // (DS_amount_18.mul(uint(1e6).sub(minting_fee))).div(uint(1e6));\n        require(DS_out_min <= DS_amount_18);\n\n        IERC20(collateral_address).safeTransferFrom(msg.sender, address(this), collateral_amount);\n        //TransferHelper.safeTransferFrom(collateral_address, msg.sender, address(this), collateral_amount);\n        DScontract.pool_mint(msg.sender, DS_amount_18);\n    }\n\n    function redeemDS(\n        uint256 DS_amount,\n        uint256 DSS_out_min,\n        uint256 COLLATERAL_out_min\n    ) external override {\n        uint256 dss_price = DScontract.dss_price();\n        uint256 collateral_ratio = DScontract.get_collateral_ratio();\n        uint256 DS_amount_18 = DS_amount * 10**missing_decimals; // DS_amount.mul(10**missing_decimals);\n\n        uint256 DS_amount_post_fee = (DS_amount * (1e6 - redemption_fee)) / 1e6; // (DS_amount.mul(uint(1e6).sub(redemption_fee))).div(uint(1e6));\n        uint256 dss_dollar_value = DS_amount_post_fee - ((DS_amount_post_fee * collateral_ratio) / PRICE_PRECISION); // DS_amount_post_fee.sub(DS_amount_post_fee.mul(collateral_ratio).div(PRICE_PRECISION));\n        uint256 dss_amount = (dss_dollar_value * PRICE_PRECISION) / dss_price; // dss_dollar_value.mul(PRICE_PRECISION).div(dss_price);\n\n        uint256 DS_amount_precision = DS_amount_post_fee;\n        uint256 collateral_dollar_value = (DS_amount_precision * collateral_ratio) / PRICE_PRECISION; // DS_amount_precision.mul(collateral_ratio).div(PRICE_PRECISION);\n        uint256 collateral_amount = collateral_dollar_value; //.mul(10**missing_decimals); //for now assume collateral is stable\n\n        redeemCollateralBalances[msg.sender] = redeemCollateralBalances[msg.sender] + collateral_amount; // redeemCollateralBalances[msg.sender].add(collateral_amount);\n        unclaimedPoolCollateral = unclaimedPoolCollateral + collateral_amount; // unclaimedPoolCollateral.add(collateral_amount);\n\n        redeemDSSBalances[msg.sender] = redeemDSSBalances[msg.sender] + dss_amount; // redeemDSSBalances[msg.sender].add(dss_amount);\n        unclaimedPoolDSS = unclaimedPoolDSS + dss_amount; // unclaimedPoolDSS.add(dss_amount);\n\n        lastRedeemed[msg.sender] = block.number;\n        DScontract.pool_burn(msg.sender, DS_amount_18);\n        DSScontract.pool_mint(address(this), dss_amount);\n    }\n\n    function collectRedemption(uint256 col_idx)\n        external\n        override\n        returns (uint256 dss_amount, uint256 collateral_amount)\n    {\n        // require(redeemPaused[col_idx] == false, \"Redeeming is paused\");\n        // require((lastRedeemed[msg.sender].add(redemption_delay)) <= block.number, \"Too soon\");\n        bool sendDSS = false;\n        bool sendCollateral = false;\n\n        if (redeemDSSBalances[msg.sender] > 0) {\n            dss_amount = redeemDSSBalances[msg.sender];\n            redeemDSSBalances[msg.sender] = 0;\n            unclaimedPoolDSS = unclaimedPoolDSS - dss_amount; // unclaimedPoolDSS.sub(dss_amount);\n            sendDSS = true;\n        }\n\n        if (redeemCollateralBalances[msg.sender] > 0) {\n            collateral_amount = redeemCollateralBalances[msg.sender];\n            redeemCollateralBalances[msg.sender] = 0;\n            unclaimedPoolCollateral = unclaimedPoolCollateral - collateral_amount; // unclaimedPoolCollateral.sub(collateral_amount);\n            sendCollateral = true;\n        }\n\n        if (sendDSS) {\n            //TransferHelper.safeTransfer(address(DSScontract), msg.sender, dss_amount);\n            IERC20(address(DSScontract)).safeTransfer(msg.sender, dss_amount);\n        }\n\n        if (sendCollateral) {\n            //TransferHelper.safeTransfer(collateral_address, msg.sender, collateral_amount);\n            IERC20(address(collateral_address)).safeTransfer(msg.sender, collateral_amount);\n        }\n    }\n\n    function setPoolParameters(\n        uint256 new_ceiling,\n        uint256 new_bonus_rate,\n        uint256 new_redemption_delay,\n        uint256 new_mint_fee,\n        uint256 new_redeem_fee,\n        uint256 new_buyback_fee,\n        uint256 new_recollat_fee\n    ) external override onlyByOwnGov {\n        pool_ceiling = new_ceiling;\n        bonus_rate = new_bonus_rate;\n        redemption_delay = new_redemption_delay;\n        minting_fee = new_mint_fee;\n        redemption_fee = new_redeem_fee;\n        buyback_fee = new_buyback_fee;\n        recollat_fee = new_recollat_fee;\n\n        //emit PoolParametersSet(new_ceiling, new_bonus_rate, new_redemption_delay, new_mint_fee, new_redeem_fee, new_buyback_fee, new_recollat_fee);\n    }\n\n    //Controller Functions\n\n    function setController(address _controller) external override onlyByOwnGov {\n        controller = IController(_controller);\n    }\n\n    function controllerMintDS(uint256 amount) external override onlyController {\n        DScontract.pool_mint(msg.sender, amount);\n    }\n\n    function controllerBurnDS(uint256 amount) external override onlyController {\n        DScontract.pool_burn(msg.sender, amount);\n    }\n\n    //TODO external for now, but needs to be internal+called when borrower proposes\n    function addValidator(address validator) external override {\n        controller.addValidator(validator);\n    }\n\n    // loan functions\n    function addDiscretionaryLoanProposal(\n        bytes32 _id,\n        uint256 _principal,\n        uint256 _duration,\n        uint256 _totalInterest,\n        string calldata _description,\n        IController.MarketInfo memory market_info\n    ) external override onlyVerified {\n        require(_principal > 0, \"principal must be greater than 0\");\n        require(_duration > 0, \"duration must be greater than 0\");\n        require(_totalInterest > 0, \"total interst must be greater than 0\");\n        require(num_proposals[msg.sender] < MAX_PROPOSALS, \"proposal limit reached\");\n        require(_principal >= 10**DScontract.decimals(), \"Needs to be in decimal format\"); // should be collateral address, not DS. Can't be less than 1.0 X?\n        require(!id_taken[_id], \"loan id must be unique\");\n\n        num_proposals[msg.sender]++;\n        id_taken[_id] = true;\n\n        current_loan_data[msg.sender].push(\n            LoanMetadata({\n                id: _id,\n                principal: _principal,\n                totalInterest: _totalInterest,\n                duration: _duration,\n                interestPaid: 0,\n                amountBorrowed: 0,\n                description: _description,\n                approved: false,\n                allowance: 0,\n                repaymentDate: 0,\n                recipient: address(0)\n            })\n        );\n\n        //controller.initiateMarket_(market_info, msg.sender, _id);\n\n        emit LoanProposal(msg.sender, _id);\n    }\n\n    function addContractLoanProposal(\n        bytes32 _id,\n        address _recipient,\n        uint256 _principal,\n        uint256 _duration,\n        uint256 _totalInterest,\n        string calldata _description,\n        IController.MarketInfo memory market_info\n    ) external override onlyVerified {\n        require(_principal > 0, \"principal must be greater than 0\");\n        require(_duration > 0, \"duration must be greater than 0\");\n        require(_totalInterest > 0, \"total interst must be greater than 0\");\n        require(num_proposals[msg.sender] < MAX_PROPOSALS, \"proposal limit reached\");\n        require(_principal >= 10**DScontract.decimals(), \"Needs to be in decimal format\");\n        require(address(_recipient).isContract(), \"Recipient must be contract\");\n        require(!id_taken[_id], \"loan id must be unique\");\n\n        num_proposals[msg.sender]++;\n        id_taken[_id] = true;\n\n        current_loan_data[msg.sender].push(\n            LoanMetadata({\n                id: _id,\n                principal: _principal,\n                totalInterest: _totalInterest,\n                duration: _duration,\n                interestPaid: 0,\n                amountBorrowed: 0,\n                description: _description,\n                approved: false,\n                allowance: 0,\n                repaymentDate: 0,\n                recipient: _recipient\n            })\n        );\n\n        //controller._initiateMarket(market_info, msg.sender, _id);\n\n        emit LoanProposal(msg.sender, _id);\n    }\n\n    function removeProposal(bytes32 id) external override onlyVerified returns (bool) {\n        return _removeProposal(msg.sender, id);\n    }\n\n    function removeProposalGov(address recipient, bytes32 id) external override onlyByOwnGov returns (bool) {\n        return _removeProposal(recipient, id);\n    }\n\n    function _removeProposal(address recipient, bytes32 id) internal returns (bool) {\n\n        for (uint256 i = 0; i < num_proposals[recipient]; i++) {\n            if (id == current_loan_data[recipient][i].id) {\n                emit LoanProposalRemoval(recipient, current_loan_data[recipient][i]);\n\n                _removeLoan(recipient, i);\n\n                num_proposals[recipient]--;\n                id_taken[id] = false;\n                return true;\n            }\n        }\n        return false;\n    }\n\n    // called by controller\n    function approveLoan(\n        address recipient, // owner of loan\n        bytes32 id,\n        address marketFactoryAddress\n    ) public override onlyValidator {\n        require(num_loans[recipient] < MAX_LOANS, \"max number of loans reached\");\n\n        for (uint256 i = 0; i < current_loan_data[recipient].length; i++) {\n            if (id == current_loan_data[recipient][i].id) {\n                require(!current_loan_data[recipient][i].approved, \"loan already approved\");\n\n                //require(controller.canBeApproved(recipient, id, marketFactoryAddress), \"not market approved\");\n\n                LoanMetadata storage loan = current_loan_data[recipient][i];\n\n                loan.approved = true;\n\n                loan.repaymentDate = block.timestamp + loan.duration;\n\n                emit LoanApproval(recipient, current_loan_data[recipient][i]);\n\n                if (!is_borrower[recipient]) {\n                    is_borrower[recipient] = true;\n                    borrowers_array.push(recipient);\n                }\n\n                num_loans[recipient]++;\n                num_proposals[recipient]--;\n                borrower_allowance[recipient] += loan.principal;\n                loan.allowance = loan.principal;\n                return;\n            }\n        }\n        revert(\"loan not found\");\n    }\n\n    function removeBorrower(address borrower) private {\n        uint256 length = borrowers_array.length;\n        for (uint256 i = 0; i < length; i++) {\n            if (borrower == borrowers_array[i]) {\n                borrowers_array[i] = borrowers_array[length - 1];\n                borrowers_array.pop();\n            }\n        }\n    }\n\n    function borrow(bytes32 id, uint256 amount) external override onlyBorrower onlyVerified {\n\n        for (uint256 i = 0; i < current_loan_data[msg.sender].length; i++) {\n            if (current_loan_data[msg.sender][i].id == id) {\n                LoanMetadata storage loan = current_loan_data[msg.sender][i];\n\n                require(loan.approved, \"loan not approved\");\n\n                require(loan.repaymentDate > block.timestamp, \"Loan has already reached maturity\");\n\n                require(loan.allowance >= amount, \"amount exceed's loan allowance\");\n\n                loan.allowance -= amount;\n\n                borrower_allowance[msg.sender] -= amount;\n\n                IERC20(collateral_address).safeTransfer(msg.sender, amount);\n\n                amount_borrowed[msg.sender] += amount;\n\n                loan.amountBorrowed += amount;\n\n                total_borrowed_amount += amount;\n\n                emit FundsBorrowed(msg.sender, amount);\n\n                return;\n            }\n        }\n        revert(\"loan not found\");\n    }\n\n    function contractBorrow(\n        address owner,\n        bytes32 id,\n        uint256 amount\n    ) external override onlyContract {\n\n        for (uint256 i = 0; i < current_loan_data[owner].length; i++) {\n            if (id == current_loan_data[owner][i].id) {\n                LoanMetadata storage loan = current_loan_data[owner][i];\n\n                require(loan.recipient == msg.sender, \"loan recipient doesn't match caller\");\n                require(loan.approved, \"loan not approved\");\n                require(loan.repaymentDate > block.timestamp, \"Loan has already reached maturity\");\n                require(loan.allowance >= amount, \"amount exceed's loan allowance\");\n\n                loan.allowance -= amount;\n\n                borrower_allowance[owner] -= amount;\n\n                IERC20(collateral_address).safeTransfer(msg.sender, amount);\n\n                amount_borrowed[owner] += amount;\n\n                loan.amountBorrowed += amount;\n\n                total_borrowed_amount += amount;\n\n                emit FundsBorrowed(msg.sender, amount);\n            }\n        }\n        revert(\"loan not found\");\n    }\n\n    function repay(\n        bytes32 id,\n        uint256 repay_principal,\n        uint256 repay_interest\n    ) external override onlyBorrower {\n        uint256 total_repayment = repay_principal + repay_interest;\n\n        for (uint256 i = 0; i < current_loan_data[msg.sender].length; i++) {\n            if (id == current_loan_data[msg.sender][i].id) {\n                LoanMetadata storage loan = current_loan_data[msg.sender][i];\n\n                require(loan.approved, \"loan not approved\");\n                require(loan.repaymentDate > block.timestamp, \"Loan has already reached maturity\");\n                require(loan.interestPaid + repay_interest <= loan.totalInterest, \"overpaid for loan interest\");\n                require(loan.amountBorrowed >= repay_principal, \"overpaid for loan principal\");\n\n                amount_borrowed[msg.sender] -= repay_principal;\n\n                loan.amountBorrowed -= repay_principal;\n\n                loan.interestPaid += repay_interest;\n\n                accrued_interest += repay_interest;\n\n                console.log(\"total_borrowed_amount\", total_borrowed_amount);\n\n                total_borrowed_amount = total_borrowed_amount - repay_principal;\n\n                //TransferHelper.safeTransferFrom(collateral_address, msg.sender, address(this), total_repayment);\n                IERC20(collateral_address).safeTransferFrom(msg.sender, address(this), total_repayment);\n                return;\n            }\n        }\n        revert(\"loan not found\");\n    }\n\n    function contractRepay(\n        address owner,\n        bytes32 id,\n        uint256 repay_principal,\n        uint256 repay_interest\n    ) external override onlyContract {\n        uint256 total_repayment = repay_principal + repay_interest;\n\n        for (uint256 i = 0; i < current_loan_data[owner].length; i++) {\n            if (id == current_loan_data[owner][i].id) {\n                LoanMetadata storage loan = current_loan_data[owner][i];\n\n                require(loan.recipient == msg.sender, \"loan recipient doesn't match caller\");\n                require(loan.approved, \"loan not approved\");\n                require(loan.repaymentDate > block.timestamp, \"Loan has already reached maturity\");\n                require(loan.interestPaid + repay_interest <= loan.totalInterest, \"overpaid for loan interest\");\n                require(loan.amountBorrowed >= repay_principal, \"overpaid for loan principal\");\n\n                amount_borrowed[owner] -= repay_principal;\n\n                loan.amountBorrowed -= repay_principal;\n\n                loan.interestPaid += repay_interest;\n\n                accrued_interest += repay_interest;\n\n                console.log(\"total_borrowed_amount\", total_borrowed_amount);\n\n                total_borrowed_amount = total_borrowed_amount - repay_principal;\n\n                //TransferHelper.safeTransferFrom(collateral_address, msg.sender, address(this), total_repayment);\n                IERC20(collateral_address).safeTransferFrom(msg.sender, address(this), total_repayment);\n                return;\n            }\n        }\n        revert(\"loan not found\");\n    }\n\n    // called by debtor if they want to resolve loan early.\n    function resolveLoan(bytes32 id) public override onlyBorrower onlyVerified {\n        for (uint256 i = 0; i < current_loan_data[msg.sender].length; i++) {\n            if (id == current_loan_data[msg.sender][i].id) {\n                LoanMetadata storage loan = current_loan_data[msg.sender][i];\n\n                require(loan.approved, \"must be an active loan\");\n                require(loan.amountBorrowed == 0, \"not fully paid back principal\");\n                require(loan.interestPaid == loan.totalInterest, \"not fully paid back interest\");\n                require(loan.repaymentDate > block.timestamp, \"loan already matured\");\n                _checkLoanStatus(msg.sender, i);\n            }\n        }\n        revert(\"loan not found\");\n    }\n\n    function contractResolveLoan(address owner, bytes32 id) public override onlyContract {\n        for (uint256 i = 0; i < current_loan_data[owner].length; i++) {\n            if (id == current_loan_data[msg.sender][i].id) {\n                LoanMetadata storage loan = current_loan_data[owner][i];\n\n                require(loan.recipient == msg.sender, \"loan recipient doesn't match caller\");\n                require(loan.approved, \"must be an active loan\");\n                require(loan.amountBorrowed == 0, \"not fully paid back principal\");\n                require(loan.interestPaid == loan.totalInterest, \"not fully paid back interest\");\n                require(loan.repaymentDate > block.timestamp, \"loan already matured\");\n                _checkLoanStatus(owner, i);\n            }\n        }\n        revert(\"loan not found\");\n    }\n\n    // restrictions on acccess?\n    function fullLoanCheck() public override {\n        for (uint256 i = 0; i < borrowers_array.length; i++) {\n            address borrower = borrowers_array[i];\n            checkAddressLoans(borrower);\n        }\n    }\n\n    // helper function: check individual loan\n    function _checkLoanStatus(address borrower, uint256 i) private {\n        LoanMetadata storage loan = current_loan_data[borrower][i];\n        if (loan.amountBorrowed > 0 || loan.interestPaid < loan.totalInterest) {\n            if (block.timestamp > loan.repaymentDate) {\n                //controller.resolveMarket(borrower, loan.id, true);\n\n                emit Default(borrower, loan);\n\n                num_loans[borrower]--;\n                id_taken[loan.id] = false;\n\n                _removeLoan(borrower, i);\n            }\n        } else {\n            // controller.resolveMarket(borrower, loan.id, false);\n            emit FullRepayment(borrower, loan);\n            // resolve market\n            num_loans[borrower]--;\n            id_taken[loan.id] = false;\n            _removeLoan(borrower, i);\n        }\n    }\n\n    // checks all user's loan's\n    function checkAddressLoans(address borrower) public override {\n        for (uint256 i = 0; i < current_loan_data[borrower].length; i++) {\n            if (current_loan_data[borrower][i].approved) {\n                _checkLoanStatus(borrower, i);\n            }\n        }\n    }\n\n    function checkLoanStatus (address owner, bytes32 id) public override {\n\n        for (uint256 i = 0; i < current_loan_data[owner].length; i++) {\n            if (id == current_loan_data[owner][i].id) {\n                require(current_loan_data[owner][i].approved, \"loan not approved\");\n\n                _checkLoanStatus(owner, i);\n                return;\n            }\n        }\n        revert(\"loan not found\");\n    }\n\n    function _removeLoan(address addr, uint256 i) private {\n        require(i < current_loan_data[addr].length, \"invalid array index\");\n        uint256 terminal_index = current_loan_data[addr].length - 1;\n        current_loan_data[addr][i] = current_loan_data[addr][terminal_index];\n        current_loan_data[addr].pop();\n    }\n\n    // GETTERS\n    \n    function getLoan(address borrower, bytes32 id) public view override returns (LoanMetadata memory) {\n        for (uint256 i = 0; i < current_loan_data[borrower].length; i++) {\n            if (id == current_loan_data[borrower][i].id) {\n                return current_loan_data[borrower][i];\n            }\n        }\n        revert(\"loan not found\");\n    }\n\n    function getLoans(address borrower) public view override returns (LoanMetadata[] memory) {\n        return current_loan_data[borrower];\n    }\n\n\n    function getBorrowerLoanData(address recipient) public view override returns (LoanMetadata memory) {\n        uint256 id = 0; //get first loandata\n        return current_loan_data[recipient][id];\n    }\n\n    function getProtocolLoanData() public view override returns (LoanData memory) {\n        LoanData memory loandata = LoanData({\n            _total_borrowed_amount: total_borrowed_amount,\n            _accrued_interest: accrued_interest\n        });\n        return loandata;\n    }\n\n    function isApproved(address borrower, uint256 idx) public view returns (bool) {\n        LoanMetadata memory loan = current_loan_data[borrower][idx];\n        return loan.approved;\n    }\n\n    event LoanProposal(address indexed recipient, bytes32 loan_id);\n    event LoanApproval(address indexed recipient, LoanMetadata loan);\n    event FullRepayment(address indexed recipient, LoanMetadata loan);\n    event Default(address indexed defaultor, LoanMetadata loan);\n    event LoanProposalRemoval(address indexed recipient, LoanMetadata loan);\n    event FundsBorrowed(address indexed recipient, uint256 amount);\n}\n"
    },
    "contracts/stablecoin/DS.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../ERC20/ERC20Custom.sol\";\nimport \"../Common/AccessControl.sol\";\nimport \"../Common/Ownable.sol\";\n\ncontract DS is ERC20Custom, AccessControl, Ownable {\n    /* ========== STATE VARIABLES ========== */\n    \n    mapping(address => bool) pools;\n    \n    address[] public pools_array;\n    address public creator_address;\n    address timelock_address;\n    address public DEFAULT_ADMIN_ADDRESS;\n    \n    uint256 constant genesis_supply = 1000000e18;\n\n    \n    /* ========== MODIFIERS ========== */\n    modifier onlyPools() {\n        require(pools[msg.sender] == true, \"Only pools can call this function\");\n        _;\n    }\n\n    /* ========== CONSTRUCTOR ========== */\n    constructor (\n        address _creator_address,\n        address _timelock_address\n    )  ERC20Custom(\"Debita Stablecoin\",\"DS\") Ownable(_creator_address)\n    {\n        _mint(_creator_address, genesis_supply);\n        creator_address = _creator_address;\n        timelock_address = _timelock_address;\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n        DEFAULT_ADMIN_ADDRESS = _msgSender();\n        _grantRole(DEFAULT_ADMIN_ROLE, _creator_address);\n    }\n\n    function addPool(address pool_address) public onlyOwner {\n        require(pool_address != address(0), \"Zero address detected\");\n\n        require(pools[pool_address] == false, \"Address already exists\");\n        pools[pool_address] = true; \n        pools_array.push(pool_address);\n    }\n    \n    // Used by pools when user redeems\n    function pool_burn(address b_address, uint256 b_amount) public onlyPools {\n        super._burn(b_address, b_amount);\n    }\n\n    function pool_mint(address m_address, uint256 m_amount) public onlyPools {\n        super._mint(m_address, m_amount);\n    }\n\n    function dss_price() public view returns(uint256){\n        return 1e6; \n    }\n\n    function get_collateral_ratio() public view returns(uint256){\n        return 1e6;\n    }\n}"
    },
    "contracts/ERC20/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.4;\n\nimport \"./IERC20.sol\";\nimport \"./draft-IERC20Permit.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}"
    },
    "contracts/stablecoin/ILendingPool.sol": {
      "content": "pragma solidity ^0.8.4;\nimport \"./IController.sol\";\n\ninterface ILendingPool {\n    struct LoanMetadata {\n        bytes32 id;\n        uint256 principal;\n        uint256 totalInterest; // total interest paid over duration\n        uint256 duration;\n        uint256 repaymentDate;\n        uint256 interestPaid; // how much paid toward interest\n        uint256 allowance;\n        uint256 amountBorrowed; // how much currently borrowed, should be 0 on full loan repayment\n        string description;\n        bool approved; // proposal => false, active loan => true\n        address recipient; // set to  0x0 if discretionary, address set to smart contract if smart contract loan.\n    }\n\n    struct LoanData {\n        uint256 _total_borrowed_amount;\n        uint256 _accrued_interest;\n    }\n\n    function mintDS(uint256 collateral_amount, uint256 DS_out_min) external;\n\n    function redeemDS(\n        uint256 DS_amount,\n        uint256 DSS_out_min,\n        uint256 COLLATERAL_out_min\n    ) external;\n\n    function collectRedemption(uint256 col_idx) external returns (uint256 dss_amount, uint256 collateral_amount);\n\n    function setPoolParameters(\n        uint256 new_ceiling,\n        uint256 new_bonus_rate,\n        uint256 new_redemption_delay,\n        uint256 new_mint_fee,\n        uint256 new_redeem_fee,\n        uint256 new_buyback_fee,\n        uint256 new_recollat_fee\n    ) external;\n\n    function setController(address controller) external;\n\n    function controllerMintDS(uint256 amount) external;\n\n    function controllerBurnDS(uint256 amount) external;\n\n    function addValidator(address validator) external;\n\n    function addDiscretionaryLoanProposal(\n        bytes32 _id,\n        uint256 _principal,\n        uint256 _duration,\n        uint256 _totalInterest,\n        string calldata _description,\n        IController.MarketInfo memory market_info\n    ) external;\n\n    function addContractLoanProposal(\n        bytes32 _id,\n        address _recipient,\n        uint256 _principal,\n        uint256 _duration,\n        uint256 _totalInterest,\n        string calldata _description,\n        IController.MarketInfo memory market_info\n    ) external;\n\n    function removeProposal(bytes32 id) external returns (bool); // called by recipient\n\n    function removeProposalGov(address recipient, bytes32 id) external returns (bool);\n\n    function approveLoan(\n        address recipient,\n        bytes32 id,\n        address marketFactoryAddress\n    ) external;\n\n    function borrow(bytes32 loan_id, uint256 amount) external;\n\n    function contractBorrow(\n        address owner,\n        bytes32 id,\n        uint256 amount\n    ) external;\n\n    function repay(\n        bytes32 loan_id,\n        uint256 repay_principal,\n        uint256 repay_interest\n    ) external;\n\n    function contractRepay(\n        address owner,\n        bytes32 loan_id,\n        uint256 repay_principal,\n        uint256 repay_interest\n    ) external;\n\n    function resolveLoan(bytes32 id) external;\n\n    function contractResolveLoan(address owner, bytes32 id) external;\n\n    function checkAddressLoans(address recipient) external;\n\n    function fullLoanCheck() external;\n\n    function checkLoanStatus (address owner, bytes32 id) external;\n\n    function is_borrower(address addr) external returns (bool);\n\n    function getLoan(address borrower, bytes32 id) external returns (LoanMetadata memory);\n\n    function getLoans(address borrower) external returns (LoanMetadata[] memory);\n\n    function borrower_allowance(address addr) external returns (uint256);\n\n    function amount_borrowed(address addr) external returns (uint256);\n\n    function num_loans(address addr) external returns (uint256);\n\n    function num_proposals(address addr) external returns (uint256);\n\n    function getBorrowerLoanData(address recipient) external returns (LoanMetadata memory);\n\n    function getProtocolLoanData() external returns (LoanData memory);\n}\n"
    },
    "contracts/ERC20/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.4;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}"
    },
    "contracts/libraries/PlaceholderReputationToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n/**\n * @title Cash\n * @dev Test contract for collateral\n */\ncontract PlaceholderReputationToken is ERC20 {\n    uint8 private _decimals;\n\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_\n    ) ERC20(name_, symbol_) {\n        _decimals = decimals_;\n    }\n\n    function decimals() public view virtual override(ERC20) returns (uint8) {\n        return _decimals;\n    }\n}\n"
    },
    "contracts/staking/stakingpool.sol": {
      "content": "pragma solidity ^0.8.4;\n\nimport \"../stablecoin/DS.sol\"; \nimport \"../stablecoin/owned.sol\";\nimport \"../stablecoin/TransferHelper.sol\";\n\nimport \"./stakedDS.sol\";\nimport \"../ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n//import \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n\ncontract StakingPool is Owned{\n\n\n    using SafeMath for uint256;\n\n    address ds_address; \n    address collateral_address; \n    address creator_address; \n\n    ERC20 private collateral_token;\n    DS private DScontract;\n    sDS private sDScontract;\n\n    uint256 missing_decimals; \n\n   mapping(address=>bool)  userStaked; \n   constructor (\n        address _ds_address,\n        address _collateral_address,\n        address _creator_address,\n\n        address _sDS_address\n        \n    ) public Owned(_creator_address){\n        require(\n            (_ds_address != address(0))\n            && (_collateral_address != address(0))\n            && (_creator_address != address(0))\n        , \"Zero address detected\"); \n        DScontract = DS(_ds_address);\n        sDScontract = sDS(_sDS_address);\n        collateral_token = ERC20(_collateral_address); \n\n        ds_address = _ds_address; \n        collateral_address = _collateral_address; \n        creator_address = _creator_address; \n\n    \n        missing_decimals = uint(18).sub(collateral_token.decimals());\n        \n        \n    }\n\tfunction stake(uint256 amount) public virtual{\n\t\tuint256 exchange_rate = get_exchange_rate();\n        TransferHelper.safeTransferFrom(address(ds_address), msg.sender, address(sDScontract), amount);\n        sDScontract.mint(msg.sender, amount, exchange_rate); \n\n        userStaked[msg.sender] = true; \n\n\n\t}\n\n\tfunction withdraw(uint256 amount) public virtual{\n\t\tuint256 exchange_rate = get_exchange_rate();\n\n\t\tsDScontract.burn(msg.sender, amount, exchange_rate);\n\n\t\tif (sDScontract.balanceOf(msg.sender) == 0){\n\t\tuserStaked[msg.sender] = false; \n\t\t}\n\n\n\t}\n\tfunction get_exchange_rate() private returns(uint256){\n\t\treturn 1e6; \n\t}\n}"
    },
    "contracts/stablecoin/TransferHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper {\n    function safeApprove(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n    }\n\n    function safeTransfer(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n    }\n\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n    }\n\n    function safeTransferETH(address to, uint value) internal {\n        (bool success,) = to.call{value:value}(new bytes(0));\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\n    }\n}"
    },
    "contracts/staking/stakedDS.sol": {
      "content": "pragma solidity ^0.8.4;\n\n//import \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"../ERC20/ERC20.sol\";\nimport \"../stablecoin/owned.sol\";\nimport \"../stablecoin/TransferHelper.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n//import \"../stablecoin/safemath.sol\";\n\n\ncontract sDS is ERC20, Owned {\n\n  mapping(address => bool) pools;\n   using SafeMath for uint256;\n\n  address[] public pools_array;\n  address deployer_address; \n  address timelock_address; \n  address ds_address; \n\n\n  constructor(string memory _name,\n        string memory _symbol,\n        address _deployer_address,\n        address _timelock_address,\n        address _ds_address) ERC20(_name, _symbol) Owned(_deployer_address) {\n\n    deployer_address = _deployer_address;\n    timelock_address = _timelock_address; \n    ds_address = _ds_address; \n\n  }\n\n  modifier onlyByOwner() {\n        require(msg.sender == owner , \"Not the owner, controller, or the governance timelock\");\n        _;\n    }\n  \n  modifier onlyPools() {\n     require(pools[msg.sender] == true, \"Only pools can call this function\");\n      _;\n  } \n\n  function addPool(address pool_address) public onlyByOwner {\n      require(pool_address != address(0), \"Zero address detected\");\n\n      require(pools[pool_address] == false, \"Address already exists\");\n      pools[pool_address] = true; \n      pools_array.push(pool_address);\n\n      //emit PoolAdded(pool_address);\n  }\n\n\n  function mint(address to, uint256 amount, uint256 exchange_rate) public onlyPools {\n  \tuint256 amountScaled = amount.mul(uint(1e6)).div(exchange_rate); //exchange_rate >=1\n\n    _mint(to, amountScaled);\n  }\n\n  function burn(address account, uint256 amount, uint256 exchange_rate) public onlyPools {\n  \tuint256 amountScaled =amount.mul(uint(1e6)).div(exchange_rate);\n   _burn(account, amount);\n\tTransferHelper.safeTransfer(ds_address, account ,amountScaled); \n\n  }\n\n\n}"
    },
    "contracts/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.4;\n\nimport \"./IERC20.sol\";\nimport \"./IERC20Metadata.sol\";\nimport \"../Common/Context.sol\";\n\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}"
    },
    "contracts/ERC20/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.4;\n\nimport \"./IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}"
    },
    "contracts/bonds/SigmoidBondingCurve.sol": {
      "content": "pragma solidity ^0.8.4;\n\nimport {BondingCurve} from \"./bondingcurve.sol\";\nimport \"../prb/PRBMathUD60x18.sol\";\n\n/// @notice y = exp(x/a) / ( b + exp(x/a) )\n/// @dev NEED TO REDO FOR GAS EFFICIENT\nabstract contract SigmoidBonding is BondingCurve {\n\n    // ASSUMES 18 TRAILING DECIMALS IN UINT256\n    using PRBMathUD60x18 for uint256;\n    uint256 a;\n    uint256 n;\n    uint256 F; // reserve ratio\n\n    constructor (\n        string memory name,\n        string memory symbol,\n        address owner,\n        address collateral,\n        uint256 _a,\n        uint256 _n\n    ) BondingCurve(name, symbol, owner, collateral) {\n\n    }\n\n    /**\n     @dev tokens returned\n     @param amount: amount collateral in => 60.18\n     */\n    function _calculatePurchaseReturn(uint256 amount) view internal override virtual returns(uint256 result) {\n        uint256 s = totalSupply();\n        uint256 one = uint256(1).fromUint();\n        result = s.mul((one + amount.div(reserves)).pow(F) - one);\n    }\n\n    /**\n     @dev collateral tokens returned\n     @param amount: tokens burning => 60.18\n     */\n    function _calculateSaleReturn(uint256 amount) view internal override virtual returns (uint256 result) {\n        uint256 s = totalSupply();\n        uint256 one = uint256(1).fromUint();\n        result = reserves - ((s - amount).pow(n + one).div(n + one)).mul(a);\n    }\n\n    /**\n     @param amount: amount added in 60.18\n     */\n    function _calculateExpectedPrice(uint256 amount) view internal override virtual returns (uint256 result) {\n        uint256 s = totalSupply();\n        result = ((s + amount).pow(n)).mul(a);\n    }\n}"
    },
    "contracts/bonds/PolynomialBondingCurve.sol": {
      "content": "pragma solidity ^0.8.4;\n\nimport {BondingCurve} from \"./bondingcurve.sol\";\nimport \"../prb/PRBMathUD60x18.sol\";\n\n/// @notice y = a * x^n => formulas from Bancor \n/// https://drive.google.com/file/d/0B3HPNP-GDn7aRkVaV3dkVl9NS2M/view?resourcekey=0-mbIgrdd0B9H8dPNRaeB_TA\n/// @dev NEED TO REDO FOR GAS EFFICIENT\nabstract contract PolynomialBonding is BondingCurve {\n\n    // ASSUMES 18 TRAILING DECIMALS IN UINT256\n    using PRBMathUD60x18 for uint256;\n    uint256 a;\n    uint256 n;\n    uint256 F; // reserve ratio\n\n    constructor (\n        string memory name,\n        string memory symbol,\n        address owner,\n        address collateral,\n        uint256 _a,\n        uint256 _n\n    ) BondingCurve(name, symbol, owner, collateral) {\n        a = _a;\n        n = _n;\n        uint256 one = uint256(1).fromUint();\n        F = one.div(_n + one); // 1 / (_n + 1)\n    }\n\n    /**\n     @dev tokens returned\n     @param amount: amount collateral in => 60.18\n     */\n    function _calculatePurchaseReturn(uint256 amount) view internal override virtual returns(uint256 result) {\n        uint256 s = totalSupply();\n        uint256 one = uint256(1).fromUint();\n        result = s.mul((one + amount.div(reserves)).pow(F) - one);\n    }\n\n    /**\n     @dev collateral tokens returned\n     @param amount: tokens burning => 60.18\n     */\n    function _calculateSaleReturn(uint256 amount) view internal override virtual returns (uint256 result) {\n        uint256 s = totalSupply();\n        uint256 one = uint256(1).fromUint();\n        result = reserves - ((s - amount).pow(n + one).div(n + one)).mul(a);\n    }\n\n    /**\n     @param amount: amount added in 60.18\n     */\n    function _calculateExpectedPrice(uint256 amount) view internal override virtual returns (uint256 result) {\n        uint256 s = totalSupply();\n        result = ((s + amount).pow(n)).mul(a);\n    }\n}"
    },
    "contracts/bonds/ConstantBondingCurve.sol": {
      "content": "pragma solidity ^0.8.4;\n\nimport { BondingCurve } from \"./bondingcurve.sol\";\nimport \"../prb/PRBMathUD60x18.sol\";\n\n/// @notice implements y = a. basic bonding curve \n// EVERYTHING IS ASSUMED TO BE IN 60.18 FORMAT\nabstract contract ConstantBondingCurve is BondingCurve {\n    // ASSUMES 18 TRAILING DECIMALS IN UINT256\n    using PRBMathUD60x18 for uint256;\n\n\n    uint256 private a;\n\n    constructor(\n        string memory name,\n        string memory symbol,\n        address owner,\n        address collateral,\n        uint256 _a\n    ) BondingCurve(name, symbol, owner, collateral) {\n        a = _a;\n    }\n\n    function _calculatePurchaseReturn(uint256 amount) view internal override virtual returns(uint256 result) {\n        result = amount.div(a);\n    }\n\n    function _calculateSaleReturn(uint256 amount) view internal override virtual returns (uint256 result) {\n        result = amount.mul(a);\n    }\n\n    /**\n     @dev for constant need a max quantity.\n     */\n    function _calculateExpectedPrice(uint256 amount) view internal override virtual returns (uint256 result) {\n        return a;\n    }\n\n    function trustedMint(address _target, uint256 _amount) external override virtual onlyOwner {\n        if (max_quantity > 0) {\n            require(_amount + totalSupply() < max_quantity, \"must be less than max quantity\");\n        }\n        _mint(_target, _amount);\n    }\n}"
    },
    "contracts/libraries/Cash.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n/**\n * @title Cash\n * @dev Test contract for collateral\n */\ncontract Cash is ERC20 {\n    uint8 private _decimals;\n\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_\n    ) ERC20(name_, symbol_) {\n        _decimals = decimals_;\n    }\n\n    function decimals() public view virtual override(ERC20) returns (uint8) {\n        return _decimals;\n    }\n\n    function faucet(uint256 _amount) public returns (bool) {\n        _mint(msg.sender, _amount);\n        return true;\n    }\n}\n"
    },
    "contracts/balancer/BPoolForTesting.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./BFactory.sol\";\nimport \"../libraries/IERC20Full.sol\";\nimport \"../libraries/Cash.sol\";\n\ncontract BPoolForTesting {\n    BFactory private bFactory;\n    BPool private bPool;\n    uint256 private constant MAX_UINT = 2**256 - 1;\n\n    constructor(BFactory _bFactory) {\n        bFactory = _bFactory;\n    }\n\n    function createBPoolForTesting(\n        Cash[] calldata _tokens,\n        uint256[] calldata _initialLiquidity,\n        uint256[] calldata _weights\n    ) external returns (BPool) {\n        require(\n            _tokens.length == _weights.length && _tokens.length == _initialLiquidity.length,\n            \"Tokens, weights and initial liquidity should all have the same length.\"\n        );\n\n        bPool = bFactory.newBPool();\n\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            _tokens[i].approve(address(bPool), MAX_UINT);\n            bPool.bind(address(_tokens[i]), _initialLiquidity[i], _weights[i]);\n        }\n\n        bPool.finalize();\n\n        return bPool;\n    }\n\n    function getBPool() external view returns (BPool) {\n        return bPool;\n    }\n}\n"
    },
    "contracts/libraries/EvenTheOdds.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../balancer/BPool.sol\";\nimport \"../turbo/AbstractMarketFactoryV3.sol\";\nimport \"hardhat/console.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\ncontract EvenTheOdds is BNum {\n    using SafeMath for uint256;\n\n    uint256 private constant MAX_UINT = 2**256 - 1;\n\n    function bringTokenBalanceToMatchOtherToken(\n        AbstractMarketFactoryV3 _marketFactory,\n        uint256 _marketId,\n        BPool _bPool,\n        uint256 _maxOutcome,\n        uint256 _maxCollateralIn\n    ) public returns (uint256 _collateralOut, uint256[] memory _balancesOut) {\n        IERC20 _collateral = _marketFactory.collateral();\n\n        // Will send remaining back.\n        _collateral.transferFrom(msg.sender, address(this), _maxCollateralIn);\n        _collateral.approve(address(_marketFactory), _maxCollateralIn);\n\n        AbstractMarketFactoryV3.Market memory _market = _marketFactory.getMarket(_marketId);\n\n        uint256 _sets = _marketFactory.calcShares(_maxCollateralIn);\n        _marketFactory.mintShares(_marketId, _sets, address(this));\n\n        uint256 _poolAmountOut = 0;\n        uint256 _targetBalance = _bPool.getBalance(address(_market.shareTokens[_maxOutcome]));\n        for (uint256 i = 0; i < _market.shareTokens.length; i++) {\n            if (i == _maxOutcome) continue;\n\n            OwnedERC20 _token = _market.shareTokens[i];\n            address _tokenAddress = address(_token);\n            uint256 _amountToAdd = _targetBalance.sub(_bPool.getBalance(_tokenAddress));\n            _token.approve(address(_bPool), _amountToAdd);\n\n            require(_sets >= _amountToAdd, \"_maxCollateralIn is insufficient\");\n\n            while (_amountToAdd > 0) {\n                // This amount will increase as more of the token is added.\n                uint256 _maxAmountAddable = bmul(_bPool.getBalance(_tokenAddress), MAX_IN_RATIO);\n                uint256 _amountThisPass = _amountToAdd;\n\n                if (_amountToAdd >= _maxAmountAddable) {\n                    _amountThisPass = _maxAmountAddable;\n                }\n\n                _poolAmountOut += _bPool.joinswapExternAmountIn(_tokenAddress, _amountThisPass, 0);\n                _amountToAdd = _amountToAdd.sub(_amountThisPass);\n            }\n        }\n\n        uint256[] memory minAmountsOut = new uint256[](_market.shareTokens.length);\n        _bPool.exitPool(_poolAmountOut, minAmountsOut);\n\n        uint256 _setsToSell = MAX_UINT;\n        for (uint256 i = 0; i < _market.shareTokens.length; i++) {\n            if (_setsToSell > _market.shareTokens[i].balanceOf(address(this))) {\n                _setsToSell = _market.shareTokens[i].balanceOf(address(this));\n            }\n        }\n\n        // Must be a multiple of share factor.\n        _setsToSell = (_setsToSell / _marketFactory.shareFactor()) * _marketFactory.shareFactor();\n\n        // Send back collateral.\n        _collateralOut = _marketFactory.burnShares(_marketId, _setsToSell, msg.sender);\n\n        // Send back any lingering shares.\n        _balancesOut = new uint256[](_market.shareTokens.length);\n        for (uint256 i = 0; i < _market.shareTokens.length; i++) {\n            _balancesOut[i] = _market.shareTokens[i].balanceOf(address(this));\n            _market.shareTokens[i].transfer(msg.sender, _balancesOut[i]);\n        }\n    }\n}\n"
    },
    "contracts/turbo/CDSMarketFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./AbstractMarketFactoryV3.sol\";\nimport \"../libraries/CalculateLinesToBPoolOdds.sol\";\nimport \"../libraries/Versioned.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\ncontract CDSMarketFactory is AbstractMarketFactoryV3, CalculateLinesToBPoolOdds, Versioned {\n    using SafeMath for uint256;\n\n    struct MarketDetails {\n        string description;\n    }\n    MarketDetails[] internal marketDetails;\n\n    constructor(\n        address _owner,\n        IERC20Full _collateral,\n        uint256 _shareFactor,\n        FeePot _feePot,\n        uint256[3] memory _fees,\n        address _protocol\n    ) AbstractMarketFactoryV3(_owner, _collateral, _shareFactor, _feePot, _fees, _protocol) Versioned(\"v1.1.0\") {}\n\n    function createMarket(\n        address _creator,\n        string calldata _description,\n        string[] calldata _names,\n        uint256[] calldata _odds\n    ) public onlyOwner returns (uint256) {\n        marketDetails.push(MarketDetails(_description));\n        return startMarket(_creator, _names, _odds, true);\n    }\n\n    function trustedResolveMarket(uint256 _id, uint256 _winningOutcome) public onlyOwner {\n        endMarket(_id, _winningOutcome);\n    }\n\n    function getMarketDetails(uint256 _id) public view returns (MarketDetails memory) {\n        return marketDetails[_id];\n    }\n\n    function getRewardEndTime(uint256 _marketId) public view override returns (uint256) {\n        return 0;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates",
          "devdoc",
          "userdoc"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}