{
  "address": "0x25917226cC1f16F055e20D36e0146905903b7F2F",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_controller",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "spender",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "id",
          "type": "uint256"
        }
      ],
      "name": "Approval",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "operator",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "bool",
          "name": "approved",
          "type": "bool"
        }
      ],
      "name": "ApprovalForAll",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "id",
          "type": "uint256"
        }
      ],
      "name": "Transfer",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "score",
          "type": "uint256"
        },
        {
          "internalType": "bool",
          "name": "atLoss",
          "type": "bool"
        }
      ],
      "name": "addScore",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "spender",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "id",
          "type": "uint256"
        }
      ],
      "name": "approve",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        }
      ],
      "name": "balanceOf",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "getApproved",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        }
      ],
      "name": "getReputationScore",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "isApprovedForAll",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        }
      ],
      "name": "mint",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "name",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "id",
          "type": "uint256"
        }
      ],
      "name": "ownerOf",
      "outputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        }
      ],
      "name": "resetScore",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "id",
          "type": "uint256"
        }
      ],
      "name": "safeTransferFrom",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "id",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "safeTransferFrom",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "operator",
          "type": "address"
        },
        {
          "internalType": "bool",
          "name": "approved",
          "type": "bool"
        }
      ],
      "name": "setApprovalForAll",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes4",
          "name": "interfaceId",
          "type": "bytes4"
        }
      ],
      "name": "supportsInterface",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "symbol",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "id",
          "type": "uint256"
        }
      ],
      "name": "tokenURI",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "id",
          "type": "uint256"
        }
      ],
      "name": "transferFrom",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0xc954749054c7ed97f3cadc35b290b5f81dd9f29d24a2f3d009b0edee7b721afa",
  "receipt": {
    "to": null,
    "from": "0xFD84b7AC1E646580db8c77f1f05F47977fAda692",
    "contractAddress": "0x25917226cC1f16F055e20D36e0146905903b7F2F",
    "transactionIndex": 10,
    "gasUsed": "1168626",
    "logsBloom": "0x00000000000000020000000000080000000000000000800000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000800000000000000000000100000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000020000000000000000001000000000000000000000000004000000000000000000001000000000000000000000000000000100000000000000000000000000000000000000000000000020000000000000000000000100000",
    "blockHash": "0x39564b4865a2877dbd7feb417403b4e6685e4d1e57fe9e1c627638ef894d4e0b",
    "transactionHash": "0xc954749054c7ed97f3cadc35b290b5f81dd9f29d24a2f3d009b0edee7b721afa",
    "logs": [
      {
        "transactionIndex": 10,
        "blockNumber": 27731078,
        "transactionHash": "0xc954749054c7ed97f3cadc35b290b5f81dd9f29d24a2f3d009b0edee7b721afa",
        "address": "0x0000000000000000000000000000000000001010",
        "topics": [
          "0x4dfe1bbbcf077ddc3e01291eea2d5c70c2b422b415d95645b9adcfd678cb1d63",
          "0x0000000000000000000000000000000000000000000000000000000000001010",
          "0x000000000000000000000000fd84b7ac1e646580db8c77f1f05f47977fada692",
          "0x000000000000000000000000c26880a0af2ea0c7e8130e6ec47af756465452e8"
        ],
        "data": "0x000000000000000000000000000000000000000000000000002984976f25b7b600000000000000000000000000000000000000000000000270450d1c3739d92a00000000000000000000000000000000000000000000145beb75276ff9cef9ad000000000000000000000000000000000000000000000002701b8884c814217400000000000000000000000000000000000000000000145beb9eac0768f4b163",
        "logIndex": 46,
        "blockHash": "0x39564b4865a2877dbd7feb417403b4e6685e4d1e57fe9e1c627638ef894d4e0b"
      }
    ],
    "blockNumber": 27731078,
    "cumulativeGasUsed": "6726753",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x4391d7acba8303740918308b119AAb956d7e6473"
  ],
  "numDeployments": 6,
  "solcInputHash": "e99c8449f30646952907aa423784d19d",
  "metadata": "{\"compiler\":{\"version\":\"0.8.4+commit.c7e474f2\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_controller\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"score\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"atLoss\",\"type\":\"bool\"}],\"name\":\"addScore\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"getReputationScore\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"resetScore\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"addScore(address,uint256,bool)\":{\"params\":{\"score\":\": 60.18 format\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"addScore(address,uint256,bool)\":{\"notice\":\"calculates average of scores added.\"},\"resetScore(address)\":{\"notice\":\"reset scores\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/stablecoin/reputationtoken.sol\":\"ReputationNFT\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@interep/contracts/IInterep.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @title Interep interface.\\n/// @dev Interface of a Interep contract.\\ninterface IInterep {\\n    struct Verifier {\\n        address contractAddress;\\n        uint8 merkleTreeDepth;\\n    }\\n\\n    struct Group {\\n        bytes32 provider;\\n        bytes32 name;\\n        uint256 root;\\n        uint8 depth;\\n    }\\n\\n    /// @dev Emitted when a Semaphore proof is verified.\\n    /// @param groupId: Id of the group.\\n    /// @param signal: Semaphore signal.\\n    event ProofVerified(uint256 indexed groupId, bytes32 signal);\\n\\n    /// @dev Emitted when an Interep group is updated.\\n    /// @param groupId: Id of the group.\\n    /// @param provider: Provider of the group.\\n    /// @param name: Name of the group.\\n    /// @param root: Root hash of the tree.\\n    /// @param depth: Depth of the tree.\\n    event GroupUpdated(\\n        uint256 groupId,\\n        bytes32 indexed provider,\\n        bytes32 indexed name,\\n        uint256 root,\\n        uint8 indexed depth\\n    );\\n\\n    /// @dev Updates the Interep groups.\\n    /// @param groups: List of Interep groups.\\n    function updateGroups(Group[] calldata groups) external;\\n\\n    /// @dev Saves the nullifier hash to avoid double signaling and emits an event\\n    /// if the zero-knowledge proof is valid.\\n    /// @param groupId: Id of the group.\\n    /// @param signal: Semaphore signal.\\n    /// @param nullifierHash: Nullifier hash.\\n    /// @param externalNullifier: External nullifier.\\n    /// @param proof: Zero-knowledge proof.\\n    function verifyProof(\\n        uint256 groupId,\\n        bytes32 signal,\\n        uint256 nullifierHash,\\n        uint256 externalNullifier,\\n        uint256[8] calldata proof\\n    ) external;\\n\\n    /// @dev Returns the root hash of an Interep group.\\n    /// @param groupId: Id of the group.\\n    /// @return Root hash of the group.\\n    function getRoot(uint256 groupId) external view returns (uint256);\\n\\n    /// @dev Returns the tree depth of an Interep group.\\n    /// @param groupId: Id of the group.\\n    /// @return Tree depth of the group.\\n    function getDepth(uint256 groupId) external view returns (uint8);\\n}\\n\",\"keccak256\":\"0xd3279ce9fbbb58b7567f66d18735f81df7e8ee61c677e9dd739d3a4823e31c5d\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The default value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        uint256 currentAllowance = allowance(owner, spender);\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `from` to `to`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[from] = fromBalance - amount;\\n        }\\n        _balances[to] += amount;\\n\\n        emit Transfer(from, to, amount);\\n\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        _balances[account] += amount;\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n        }\\n        _totalSupply -= amount;\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\\n     *\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Might emit an {Approval} event.\\n     */\\n    function _spendAllowance(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n}\\n\",\"keccak256\":\"0x24b04b8aacaaf1a4a0719117b29c9c3647b1f479c5ac2a60f5ff1bb6d839c238\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\",\"keccak256\":\"0x9750c6b834f7b43000631af5cc30001c5f547b3ceb3635488f140f60e897ea6b\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0x8de418a5503946cabe331f35fe242d3201a73f67f77aaeb7110acb1f30423aca\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0xf41ca991f30855bf80ffd11e9347856a517b977f0a6c2d52e6421a99b7840329\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../extensions/draft-IERC20Permit.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    function safePermit(\\n        IERC20Permit token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x032807210d1d7d218963d7355d62e021a84bf1b3339f4f50be2f63b53cccaf29\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xd6153ce99bcdcce22b124f755e72553295be6abcd63804cfdffceb188b8bef10\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0xe2e337e6dde9ef6b680e07338c493ebea1b5fd09b43424112868e9cc1706bca7\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Strings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n}\\n\",\"keccak256\":\"0xaf159a8b1923ad2a26d516089bceca9bdeaeacd04be50983ea00ba63070f08a3\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator,\\n        Rounding rounding\\n    ) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. It the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`.\\n        // We also know that `k`, the position of the most significant bit, is such that `msb(a) = 2**k`.\\n        // This gives `2**k < a <= 2**(k+1)` \\u2192 `2**(k/2) <= sqrt(a) < 2 ** (k/2+1)`.\\n        // Using an algorithm similar to the msb conmputation, we are able to compute `result = 2**(k/2)` which is a\\n        // good first aproximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1;\\n        uint256 x = a;\\n        if (x >> 128 > 0) {\\n            x >>= 128;\\n            result <<= 64;\\n        }\\n        if (x >> 64 > 0) {\\n            x >>= 64;\\n            result <<= 32;\\n        }\\n        if (x >> 32 > 0) {\\n            x >>= 32;\\n            result <<= 16;\\n        }\\n        if (x >> 16 > 0) {\\n            x >>= 16;\\n            result <<= 8;\\n        }\\n        if (x >> 8 > 0) {\\n            x >>= 8;\\n            result <<= 4;\\n        }\\n        if (x >> 4 > 0) {\\n            x >>= 4;\\n            result <<= 2;\\n        }\\n        if (x >> 2 > 0) {\\n            result <<= 1;\\n        }\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = sqrt(a);\\n        if (rounding == Rounding.Up && result * result < a) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n}\\n\",\"keccak256\":\"0xd15c3e400531f00203839159b2b8e7209c5158b35618f570c695b7e47f12e9f0\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x0f633a0223d9a1dcccfcf38a64c9de0874dfcbfac0c6941ccf074d63a2ce0e1e\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/SignedSafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/math/SignedSafeMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SignedSafeMath` is no longer needed starting with Solidity 0.8. The compiler\\n * now has built in overflow checking.\\n */\\nlibrary SignedSafeMath {\\n    /**\\n     * @dev Returns the multiplication of two signed integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(int256 a, int256 b) internal pure returns (int256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two signed integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(int256 a, int256 b) internal pure returns (int256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two signed integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(int256 a, int256 b) internal pure returns (int256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two signed integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(int256 a, int256 b) internal pure returns (int256) {\\n        return a + b;\\n    }\\n}\\n\",\"keccak256\":\"0x62f53f262fabbbc6d8ab49488d8fce36370351aff2b8d3898d499d68995a71c2\",\"license\":\"MIT\"},\"contracts/balancer/BColor.sol\":{\"content\":\"// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\ninterface BColor {\\n    function getColor() external view returns (bytes32);\\n}\\n\\ncontract BBronze is BColor {\\n    function getColor() external pure override returns (bytes32) {\\n        return bytes32(\\\"BRONZE\\\");\\n    }\\n}\\n\",\"keccak256\":\"0x6d3291d0338666da918131e0b475b360e02f9642401746e7abd2cf5a39f16398\",\"license\":\"MIT\"},\"contracts/balancer/BConst.sol\":{\"content\":\"// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"./BColor.sol\\\";\\n\\ncontract BConst is BBronze {\\n    uint256 public constant BONE = 10**18;\\n\\n    uint256 public constant MIN_BOUND_TOKENS = 2;\\n    uint256 public constant MAX_BOUND_TOKENS = 8;\\n\\n    uint256 public constant MIN_FEE = BONE / 10**6;\\n    uint256 public constant MAX_FEE = BONE / 10;\\n    uint256 public constant EXIT_FEE = 0;\\n\\n    uint256 public constant MIN_WEIGHT = BONE;\\n    uint256 public constant MAX_WEIGHT = BONE * 50;\\n    uint256 public constant MAX_TOTAL_WEIGHT = BONE * 50;\\n    uint256 public constant MIN_BALANCE = BONE / 10**12;\\n\\n    uint256 public constant INIT_POOL_SUPPLY = BONE * 100;\\n\\n    uint256 public constant MIN_BPOW_BASE = 1 wei;\\n    uint256 public constant MAX_BPOW_BASE = (2 * BONE) - 1 wei;\\n    uint256 public constant BPOW_PRECISION = BONE / 10**10;\\n\\n    uint256 public constant MAX_IN_RATIO = BONE / 2;\\n    uint256 public constant MAX_OUT_RATIO = (BONE / 3) + 1 wei;\\n}\\n\",\"keccak256\":\"0x329a7ddac03d6ab6f9842504b4c66009a8e829782538946be262aef9fc5ac9b3\",\"license\":\"MIT\"},\"contracts/balancer/BFactory.sol\":{\"content\":\"// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is disstributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n// Builds new BPools, logging their addresses and providing `isBPool(address) -> (bool)`\\n\\nimport \\\"./BPool.sol\\\";\\n\\ncontract BFactory is BBronze {\\n    event LOG_NEW_POOL(address indexed caller, address indexed pool);\\n\\n    event LOG_BLABS(address indexed caller, address indexed blabs);\\n\\n    mapping(address => bool) private _isBPool;\\n\\n    function isBPool(address b) external view returns (bool) {\\n        return _isBPool[b];\\n    }\\n\\n    function newBPool() external returns (BPool) {\\n        BPool bpool = new BPool();\\n        _isBPool[address(bpool)] = true;\\n        emit LOG_NEW_POOL(msg.sender, address(bpool));\\n        bpool.setController(msg.sender);\\n        return bpool;\\n    }\\n\\n    address private _blabs;\\n\\n    constructor() {\\n        _blabs = msg.sender;\\n    }\\n\\n    function getBLabs() external view returns (address) {\\n        return _blabs;\\n    }\\n\\n    function setBLabs(address b) external {\\n        require(msg.sender == _blabs, \\\"ERR_NOT_BLABS\\\");\\n        emit LOG_BLABS(msg.sender, b);\\n        _blabs = b;\\n    }\\n\\n    function collect(BPool pool) external {\\n        require(msg.sender == _blabs, \\\"ERR_NOT_BLABS\\\");\\n        uint256 collected = IERC20Balancer(pool).balanceOf(address(this));\\n        bool xfer = pool.transfer(_blabs, collected);\\n        require(xfer, \\\"ERR_ERC20_FAILED\\\");\\n    }\\n}\\n\",\"keccak256\":\"0xb8a30f5089a3e49d13fa63ca815761b1e67d5985c5549b11d5b5ea88cab45ec5\",\"license\":\"MIT\"},\"contracts/balancer/BMath.sol\":{\"content\":\"// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"./BNum.sol\\\";\\n\\ncontract BMath is BBronze, BConst, BNum {\\n    /**********************************************************************************************\\n    // calcSpotPrice                                                                             //\\n    // sP = spotPrice                                                                            //\\n    // bI = tokenBalanceIn                ( bI / wI )         1                                  //\\n    // bO = tokenBalanceOut         sP =  -----------  *  ----------                             //\\n    // wI = tokenWeightIn                 ( bO / wO )     ( 1 - sF )                             //\\n    // wO = tokenWeightOut                                                                       //\\n    // sF = swapFee                                                                              //\\n    **********************************************************************************************/\\n    function calcSpotPrice(\\n        uint256 tokenBalanceIn,\\n        uint256 tokenWeightIn,\\n        uint256 tokenBalanceOut,\\n        uint256 tokenWeightOut,\\n        uint256 swapFee\\n    ) public pure returns (uint256 spotPrice) {\\n        uint256 numer = bdiv(tokenBalanceIn, tokenWeightIn);\\n        uint256 denom = bdiv(tokenBalanceOut, tokenWeightOut);\\n        uint256 ratio = bdiv(numer, denom);\\n        uint256 scale = bdiv(BONE, bsub(BONE, swapFee));\\n        return (spotPrice = bmul(ratio, scale));\\n    }\\n\\n    /**********************************************************************************************\\n    // calcOutGivenIn                                                                            //\\n    // aO = tokenAmountOut                                                                       //\\n    // bO = tokenBalanceOut                                                                      //\\n    // bI = tokenBalanceIn              /      /            bI             \\\\    (wI / wO) \\\\      //\\n    // aI = tokenAmountIn    aO = bO * |  1 - | --------------------------  | ^            |     //\\n    // wI = tokenWeightIn               \\\\      \\\\ ( bI + ( aI * ( 1 - sF )) /              /      //\\n    // wO = tokenWeightOut                                                                       //\\n    // sF = swapFee                                                                              //\\n    **********************************************************************************************/\\n    function calcOutGivenIn(\\n        uint256 tokenBalanceIn,\\n        uint256 tokenWeightIn,\\n        uint256 tokenBalanceOut,\\n        uint256 tokenWeightOut,\\n        uint256 tokenAmountIn,\\n        uint256 swapFee\\n    ) public pure returns (uint256 tokenAmountOut) {\\n        uint256 weightRatio = bdiv(tokenWeightIn, tokenWeightOut);\\n        uint256 adjustedIn = bsub(BONE, swapFee);\\n        adjustedIn = bmul(tokenAmountIn, adjustedIn);\\n        uint256 y = bdiv(tokenBalanceIn, badd(tokenBalanceIn, adjustedIn));\\n        uint256 foo = bpow(y, weightRatio);\\n        uint256 bar = bsub(BONE, foo);\\n        tokenAmountOut = bmul(tokenBalanceOut, bar);\\n        return tokenAmountOut;\\n    }\\n\\n    /**********************************************************************************************\\n    // calcInGivenOut                                                                            //\\n    // aI = tokenAmountIn                                                                        //\\n    // bO = tokenBalanceOut               /  /     bO      \\\\    (wO / wI)      \\\\                 //\\n    // bI = tokenBalanceIn          bI * |  | ------------  | ^            - 1  |                //\\n    // aO = tokenAmountOut    aI =        \\\\  \\\\ ( bO - aO ) /                   /                 //\\n    // wI = tokenWeightIn           --------------------------------------------                 //\\n    // wO = tokenWeightOut                          ( 1 - sF )                                   //\\n    // sF = swapFee                                                                              //\\n    **********************************************************************************************/\\n    function calcInGivenOut(\\n        uint256 tokenBalanceIn,\\n        uint256 tokenWeightIn,\\n        uint256 tokenBalanceOut,\\n        uint256 tokenWeightOut,\\n        uint256 tokenAmountOut,\\n        uint256 swapFee\\n    ) public pure returns (uint256 tokenAmountIn) {\\n        uint256 weightRatio = bdiv(tokenWeightOut, tokenWeightIn);\\n        uint256 diff = bsub(tokenBalanceOut, tokenAmountOut);\\n        uint256 y = bdiv(tokenBalanceOut, diff);\\n        uint256 foo = bpow(y, weightRatio);\\n        foo = bsub(foo, BONE);\\n        tokenAmountIn = bsub(BONE, swapFee);\\n        tokenAmountIn = bdiv(bmul(tokenBalanceIn, foo), tokenAmountIn);\\n        return tokenAmountIn;\\n    }\\n\\n    /**********************************************************************************************\\n    // calcPoolOutGivenSingleIn                                                                  //\\n    // pAo = poolAmountOut         /                                              \\\\              //\\n    // tAi = tokenAmountIn        ///      /     //    wI \\\\      \\\\\\\\       \\\\     wI \\\\             //\\n    // wI = tokenWeightIn        //| tAi *| 1 - || 1 - --  | * sF || + tBi \\\\    --  \\\\            //\\n    // tW = totalWeight     pAo=||  \\\\      \\\\     \\\\\\\\    tW /      //         | ^ tW   | * pS - pS //\\n    // tBi = tokenBalanceIn      \\\\\\\\  ------------------------------------- /        /            //\\n    // pS = poolSupply            \\\\\\\\                    tBi               /        /             //\\n    // sF = swapFee                \\\\                                              /              //\\n    **********************************************************************************************/\\n\\n    // Charge the trading fee for the proportion of tokenAi\\n    ///  which is implicitly traded to the other pool tokens.\\n    // That proportion is (1- weightTokenIn)\\n    // tokenAiAfterFee = tAi * (1 - (1-weightTi) * poolFee);\\n\\n    function calcPoolOutGivenSingleIn(\\n        uint256 tokenBalanceIn,\\n        uint256 tokenWeightIn,\\n        uint256 poolSupply,\\n        uint256 totalWeight,\\n        uint256 tokenAmountIn,\\n        uint256 swapFee\\n    ) public pure returns (uint256 poolAmountOut) {\\n        uint256 normalizedWeight = bdiv(tokenWeightIn, totalWeight);\\n        uint256 zaz = bmul(bsub(BONE, normalizedWeight), swapFee);\\n        uint256 tokenAmountInAfterFee = bmul(tokenAmountIn, bsub(BONE, zaz));\\n\\n        uint256 newTokenBalanceIn = badd(tokenBalanceIn, tokenAmountInAfterFee);\\n        uint256 tokenInRatio = bdiv(newTokenBalanceIn, tokenBalanceIn);\\n\\n        // uint newPoolSupply = (ratioTi ^ weightTi) * poolSupply;\\n        uint256 poolRatio = bpow(tokenInRatio, normalizedWeight);\\n        uint256 newPoolSupply = bmul(poolRatio, poolSupply);\\n        poolAmountOut = bsub(newPoolSupply, poolSupply);\\n        return poolAmountOut;\\n    }\\n\\n    /**********************************************************************************************\\n    // calcSingleInGivenPoolOut                                                                  //\\n    // tAi = tokenAmountIn              //(pS + pAo)\\\\     /    1    \\\\\\\\                           //\\n    // pS = poolSupply                 || ---------  | ^ | --------- || * bI - bI                //\\n    // pAo = poolAmountOut              \\\\\\\\    pS    /     \\\\(wI / tW)//                           //\\n    // bI = balanceIn          tAi =  --------------------------------------------               //\\n    // wI = weightIn                              /      wI  \\\\                                   //\\n    // tW = totalWeight                          |  1 - ----  |  * sF                            //\\n    // sF = swapFee                               \\\\      tW  /                                   //\\n    **********************************************************************************************/\\n    function calcSingleInGivenPoolOut(\\n        uint256 tokenBalanceIn,\\n        uint256 tokenWeightIn,\\n        uint256 poolSupply,\\n        uint256 totalWeight,\\n        uint256 poolAmountOut,\\n        uint256 swapFee\\n    ) public pure returns (uint256 tokenAmountIn) {\\n        uint256 normalizedWeight = bdiv(tokenWeightIn, totalWeight);\\n        uint256 newPoolSupply = badd(poolSupply, poolAmountOut);\\n        uint256 poolRatio = bdiv(newPoolSupply, poolSupply);\\n\\n        //uint newBalTi = poolRatio^(1/weightTi) * balTi;\\n        uint256 boo = bdiv(BONE, normalizedWeight);\\n        uint256 tokenInRatio = bpow(poolRatio, boo);\\n        uint256 newTokenBalanceIn = bmul(tokenInRatio, tokenBalanceIn);\\n        uint256 tokenAmountInAfterFee = bsub(newTokenBalanceIn, tokenBalanceIn);\\n        // Do reverse order of fees charged in joinswap_ExternAmountIn, this way\\n        //     ``` pAo == joinswap_ExternAmountIn(Ti, joinswap_PoolAmountOut(pAo, Ti)) ```\\n        //uint tAi = tAiAfterFee / (1 - (1-weightTi) * swapFee) ;\\n        uint256 zar = bmul(bsub(BONE, normalizedWeight), swapFee);\\n        tokenAmountIn = bdiv(tokenAmountInAfterFee, bsub(BONE, zar));\\n        return tokenAmountIn;\\n    }\\n\\n    /**********************************************************************************************\\n    // calcSingleOutGivenPoolIn                                                                  //\\n    // tAo = tokenAmountOut            /      /                                             \\\\\\\\   //\\n    // bO = tokenBalanceOut           /      // pS - (pAi * (1 - eF)) \\\\     /    1    \\\\      \\\\\\\\  //\\n    // pAi = poolAmountIn            | bO - || ----------------------- | ^ | --------- | * b0 || //\\n    // ps = poolSupply                \\\\      \\\\\\\\          pS           /     \\\\(wO / tW)/      //  //\\n    // wI = tokenWeightIn      tAo =   \\\\      \\\\                                             //   //\\n    // tW = totalWeight                    /     /      wO \\\\       \\\\                             //\\n    // sF = swapFee                    *  | 1 - |  1 - ---- | * sF  |                            //\\n    // eF = exitFee                        \\\\     \\\\      tW /       /                             //\\n    **********************************************************************************************/\\n    function calcSingleOutGivenPoolIn(\\n        uint256 tokenBalanceOut,\\n        uint256 tokenWeightOut,\\n        uint256 poolSupply,\\n        uint256 totalWeight,\\n        uint256 poolAmountIn,\\n        uint256 swapFee\\n    ) public pure returns (uint256 tokenAmountOut) {\\n        uint256 normalizedWeight = bdiv(tokenWeightOut, totalWeight);\\n        // charge exit fee on the pool token side\\n        // pAiAfterExitFee = pAi*(1-exitFee)\\n        uint256 poolAmountInAfterExitFee = bmul(poolAmountIn, bsub(BONE, EXIT_FEE));\\n        uint256 newPoolSupply = bsub(poolSupply, poolAmountInAfterExitFee);\\n        uint256 poolRatio = bdiv(newPoolSupply, poolSupply);\\n\\n        // newBalTo = poolRatio^(1/weightTo) * balTo;\\n        uint256 tokenOutRatio = bpow(poolRatio, bdiv(BONE, normalizedWeight));\\n        uint256 newTokenBalanceOut = bmul(tokenOutRatio, tokenBalanceOut);\\n\\n        uint256 tokenAmountOutBeforeSwapFee = bsub(tokenBalanceOut, newTokenBalanceOut);\\n\\n        // charge swap fee on the output token side\\n        //uint tAo = tAoBeforeSwapFee * (1 - (1-weightTo) * swapFee)\\n        uint256 zaz = bmul(bsub(BONE, normalizedWeight), swapFee);\\n        tokenAmountOut = bmul(tokenAmountOutBeforeSwapFee, bsub(BONE, zaz));\\n        return tokenAmountOut;\\n    }\\n\\n    /**********************************************************************************************\\n    // calcPoolInGivenSingleOut                                                                  //\\n    // pAi = poolAmountIn               // /               tAo             \\\\\\\\     / wO \\\\     \\\\   //\\n    // bO = tokenBalanceOut            // | bO - -------------------------- |\\\\   | ---- |     \\\\  //\\n    // tAo = tokenAmountOut      pS - ||   \\\\     1 - ((1 - (tO / tW)) * sF)/  | ^ \\\\ tW /  * pS | //\\n    // ps = poolSupply                 \\\\\\\\ -----------------------------------/                /  //\\n    // wO = tokenWeightOut  pAi =       \\\\\\\\               bO                 /                /   //\\n    // tW = totalWeight           -------------------------------------------------------------  //\\n    // sF = swapFee                                        ( 1 - eF )                            //\\n    // eF = exitFee                                                                              //\\n    **********************************************************************************************/\\n    function calcPoolInGivenSingleOut(\\n        uint256 tokenBalanceOut,\\n        uint256 tokenWeightOut,\\n        uint256 poolSupply,\\n        uint256 totalWeight,\\n        uint256 tokenAmountOut,\\n        uint256 swapFee\\n    ) public pure returns (uint256 poolAmountIn) {\\n        // charge swap fee on the output token side\\n        uint256 normalizedWeight = bdiv(tokenWeightOut, totalWeight);\\n        //uint tAoBeforeSwapFee = tAo / (1 - (1-weightTo) * swapFee) ;\\n        uint256 zoo = bsub(BONE, normalizedWeight);\\n        uint256 zar = bmul(zoo, swapFee);\\n        uint256 tokenAmountOutBeforeSwapFee = bdiv(tokenAmountOut, bsub(BONE, zar));\\n\\n        uint256 newTokenBalanceOut = bsub(tokenBalanceOut, tokenAmountOutBeforeSwapFee);\\n        uint256 tokenOutRatio = bdiv(newTokenBalanceOut, tokenBalanceOut);\\n\\n        //uint newPoolSupply = (ratioTo ^ weightTo) * poolSupply;\\n        uint256 poolRatio = bpow(tokenOutRatio, normalizedWeight);\\n        uint256 newPoolSupply = bmul(poolRatio, poolSupply);\\n        uint256 poolAmountInAfterExitFee = bsub(poolSupply, newPoolSupply);\\n\\n        // charge exit fee on the pool token side\\n        // pAi = pAiAfterExitFee/(1-exitFee)\\n        poolAmountIn = bdiv(poolAmountInAfterExitFee, bsub(BONE, EXIT_FEE));\\n        return poolAmountIn;\\n    }\\n}\\n\",\"keccak256\":\"0x14c1eb51464ef7673b8497df8441093f92f949f374ba58be6c57264f90405ecd\",\"license\":\"MIT\"},\"contracts/balancer/BNum.sol\":{\"content\":\"// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"./BConst.sol\\\";\\n\\ncontract BNum is BConst {\\n    function btoi(uint256 a) internal pure returns (uint256) {\\n        return a / BONE;\\n    }\\n\\n    function bfloor(uint256 a) internal pure returns (uint256) {\\n        return btoi(a) * BONE;\\n    }\\n\\n    function badd(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"ERR_ADD_OVERFLOW\\\");\\n        return c;\\n    }\\n\\n    function bsub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        (uint256 c, bool flag) = bsubSign(a, b);\\n        require(!flag, \\\"ERR_SUB_UNDERFLOW\\\");\\n        return c;\\n    }\\n\\n    function bsubSign(uint256 a, uint256 b) internal pure returns (uint256, bool) {\\n        if (a >= b) {\\n            return (a - b, false);\\n        } else {\\n            return (b - a, true);\\n        }\\n    }\\n\\n    function bmul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c0 = a * b;\\n        require(a == 0 || c0 / a == b, \\\"ERR_MUL_OVERFLOW\\\");\\n        uint256 c1 = c0 + (BONE / 2);\\n        require(c1 >= c0, \\\"ERR_MUL_OVERFLOW\\\");\\n        uint256 c2 = c1 / BONE;\\n        return c2;\\n    }\\n\\n    function bdiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b != 0, \\\"ERR_DIV_ZERO\\\");\\n        uint256 c0 = a * BONE;\\n        require(a == 0 || c0 / a == BONE, \\\"ERR_DIV_INTERNAL\\\"); // bmul overflow\\n        uint256 c1 = c0 + (b / 2);\\n        require(c1 >= c0, \\\"ERR_DIV_INTERNAL\\\"); //  badd require\\n        uint256 c2 = c1 / b;\\n        return c2;\\n    }\\n\\n    // DSMath.wpow\\n    function bpowi(uint256 a, uint256 n) internal pure returns (uint256) {\\n        uint256 z = n % 2 != 0 ? a : BONE;\\n\\n        for (n /= 2; n != 0; n /= 2) {\\n            a = bmul(a, a);\\n\\n            if (n % 2 != 0) {\\n                z = bmul(z, a);\\n            }\\n        }\\n        return z;\\n    }\\n\\n    // Compute b^(e.w) by splitting it into (b^e)*(b^0.w).\\n    // Use `bpowi` for `b^e` and `bpowK` for k iterations\\n    // of approximation of b^0.w\\n    function bpow(uint256 base, uint256 exp) internal pure returns (uint256) {\\n        require(base >= MIN_BPOW_BASE, \\\"ERR_BPOW_BASE_TOO_LOW\\\");\\n        require(base <= MAX_BPOW_BASE, \\\"ERR_BPOW_BASE_TOO_HIGH\\\");\\n\\n        uint256 whole = bfloor(exp);\\n        uint256 remain = bsub(exp, whole);\\n\\n        uint256 wholePow = bpowi(base, btoi(whole));\\n\\n        if (remain == 0) {\\n            return wholePow;\\n        }\\n\\n        uint256 partialResult = bpowApprox(base, remain, BPOW_PRECISION);\\n        return bmul(wholePow, partialResult);\\n    }\\n\\n    function bpowApprox(\\n        uint256 base,\\n        uint256 exp,\\n        uint256 precision\\n    ) internal pure returns (uint256) {\\n        // term 0:\\n        uint256 a = exp;\\n        (uint256 x, bool xneg) = bsubSign(base, BONE);\\n        uint256 term = BONE;\\n        uint256 sum = term;\\n        bool negative = false;\\n\\n        // term(k) = numer / denom\\n        //         = (product(a - i - 1, i=1-->k) * x^k) / (k!)\\n        // each iteration, multiply previous term by (a-(k-1)) * x / k\\n        // continue until term is less than precision\\n        for (uint256 i = 1; term >= precision; i++) {\\n            uint256 bigK = i * BONE;\\n            (uint256 c, bool cneg) = bsubSign(a, bsub(bigK, BONE));\\n            term = bmul(term, bmul(c, x));\\n            term = bdiv(term, bigK);\\n            if (term == 0) break;\\n\\n            if (xneg) negative = !negative;\\n            if (cneg) negative = !negative;\\n            if (negative) {\\n                sum = bsub(sum, term);\\n            } else {\\n                sum = badd(sum, term);\\n            }\\n        }\\n\\n        return sum;\\n    }\\n}\\n\",\"keccak256\":\"0xce47c1071dc0cce2a78b9e34540ebcda49b4d26de2e011090e99476862a985fd\",\"license\":\"MIT\"},\"contracts/balancer/BPool.sol\":{\"content\":\"// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"./BToken.sol\\\";\\nimport \\\"./BMath.sol\\\";\\n\\ncontract BPool is BBronze, BToken, BMath {\\n    struct Record {\\n        bool bound; // is token bound to pool\\n        uint256 index; // private\\n        uint256 denorm; // denormalized weight\\n        uint256 balance;\\n    }\\n\\n    event LOG_SWAP(\\n        address indexed caller,\\n        address indexed tokenIn,\\n        address indexed tokenOut,\\n        uint256 tokenAmountIn,\\n        uint256 tokenAmountOut\\n    );\\n\\n    event LOG_JOIN(address indexed caller, address indexed tokenIn, uint256 tokenAmountIn);\\n\\n    event LOG_EXIT(address indexed caller, address indexed tokenOut, uint256 tokenAmountOut);\\n\\n    event LOG_CALL(bytes4 indexed sig, address indexed caller, bytes data) anonymous;\\n\\n    modifier _logs_() {\\n        emit LOG_CALL(msg.sig, msg.sender, msg.data);\\n        _;\\n    }\\n\\n    modifier _lock_() {\\n        require(!_mutex, \\\"ERR_REENTRY\\\");\\n        _mutex = true;\\n        _;\\n        _mutex = false;\\n    }\\n\\n    modifier _viewlock_() {\\n        require(!_mutex, \\\"ERR_REENTRY\\\");\\n        _;\\n    }\\n\\n    bool private _mutex;\\n\\n    address private _factory; // BFactory address to push token exitFee to\\n    address private _controller; // has CONTROL role\\n    bool private _publicSwap; // true if PUBLIC can call SWAP functions\\n\\n    // `setSwapFee` and `finalize` require CONTROL\\n    // `finalize` sets `PUBLIC can SWAP`, `PUBLIC can JOIN`\\n    uint256 private _swapFee;\\n    bool private _finalized;\\n\\n    address[] private _tokens;\\n    mapping(address => Record) private _records;\\n    uint256 private _totalWeight;\\n\\n    constructor() {\\n        _controller = msg.sender;\\n        _factory = msg.sender;\\n        _swapFee = MIN_FEE;\\n        _publicSwap = false;\\n        _finalized = false;\\n    }\\n\\n    function isPublicSwap() external view returns (bool) {\\n        return _publicSwap;\\n    }\\n\\n    function isFinalized() external view returns (bool) {\\n        return _finalized;\\n    }\\n\\n    function isBound(address t) external view returns (bool) {\\n        return _records[t].bound;\\n    }\\n\\n    function getNumTokens() external view returns (uint256) {\\n        return _tokens.length;\\n    }\\n\\n    function getCurrentTokens() external view _viewlock_ returns (address[] memory tokens) {\\n        return _tokens;\\n    }\\n\\n    function getFinalTokens() external view _viewlock_ returns (address[] memory tokens) {\\n        require(_finalized, \\\"ERR_NOT_FINALIZED\\\");\\n        return _tokens;\\n    }\\n\\n    function getDenormalizedWeight(address token) external view _viewlock_ returns (uint256) {\\n        require(_records[token].bound, \\\"ERR_NOT_BOUND\\\");\\n        return _records[token].denorm;\\n    }\\n\\n    function getTotalDenormalizedWeight() external view _viewlock_ returns (uint256) {\\n        return _totalWeight;\\n    }\\n\\n    function getNormalizedWeight(address token) external view _viewlock_ returns (uint256) {\\n        require(_records[token].bound, \\\"ERR_NOT_BOUND\\\");\\n        uint256 denorm = _records[token].denorm;\\n        return bdiv(denorm, _totalWeight);\\n    }\\n\\n    function getBalance(address token) external view _viewlock_ returns (uint256) {\\n        require(_records[token].bound, \\\"ERR_NOT_BOUND\\\");\\n        return _records[token].balance;\\n    }\\n\\n    function getSwapFee() external view _viewlock_ returns (uint256) {\\n        return _swapFee;\\n    }\\n\\n    function getController() external view _viewlock_ returns (address) {\\n        return _controller;\\n    }\\n\\n    function setSwapFee(uint256 swapFee) external _logs_ _lock_ {\\n        require(!_finalized, \\\"ERR_IS_FINALIZED\\\");\\n        require(msg.sender == _controller, \\\"ERR_NOT_CONTROLLER\\\");\\n        require(swapFee >= MIN_FEE, \\\"ERR_MIN_FEE\\\");\\n        require(swapFee <= MAX_FEE, \\\"ERR_MAX_FEE\\\");\\n        _swapFee = swapFee;\\n    }\\n\\n    function setController(address manager) external _logs_ _lock_ {\\n        require(msg.sender == _controller, \\\"ERR_NOT_CONTROLLER\\\");\\n        _controller = manager;\\n    }\\n\\n    function setPublicSwap(bool public_) external _logs_ _lock_ {\\n        require(!_finalized, \\\"ERR_IS_FINALIZED\\\");\\n        require(msg.sender == _controller, \\\"ERR_NOT_CONTROLLER\\\");\\n        _publicSwap = public_;\\n    }\\n\\n    function finalize() external _logs_ _lock_ {\\n        require(msg.sender == _controller, \\\"ERR_NOT_CONTROLLER\\\");\\n        require(!_finalized, \\\"ERR_IS_FINALIZED\\\");\\n        require(_tokens.length >= MIN_BOUND_TOKENS, \\\"ERR_MIN_TOKENS\\\");\\n\\n        _finalized = true;\\n        _publicSwap = true;\\n\\n        _mintPoolShare(INIT_POOL_SUPPLY);\\n        _pushPoolShare(msg.sender, INIT_POOL_SUPPLY);\\n    }\\n\\n    function bind(\\n        address token,\\n        uint256 balance,\\n        uint256 denorm\\n    )\\n        external\\n        _logs_ // _lock_  Bind does not lock because it jumps to `rebind`, which does\\n    {\\n        require(msg.sender == _controller, \\\"ERR_NOT_CONTROLLER\\\");\\n        require(!_records[token].bound, \\\"ERR_IS_BOUND\\\");\\n        require(!_finalized, \\\"ERR_IS_FINALIZED\\\");\\n\\n        require(_tokens.length < MAX_BOUND_TOKENS, \\\"ERR_MAX_TOKENS\\\");\\n\\n        _records[token] = Record({\\n            bound: true,\\n            index: _tokens.length,\\n            denorm: 0, // balance and denorm will be validated\\n            balance: 0 // and set by `rebind`\\n        });\\n        _tokens.push(token);\\n        rebind(token, balance, denorm);\\n    }\\n\\n    function rebind(\\n        address token,\\n        uint256 balance,\\n        uint256 denorm\\n    ) public _logs_ _lock_ {\\n        require(msg.sender == _controller, \\\"ERR_NOT_CONTROLLER\\\");\\n        require(_records[token].bound, \\\"ERR_NOT_BOUND\\\");\\n        require(!_finalized, \\\"ERR_IS_FINALIZED\\\");\\n\\n        require(denorm >= MIN_WEIGHT, \\\"ERR_MIN_WEIGHT\\\");\\n        require(denorm <= MAX_WEIGHT, \\\"ERR_MAX_WEIGHT\\\");\\n        require(balance >= MIN_BALANCE, \\\"ERR_MIN_BALANCE\\\");\\n\\n        // Adjust the denorm and totalWeight\\n        uint256 oldWeight = _records[token].denorm;\\n        if (denorm > oldWeight) {\\n            _totalWeight = badd(_totalWeight, bsub(denorm, oldWeight));\\n            require(_totalWeight <= MAX_TOTAL_WEIGHT, \\\"ERR_MAX_TOTAL_WEIGHT\\\");\\n        } else if (denorm < oldWeight) {\\n            _totalWeight = bsub(_totalWeight, bsub(oldWeight, denorm));\\n        }\\n        _records[token].denorm = denorm;\\n\\n        // Adjust the balance record and actual token balance\\n        uint256 oldBalance = _records[token].balance;\\n        _records[token].balance = balance;\\n        if (balance > oldBalance) {\\n            _pullUnderlying(token, msg.sender, bsub(balance, oldBalance));\\n        } else if (balance < oldBalance) {\\n            // In this case liquidity is being withdrawn, so charge EXIT_FEE\\n            uint256 tokenBalanceWithdrawn = bsub(oldBalance, balance);\\n            uint256 tokenExitFee = bmul(tokenBalanceWithdrawn, EXIT_FEE);\\n            _pushUnderlying(token, msg.sender, bsub(tokenBalanceWithdrawn, tokenExitFee));\\n            _pushUnderlying(token, _factory, tokenExitFee);\\n        }\\n    }\\n\\n    function unbind(address token) external _logs_ _lock_ {\\n        require(msg.sender == _controller, \\\"ERR_NOT_CONTROLLER\\\");\\n        require(_records[token].bound, \\\"ERR_NOT_BOUND\\\");\\n        require(!_finalized, \\\"ERR_IS_FINALIZED\\\");\\n\\n        uint256 tokenBalance = _records[token].balance;\\n        uint256 tokenExitFee = bmul(tokenBalance, EXIT_FEE);\\n\\n        _totalWeight = bsub(_totalWeight, _records[token].denorm);\\n\\n        // Swap the token-to-unbind with the last token,\\n        // then delete the last token\\n        uint256 index = _records[token].index;\\n        uint256 last = _tokens.length - 1;\\n        _tokens[index] = _tokens[last];\\n        _records[_tokens[index]].index = index;\\n        _tokens.pop();\\n        _records[token] = Record({bound: false, index: 0, denorm: 0, balance: 0});\\n\\n        _pushUnderlying(token, msg.sender, bsub(tokenBalance, tokenExitFee));\\n        _pushUnderlying(token, _factory, tokenExitFee);\\n    }\\n\\n    // Absorb any tokens that have been sent to this contract into the pool\\n    function gulp(address token) external _logs_ _lock_ {\\n        require(_records[token].bound, \\\"ERR_NOT_BOUND\\\");\\n        _records[token].balance = IERC20Balancer(token).balanceOf(address(this));\\n    }\\n\\n    function getSpotPrice(address tokenIn, address tokenOut) external view _viewlock_ returns (uint256 spotPrice) {\\n        require(_records[tokenIn].bound, \\\"ERR_NOT_BOUND\\\");\\n        require(_records[tokenOut].bound, \\\"ERR_NOT_BOUND\\\");\\n        Record storage inRecord = _records[tokenIn];\\n        Record storage outRecord = _records[tokenOut];\\n        return calcSpotPrice(inRecord.balance, inRecord.denorm, outRecord.balance, outRecord.denorm, _swapFee);\\n    }\\n\\n    function getSpotPriceSansFee(address tokenIn, address tokenOut)\\n        external\\n        view\\n        _viewlock_\\n        returns (uint256 spotPrice)\\n    {\\n        require(_records[tokenIn].bound, \\\"ERR_NOT_BOUND\\\");\\n        require(_records[tokenOut].bound, \\\"ERR_NOT_BOUND\\\");\\n        Record storage inRecord = _records[tokenIn];\\n        Record storage outRecord = _records[tokenOut];\\n        return calcSpotPrice(inRecord.balance, inRecord.denorm, outRecord.balance, outRecord.denorm, 0);\\n    }\\n\\n    function joinPool(uint256 poolAmountOut, uint256[] calldata maxAmountsIn) external _logs_ _lock_ {\\n        require(_finalized, \\\"ERR_NOT_FINALIZED\\\");\\n\\n        uint256 poolTotal = totalSupply();\\n        uint256 ratio = bdiv(poolAmountOut, poolTotal);\\n        require(ratio != 0, \\\"ERR_MATH_APPROX\\\");\\n\\n        for (uint256 i = 0; i < _tokens.length; i++) {\\n            address t = _tokens[i];\\n            uint256 bal = _records[t].balance;\\n            uint256 tokenAmountIn = bmul(ratio, bal);\\n            require(tokenAmountIn != 0, \\\"ERR_MATH_APPROX\\\");\\n            require(tokenAmountIn <= maxAmountsIn[i], \\\"ERR_LIMIT_IN\\\");\\n            _records[t].balance = badd(_records[t].balance, tokenAmountIn);\\n            emit LOG_JOIN(msg.sender, t, tokenAmountIn);\\n            _pullUnderlying(t, msg.sender, tokenAmountIn);\\n        }\\n        _mintPoolShare(poolAmountOut);\\n        _pushPoolShare(msg.sender, poolAmountOut);\\n    }\\n\\n    function exitPool(uint256 poolAmountIn, uint256[] calldata minAmountsOut) external _logs_ _lock_ {\\n        require(_finalized, \\\"ERR_NOT_FINALIZED\\\");\\n\\n        uint256 poolTotal = totalSupply();\\n        uint256 exitFee = bmul(poolAmountIn, EXIT_FEE);\\n        uint256 pAiAfterExitFee = bsub(poolAmountIn, exitFee);\\n        uint256 ratio = bdiv(pAiAfterExitFee, poolTotal);\\n        require(ratio != 0, \\\"ERR_MATH_APPROX\\\");\\n\\n        _pullPoolShare(msg.sender, poolAmountIn);\\n        _pushPoolShare(_factory, exitFee);\\n        _burnPoolShare(pAiAfterExitFee);\\n\\n        for (uint256 i = 0; i < _tokens.length; i++) {\\n            address t = _tokens[i];\\n            uint256 bal = _records[t].balance;\\n            uint256 tokenAmountOut = bmul(ratio, bal);\\n            require(tokenAmountOut != 0, \\\"ERR_MATH_APPROX\\\");\\n            require(tokenAmountOut >= minAmountsOut[i], \\\"ERR_LIMIT_OUT\\\");\\n            _records[t].balance = bsub(_records[t].balance, tokenAmountOut);\\n            emit LOG_EXIT(msg.sender, t, tokenAmountOut);\\n            _pushUnderlying(t, msg.sender, tokenAmountOut);\\n        }\\n    }\\n\\n    function calcExitPool(uint256 poolAmountIn, uint256[] calldata minAmountsOut)\\n        external\\n        view\\n        returns (uint256[] memory)\\n    {\\n        require(_finalized, \\\"ERR_NOT_FINALIZED\\\");\\n\\n        uint256 poolTotal = totalSupply();\\n        uint256 exitFee = bmul(poolAmountIn, EXIT_FEE);\\n        uint256 pAiAfterExitFee = bsub(poolAmountIn, exitFee);\\n        uint256 ratio = bdiv(pAiAfterExitFee, poolTotal);\\n\\n        uint256[] memory _amounts = new uint256[](_tokens.length * 2);\\n\\n        for (uint256 i = 0; i < _tokens.length; i++) {\\n            address t = _tokens[i];\\n            uint256 bal = _records[t].balance;\\n\\n            _amounts[i] = bmul(ratio, bal);\\n            _amounts[_tokens.length + i] = minAmountsOut[i];\\n            require(_amounts[i] >= minAmountsOut[i], \\\"ERR_LIMIT_OUT\\\");\\n        }\\n\\n        return _amounts;\\n    }\\n\\n    function swapExactAmountIn(\\n        address tokenIn,\\n        uint256 tokenAmountIn,\\n        address tokenOut,\\n        uint256 minAmountOut,\\n        uint256 maxPrice\\n    ) external _logs_ _lock_ returns (uint256 tokenAmountOut, uint256 spotPriceAfter) {\\n        require(_records[tokenIn].bound, \\\"ERR_NOT_BOUND\\\");\\n        require(_records[tokenOut].bound, \\\"ERR_NOT_BOUND\\\");\\n        require(_publicSwap, \\\"ERR_SWAP_NOT_PUBLIC\\\");\\n\\n        Record storage inRecord = _records[address(tokenIn)];\\n        Record storage outRecord = _records[address(tokenOut)];\\n\\n        require(tokenAmountIn <= bmul(inRecord.balance, MAX_IN_RATIO), \\\"ERR_MAX_IN_RATIO\\\");\\n\\n        uint256 spotPriceBefore =\\n            calcSpotPrice(inRecord.balance, inRecord.denorm, outRecord.balance, outRecord.denorm, _swapFee);\\n        require(spotPriceBefore <= maxPrice, \\\"ERR_BAD_LIMIT_PRICE\\\");\\n\\n        tokenAmountOut = calcOutGivenIn(\\n            inRecord.balance,\\n            inRecord.denorm,\\n            outRecord.balance,\\n            outRecord.denorm,\\n            tokenAmountIn,\\n            _swapFee\\n        );\\n        require(tokenAmountOut >= minAmountOut, \\\"ERR_LIMIT_OUT\\\");\\n\\n        inRecord.balance = badd(inRecord.balance, tokenAmountIn);\\n        outRecord.balance = bsub(outRecord.balance, tokenAmountOut);\\n\\n        spotPriceAfter = calcSpotPrice(\\n            inRecord.balance,\\n            inRecord.denorm,\\n            outRecord.balance,\\n            outRecord.denorm,\\n            _swapFee\\n        );\\n        require(spotPriceAfter >= spotPriceBefore, \\\"ERR_MATH_APPROX\\\");\\n        require(spotPriceAfter <= maxPrice, \\\"ERR_LIMIT_PRICE\\\");\\n        require(spotPriceBefore <= bdiv(tokenAmountIn, tokenAmountOut), \\\"ERR_MATH_APPROX\\\");\\n\\n        emit LOG_SWAP(msg.sender, tokenIn, tokenOut, tokenAmountIn, tokenAmountOut);\\n\\n        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\\n        _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\\n\\n        return (tokenAmountOut, spotPriceAfter);\\n    }\\n\\n    function swapExactAmountOut(\\n        address tokenIn,\\n        uint256 maxAmountIn,\\n        address tokenOut,\\n        uint256 tokenAmountOut,\\n        uint256 maxPrice\\n    ) external _logs_ _lock_ returns (uint256 tokenAmountIn, uint256 spotPriceAfter) {\\n        require(_records[tokenIn].bound, \\\"ERR_NOT_BOUND\\\");\\n        require(_records[tokenOut].bound, \\\"ERR_NOT_BOUND\\\");\\n        require(_publicSwap, \\\"ERR_SWAP_NOT_PUBLIC\\\");\\n\\n        Record storage inRecord = _records[address(tokenIn)];\\n        Record storage outRecord = _records[address(tokenOut)];\\n\\n        require(tokenAmountOut <= bmul(outRecord.balance, MAX_OUT_RATIO), \\\"ERR_MAX_OUT_RATIO\\\");\\n\\n        uint256 spotPriceBefore =\\n            calcSpotPrice(inRecord.balance, inRecord.denorm, outRecord.balance, outRecord.denorm, _swapFee);\\n        require(spotPriceBefore <= maxPrice, \\\"ERR_BAD_LIMIT_PRICE\\\");\\n\\n        tokenAmountIn = calcInGivenOut(\\n            inRecord.balance,\\n            inRecord.denorm,\\n            outRecord.balance,\\n            outRecord.denorm,\\n            tokenAmountOut,\\n            _swapFee\\n        );\\n        require(tokenAmountIn <= maxAmountIn, \\\"ERR_LIMIT_IN\\\");\\n\\n        inRecord.balance = badd(inRecord.balance, tokenAmountIn);\\n        outRecord.balance = bsub(outRecord.balance, tokenAmountOut);\\n\\n        spotPriceAfter = calcSpotPrice(\\n            inRecord.balance,\\n            inRecord.denorm,\\n            outRecord.balance,\\n            outRecord.denorm,\\n            _swapFee\\n        );\\n        require(spotPriceAfter >= spotPriceBefore, \\\"ERR_MATH_APPROX\\\");\\n        require(spotPriceAfter <= maxPrice, \\\"ERR_LIMIT_PRICE\\\");\\n        require(spotPriceBefore <= bdiv(tokenAmountIn, tokenAmountOut), \\\"ERR_MATH_APPROX\\\");\\n\\n        emit LOG_SWAP(msg.sender, tokenIn, tokenOut, tokenAmountIn, tokenAmountOut);\\n\\n        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\\n        _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\\n\\n        return (tokenAmountIn, spotPriceAfter);\\n    }\\n\\n    function joinswapExternAmountIn(\\n        address tokenIn,\\n        uint256 tokenAmountIn,\\n        uint256 minPoolAmountOut\\n    ) external _logs_ _lock_ returns (uint256 poolAmountOut) {\\n        require(_finalized, \\\"ERR_NOT_FINALIZED\\\");\\n        require(_records[tokenIn].bound, \\\"ERR_NOT_BOUND\\\");\\n        require(tokenAmountIn <= bmul(_records[tokenIn].balance, MAX_IN_RATIO), \\\"ERR_MAX_IN_RATIO\\\");\\n\\n        Record storage inRecord = _records[tokenIn];\\n\\n        poolAmountOut = calcPoolOutGivenSingleIn(\\n            inRecord.balance,\\n            inRecord.denorm,\\n            _totalSupply,\\n            _totalWeight,\\n            tokenAmountIn,\\n            _swapFee\\n        );\\n\\n        require(poolAmountOut >= minPoolAmountOut, \\\"ERR_LIMIT_OUT\\\");\\n\\n        inRecord.balance = badd(inRecord.balance, tokenAmountIn);\\n\\n        emit LOG_JOIN(msg.sender, tokenIn, tokenAmountIn);\\n\\n        _mintPoolShare(poolAmountOut);\\n        _pushPoolShare(msg.sender, poolAmountOut);\\n        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\\n\\n        return poolAmountOut;\\n    }\\n\\n    function joinswapPoolAmountOut(\\n        address tokenIn,\\n        uint256 poolAmountOut,\\n        uint256 maxAmountIn\\n    ) external _logs_ _lock_ returns (uint256 tokenAmountIn) {\\n        require(_finalized, \\\"ERR_NOT_FINALIZED\\\");\\n        require(_records[tokenIn].bound, \\\"ERR_NOT_BOUND\\\");\\n\\n        Record storage inRecord = _records[tokenIn];\\n\\n        tokenAmountIn = calcSingleInGivenPoolOut(\\n            inRecord.balance,\\n            inRecord.denorm,\\n            _totalSupply,\\n            _totalWeight,\\n            poolAmountOut,\\n            _swapFee\\n        );\\n\\n        require(tokenAmountIn != 0, \\\"ERR_MATH_APPROX\\\");\\n        require(tokenAmountIn <= maxAmountIn, \\\"ERR_LIMIT_IN\\\");\\n\\n        require(tokenAmountIn <= bmul(_records[tokenIn].balance, MAX_IN_RATIO), \\\"ERR_MAX_IN_RATIO\\\");\\n\\n        inRecord.balance = badd(inRecord.balance, tokenAmountIn);\\n\\n        emit LOG_JOIN(msg.sender, tokenIn, tokenAmountIn);\\n\\n        _mintPoolShare(poolAmountOut);\\n        _pushPoolShare(msg.sender, poolAmountOut);\\n        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\\n\\n        return tokenAmountIn;\\n    }\\n\\n    function exitswapPoolAmountIn(\\n        address tokenOut,\\n        uint256 poolAmountIn,\\n        uint256 minAmountOut\\n    ) external _logs_ _lock_ returns (uint256 tokenAmountOut) {\\n        require(_finalized, \\\"ERR_NOT_FINALIZED\\\");\\n        require(_records[tokenOut].bound, \\\"ERR_NOT_BOUND\\\");\\n\\n        Record storage outRecord = _records[tokenOut];\\n\\n        tokenAmountOut = calcSingleOutGivenPoolIn(\\n            outRecord.balance,\\n            outRecord.denorm,\\n            _totalSupply,\\n            _totalWeight,\\n            poolAmountIn,\\n            _swapFee\\n        );\\n\\n        require(tokenAmountOut >= minAmountOut, \\\"ERR_LIMIT_OUT\\\");\\n\\n        require(tokenAmountOut <= bmul(_records[tokenOut].balance, MAX_OUT_RATIO), \\\"ERR_MAX_OUT_RATIO\\\");\\n\\n        outRecord.balance = bsub(outRecord.balance, tokenAmountOut);\\n\\n        uint256 exitFee = bmul(poolAmountIn, EXIT_FEE);\\n\\n        emit LOG_EXIT(msg.sender, tokenOut, tokenAmountOut);\\n\\n        _pullPoolShare(msg.sender, poolAmountIn);\\n        _burnPoolShare(bsub(poolAmountIn, exitFee));\\n        _pushPoolShare(_factory, exitFee);\\n        _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\\n\\n        return tokenAmountOut;\\n    }\\n\\n    function exitswapExternAmountOut(\\n        address tokenOut,\\n        uint256 tokenAmountOut,\\n        uint256 maxPoolAmountIn\\n    ) external _logs_ _lock_ returns (uint256 poolAmountIn) {\\n        require(_finalized, \\\"ERR_NOT_FINALIZED\\\");\\n        require(_records[tokenOut].bound, \\\"ERR_NOT_BOUND\\\");\\n        require(tokenAmountOut <= bmul(_records[tokenOut].balance, MAX_OUT_RATIO), \\\"ERR_MAX_OUT_RATIO\\\");\\n\\n        Record storage outRecord = _records[tokenOut];\\n\\n        poolAmountIn = calcPoolInGivenSingleOut(\\n            outRecord.balance,\\n            outRecord.denorm,\\n            _totalSupply,\\n            _totalWeight,\\n            tokenAmountOut,\\n            _swapFee\\n        );\\n\\n        require(poolAmountIn != 0, \\\"ERR_MATH_APPROX\\\");\\n        require(poolAmountIn <= maxPoolAmountIn, \\\"ERR_LIMIT_IN\\\");\\n\\n        outRecord.balance = bsub(outRecord.balance, tokenAmountOut);\\n\\n        uint256 exitFee = bmul(poolAmountIn, EXIT_FEE);\\n\\n        emit LOG_EXIT(msg.sender, tokenOut, tokenAmountOut);\\n\\n        _pullPoolShare(msg.sender, poolAmountIn);\\n        _burnPoolShare(bsub(poolAmountIn, exitFee));\\n        _pushPoolShare(_factory, exitFee);\\n        _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\\n\\n        return poolAmountIn;\\n    }\\n\\n    // ==\\n    // 'Underlying' token-manipulation functions make external calls but are NOT locked\\n    // You must `_lock_` or otherwise ensure reentry-safety\\n\\n    function _pullUnderlying(\\n        address erc20,\\n        address from,\\n        uint256 amount\\n    ) internal {\\n        bool xfer = IERC20Balancer(erc20).transferFrom(from, address(this), amount);\\n        require(xfer, \\\"ERR_ERC20_FALSE\\\");\\n    }\\n\\n    function _pushUnderlying(\\n        address erc20,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool xfer = IERC20Balancer(erc20).transfer(to, amount);\\n        require(xfer, \\\"ERR_ERC20_FALSE\\\");\\n    }\\n\\n    function _pullPoolShare(address from, uint256 amount) internal {\\n        _pull(from, amount);\\n    }\\n\\n    function _pushPoolShare(address to, uint256 amount) internal {\\n        _push(to, amount);\\n    }\\n\\n    function _mintPoolShare(uint256 amount) internal {\\n        _mint(amount);\\n    }\\n\\n    function _burnPoolShare(uint256 amount) internal {\\n        _burn(amount);\\n    }\\n}\\n\",\"keccak256\":\"0x8c65c1a2966e2e6d775beea034f3023ce1fb0182fd84da5a83820191fe494664\",\"license\":\"MIT\"},\"contracts/balancer/BToken.sol\":{\"content\":\"// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"./BNum.sol\\\";\\n\\ninterface IERC20Balancer {\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address whom) external view returns (uint256);\\n\\n    function allowance(address src, address dst) external view returns (uint256);\\n\\n    function approve(address dst, uint256 amt) external returns (bool);\\n\\n    function transfer(address dst, uint256 amt) external returns (bool);\\n\\n    function transferFrom(\\n        address src,\\n        address dst,\\n        uint256 amt\\n    ) external returns (bool);\\n}\\n\\ncontract BTokenBase is BNum {\\n    mapping(address => uint256) internal _balance;\\n    mapping(address => mapping(address => uint256)) internal _allowance;\\n    uint256 internal _totalSupply;\\n\\n    event Approval(address indexed src, address indexed dst, uint256 amt);\\n    event Transfer(address indexed src, address indexed dst, uint256 amt);\\n\\n    function _mint(uint256 amt) internal {\\n        _balance[address(this)] = badd(_balance[address(this)], amt);\\n        _totalSupply = badd(_totalSupply, amt);\\n        emit Transfer(address(0), address(this), amt);\\n    }\\n\\n    function _burn(uint256 amt) internal {\\n        require(_balance[address(this)] >= amt, \\\"ERR_INSUFFICIENT_BAL\\\");\\n        _balance[address(this)] = bsub(_balance[address(this)], amt);\\n        _totalSupply = bsub(_totalSupply, amt);\\n        emit Transfer(address(this), address(0), amt);\\n    }\\n\\n    function _move(\\n        address src,\\n        address dst,\\n        uint256 amt\\n    ) internal {\\n        require(_balance[src] >= amt, \\\"ERR_INSUFFICIENT_BAL\\\");\\n        _balance[src] = bsub(_balance[src], amt);\\n        _balance[dst] = badd(_balance[dst], amt);\\n        emit Transfer(src, dst, amt);\\n    }\\n\\n    function _push(address to, uint256 amt) internal {\\n        _move(address(this), to, amt);\\n    }\\n\\n    function _pull(address from, uint256 amt) internal {\\n        _move(from, address(this), amt);\\n    }\\n}\\n\\ncontract BToken is BTokenBase, IERC20Balancer {\\n    string private _name = \\\"Balancer Pool Token\\\";\\n    string private _symbol = \\\"BPT\\\";\\n    uint8 private _decimals = 18;\\n\\n    function name() public view returns (string memory) {\\n        return _name;\\n    }\\n\\n    function symbol() public view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    function decimals() public view returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    function allowance(address src, address dst) external view override returns (uint256) {\\n        return _allowance[src][dst];\\n    }\\n\\n    function balanceOf(address whom) external view override returns (uint256) {\\n        return _balance[whom];\\n    }\\n\\n    function totalSupply() public view override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    function approve(address dst, uint256 amt) external override returns (bool) {\\n        _allowance[msg.sender][dst] = amt;\\n        emit Approval(msg.sender, dst, amt);\\n        return true;\\n    }\\n\\n    function increaseApproval(address dst, uint256 amt) external returns (bool) {\\n        _allowance[msg.sender][dst] = badd(_allowance[msg.sender][dst], amt);\\n        emit Approval(msg.sender, dst, _allowance[msg.sender][dst]);\\n        return true;\\n    }\\n\\n    function decreaseApproval(address dst, uint256 amt) external returns (bool) {\\n        uint256 oldValue = _allowance[msg.sender][dst];\\n        if (amt > oldValue) {\\n            _allowance[msg.sender][dst] = 0;\\n        } else {\\n            _allowance[msg.sender][dst] = bsub(oldValue, amt);\\n        }\\n        emit Approval(msg.sender, dst, _allowance[msg.sender][dst]);\\n        return true;\\n    }\\n\\n    function transfer(address dst, uint256 amt) external override returns (bool) {\\n        _move(msg.sender, dst, amt);\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address src,\\n        address dst,\\n        uint256 amt\\n    ) external override returns (bool) {\\n        require(msg.sender == src || amt <= _allowance[src][msg.sender], \\\"ERR_BTOKEN_BAD_CALLER\\\");\\n        _move(src, dst, amt);\\n        if (msg.sender != src && _allowance[src][msg.sender] != type(uint256).max) {\\n            _allowance[src][msg.sender] = bsub(_allowance[src][msg.sender], amt);\\n            emit Approval(msg.sender, dst, _allowance[src][msg.sender]);\\n        }\\n        return true;\\n    }\\n}\\n\",\"keccak256\":\"0x4bad2e0da3c0daa4cca2ff05e40cfae7287c5504119e419cb561ee67ab382f43\",\"license\":\"MIT\"},\"contracts/bonds/Ibondingcurve.sol\":{\"content\":\"pragma solidity ^0.8.4; \\n\\n\\ninterface IBondingCurve{\\n\\tfunction setMarketManager(address _market_manager) external;\\n\\tfunction getTotalZCB(uint256 marketId) external returns (uint256 result);\\n\\tfunction getTotalDS(uint256 marketId) external returns (uint256 result);\\n\\tfunction getMaxQuantity(uint256 marketId) external view returns (uint256 result);\\n\\tfunction curveInit(uint256 marketId) external;\\n\\tfunction getExpectedPrice(uint256 marketId, uint256 amountIn) external view returns (uint256 result);\\n\\tfunction getCollateral() external returns (address);\\n\\tfunction buy(\\n\\t\\taddress marketFactoryAddress, \\n\\t\\taddress trader,\\n\\t\\tuint256 amountIn, \\n\\t\\tuint256 marketId\\n\\t) external returns(uint256);\\n\\tfunction sell(\\n\\t\\taddress marketFactoryAddress, \\n\\t\\taddress trader,\\n\\t\\tuint256 amountIn, \\n\\t\\tuint256 marketId\\n\\t) external returns (uint256);\\n\\tfunction redeem(\\n\\t\\tuint256 marketId, \\n\\t\\taddress receiver, \\n\\t\\tuint256 zcb_redeem_amount, \\n\\t\\tuint256 collateral_redeem_amount\\n\\t) external;\\n\\tfunction redeemPostAssessment(\\n\\t\\tuint256 marketId, \\n\\t\\taddress redeemer,\\n\\t\\tuint256 collateral_amount\\n\\t) external;\\n\\tfunction burnFirstLoss(\\n\\t\\tuint256 marketId, \\n\\t\\tuint256 burn_collateral_amount\\n\\t) external;\\n\\tfunction mint(\\n\\t\\tuint256 marketId, \\n\\t\\tuint256 mintAmount,\\n\\t\\taddress to\\n\\t) external;\\n\\tfunction burn(\\n\\t\\tuint256 marketId, \\n\\t\\tuint256 burnAmount, \\n\\t\\taddress to\\n\\t) external;\\n}\",\"keccak256\":\"0xe845e38e8bd98c0f9be5a6e585cad5965419d50a72f7d7bd06d2496641a9376a\"},\"contracts/bonds/LinearBondingCurve.sol\":{\"content\":\"pragma solidity ^0.8.4;\\n\\nimport {BondingCurve} from \\\"./bondingcurve.sol\\\";\\nimport {FixedPointMathLib} from \\\"solmate/src/utils/FixedPointMathLib.sol\\\";\\nimport \\\"hardhat/console.sol\\\";\\n\\n/// @notice y = a * x + b\\n/// @dev NEED TO REDO FOR GAS EFFICIENT\\ncontract LinearBondingCurve is BondingCurve {\\n  // ASSUMES 18 TRAILING DECIMALS IN UINT256\\n  using FixedPointMathLib for uint256;\\n  uint256 a;\\n  uint256 b;\\n\\n  constructor (\\n      string memory name,\\n      string memory symbol,\\n      address owner,\\n      address collateral,\\n      uint256 _a,\\n      uint256 _b\\n  ) BondingCurve(name, symbol, owner, collateral) {\\n      a = _a;\\n      b = _b;\\n  }\\n  /**\\n   @dev tokens returned = [((a*s + b)^2 + 2*a*p)^(1/2) - (a*s + b)] / a\\n   @param amount: amount collateral in => has collateral decimal number.\\n   tokens returned in 60.18\\n   */\\n  function _calculatePurchaseReturn(uint256 amount) view internal override virtual returns(uint256) {\\n    uint256 s = totalSupply() ;\\n    uint256 _amount = amount * 10 ** (18 - collateral_dec);\\n    console.log('s', s, a); \\n    console.log('b', b); \\n\\n    uint256 x = ((a.mulWadDown(s) + b) ** 2)/math_precision; \\n    console.log('x', x); \\n\\n    uint256 y = 2*( a.mulWadDown(_amount)); \\n    console.log('y', y); \\n\\n    uint256 x_y_sqrt = ((x+y)*math_precision).sqrt();\\n    console.log('x_y_sqrt', x_y_sqrt); \\n\\n    uint256 z = (a.mulWadDown(s) + b); \\n    console.log('z', z); \\n\\n    uint256 result = (x_y_sqrt-z).divWadDown(a);\\n    console.log('result', result); \\n\\n    return result; \\n\\n\\n      // uint256 two = uint256(2).fromUint();\\n      // result = (((a.mul(s) + b).pow(two) + two.mul(a).mul(amount)).sqrt() - (a.mul(s) + b)).div(a);\\n      //result = ( ( ( ((a.mulWadDown(s) + b) ** 2)/math_precision + 2 * a.mulWadDown(_amount) ) * math_precision ).sqrt() - (a.mulWadDown(s) + b) ).divWadDown(a);\\n  }\\n\\n  /// @notice calculates area under the curve from current supply to s+amount\\n  /// result = a * amount / 2  * (2* supply + amount) + b * amount\\n  /// @dev amount is in 60.18.\\n  /// returned in collateral decimals\\n  function _calcAreaUnderCurve(uint256 amount) internal view override virtual returns(uint256){\\n    uint256 s = totalSupply(); \\n\\n    uint256 result = ( a.mulWadDown(amount) / 2 ).mulWadDown(2 * s + amount) + b.mulWadDown(amount); \\n    console.log('result', result); \\n    result /= (10 ** (18 - collateral_dec));\\n\\n    return result; \\n  }\\n\\n  /**\\n   @notice calculates area under curve from s-amount to s, is c(as-ac/2+b) where c is amount \\n   @dev collateral tokens returned\\n   @param amount: tokens burning => 60.18 amount needs to be in 18 decimal \\n   @dev returns amount of collateral tokens with collateral decimals\\n   */\\n  function _calculateSaleReturn(uint256 amount) view internal override virtual returns (uint256) {\\n    uint s = totalSupply();\\n\\n    console.log('amount', amount, s); \\n\\n    uint256 x = a.mulWadDown(s); \\n    console.log('x', x); \\n    uint256 y = a.mulWadDown(amount)/2; \\n    console.log('y', y); \\n    uint256 z = b + x - y; \\n    console.log('z', z); \\n    uint256 result = amount.mulWadDown(z); \\n    console.log('result', result); \\n\\n    result = result / (10 ** (18 - collateral_dec));\\n\\n    return result; \\n    \\n    // uint256 _reserves = reserves * 10 ** (18 - collateral_dec);\\n\\n    // console.log(\\\"_reserves\\\", _reserves);\\n    // result = _reserves - ( (a / 2).mulWadDown((((s - amount)**2) / math_precision)) + b.mulWadDown(s - amount) );\\n    // console.log(\\\"s - amount\\\", s - amount);\\n    // result /= (10 ** (18 - collateral_dec));\\n  }\\n\\n  /**\\n   @param amount: amount added in 60.18\\n   @dev returns price in 60.18\\n   */\\n  function _calculateExpectedPrice(uint256 amount) view internal override virtual returns (uint256 result) {\\n    uint256 s = totalSupply();\\n\\n    result = (s + amount).mulWadDown(a) + b;\\n  }\\n\\n  function _calculateDecreasedPrice(uint256 amount) view internal override virtual returns (uint256 result) {\\n    result = (totalSupply() - amount).mulWadDown(a) + b;\\n  }\\n\\n  /**\\n   @notice probability = a * x + b, 60.18\\n   returns probability in 60.18\\n   */\\n  function _calculateProbability(uint256 amount) view internal override virtual returns (uint256 score) {\\n      //score = amount.mul(a) + b;\\n    score = amount.mulWadDown(a) + b;\\n  }\\n\\n\\n\\n function _calculateScore(uint256 priceOut, bool atLoss)view internal override virtual returns (uint256 score) {\\n      // uint256 two = uint256(2).fromUint();\\n      // if (atLoss) {score =  ((priceOut-math_precision).div(math_precision)).pow(two);}\\n      // else {score = ((priceOut).div(math_precision)).pow(two);}\\n    if (atLoss) {\\n        score = ((priceOut - math_precision) ** 2) / math_precision;\\n    } else {\\n        score = (priceOut ** 2) / math_precision;\\n    }\\n\\n  }\\n\\n  function getParams() public view returns(uint,uint){\\n    return (a,b); \\n  }\\n}\",\"keccak256\":\"0xb6a8f40e27c5bc1ca88941f5c76bcd2ca66eb424a2bb9f8ca428d5a54e7257ef\"},\"contracts/bonds/LinearBondingCurveFactory.sol\":{\"content\":\"pragma solidity ^0.8.4;\\nimport {OwnedERC20} from \\\"../turbo/OwnedShareToken.sol\\\";\\nimport {LinearBondingCurve} from \\\"./LinearBondingCurve.sol\\\"; \\nimport {LinearShortZCB} from \\\"./LinearShortZCB.sol\\\"; \\n\\n/// @notice need to separate factories because of contract size error \\ncontract LinearBondingCurveFactory{\\n\\n  address controller; \\n  constructor(){\\n    controller = msg.sender; \\n  }\\n\\n  function newLongZCB(\\n    string memory name, \\n    string memory symbol,\\n    address marketmanager_address,\\n    address vault_address, \\n    uint256 a, \\n    uint256 b) external returns(OwnedERC20){\\n\\n    OwnedERC20 zcb = new LinearBondingCurve(\\n    name,\\n    symbol,\\n    marketmanager_address, // owner\\n    vault_address,  \\n    a,\\n    b\\n  );\\n    return zcb; \\n  }\\n\\n  function newShortZCB(\\n    string memory name,\\n    string memory symbol, \\n    address marketmanager_address, \\n    address vault_address, \\n    address longZCBaddress, \\n    uint256 marketId\\n    ) external returns (OwnedERC20){\\n\\n    OwnedERC20 shortZCB = new LinearShortZCB(\\n      name, symbol, marketmanager_address, vault_address, longZCBaddress, marketId); \\n    return shortZCB;\\n\\n\\n  }\\n\\n\\n\\n\\n\\n}\",\"keccak256\":\"0x8b16fd291dba65debbfa86f41e81672a09ef9c319b037f4802486a4040bb2dcb\"},\"contracts/bonds/LinearShortZCB.sol\":{\"content\":\"pragma solidity ^0.8.4;\\nimport {OwnedERC20} from \\\"../turbo/OwnedShareToken.sol\\\";\\nimport \\\"hardhat/console.sol\\\";\\n//import \\\"../prb/PRBMathUD60x18.sol\\\";\\nimport {FixedPointMathLib} from \\\"solmate/src/utils/FixedPointMathLib.sol\\\";\\nimport {ERC20} from \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport {SafeERC20} from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport {LinearBondingCurve} from \\\"./LinearBondingCurve.sol\\\"; \\nimport {MarketManager} from \\\"../stablecoin/marketmanager.sol\\\"; \\n\\n/// @notice this contract allows tokenized short positions at a price 1-zcb\\n/// 1 shortZCB is a representation of borrowing+ selling 1 longZCB  \\n/// ex. when longZCB price is 0.9, shortZCB is 0.1\\n/// 1. trader transfer total x amount, 0.1 per shortZCB to this contract \\n/// 2. this contract borrow+sell from marketmanager, y amount of collateral sent back here\\n/// 3. x+y should equal (supply - sold supply), \\n/// at maturity funds here will be burned and redeemed amount will be minted just like longZCB \\ncontract LinearShortZCB is OwnedERC20{\\n\\n\\tusing FixedPointMathLib for uint256;\\n \\tusing SafeERC20 for ERC20;\\n\\n\\tERC20 collateral;\\n\\n\\tuint256 math_precision; \\n\\tuint256 collateral_dec; \\n\\tuint256 marketId; \\n\\tuint256 reserves;  \\n\\tLinearBondingCurve LongZCB;\\n\\n\\n\\n  constructor (\\n    string memory name,\\n    string memory symbol,\\n    address owner, // market manager.\\n    address _collateral, //vault tokens ,\\n\\n    address LongZCB_address, \\n    uint256 _marketId\\n)  OwnedERC20(name, symbol, owner) {\\n    collateral = ERC20(_collateral); \\n    math_precision = 1e18;\\n    collateral_dec = collateral.decimals();\\n    collateral.approve(owner, 10*(10**8)* collateral_dec); \\n    LongZCB = LinearBondingCurve(LongZCB_address); \\n    marketId = _marketId; \\n\\n  }\\n\\n  function getCollateral() public view returns(address){\\n  \\treturn address(collateral);\\n  }\\n\\n  /// @notice maximum possiblesell amount given current reserves\\n  /// should be instead maximum possible borrow amount \\n  function getMaxShortAmount() public view returns(uint256){\\n  \\tuint256 c = LongZCB.getTotalZCB(); \\n   \\t(uint256 a, uint256 b) = LongZCB.getParams(); \\n\\n  \\treturn c - (a/2).mulWadDown(c.mulWadDown(c)) - b.mulWadDown(c); \\n\\n  }\\n\\n  /// @notice calculates amount of ZCB to sell given collateral for shorts\\n  /// @param amount in collateral dec\\n  /// returns in 18 dec shortZCB amount \\n  function calculateAmountGivenSell(uint256 amount) public view returns(uint256,uint256){\\n  \\tuint256 amount_ = amount * 10**(18-collateral_dec); \\n  \\tuint256 c = LongZCB.getTotalZCB(); \\n\\n  \\tconsole.log('c', c);\\n\\n  \\t(uint256 a, uint256 b) = LongZCB.getParams(); \\n  \\tuint256 x = (math_precision-b).mulWadDown(math_precision-b); \\t\\n\\n  \\tuint256 q = 2*a.mulWadDown(c);\\n  \\tuint256 w = (a.mulWadDown(a)).mulWadDown(c.mulWadDown(c)); \\n  \\tuint256 e = q.mulWadDown(b); \\n  \\tuint256 t = 2*a.mulWadDown(amount_);\\n  \\t// uint256 rhs = ((x - q+w+e+t)*math_precision).sqrt(); \\n\\n  \\t// console.log('rhs', rhs); \\n  \\tuint256 numerator; \\n  \\tunchecked {numerator = (math_precision - b) - (((x - q+w+e+t)*math_precision).sqrt()) ;} \\n   \\tif (numerator >= 2**255 ) revert('Not enough liquidity'); \\n\\n   \\tuint256 cprime = numerator.divWadDown(a);\\n   \\tconsole.log('cprime', cprime, c); \\n\\n   \\treturn ((c -cprime), cprime); \\n\\n\\n  }\\n\\n\\t/// @notice called from the marketmanager \\n\\tfunction trustedShort(\\n\\t\\taddress trader, \\n\\t\\tuint256 collateral_amount) public onlyOwner returns (uint256) {\\n\\n\\t\\t(uint256 shortTokensToMint, uint256 supply_after_sell)  = calculateAmountGivenSell(collateral_amount); \\n\\t\\tcollateral.safeTransferFrom(trader, address(this), collateral_amount); \\n\\n\\t\\tMarketManager marketmanager = MarketManager(owner); \\n\\t\\tmarketmanager.borrow_for_shortZCB(marketId, shortTokensToMint);  \\n\\t\\tuint256 amountOut = marketmanager.sell(marketId, shortTokensToMint); \\n\\t\\tconsole.log('amountout', amountOut, collateral_amount);\\n\\t\\tconsole.log('supply_after_sell', supply_after_sell); \\n\\n    //amountOut + collateral_amount should equal shortTokensToMint \\n    _mint(trader, shortTokensToMint); \\n\\n    reserves += (collateral_amount + amountOut); \\n    return shortTokensToMint; \\n\\n\\t}\\n\\n\\n \\t/// @notice amount is in collateral \\n\\tfunction calculateAveragePrice(uint256 amount) public view returns(uint256, uint256){\\n\\t\\t(uint256 shortTokenAmount, uint256 k) = calculateAmountGivenSell(amount); \\n\\t\\treturn ((amount * 10**(18-collateral_dec)).divWadDown(shortTokenAmount),shortTokenAmount) ; \\n\\t}\\n\\n\\n \\n\\n}\",\"keccak256\":\"0x1729a2fe71007aa2531b93a513bf1fdbee2776987c0e7e79be58fcf94f4874be\"},\"contracts/bonds/bondingcurve.sol\":{\"content\":\"pragma solidity ^0.8.4;\\nimport {OwnedERC20} from \\\"../turbo/OwnedShareToken.sol\\\";\\nimport \\\"hardhat/console.sol\\\";\\n//import \\\"../prb/PRBMathUD60x18.sol\\\";\\nimport {FixedPointMathLib} from \\\"solmate/src/utils/FixedPointMathLib.sol\\\";\\nimport {ERC20} from \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport {SafeERC20} from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\n\\n//TODO need to actually review for security and shit.\\nabstract contract BondingCurve is OwnedERC20 {\\n\\t// ASSUMES 18 TRAILING DECIMALS IN UINT256\\n\\tusing SafeERC20 for ERC20;\\n\\tusing FixedPointMathLib for uint256;\\n\\n\\tuint256 internal price_upper_bound;\\n\\tuint256 internal price_lower_bound;\\n\\tuint256 internal reserves;\\n\\tuint256 internal max_quantity;\\n\\tuint256 internal math_precision; \\n\\tuint256 internal collateral_dec;\\n\\tERC20 collateral; // NEED TO CHANGE ONCE VAULT IS DONE\\n\\taddress[] private buyers; // keeps track for final reputation.\\n\\n\\n\\tconstructor (\\n\\t\\tstring memory name,\\n\\t\\tstring memory symbol,\\n\\t\\t\\taddress owner, // market manager.\\n\\t\\t\\taddress _collateral\\n\\t\\t\\t) OwnedERC20(name, symbol, owner) {\\n\\t\\tcollateral = ERC20(_collateral);\\n\\t\\tmath_precision = 1e18;\\n\\t\\tcollateral_dec = collateral.decimals();\\n\\t}\\n\\n\\n\\tfunction setUpperBound(uint256 upper_bound) public onlyOwner {\\n\\t\\tprice_upper_bound = upper_bound;\\n\\t}\\n\\n\\tfunction setLowerBound(uint256 lower_bound) public onlyOwner {\\n\\t\\tprice_lower_bound = lower_bound;\\n\\t}\\n\\n\\tfunction setMaxQuantity(uint256 _max_quantity) public onlyOwner {\\n\\t\\tmax_quantity = _max_quantity;\\n\\t}\\n\\n\\t/**\\n\\t @notice called by market manager, like trustedMint but returns amount out\\n\\t @param collateral_amount: amount of collateral in. => w/ collateral decimals\\n\\t */\\n\\t function trustedBuy(address trader, uint256 collateral_amount) public onlyOwner returns (uint256) {\\n\\t\\tuint256 tokens = _calculatePurchaseReturn(collateral_amount);\\n\\t\\tconsole.log('TOKENS', tokens, collateral_amount); \\n\\t\\treserves += collateral_amount;\\n\\n\\t\\trequire(collateral.balanceOf(trader)>= collateral_amount,\\\"not enough balance\\\"); \\n\\t\\tcollateral.safeTransferFrom(trader, address(this), collateral_amount);\\n\\t\\t_mint(trader, tokens);\\n\\t\\treturn tokens;\\n\\t }\\n\\n\\t/**\\n\\t @param zcb_amount: amount of zcb tokens burned, needs to be in 18 decimals \\n\\t */\\n\\t function trustedSell(address trader, uint256 zcb_amount) public onlyOwner returns (uint256) {\\n\\t\\tuint256 collateral_out = _calculateSaleReturn(zcb_amount);\\n\\t\\tconsole.log(\\\"colalteralout\\\", collateral_out); \\n\\t\\t_burn(trader, zcb_amount);\\n\\t\\tconsole.log('here', zcb_amount);\\n\\n\\t\\tcollateral.safeTransfer(trader, collateral_out);\\n\\t\\tconsole.log('here2', collateral_out);\\n\\n\\t\\treserves -= collateral_out;\\n\\t\\tconsole.log('here3');\\n\\n\\t\\treturn collateral_out;\\n\\t }\\n\\n\\t function trustedApproveCollateralTransfer(address trader, uint256 amount) public onlyOwner {\\n\\t\\tcollateral.approve(trader, amount);\\n\\t }\\n\\n\\t/**\\n\\t @notice calculates tokens returns from input collateral\\n\\t @dev shouldn't be calling this function, should be calculating amount from frontend.\\n\\t @param amount: input collateral (ds)\\n\\t */\\n\\t function calculatePurchaseReturn(uint256 amount) public view  returns (uint256 result) {\\n\\t\\tresult = _calculatePurchaseReturn(amount);\\n\\t }\\n\\n\\n\\t/// @notice gets required amount of collateral to purchase X amount of tokens\\n\\t/// need to get area under the curve from current supply X_  to X_+X \\n\\tfunction calcAreaUnderCurve(uint256 amount) public view  returns(uint){\\n\\t\\treturn _calcAreaUnderCurve(amount); \\n\\t}\\n\\n\\t/**\\n\\t @notice calculates collateral returns from selling tokens\\n\\t @param amount: amount of tokens selling\\n\\t */\\n\\t function calculateSaleReturn(uint256 amount) public view  returns (uint256 result) {\\n\\t\\tresult = _calculateSaleReturn(amount);\\n\\t }\\n\\n\\t/// @notice calculates score necessary to update reputation score\\n\\tfunction calculateScore(uint256 priceOut, bool atLoss) public view returns(uint){\\n\\t\\treturn _calculateScore(priceOut, atLoss);\\n\\t}\\n\\n\\n\\n\\t/// @notice calculates implied probability of the trader \\n\\t/// @param quantity is the ratio amount(in colalteral) / total collateral budget for trader, in 18 decimals \\n\\tfunction calcImpliedProbability(uint256 collateral_amount, uint256 quantity) public view returns(uint256 prob){\\n\\t\\tuint256 zcb_amount = calculatePurchaseReturn(collateral_amount); \\n\\t\\tconsole.log('zcb_amount', zcb_amount); \\n\\t\\t//uint256 avg_price = collateral_amount/zcb_amount; \\n\\t\\tuint256 avg_price = calcAveragePrice(zcb_amount); //18 decimals \\n\\t\\tconsole.log('avg_price', avg_price); \\n\\t\\tuint256 b = avg_price.mulWadDown(math_precision - avg_price);\\n\\t\\tconsole.log('b', b);\\n\\t\\tuint256 prob = quantity.mulWadDown(b)+ avg_price; \\n\\t\\treturn prob; \\n\\t}\\n\\n\\t/// @notice caluclates average price for the user to buy amount tokens \\n\\t/// @dev which is average under the curve divided by amount \\n\\t/// amount is the amount of bonds, 18 decimals \\n\\tfunction calcAveragePrice(uint256 amount) public view returns(uint256){\\n\\n\\t\\tuint256 area = calcAreaUnderCurve(amount); //this takes in 18 \\n\\t\\tconsole.log(\\\"area\\\", area); \\n\\n\\t\\t//area is in decimal 6, amount is in 18\\n\\t\\tuint256 area_in_precision = area*(10**12); \\n\\t\\tuint256 result = area_in_precision.divWadDown(amount); \\n\\t\\t//returns a 18 decimal avg price \\n\\t\\treturn result; \\n\\t}\\n\\n\\t/**\\n\\t @notice calculates expected price given user buys X tokens\\n\\t @param amount: hypothetical amount of tokens bought\\n\\t */\\t\\n\\t function calculateExpectedPrice(uint256 amount) public view  returns (uint256 result) {\\n\\t\\tresult = _calculateExpectedPrice(amount);\\n\\t }\\n\\n\\t function getTotalCollateral() public view returns (uint256 result) {\\n\\t\\tresult = collateral.balanceOf(address(this));\\n\\t }\\n\\n\\t function getCollateral() public view returns (address) {\\n\\t\\treturn address(collateral);\\n\\t } \\n\\n\\t function getTotalZCB() public view returns (uint256 result) {\\n\\t\\tresult = totalSupply();\\n\\t }\\n\\n\\t function getMaxQuantity() public view returns (uint256 result) {\\n\\t\\tresult = max_quantity;\\n\\t }\\n\\n\\t function getUpperBound() public view returns (uint256 result) {\\n\\t\\tresult = price_upper_bound;\\n\\t }\\n\\n\\t function getLowerBound() public view returns (uint256 result) {\\n\\t\\tresult = price_lower_bound;\\n\\t }\\n\\t function getReserves() public view returns(uint256){\\n\\t\\treturn reserves; \\n\\t }\\n\\n\\t/**\\n\\t @notice buy bond tokens with necessary checks and transfers of collateral.\\n\\t @param amount: amount of collateral/ds paid in exchange for tokens\\n\\t @dev amount has number of collateral decimals\\n\\t */\\n\\t function buy(uint256 amount) public {\\n\\t\\tuint256 tokens = _calculatePurchaseReturn(amount);\\n\\t\\tconsole.log(\\\"buy:tokens\\\", tokens);\\n\\t\\treserves += amount; // CAN REPLACE WITH collateral.balanceOf(this)\\n\\t\\t_mint(msg.sender, tokens);\\n\\t\\tcollateral.safeTransferFrom(msg.sender, address(this), amount);\\n\\t}\\n\\n\\t/**\\n\\t @notice sell bond tokens with necessary checks and transfers of collateral\\n\\t @param amount: amount of tokens selling. 60.18.\\n\\t */\\n\\tfunction sell(uint256 amount) public {\\n\\t\\tuint256 sale = _calculateSaleReturn(amount);\\n\\t\\t_burn(msg.sender, amount);\\n\\t\\tcollateral.safeTransfer(msg.sender, sale);\\n\\t\\treserves -= sale;\\n\\t }\\n\\n\\t/**\\n\\t @dev doesn't perform any checks, checks performed by caller\\n\\t */\\n\\tfunction incrementReserves(uint256 amount) public onlyOwner{\\n\\t\\treserves += amount;\\n\\t }\\n\\n\\t/**\\n\\t @dev doesn't perform any checks, checks performed by caller\\n\\t */\\n\\tfunction decrementReserves(uint256 amount) public onlyOwner {\\n\\t\\treserves -= amount;\\n\\t }\\n\\n\\t/**\\n\\t @notice used for calculating reputation score on resolved market.\\n\\t */\\n\\tfunction calculateProbability(uint256 amount) view public returns (uint256 score) {\\n\\t\\treturn _calculateProbability(amount);\\n\\t }\\n\\n\\t// function trustedBurn(address trader, uint256 amount) public onlyOwner{\\n\\t// \\t_burn(trader, amount);\\n\\t//  }\\n\\n\\n\\n\\n\\n\\tfunction redeem(\\n\\t\\taddress receiver, \\n\\t\\tuint256 zcb_redeem_amount, \\n\\t\\tuint256 collateral_redeem_amount\\n\\t\\t) external  onlyOwner {\\n\\t\\t_burn(receiver, zcb_redeem_amount);\\n\\t\\tcollateral.safeTransfer(receiver, collateral_redeem_amount); \\n\\t\\treserves -= collateral_redeem_amount;\\n\\t }\\n\\n\\n\\n\\tfunction redeemPostAssessment(\\n\\t\\taddress redeemer,\\n\\t\\tuint256 collateral_amount\\n\\t\\t) external  onlyOwner{\\n\\t\\tuint256 redeem_amount = balanceOf(redeemer);\\n\\t\\t_burn(redeemer, redeem_amount); \\n\\t\\tcollateral.safeTransfer(redeemer, collateral_amount); \\n\\t\\treserves -= collateral_amount;\\n\\t }\\n\\n\\tfunction burnFirstLoss(\\n\\t\\tuint256 burn_collateral_amount\\n\\t\\t) external onlyOwner{\\n\\t\\tcollateral.safeTransfer(owner, burn_collateral_amount); \\n\\t\\treserves -= burn_collateral_amount;\\n\\t }\\n\\n\\n\\t function _beforeTokenTransfer(\\n\\t\\taddress from,\\n\\t\\taddress to,\\n\\t\\tuint256 amount\\n\\t\\t) internal override virtual {\\n\\t\\t\\t// on _mint\\n\\t\\t\\tif (from == address(0) && price_upper_bound > 0) {\\n\\t\\t\\t\\tconsole.log(\\\"beforeTT: price_upper_bound\\\", price_upper_bound);\\n\\t\\t\\t\\trequire(_calculateExpectedPrice(amount) <= price_upper_bound, \\\"above price upper bound\\\");\\n\\t\\t\\t\\t// if (balanceOf(to) == 0 && amount > 0) {\\n\\t\\t\\t\\t//     buyers.push(to);\\n\\t\\t\\t\\t// }\\n\\t\\t\\t}\\n\\t\\t// on _burn\\n\\t\\telse if (to == address(0) && price_lower_bound > 0) {\\n\\t\\t\\trequire(_calculateDecreasedPrice(amount) >= price_lower_bound, \\\"below price lower bound\\\");\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n\\t @dev amount is tokens burned.\\n\\t */\\n\\t function calculateDecreasedPrice(uint256 amount) view internal virtual returns (uint256 result) {\\n\\t\\tresult = _calculateDecreasedPrice(amount);\\n\\t }\\n\\n\\t function _calcAreaUnderCurve(uint256 amount) internal view  virtual returns(uint256 result); \\n\\n\\t function _calculateScore(uint256 priceOut, bool atLoss) view internal virtual returns(uint256 score);\\n\\n\\t function _calculatePurchaseReturn(uint256 amount) view internal virtual returns(uint256 result);\\n\\n\\t function _calculateSaleReturn(uint256 amount) view internal virtual returns (uint256 result);\\n\\n\\t function _calculateExpectedPrice(uint256 amount) view internal virtual returns (uint256 result);\\n\\n\\t function _calculateProbability(uint256 amount) view internal virtual returns (uint256 score);\\n\\n\\t function _calculateDecreasedPrice(uint256 amount) view internal virtual returns (uint256 result);\\n\\t}\",\"keccak256\":\"0xe76b4cfa47db764ce3abc89f0d95f1634c6ba99a2d19a9fc6b53f7bef2194285\"},\"contracts/libraries/CalculateLinesToBPoolOdds.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/SignedSafeMath.sol\\\";\\n\\nabstract contract CalculateLinesToBPoolOdds {\\n    using SafeMath for uint256;\\n    using SignedSafeMath for int256;\\n\\n    uint256 constant MAX_BPOOL_WEIGHT = 50e18;\\n\\n    function ratioOdds(uint256[] memory _proportions) internal pure returns (uint256[] memory _odds) {\\n        uint256 _total = sum(_proportions);\\n\\n        _odds = new uint256[](_proportions.length);\\n        for (uint256 i = 0; i < _proportions.length; i++) {\\n            _odds[i] = (MAX_BPOOL_WEIGHT).mul(_proportions[i]).div(_total);\\n            require(_odds[i] >= 1e18, \\\"min outcome weight is 2%\\\");\\n        }\\n    }\\n\\n    function sum(uint256[] memory _numbers) private pure returns (uint256 _sum) {\\n        for (uint256 i = 0; i < _numbers.length; i++) {\\n            _sum += _numbers[i];\\n        }\\n    }\\n\\n    function evenOdds(bool _invalid, uint256 _outcomes) internal pure returns (uint256[] memory _odds) {\\n        uint256 _size = _outcomes + (_invalid ? 1 : 0);\\n        _odds = new uint256[](_size);\\n\\n        if (_invalid) _odds[0] = 1e18; // 2%\\n\\n        uint256 _each = (_invalid ? 49e18 : 50e18) / _outcomes;\\n        for (uint256 i = _invalid ? 1 : 0; i < _size; i++) {\\n            _odds[i] = _each;\\n        }\\n    }\\n\\n    function oddsFromLines(int256 _moneyline1, int256 _moneyline2) internal pure returns (uint256[] memory _odds) {\\n        uint256 _odds1 = __calcLineToOdds(_moneyline1);\\n        uint256 _odds2 = __calcLineToOdds(_moneyline2);\\n\\n        uint256 _total = _odds1 + _odds2;\\n\\n        _odds1 = uint256(49e18).mul(_odds1).div(_total);\\n        _odds2 = uint256(49e18).mul(_odds2).div(_total);\\n\\n        // Moneyline odds are too skewed: would have under 2% odds.\\n        require(_odds1 >= 1e18);\\n        require(_odds2 >= 1e18);\\n\\n        _odds = new uint256[](3);\\n        _odds[0] = 1e18; // Invalid, 2%\\n        _odds[1] = _odds1;\\n        _odds[2] = _odds2;\\n    }\\n\\n    function __calcLineToOdds(int256 _line) internal pure returns (uint256) {\\n        if (_line < 0) {\\n            // favored\\n            uint256 _posLine = uint256(-_line);\\n            return _posLine.mul(49e18).div(_posLine.add(100)); // 49e18 * _line / (_line + 100)\\n        } else {\\n            // underdog\\n            return uint256(4900e18).div(uint256(_line).add(100)); // 49e18 * 100 / (_line + 100)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xca10bd78d1908da65a3fe474605312f63b592b0750ecdf3e5b54adbff0f4daf5\",\"license\":\"MIT\"},\"contracts/libraries/IERC20Full.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IERC20Full is IERC20 {\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0xd4f708218be4eb92ec676cde580e2579a03dafd2ca8436b70a25e8331c3f0218\",\"license\":\"MIT\"},\"contracts/libraries/IOwnable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\ninterface IOwnable {\\n    function getOwner() external view returns (address);\\n\\n    function transferOwnership(address _newOwner) external returns (bool);\\n}\\n\",\"keccak256\":\"0xace284dc2ca2afd8e6e1b16f2c3abb9af28ae70b627c3557722e4618c65ef8d9\",\"license\":\"MIT\"},\"contracts/libraries/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"./IOwnable.sol\\\";\\n\\n/**\\n * @title Ownable\\n * @dev The Ownable contract has an owner address, and provides basic authorization control\\n * functions, this simplifies the implementation of \\\"user permissions\\\".\\n */\\nabstract contract Ownable is IOwnable {\\n    address internal owner;\\n\\n    /**\\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\\n     * account.\\n     */\\n    constructor() {\\n        owner = msg.sender;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(msg.sender == owner);\\n        _;\\n    }\\n\\n    function getOwner() public view override returns (address) {\\n        return owner;\\n    }\\n\\n    /**\\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\\n     * @param _newOwner The address to transfer ownership to.\\n     */\\n    function transferOwnership(address _newOwner) public override onlyOwner returns (bool) {\\n        require(_newOwner != address(0));\\n        onTransferOwnership(owner, _newOwner);\\n        owner = _newOwner;\\n        return true;\\n    }\\n\\n    // Subclasses of this token may want to send additional logs through the centralized Augur log emitter contract\\n    function onTransferOwnership(address, address) internal virtual;\\n}\\n\",\"keccak256\":\"0x26c297226aeb6ad5e522fe97f9d68cc4474b2560bf22c8cd124c93442d339a4c\",\"license\":\"MIT\"},\"contracts/libraries/Rewardable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nabstract contract Rewardable {\\n    // Rewards will be paid out over the lifetime of an event.\\n    // An value of zero will start rewards immediately and proceed based on the values set in master chef.\\n\\n    // _Id here is the market id passed to the amm factory when creating a pool.\\n    function getRewardEndTime(uint256 _marketId) public view virtual returns (uint256);\\n}\\n\",\"keccak256\":\"0xcb5296c464967afdf84ea175e46345f8e291c0e621299cb0f6ecfed9e9585add\",\"license\":\"MIT\"},\"contracts/libraries/Versioned.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nabstract contract Versioned {\\n    string internal version;\\n\\n    constructor(string memory _version) {\\n        version = _version;\\n    }\\n\\n    function getVersion() public view returns (string memory) {\\n        return version;\\n    }\\n}\\n\",\"keccak256\":\"0xea7089752f1a6e834ae7428c709749b2088ebedcebb5c4427945fc6d8131950b\",\"license\":\"MIT\"},\"contracts/prb/PRBMath.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\npragma solidity >=0.8.4;\\n\\n/// @notice Emitted when the result overflows uint256.\\nerror PRBMath__MulDivFixedPointOverflow(uint256 prod1);\\n\\n/// @notice Emitted when the result overflows uint256.\\nerror PRBMath__MulDivOverflow(uint256 prod1, uint256 denominator);\\n\\n/// @notice Emitted when one of the inputs is type(int256).min.\\nerror PRBMath__MulDivSignedInputTooSmall();\\n\\n/// @notice Emitted when the intermediary absolute result overflows int256.\\nerror PRBMath__MulDivSignedOverflow(uint256 rAbs);\\n\\n/// @notice Emitted when the input is MIN_SD59x18.\\nerror PRBMathSD59x18__AbsInputTooSmall();\\n\\n/// @notice Emitted when ceiling a number overflows SD59x18.\\nerror PRBMathSD59x18__CeilOverflow(int256 x);\\n\\n/// @notice Emitted when one of the inputs is MIN_SD59x18.\\nerror PRBMathSD59x18__DivInputTooSmall();\\n\\n/// @notice Emitted when one of the intermediary unsigned results overflows SD59x18.\\nerror PRBMathSD59x18__DivOverflow(uint256 rAbs);\\n\\n/// @notice Emitted when the input is greater than 133.084258667509499441.\\nerror PRBMathSD59x18__ExpInputTooBig(int256 x);\\n\\n/// @notice Emitted when the input is greater than 192.\\nerror PRBMathSD59x18__Exp2InputTooBig(int256 x);\\n\\n/// @notice Emitted when flooring a number underflows SD59x18.\\nerror PRBMathSD59x18__FloorUnderflow(int256 x);\\n\\n/// @notice Emitted when converting a basic integer to the fixed-point format overflows SD59x18.\\nerror PRBMathSD59x18__FromIntOverflow(int256 x);\\n\\n/// @notice Emitted when converting a basic integer to the fixed-point format underflows SD59x18.\\nerror PRBMathSD59x18__FromIntUnderflow(int256 x);\\n\\n/// @notice Emitted when the product of the inputs is negative.\\nerror PRBMathSD59x18__GmNegativeProduct(int256 x, int256 y);\\n\\n/// @notice Emitted when multiplying the inputs overflows SD59x18.\\nerror PRBMathSD59x18__GmOverflow(int256 x, int256 y);\\n\\n/// @notice Emitted when the input is less than or equal to zero.\\nerror PRBMathSD59x18__LogInputTooSmall(int256 x);\\n\\n/// @notice Emitted when one of the inputs is MIN_SD59x18.\\nerror PRBMathSD59x18__MulInputTooSmall();\\n\\n/// @notice Emitted when the intermediary absolute result overflows SD59x18.\\nerror PRBMathSD59x18__MulOverflow(uint256 rAbs);\\n\\n/// @notice Emitted when the intermediary absolute result overflows SD59x18.\\nerror PRBMathSD59x18__PowuOverflow(uint256 rAbs);\\n\\n/// @notice Emitted when the input is negative.\\nerror PRBMathSD59x18__SqrtNegativeInput(int256 x);\\n\\n/// @notice Emitted when the calculating the square root overflows SD59x18.\\nerror PRBMathSD59x18__SqrtOverflow(int256 x);\\n\\n/// @notice Emitted when addition overflows UD60x18.\\nerror PRBMathUD60x18__AddOverflow(uint256 x, uint256 y);\\n\\n/// @notice Emitted when ceiling a number overflows UD60x18.\\nerror PRBMathUD60x18__CeilOverflow(uint256 x);\\n\\n/// @notice Emitted when the input is greater than 133.084258667509499441.\\nerror PRBMathUD60x18__ExpInputTooBig(uint256 x);\\n\\n/// @notice Emitted when the input is greater than 192.\\nerror PRBMathUD60x18__Exp2InputTooBig(uint256 x);\\n\\n/// @notice Emitted when converting a basic integer to the fixed-point format format overflows UD60x18.\\nerror PRBMathUD60x18__FromUintOverflow(uint256 x);\\n\\n/// @notice Emitted when multiplying the inputs overflows UD60x18.\\nerror PRBMathUD60x18__GmOverflow(uint256 x, uint256 y);\\n\\n/// @notice Emitted when the input is less than 1.\\nerror PRBMathUD60x18__LogInputTooSmall(uint256 x);\\n\\n/// @notice Emitted when the calculating the square root overflows UD60x18.\\nerror PRBMathUD60x18__SqrtOverflow(uint256 x);\\n\\n/// @notice Emitted when subtraction underflows UD60x18.\\nerror PRBMathUD60x18__SubUnderflow(uint256 x, uint256 y);\\n\\n/// @dev Common mathematical functions used in both PRBMathSD59x18 and PRBMathUD60x18. Note that this shared library\\n/// does not always assume the signed 59.18-decimal fixed-point or the unsigned 60.18-decimal fixed-point\\n/// representation. When it does not, it is explicitly mentioned in the NatSpec documentation.\\nlibrary PRBMath {\\n    /// STRUCTS ///\\n\\n    struct SD59x18 {\\n        int256 value;\\n    }\\n\\n    struct UD60x18 {\\n        uint256 value;\\n    }\\n\\n    /// STORAGE ///\\n\\n    /// @dev How many trailing decimals can be represented.\\n    uint256 internal constant SCALE = 1e18;\\n\\n    /// @dev Largest power of two divisor of SCALE.\\n    uint256 internal constant SCALE_LPOTD = 262144;\\n\\n    /// @dev SCALE inverted mod 2^256.\\n    uint256 internal constant SCALE_INVERSE =\\n        78156646155174841979727994598816262306175212592076161876661_508869554232690281;\\n\\n    /// FUNCTIONS ///\\n\\n    /// @notice Calculates the binary exponent of x using the binary fraction method.\\n    /// @dev Has to use 192.64-bit fixed-point numbers.\\n    /// See https://ethereum.stackexchange.com/a/96594/24693.\\n    /// @param x The exponent as an unsigned 192.64-bit fixed-point number.\\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\\n    function exp2(uint256 x) internal pure returns (uint256 result) {\\n        unchecked {\\n            // Start from 0.5 in the 192.64-bit fixed-point format.\\n            result = 0x800000000000000000000000000000000000000000000000;\\n\\n            // Multiply the result by root(2, 2^-i) when the bit at position i is 1. None of the intermediary results overflows\\n            // because the initial result is 2^191 and all magic factors are less than 2^65.\\n            if (x & 0x8000000000000000 > 0) {\\n                result = (result * 0x16A09E667F3BCC909) >> 64;\\n            }\\n            if (x & 0x4000000000000000 > 0) {\\n                result = (result * 0x1306FE0A31B7152DF) >> 64;\\n            }\\n            if (x & 0x2000000000000000 > 0) {\\n                result = (result * 0x1172B83C7D517ADCE) >> 64;\\n            }\\n            if (x & 0x1000000000000000 > 0) {\\n                result = (result * 0x10B5586CF9890F62A) >> 64;\\n            }\\n            if (x & 0x800000000000000 > 0) {\\n                result = (result * 0x1059B0D31585743AE) >> 64;\\n            }\\n            if (x & 0x400000000000000 > 0) {\\n                result = (result * 0x102C9A3E778060EE7) >> 64;\\n            }\\n            if (x & 0x200000000000000 > 0) {\\n                result = (result * 0x10163DA9FB33356D8) >> 64;\\n            }\\n            if (x & 0x100000000000000 > 0) {\\n                result = (result * 0x100B1AFA5ABCBED61) >> 64;\\n            }\\n            if (x & 0x80000000000000 > 0) {\\n                result = (result * 0x10058C86DA1C09EA2) >> 64;\\n            }\\n            if (x & 0x40000000000000 > 0) {\\n                result = (result * 0x1002C605E2E8CEC50) >> 64;\\n            }\\n            if (x & 0x20000000000000 > 0) {\\n                result = (result * 0x100162F3904051FA1) >> 64;\\n            }\\n            if (x & 0x10000000000000 > 0) {\\n                result = (result * 0x1000B175EFFDC76BA) >> 64;\\n            }\\n            if (x & 0x8000000000000 > 0) {\\n                result = (result * 0x100058BA01FB9F96D) >> 64;\\n            }\\n            if (x & 0x4000000000000 > 0) {\\n                result = (result * 0x10002C5CC37DA9492) >> 64;\\n            }\\n            if (x & 0x2000000000000 > 0) {\\n                result = (result * 0x1000162E525EE0547) >> 64;\\n            }\\n            if (x & 0x1000000000000 > 0) {\\n                result = (result * 0x10000B17255775C04) >> 64;\\n            }\\n            if (x & 0x800000000000 > 0) {\\n                result = (result * 0x1000058B91B5BC9AE) >> 64;\\n            }\\n            if (x & 0x400000000000 > 0) {\\n                result = (result * 0x100002C5C89D5EC6D) >> 64;\\n            }\\n            if (x & 0x200000000000 > 0) {\\n                result = (result * 0x10000162E43F4F831) >> 64;\\n            }\\n            if (x & 0x100000000000 > 0) {\\n                result = (result * 0x100000B1721BCFC9A) >> 64;\\n            }\\n            if (x & 0x80000000000 > 0) {\\n                result = (result * 0x10000058B90CF1E6E) >> 64;\\n            }\\n            if (x & 0x40000000000 > 0) {\\n                result = (result * 0x1000002C5C863B73F) >> 64;\\n            }\\n            if (x & 0x20000000000 > 0) {\\n                result = (result * 0x100000162E430E5A2) >> 64;\\n            }\\n            if (x & 0x10000000000 > 0) {\\n                result = (result * 0x1000000B172183551) >> 64;\\n            }\\n            if (x & 0x8000000000 > 0) {\\n                result = (result * 0x100000058B90C0B49) >> 64;\\n            }\\n            if (x & 0x4000000000 > 0) {\\n                result = (result * 0x10000002C5C8601CC) >> 64;\\n            }\\n            if (x & 0x2000000000 > 0) {\\n                result = (result * 0x1000000162E42FFF0) >> 64;\\n            }\\n            if (x & 0x1000000000 > 0) {\\n                result = (result * 0x10000000B17217FBB) >> 64;\\n            }\\n            if (x & 0x800000000 > 0) {\\n                result = (result * 0x1000000058B90BFCE) >> 64;\\n            }\\n            if (x & 0x400000000 > 0) {\\n                result = (result * 0x100000002C5C85FE3) >> 64;\\n            }\\n            if (x & 0x200000000 > 0) {\\n                result = (result * 0x10000000162E42FF1) >> 64;\\n            }\\n            if (x & 0x100000000 > 0) {\\n                result = (result * 0x100000000B17217F8) >> 64;\\n            }\\n            if (x & 0x80000000 > 0) {\\n                result = (result * 0x10000000058B90BFC) >> 64;\\n            }\\n            if (x & 0x40000000 > 0) {\\n                result = (result * 0x1000000002C5C85FE) >> 64;\\n            }\\n            if (x & 0x20000000 > 0) {\\n                result = (result * 0x100000000162E42FF) >> 64;\\n            }\\n            if (x & 0x10000000 > 0) {\\n                result = (result * 0x1000000000B17217F) >> 64;\\n            }\\n            if (x & 0x8000000 > 0) {\\n                result = (result * 0x100000000058B90C0) >> 64;\\n            }\\n            if (x & 0x4000000 > 0) {\\n                result = (result * 0x10000000002C5C860) >> 64;\\n            }\\n            if (x & 0x2000000 > 0) {\\n                result = (result * 0x1000000000162E430) >> 64;\\n            }\\n            if (x & 0x1000000 > 0) {\\n                result = (result * 0x10000000000B17218) >> 64;\\n            }\\n            if (x & 0x800000 > 0) {\\n                result = (result * 0x1000000000058B90C) >> 64;\\n            }\\n            if (x & 0x400000 > 0) {\\n                result = (result * 0x100000000002C5C86) >> 64;\\n            }\\n            if (x & 0x200000 > 0) {\\n                result = (result * 0x10000000000162E43) >> 64;\\n            }\\n            if (x & 0x100000 > 0) {\\n                result = (result * 0x100000000000B1721) >> 64;\\n            }\\n            if (x & 0x80000 > 0) {\\n                result = (result * 0x10000000000058B91) >> 64;\\n            }\\n            if (x & 0x40000 > 0) {\\n                result = (result * 0x1000000000002C5C8) >> 64;\\n            }\\n            if (x & 0x20000 > 0) {\\n                result = (result * 0x100000000000162E4) >> 64;\\n            }\\n            if (x & 0x10000 > 0) {\\n                result = (result * 0x1000000000000B172) >> 64;\\n            }\\n            if (x & 0x8000 > 0) {\\n                result = (result * 0x100000000000058B9) >> 64;\\n            }\\n            if (x & 0x4000 > 0) {\\n                result = (result * 0x10000000000002C5D) >> 64;\\n            }\\n            if (x & 0x2000 > 0) {\\n                result = (result * 0x1000000000000162E) >> 64;\\n            }\\n            if (x & 0x1000 > 0) {\\n                result = (result * 0x10000000000000B17) >> 64;\\n            }\\n            if (x & 0x800 > 0) {\\n                result = (result * 0x1000000000000058C) >> 64;\\n            }\\n            if (x & 0x400 > 0) {\\n                result = (result * 0x100000000000002C6) >> 64;\\n            }\\n            if (x & 0x200 > 0) {\\n                result = (result * 0x10000000000000163) >> 64;\\n            }\\n            if (x & 0x100 > 0) {\\n                result = (result * 0x100000000000000B1) >> 64;\\n            }\\n            if (x & 0x80 > 0) {\\n                result = (result * 0x10000000000000059) >> 64;\\n            }\\n            if (x & 0x40 > 0) {\\n                result = (result * 0x1000000000000002C) >> 64;\\n            }\\n            if (x & 0x20 > 0) {\\n                result = (result * 0x10000000000000016) >> 64;\\n            }\\n            if (x & 0x10 > 0) {\\n                result = (result * 0x1000000000000000B) >> 64;\\n            }\\n            if (x & 0x8 > 0) {\\n                result = (result * 0x10000000000000006) >> 64;\\n            }\\n            if (x & 0x4 > 0) {\\n                result = (result * 0x10000000000000003) >> 64;\\n            }\\n            if (x & 0x2 > 0) {\\n                result = (result * 0x10000000000000001) >> 64;\\n            }\\n            if (x & 0x1 > 0) {\\n                result = (result * 0x10000000000000001) >> 64;\\n            }\\n\\n            // We're doing two things at the same time:\\n            //\\n            //   1. Multiply the result by 2^n + 1, where \\\"2^n\\\" is the integer part and the one is added to account for\\n            //      the fact that we initially set the result to 0.5. This is accomplished by subtracting from 191\\n            //      rather than 192.\\n            //   2. Convert the result to the unsigned 60.18-decimal fixed-point format.\\n            //\\n            // This works because 2^(191-ip) = 2^ip / 2^191, where \\\"ip\\\" is the integer part \\\"2^n\\\".\\n            result *= SCALE;\\n            result >>= (191 - (x >> 64));\\n        }\\n    }\\n\\n    /// @notice Finds the zero-based index of the first one in the binary representation of x.\\n    /// @dev See the note on msb in the \\\"Find First Set\\\" Wikipedia article https://en.wikipedia.org/wiki/Find_first_set\\n    /// @param x The uint256 number for which to find the index of the most significant bit.\\n    /// @return msb The index of the most significant bit as an uint256.\\n    function mostSignificantBit(uint256 x) internal pure returns (uint256 msb) {\\n        if (x >= 2**128) {\\n            x >>= 128;\\n            msb += 128;\\n        }\\n        if (x >= 2**64) {\\n            x >>= 64;\\n            msb += 64;\\n        }\\n        if (x >= 2**32) {\\n            x >>= 32;\\n            msb += 32;\\n        }\\n        if (x >= 2**16) {\\n            x >>= 16;\\n            msb += 16;\\n        }\\n        if (x >= 2**8) {\\n            x >>= 8;\\n            msb += 8;\\n        }\\n        if (x >= 2**4) {\\n            x >>= 4;\\n            msb += 4;\\n        }\\n        if (x >= 2**2) {\\n            x >>= 2;\\n            msb += 2;\\n        }\\n        if (x >= 2**1) {\\n            // No need to shift x any more.\\n            msb += 1;\\n        }\\n    }\\n\\n    /// @notice Calculates floor(x*y\\u00f7denominator) with full precision.\\n    ///\\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv.\\n    ///\\n    /// Requirements:\\n    /// - The denominator cannot be zero.\\n    /// - The result must fit within uint256.\\n    ///\\n    /// Caveats:\\n    /// - This function does not work with fixed-point numbers.\\n    ///\\n    /// @param x The multiplicand as an uint256.\\n    /// @param y The multiplier as an uint256.\\n    /// @param denominator The divisor as an uint256.\\n    /// @return result The result as an uint256.\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n        // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n        // variables such that product = prod1 * 2^256 + prod0.\\n        uint256 prod0; // Least significant 256 bits of the product\\n        uint256 prod1; // Most significant 256 bits of the product\\n        assembly {\\n            let mm := mulmod(x, y, not(0))\\n            prod0 := mul(x, y)\\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n        }\\n\\n        // Handle non-overflow cases, 256 by 256 division.\\n        if (prod1 == 0) {\\n            unchecked {\\n                result = prod0 / denominator;\\n            }\\n            return result;\\n        }\\n\\n        // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n        if (prod1 >= denominator) {\\n            revert PRBMath__MulDivOverflow(prod1, denominator);\\n        }\\n\\n        ///////////////////////////////////////////////\\n        // 512 by 256 division.\\n        ///////////////////////////////////////////////\\n\\n        // Make division exact by subtracting the remainder from [prod1 prod0].\\n        uint256 remainder;\\n        assembly {\\n            // Compute remainder using mulmod.\\n            remainder := mulmod(x, y, denominator)\\n\\n            // Subtract 256 bit number from 512 bit number.\\n            prod1 := sub(prod1, gt(remainder, prod0))\\n            prod0 := sub(prod0, remainder)\\n        }\\n\\n        // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n        // See https://cs.stackexchange.com/q/138556/92363.\\n        unchecked {\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 lpotdod = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by lpotdod.\\n                denominator := div(denominator, lpotdod)\\n\\n                // Divide [prod1 prod0] by lpotdod.\\n                prod0 := div(prod0, lpotdod)\\n\\n                // Flip lpotdod such that it is 2^256 / lpotdod. If lpotdod is zero, then it becomes one.\\n                lpotdod := add(div(sub(0, lpotdod), lpotdod), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * lpotdod;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /// @notice Calculates floor(x*y\\u00f71e18) with full precision.\\n    ///\\n    /// @dev Variant of \\\"mulDiv\\\" with constant folding, i.e. in which the denominator is always 1e18. Before returning the\\n    /// final result, we add 1 if (x * y) % SCALE >= HALF_SCALE. Without this, 6.6e-19 would be truncated to 0 instead of\\n    /// being rounded to 1e-18.  See \\\"Listing 6\\\" and text above it at https://accu.org/index.php/journals/1717.\\n    ///\\n    /// Requirements:\\n    /// - The result must fit within uint256.\\n    ///\\n    /// Caveats:\\n    /// - The body is purposely left uncommented; see the NatSpec comments in \\\"PRBMath.mulDiv\\\" to understand how this works.\\n    /// - It is assumed that the result can never be type(uint256).max when x and y solve the following two equations:\\n    ///     1. x * y = type(uint256).max * SCALE\\n    ///     2. (x * y) % SCALE >= SCALE / 2\\n    ///\\n    /// @param x The multiplicand as an unsigned 60.18-decimal fixed-point number.\\n    /// @param y The multiplier as an unsigned 60.18-decimal fixed-point number.\\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\\n    function mulDivFixedPoint(uint256 x, uint256 y) internal pure returns (uint256 result) {\\n        uint256 prod0;\\n        uint256 prod1;\\n        assembly {\\n            let mm := mulmod(x, y, not(0))\\n            prod0 := mul(x, y)\\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n        }\\n\\n        if (prod1 >= SCALE) {\\n            revert PRBMath__MulDivFixedPointOverflow(prod1);\\n        }\\n\\n        uint256 remainder;\\n        uint256 roundUpUnit;\\n        assembly {\\n            remainder := mulmod(x, y, SCALE)\\n            roundUpUnit := gt(remainder, 499999999999999999)\\n        }\\n\\n        if (prod1 == 0) {\\n            unchecked {\\n                result = (prod0 / SCALE) + roundUpUnit;\\n                return result;\\n            }\\n        }\\n\\n        assembly {\\n            result := add(\\n                mul(\\n                    or(\\n                        div(sub(prod0, remainder), SCALE_LPOTD),\\n                        mul(sub(prod1, gt(remainder, prod0)), add(div(sub(0, SCALE_LPOTD), SCALE_LPOTD), 1))\\n                    ),\\n                    SCALE_INVERSE\\n                ),\\n                roundUpUnit\\n            )\\n        }\\n    }\\n\\n    /// @notice Calculates floor(x*y\\u00f7denominator) with full precision.\\n    ///\\n    /// @dev An extension of \\\"mulDiv\\\" for signed numbers. Works by computing the signs and the absolute values separately.\\n    ///\\n    /// Requirements:\\n    /// - None of the inputs can be type(int256).min.\\n    /// - The result must fit within int256.\\n    ///\\n    /// @param x The multiplicand as an int256.\\n    /// @param y The multiplier as an int256.\\n    /// @param denominator The divisor as an int256.\\n    /// @return result The result as an int256.\\n    function mulDivSigned(\\n        int256 x,\\n        int256 y,\\n        int256 denominator\\n    ) internal pure returns (int256 result) {\\n        if (x == type(int256).min || y == type(int256).min || denominator == type(int256).min) {\\n            revert PRBMath__MulDivSignedInputTooSmall();\\n        }\\n\\n        // Get hold of the absolute values of x, y and the denominator.\\n        uint256 ax;\\n        uint256 ay;\\n        uint256 ad;\\n        unchecked {\\n            ax = x < 0 ? uint256(-x) : uint256(x);\\n            ay = y < 0 ? uint256(-y) : uint256(y);\\n            ad = denominator < 0 ? uint256(-denominator) : uint256(denominator);\\n        }\\n\\n        // Compute the absolute value of (x*y)\\u00f7denominator. The result must fit within int256.\\n        uint256 rAbs = mulDiv(ax, ay, ad);\\n        if (rAbs > uint256(type(int256).max)) {\\n            revert PRBMath__MulDivSignedOverflow(rAbs);\\n        }\\n\\n        // Get the signs of x, y and the denominator.\\n        uint256 sx;\\n        uint256 sy;\\n        uint256 sd;\\n        assembly {\\n            sx := sgt(x, sub(0, 1))\\n            sy := sgt(y, sub(0, 1))\\n            sd := sgt(denominator, sub(0, 1))\\n        }\\n\\n        // XOR over sx, sy and sd. This is checking whether there are one or three negative signs in the inputs.\\n        // If yes, the result should be negative.\\n        result = sx ^ sy ^ sd == 0 ? -int256(rAbs) : int256(rAbs);\\n    }\\n\\n    /// @notice Calculates the square root of x, rounding down.\\n    /// @dev Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\\n    ///\\n    /// Caveats:\\n    /// - This function does not work with fixed-point numbers.\\n    ///\\n    /// @param x The uint256 number for which to calculate the square root.\\n    /// @return result The result as an uint256.\\n    function sqrt(uint256 x) internal pure returns (uint256 result) {\\n        if (x == 0) {\\n            return 0;\\n        }\\n\\n        // Set the initial guess to the least power of two that is greater than or equal to sqrt(x).\\n        uint256 xAux = uint256(x);\\n        result = 1;\\n        if (xAux >= 0x100000000000000000000000000000000) {\\n            xAux >>= 128;\\n            result <<= 64;\\n        }\\n        if (xAux >= 0x10000000000000000) {\\n            xAux >>= 64;\\n            result <<= 32;\\n        }\\n        if (xAux >= 0x100000000) {\\n            xAux >>= 32;\\n            result <<= 16;\\n        }\\n        if (xAux >= 0x10000) {\\n            xAux >>= 16;\\n            result <<= 8;\\n        }\\n        if (xAux >= 0x100) {\\n            xAux >>= 8;\\n            result <<= 4;\\n        }\\n        if (xAux >= 0x10) {\\n            xAux >>= 4;\\n            result <<= 2;\\n        }\\n        if (xAux >= 0x4) {\\n            result <<= 1;\\n        }\\n\\n        // The operations can never overflow because the result is max 2^127 when it enters this block.\\n        unchecked {\\n            result = (result + x / result) >> 1;\\n            result = (result + x / result) >> 1;\\n            result = (result + x / result) >> 1;\\n            result = (result + x / result) >> 1;\\n            result = (result + x / result) >> 1;\\n            result = (result + x / result) >> 1;\\n            result = (result + x / result) >> 1; // Seven iterations should be enough\\n            uint256 roundedDownResult = x / result;\\n            return result >= roundedDownResult ? roundedDownResult : result;\\n        }\\n    }\\n}\",\"keccak256\":\"0xe7c890390f136477835cd5ca21aff681fdf36f1d79a3166b679afcc9d8c3122b\",\"license\":\"Unlicense\"},\"contracts/prb/PRBMathUD60x18.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\npragma solidity >=0.8.4;\\n\\nimport \\\"./PRBMath.sol\\\";\\n\\n/// @title PRBMathUD60x18\\n/// @author Paul Razvan Berg\\n/// @notice Smart contract library for advanced fixed-point math that works with uint256 numbers considered to have 18\\n/// trailing decimals. We call this number representation unsigned 60.18-decimal fixed-point, since there can be up to 60\\n/// digits in the integer part and up to 18 decimals in the fractional part. The numbers are bound by the minimum and the\\n/// maximum values permitted by the Solidity type uint256.\\nlibrary PRBMathUD60x18 {\\n    /// @dev Half the SCALE number.\\n    uint256 internal constant HALF_SCALE = 5e17;\\n\\n    /// @dev log2(e) as an unsigned 60.18-decimal fixed-point number.\\n    uint256 internal constant LOG2_E = 1_442695040888963407;\\n\\n    /// @dev The maximum value an unsigned 60.18-decimal fixed-point number can have.\\n    uint256 internal constant MAX_UD60x18 =\\n        115792089237316195423570985008687907853269984665640564039457_584007913129639935;\\n\\n    /// @dev The maximum whole value an unsigned 60.18-decimal fixed-point number can have.\\n    uint256 internal constant MAX_WHOLE_UD60x18 =\\n        115792089237316195423570985008687907853269984665640564039457_000000000000000000;\\n\\n    /// @dev How many trailing decimals can be represented.\\n    uint256 internal constant SCALE = 1e18;\\n\\n    /// @notice Calculates the arithmetic average of x and y, rounding down.\\n    /// @param x The first operand as an unsigned 60.18-decimal fixed-point number.\\n    /// @param y The second operand as an unsigned 60.18-decimal fixed-point number.\\n    /// @return result The arithmetic average as an unsigned 60.18-decimal fixed-point number.\\n    function avg(uint256 x, uint256 y) internal pure returns (uint256 result) {\\n        // The operations can never overflow.\\n        unchecked {\\n            // The last operand checks if both x and y are odd and if that is the case, we add 1 to the result. We need\\n            // to do this because if both numbers are odd, the 0.5 remainder gets truncated twice.\\n            result = (x >> 1) + (y >> 1) + (x & y & 1);\\n        }\\n    }\\n\\n    /// @notice Yields the least unsigned 60.18 decimal fixed-point number greater than or equal to x.\\n    ///\\n    /// @dev Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts.\\n    /// See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\\n    ///\\n    /// Requirements:\\n    /// - x must be less than or equal to MAX_WHOLE_UD60x18.\\n    ///\\n    /// @param x The unsigned 60.18-decimal fixed-point number to ceil.\\n    /// @param result The least integer greater than or equal to x, as an unsigned 60.18-decimal fixed-point number.\\n    function ceil(uint256 x) internal pure returns (uint256 result) {\\n        if (x > MAX_WHOLE_UD60x18) {\\n            revert PRBMathUD60x18__CeilOverflow(x);\\n        }\\n        assembly {\\n            // Equivalent to \\\"x % SCALE\\\" but faster.\\n            let remainder := mod(x, SCALE)\\n\\n            // Equivalent to \\\"SCALE - remainder\\\" but faster.\\n            let delta := sub(SCALE, remainder)\\n\\n            // Equivalent to \\\"x + delta * (remainder > 0 ? 1 : 0)\\\" but faster.\\n            result := add(x, mul(delta, gt(remainder, 0)))\\n        }\\n    }\\n\\n    /// @notice Divides two unsigned 60.18-decimal fixed-point numbers, returning a new unsigned 60.18-decimal fixed-point number.\\n    ///\\n    /// @dev Uses mulDiv to enable overflow-safe multiplication and division.\\n    ///\\n    /// Requirements:\\n    /// - The denominator cannot be zero.\\n    ///\\n    /// @param x The numerator as an unsigned 60.18-decimal fixed-point number.\\n    /// @param y The denominator as an unsigned 60.18-decimal fixed-point number.\\n    /// @param result The quotient as an unsigned 60.18-decimal fixed-point number.\\n    function div(uint256 x, uint256 y) internal pure returns (uint256 result) {\\n        result = PRBMath.mulDiv(x, SCALE, y);\\n    }\\n\\n    /// @notice Returns Euler's number as an unsigned 60.18-decimal fixed-point number.\\n    /// @dev See https://en.wikipedia.org/wiki/E_(mathematical_constant).\\n    function e() internal pure returns (uint256 result) {\\n        result = 2_718281828459045235;\\n    }\\n\\n    /// @notice Calculates the natural exponent of x.\\n    ///\\n    /// @dev Based on the insight that e^x = 2^(x * log2(e)).\\n    ///\\n    /// Requirements:\\n    /// - All from \\\"log2\\\".\\n    /// - x must be less than 133.084258667509499441.\\n    ///\\n    /// @param x The exponent as an unsigned 60.18-decimal fixed-point number.\\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\\n    function exp(uint256 x) internal pure returns (uint256 result) {\\n        // Without this check, the value passed to \\\"exp2\\\" would be greater than 192.\\n        if (x >= 133_084258667509499441) {\\n            revert PRBMathUD60x18__ExpInputTooBig(x);\\n        }\\n\\n        // Do the fixed-point multiplication inline to save gas.\\n        unchecked {\\n            uint256 doubleScaleProduct = x * LOG2_E;\\n            result = exp2((doubleScaleProduct + HALF_SCALE) / SCALE);\\n        }\\n    }\\n\\n    /// @notice Calculates the binary exponent of x using the binary fraction method.\\n    ///\\n    /// @dev See https://ethereum.stackexchange.com/q/79903/24693.\\n    ///\\n    /// Requirements:\\n    /// - x must be 192 or less.\\n    /// - The result must fit within MAX_UD60x18.\\n    ///\\n    /// @param x The exponent as an unsigned 60.18-decimal fixed-point number.\\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\\n    function exp2(uint256 x) internal pure returns (uint256 result) {\\n        // 2^192 doesn't fit within the 192.64-bit format used internally in this function.\\n        if (x >= 192e18) {\\n            revert PRBMathUD60x18__Exp2InputTooBig(x);\\n        }\\n\\n        unchecked {\\n            // Convert x to the 192.64-bit fixed-point format.\\n            uint256 x192x64 = (x << 64) / SCALE;\\n\\n            // Pass x to the PRBMath.exp2 function, which uses the 192.64-bit fixed-point number representation.\\n            result = PRBMath.exp2(x192x64);\\n        }\\n    }\\n\\n    /// @notice Yields the greatest unsigned 60.18 decimal fixed-point number less than or equal to x.\\n    /// @dev Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts.\\n    /// See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\\n    /// @param x The unsigned 60.18-decimal fixed-point number to floor.\\n    /// @param result The greatest integer less than or equal to x, as an unsigned 60.18-decimal fixed-point number.\\n    function floor(uint256 x) internal pure returns (uint256 result) {\\n        assembly {\\n            // Equivalent to \\\"x % SCALE\\\" but faster.\\n            let remainder := mod(x, SCALE)\\n\\n            // Equivalent to \\\"x - remainder * (remainder > 0 ? 1 : 0)\\\" but faster.\\n            result := sub(x, mul(remainder, gt(remainder, 0)))\\n        }\\n    }\\n\\n    /// @notice Yields the excess beyond the floor of x.\\n    /// @dev Based on the odd function definition https://en.wikipedia.org/wiki/Fractional_part.\\n    /// @param x The unsigned 60.18-decimal fixed-point number to get the fractional part of.\\n    /// @param result The fractional part of x as an unsigned 60.18-decimal fixed-point number.\\n    function frac(uint256 x) internal pure returns (uint256 result) {\\n        assembly {\\n            result := mod(x, SCALE)\\n        }\\n    }\\n\\n    /// @notice Converts a number from basic integer form to unsigned 60.18-decimal fixed-point representation.\\n    ///\\n    /// @dev Requirements:\\n    /// - x must be less than or equal to MAX_UD60x18 divided by SCALE.\\n    ///\\n    /// @param x The basic integer to convert.\\n    /// @param result The same number in unsigned 60.18-decimal fixed-point representation.\\n    function fromUint(uint256 x) internal pure returns (uint256 result) {\\n        unchecked {\\n            if (x > MAX_UD60x18 / SCALE) {\\n                revert PRBMathUD60x18__FromUintOverflow(x);\\n            }\\n            result = x * SCALE;\\n        }\\n    }\\n\\n    /// @notice Calculates geometric mean of x and y, i.e. sqrt(x * y), rounding down.\\n    ///\\n    /// @dev Requirements:\\n    /// - x * y must fit within MAX_UD60x18, lest it overflows.\\n    ///\\n    /// @param x The first operand as an unsigned 60.18-decimal fixed-point number.\\n    /// @param y The second operand as an unsigned 60.18-decimal fixed-point number.\\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\\n    function gm(uint256 x, uint256 y) internal pure returns (uint256 result) {\\n        if (x == 0) {\\n            return 0;\\n        }\\n\\n        unchecked {\\n            // Checking for overflow this way is faster than letting Solidity do it.\\n            uint256 xy = x * y;\\n            if (xy / x != y) {\\n                revert PRBMathUD60x18__GmOverflow(x, y);\\n            }\\n\\n            // We don't need to multiply by the SCALE here because the x*y product had already picked up a factor of SCALE\\n            // during multiplication. See the comments within the \\\"sqrt\\\" function.\\n            result = PRBMath.sqrt(xy);\\n        }\\n    }\\n\\n    /// @notice Calculates 1 / x, rounding toward zero.\\n    ///\\n    /// @dev Requirements:\\n    /// - x cannot be zero.\\n    ///\\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the inverse.\\n    /// @return result The inverse as an unsigned 60.18-decimal fixed-point number.\\n    function inv(uint256 x) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 1e36 is SCALE * SCALE.\\n            result = 1e36 / x;\\n        }\\n    }\\n\\n    /// @notice Calculates the natural logarithm of x.\\n    ///\\n    /// @dev Based on the insight that ln(x) = log2(x) / log2(e).\\n    ///\\n    /// Requirements:\\n    /// - All from \\\"log2\\\".\\n    ///\\n    /// Caveats:\\n    /// - All from \\\"log2\\\".\\n    /// - This doesn't return exactly 1 for 2.718281828459045235, for that we would need more fine-grained precision.\\n    ///\\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the natural logarithm.\\n    /// @return result The natural logarithm as an unsigned 60.18-decimal fixed-point number.\\n    function ln(uint256 x) internal pure returns (uint256 result) {\\n        // Do the fixed-point multiplication inline to save gas. This is overflow-safe because the maximum value that log2(x)\\n        // can return is 196205294292027477728.\\n        unchecked {\\n            result = (log2(x) * SCALE) / LOG2_E;\\n        }\\n    }\\n\\n    /// @notice Calculates the common logarithm of x.\\n    ///\\n    /// @dev First checks if x is an exact power of ten and it stops if yes. If it's not, calculates the common\\n    /// logarithm based on the insight that log10(x) = log2(x) / log2(10).\\n    ///\\n    /// Requirements:\\n    /// - All from \\\"log2\\\".\\n    ///\\n    /// Caveats:\\n    /// - All from \\\"log2\\\".\\n    ///\\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the common logarithm.\\n    /// @return result The common logarithm as an unsigned 60.18-decimal fixed-point number.\\n    function log10(uint256 x) internal pure returns (uint256 result) {\\n        if (x < SCALE) {\\n            revert PRBMathUD60x18__LogInputTooSmall(x);\\n        }\\n\\n        // Note that the \\\"mul\\\" in this block is the assembly multiplication operation, not the \\\"mul\\\" function defined\\n        // in this contract.\\n        // prettier-ignore\\n        assembly {\\n            switch x\\n            case 1 { result := mul(SCALE, sub(0, 18)) }\\n            case 10 { result := mul(SCALE, sub(1, 18)) }\\n            case 100 { result := mul(SCALE, sub(2, 18)) }\\n            case 1000 { result := mul(SCALE, sub(3, 18)) }\\n            case 10000 { result := mul(SCALE, sub(4, 18)) }\\n            case 100000 { result := mul(SCALE, sub(5, 18)) }\\n            case 1000000 { result := mul(SCALE, sub(6, 18)) }\\n            case 10000000 { result := mul(SCALE, sub(7, 18)) }\\n            case 100000000 { result := mul(SCALE, sub(8, 18)) }\\n            case 1000000000 { result := mul(SCALE, sub(9, 18)) }\\n            case 10000000000 { result := mul(SCALE, sub(10, 18)) }\\n            case 100000000000 { result := mul(SCALE, sub(11, 18)) }\\n            case 1000000000000 { result := mul(SCALE, sub(12, 18)) }\\n            case 10000000000000 { result := mul(SCALE, sub(13, 18)) }\\n            case 100000000000000 { result := mul(SCALE, sub(14, 18)) }\\n            case 1000000000000000 { result := mul(SCALE, sub(15, 18)) }\\n            case 10000000000000000 { result := mul(SCALE, sub(16, 18)) }\\n            case 100000000000000000 { result := mul(SCALE, sub(17, 18)) }\\n            case 1000000000000000000 { result := 0 }\\n            case 10000000000000000000 { result := SCALE }\\n            case 100000000000000000000 { result := mul(SCALE, 2) }\\n            case 1000000000000000000000 { result := mul(SCALE, 3) }\\n            case 10000000000000000000000 { result := mul(SCALE, 4) }\\n            case 100000000000000000000000 { result := mul(SCALE, 5) }\\n            case 1000000000000000000000000 { result := mul(SCALE, 6) }\\n            case 10000000000000000000000000 { result := mul(SCALE, 7) }\\n            case 100000000000000000000000000 { result := mul(SCALE, 8) }\\n            case 1000000000000000000000000000 { result := mul(SCALE, 9) }\\n            case 10000000000000000000000000000 { result := mul(SCALE, 10) }\\n            case 100000000000000000000000000000 { result := mul(SCALE, 11) }\\n            case 1000000000000000000000000000000 { result := mul(SCALE, 12) }\\n            case 10000000000000000000000000000000 { result := mul(SCALE, 13) }\\n            case 100000000000000000000000000000000 { result := mul(SCALE, 14) }\\n            case 1000000000000000000000000000000000 { result := mul(SCALE, 15) }\\n            case 10000000000000000000000000000000000 { result := mul(SCALE, 16) }\\n            case 100000000000000000000000000000000000 { result := mul(SCALE, 17) }\\n            case 1000000000000000000000000000000000000 { result := mul(SCALE, 18) }\\n            case 10000000000000000000000000000000000000 { result := mul(SCALE, 19) }\\n            case 100000000000000000000000000000000000000 { result := mul(SCALE, 20) }\\n            case 1000000000000000000000000000000000000000 { result := mul(SCALE, 21) }\\n            case 10000000000000000000000000000000000000000 { result := mul(SCALE, 22) }\\n            case 100000000000000000000000000000000000000000 { result := mul(SCALE, 23) }\\n            case 1000000000000000000000000000000000000000000 { result := mul(SCALE, 24) }\\n            case 10000000000000000000000000000000000000000000 { result := mul(SCALE, 25) }\\n            case 100000000000000000000000000000000000000000000 { result := mul(SCALE, 26) }\\n            case 1000000000000000000000000000000000000000000000 { result := mul(SCALE, 27) }\\n            case 10000000000000000000000000000000000000000000000 { result := mul(SCALE, 28) }\\n            case 100000000000000000000000000000000000000000000000 { result := mul(SCALE, 29) }\\n            case 1000000000000000000000000000000000000000000000000 { result := mul(SCALE, 30) }\\n            case 10000000000000000000000000000000000000000000000000 { result := mul(SCALE, 31) }\\n            case 100000000000000000000000000000000000000000000000000 { result := mul(SCALE, 32) }\\n            case 1000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 33) }\\n            case 10000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 34) }\\n            case 100000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 35) }\\n            case 1000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 36) }\\n            case 10000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 37) }\\n            case 100000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 38) }\\n            case 1000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 39) }\\n            case 10000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 40) }\\n            case 100000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 41) }\\n            case 1000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 42) }\\n            case 10000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 43) }\\n            case 100000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 44) }\\n            case 1000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 45) }\\n            case 10000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 46) }\\n            case 100000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 47) }\\n            case 1000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 48) }\\n            case 10000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 49) }\\n            case 100000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 50) }\\n            case 1000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 51) }\\n            case 10000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 52) }\\n            case 100000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 53) }\\n            case 1000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 54) }\\n            case 10000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 55) }\\n            case 100000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 56) }\\n            case 1000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 57) }\\n            case 10000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 58) }\\n            case 100000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 59) }\\n            default {\\n                result := MAX_UD60x18\\n            }\\n        }\\n\\n        if (result == MAX_UD60x18) {\\n            // Do the fixed-point division inline to save gas. The denominator is log2(10).\\n            unchecked {\\n                result = (log2(x) * SCALE) / 3_321928094887362347;\\n            }\\n        }\\n    }\\n\\n    /// @notice Calculates the binary logarithm of x.\\n    ///\\n    /// @dev Based on the iterative approximation algorithm.\\n    /// https://en.wikipedia.org/wiki/Binary_logarithm#Iterative_approximation\\n    ///\\n    /// Requirements:\\n    /// - x must be greater than or equal to SCALE, otherwise the result would be negative.\\n    ///\\n    /// Caveats:\\n    /// - The results are nor perfectly accurate to the last decimal, due to the lossy precision of the iterative approximation.\\n    ///\\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the binary logarithm.\\n    /// @return result The binary logarithm as an unsigned 60.18-decimal fixed-point number.\\n    function log2(uint256 x) internal pure returns (uint256 result) {\\n        if (x < SCALE) {\\n            revert PRBMathUD60x18__LogInputTooSmall(x);\\n        }\\n        unchecked {\\n            // Calculate the integer part of the logarithm and add it to the result and finally calculate y = x * 2^(-n).\\n            uint256 n = PRBMath.mostSignificantBit(x / SCALE);\\n\\n            // The integer part of the logarithm as an unsigned 60.18-decimal fixed-point number. The operation can't overflow\\n            // because n is maximum 255 and SCALE is 1e18.\\n            result = n * SCALE;\\n\\n            // This is y = x * 2^(-n).\\n            uint256 y = x >> n;\\n\\n            // If y = 1, the fractional part is zero.\\n            if (y == SCALE) {\\n                return result;\\n            }\\n\\n            // Calculate the fractional part via the iterative approximation.\\n            // The \\\"delta >>= 1\\\" part is equivalent to \\\"delta /= 2\\\", but shifting bits is faster.\\n            for (uint256 delta = HALF_SCALE; delta > 0; delta >>= 1) {\\n                y = (y * y) / SCALE;\\n\\n                // Is y^2 > 2 and so in the range [2,4)?\\n                if (y >= 2 * SCALE) {\\n                    // Add the 2^(-m) factor to the logarithm.\\n                    result += delta;\\n\\n                    // Corresponds to z/2 on Wikipedia.\\n                    y >>= 1;\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @notice Multiplies two unsigned 60.18-decimal fixed-point numbers together, returning a new unsigned 60.18-decimal\\n    /// fixed-point number.\\n    /// @dev See the documentation for the \\\"PRBMath.mulDivFixedPoint\\\" function.\\n    /// @param x The multiplicand as an unsigned 60.18-decimal fixed-point number.\\n    /// @param y The multiplier as an unsigned 60.18-decimal fixed-point number.\\n    /// @return result The product as an unsigned 60.18-decimal fixed-point number.\\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 result) {\\n        result = PRBMath.mulDivFixedPoint(x, y);\\n    }\\n\\n    /// @notice Returns PI as an unsigned 60.18-decimal fixed-point number.\\n    function pi() internal pure returns (uint256 result) {\\n        result = 3_141592653589793238;\\n    }\\n\\n    /// @notice Raises x to the power of y.\\n    ///\\n    /// @dev Based on the insight that x^y = 2^(log2(x) * y).\\n    ///\\n    /// Requirements:\\n    /// - All from \\\"exp2\\\", \\\"log2\\\" and \\\"mul\\\".\\n    ///\\n    /// Caveats:\\n    /// - All from \\\"exp2\\\", \\\"log2\\\" and \\\"mul\\\".\\n    /// - Assumes 0^0 is 1.\\n    ///\\n    /// @param x Number to raise to given power y, as an unsigned 60.18-decimal fixed-point number.\\n    /// @param y Exponent to raise x to, as an unsigned 60.18-decimal fixed-point number.\\n    /// @return result x raised to power y, as an unsigned 60.18-decimal fixed-point number.\\n    function pow(uint256 x, uint256 y) internal pure returns (uint256 result) {\\n        if (x == 0) {\\n            result = y == 0 ? SCALE : uint256(0);\\n        } else {\\n            result = exp2(mul(log2(x), y));\\n        }\\n    }\\n\\n    /// @notice Raises x (unsigned 60.18-decimal fixed-point number) to the power of y (basic unsigned integer) using the\\n    /// famous algorithm \\\"exponentiation by squaring\\\".\\n    ///\\n    /// @dev See https://en.wikipedia.org/wiki/Exponentiation_by_squaring\\n    ///\\n    /// Requirements:\\n    /// - The result must fit within MAX_UD60x18.\\n    ///\\n    /// Caveats:\\n    /// - All from \\\"mul\\\".\\n    /// - Assumes 0^0 is 1.\\n    ///\\n    /// @param x The base as an unsigned 60.18-decimal fixed-point number.\\n    /// @param y The exponent as an uint256.\\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\\n    function powu(uint256 x, uint256 y) internal pure returns (uint256 result) {\\n        // Calculate the first iteration of the loop in advance.\\n        result = y & 1 > 0 ? x : SCALE;\\n\\n        // Equivalent to \\\"for(y /= 2; y > 0; y /= 2)\\\" but faster.\\n        for (y >>= 1; y > 0; y >>= 1) {\\n            x = PRBMath.mulDivFixedPoint(x, x);\\n\\n            // Equivalent to \\\"y % 2 == 1\\\" but faster.\\n            if (y & 1 > 0) {\\n                result = PRBMath.mulDivFixedPoint(result, x);\\n            }\\n        }\\n    }\\n\\n    /// @notice Returns 1 as an unsigned 60.18-decimal fixed-point number.\\n    function scale() internal pure returns (uint256 result) {\\n        result = SCALE;\\n    }\\n\\n    /// @notice Calculates the square root of x, rounding down.\\n    /// @dev Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\\n    ///\\n    /// Requirements:\\n    /// - x must be less than MAX_UD60x18 / SCALE.\\n    ///\\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the square root.\\n    /// @return result The result as an unsigned 60.18-decimal fixed-point .\\n    function sqrt(uint256 x) internal pure returns (uint256 result) {\\n        unchecked {\\n            if (x > MAX_UD60x18 / SCALE) {\\n                revert PRBMathUD60x18__SqrtOverflow(x);\\n            }\\n            // Multiply x by the SCALE to account for the factor of SCALE that is picked up when multiplying two unsigned\\n            // 60.18-decimal fixed-point numbers together (in this case, those two numbers are both the square root).\\n            result = PRBMath.sqrt(x * SCALE);\\n        }\\n    }\\n\\n    /// @notice Converts a unsigned 60.18-decimal fixed-point number to basic integer form, rounding down in the process.\\n    /// @param x The unsigned 60.18-decimal fixed-point number to convert.\\n    /// @return result The same number in basic integer form.\\n    function toUint(uint256 x) internal pure returns (uint256 result) {\\n        unchecked {\\n            result = x / SCALE;\\n        }\\n    }\\n}\",\"keccak256\":\"0xf642499f1cbe1d382342af37d2850edc34d2348d4343e4abfd25148a34d03575\",\"license\":\"Unlicense\"},\"contracts/stablecoin/IMarketManager.sol\":{\"content\":\"pragma solidity ^0.8.4;\\n\\nimport \\\"./owned.sol\\\";\\nimport \\\"../turbo/AMMFactory.sol\\\"; \\nimport \\\"./reputationtoken.sol\\\"; \\nimport \\\"../bonds/Ibondingcurve.sol\\\"; \\n\\n\\ninterface IMarketManager {\\n\\t/**\\n\\t@dev initializes bonding curve for given market.\\n\\t */\\n\\tfunction initiate_bonding_curve(uint256 marketId) \\n\\t\\texternal;\\n\\n\\n\\tfunction setMarketRestrictionData(\\t\\n\\t\\tbool _duringMarketAssessment,\\n\\t\\tbool _onlyReputable,  \\n\\t\\tuint256 marketId,\\n\\t\\tuint256 min_rep_score)\\n\\t\\texternal; \\n\\n \\tfunction deactivateMarket(uint256 marketId) external; \\n\\n\\tfunction setAssessmentPhase(\\n\\t\\tuint256 marketId, \\n\\t\\tbool _duringMarketAssessment,\\n\\t\\tbool _onlyReputable) \\n\\t\\texternal;\\n\\t\\n\\n\\tfunction canBuy(\\n\\t\\taddress trader,\\n\\t\\taddress ammFactoryAddress, \\n\\t\\taddress marketFactoryAddress, \\n\\t\\tuint256 amount,//this is in DS with decimals \\n\\t\\tuint256 marketId) external view returns(bool);\\n\\n\\n\\n\\tfunction buy(\\n\\t\\tAMMFactory ammFactory, \\n\\t\\tAbstractMarketFactoryV3 marketFactory, \\n        uint256 _marketId,\\n        uint256 _collateralIn\\n        ) external returns (uint256);\\n\\n\\tfunction sell(\\n\\t\\tAMMFactory ammFactory, \\n\\t\\tAbstractMarketFactoryV3 marketFactory, \\n        uint256 _marketId,\\n        uint256 _zcb_amount_in\\n        ) external returns (uint256); \\n\\t\\n\\n\\tfunction update_redemption_price(\\n\\t\\tuint256 marketId,\\n\\t\\tbool atLoss, \\n\\t\\tuint256 extra_gain, \\n\\t\\tuint256 principal_loss) \\n\\t\\texternal;\\n\\n\\tfunction handle_maturity(\\n\\t\\tuint256 marketId, \\n\\t\\tbool atLoss, \\n\\t\\tuint256 principal_loss) \\n\\t\\texternal; \\n\\n\\tfunction denyMarket(\\n\\t\\tuint256 marketId)\\n\\t\\texternal; \\n\\n\\tfunction borrow_with_collateral(\\n\\t\\tuint256 _marketId, \\n\\t\\tuint256 requested_zcb, \\n\\t\\taddress trader\\n\\t\\t) external; \\n\\n\\tfunction repay_for_collateral(\\n\\t\\tuint256 _marketId, \\n\\t\\tuint256 repaying_zcb, \\n\\t\\taddress trader\\n\\t\\t) external;\\n}\\n\\n\",\"keccak256\":\"0xfa4f9c36c9f58f05f4230d33a21033953d95015ae25c78109dc7713f6d1bec85\"},\"contracts/stablecoin/IReputationNFT.sol\":{\"content\":\"pragma solidity ^0.8.4; \\n\\n\\ninterface IReputationNFT {\\n  \\n}\",\"keccak256\":\"0x9863219b7290ad879cbc4b32affe30e8f36ae21b3443669e2fc449657cf4b6bf\"},\"contracts/stablecoin/controller.sol\":{\"content\":\"pragma solidity ^0.8.4;\\nimport \\\"../turbo/TrustedMarketFactoryV3.sol\\\";\\nimport {MarketManager} from \\\"./marketmanager.sol\\\";\\nimport {ReputationNFT} from \\\"./reputationtoken.sol\\\";\\nimport {OwnedERC20} from \\\"../turbo/OwnedShareToken.sol\\\";\\nimport {LinearBondingCurve} from \\\"../bonds/LinearBondingCurve.sol\\\";\\nimport {BondingCurve} from \\\"../bonds/bondingcurve.sol\\\";\\nimport {LinearBondingCurveFactory} from \\\"../bonds/LinearBondingCurveFactory.sol\\\"; \\nimport {Vault} from \\\"../vaults/vault.sol\\\";\\nimport {Instrument} from \\\"../vaults/instrument.sol\\\";\\nimport {Strings} from \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\nimport {FixedPointMathLib} from \\\"solmate/src/utils/FixedPointMathLib.sol\\\";\\n\\nimport \\\"hardhat/console.sol\\\";\\nimport \\\"@interep/contracts/IInterep.sol\\\";\\n\\n\\n// Controller contract responsible for providing initial liquidity to the\\n// borrower cds market, collect winnings when default, and burn the corresponding DS\\ncontract Controller {\\n  using SafeMath for uint256;\\n  using FixedPointMathLib for uint256;\\n\\n  struct MarketData {\\n      address instrument_address;\\n      address recipient;\\n  }\\n\\n  event MarketInitiated(uint256 marketId, address recipient);\\n\\n  mapping(address => bool) public  validators; \\n  mapping(address => bool) public  verified;\\n  mapping(uint256 => MarketData) public market_data; // id => recipient\\n  mapping(address=> uint256) public ad_to_id; //utilizer address to marketId, only one market ID per address at given moment, can generalize later\\n\\n  address[] validators_array;\\n\\n  address creator_address;\\n\\n  IInterep interep;\\n  TrustedMarketFactoryV3 marketFactory;\\n  MarketManager marketManager;\\n  Vault public vault;\\n  ReputationNFT repNFT; \\n  LinearBondingCurveFactory linearBCFactory; \\n\\n  uint256 constant TWITTER_UNRATED_GROUP_ID = 16106950158033643226105886729341667676405340206102109927577753383156646348711;\\n  bytes32 constant private signal = bytes32(\\\"twitter-unrated\\\");\\n  uint256 insurance_constant = 5e5; //1 is 1e6, also needs to be able to be changed \\n  uint256 constant PRICE_PRECISION = 1e18; \\n  \\n  // Bond Curve Name\\n  string constant baseName = \\\"Bond\\\";\\n  string constant baseSymbol = \\\"B\\\";\\n  string constant s_baseName = \\\"sBond\\\";\\n  string constant s_baseSymbol = \\\"sB\\\";\\n  uint256 nonce = 0;\\n\\n  /* ========== MODIFIERS ========== */\\n  modifier onlyValidator() {\\n      require(validators[msg.sender] == true || msg.sender == creator_address, \\\"Only Validators can call this function\\\");\\n      _;\\n  }\\n\\n  modifier onlyOwner() {\\n      require(msg.sender == creator_address, \\\"Only Owner can call this function\\\");\\n      _;\\n  }\\n  modifier onlyManager() {\\n      require(msg.sender == address(marketManager) || msg.sender == creator_address, \\\"Only Manager can call this function\\\");\\n      _;\\n  }\\n\\n  constructor (\\n      address _creator_address,\\n      address _interep_address\\n  ) {\\n      creator_address = _creator_address;\\n      interep = IInterep(_interep_address);\\n\\n      linearBCFactory = new LinearBondingCurveFactory(); \\n  }\\n\\n  /*----Setup Functions----*/\\n\\n  function setMarketManager(address _marketManager) public onlyOwner {\\n      require(_marketManager != address(0));\\n      marketManager = MarketManager(_marketManager);\\n  }\\n\\n  function setVault(address _vault) public onlyOwner {\\n      require(_vault != address(0));\\n      vault = Vault(_vault);\\n  }\\n\\n  function setMarketFactory(address _marketFactory) public onlyOwner {\\n      require(_marketFactory != address(0));\\n      marketFactory = TrustedMarketFactoryV3(_marketFactory);\\n  }\\n\\n  function setReputationNFT(address NFT_address) public onlyOwner{\\n      repNFT = ReputationNFT(NFT_address); \\n  }\\n\\n\\n  /// @notice curveparams for linear bonds \\n  /// b is a initial price parameter we choose i.e 0.9, a is a function of b\\n  /// a = (1-b) **2 / 2* interest \\n  /// @dev both principal/interest should be in price precision\\n  /// @param interest is amount of interest in dollars, not percentage,\\n  /// returns a,b is both in 18 price_precision\\n  function getCurveParams(uint256 principal, uint256 interest) internal view returns (uint256, uint256){\\n\\n    uint256 price_precision = 1e18; \\n    uint256 interest_ = interest * (10**12); \\n    uint256 principal_ = principal * (10**12); \\n\\n    uint256 b = (2*principal_).divWadDown(principal_+interest_) - price_precision; \\n    uint256 a = (price_precision -b).divWadDown(principal_+interest_); \\n\\n    return (a,b);\\n\\n\\n}\\n\\n\\n\\n  function verifyAddress(\\n      uint256 nullifier_hash, \\n      uint256 external_nullifier,\\n      uint256[8] calldata proof\\n  ) external  {\\n      require(!verified[msg.sender], \\\"address already verified\\\");\\n      interep.verifyProof(TWITTER_UNRATED_GROUP_ID, signal, nullifier_hash, external_nullifier, proof);\\n      verified[msg.sender] = true;\\n  }\\n\\n  function testVerifyAddress() external {\\n    verified[msg.sender] = true;\\n  }\\n\\n\\n  function mintRepNFT(\\n    address NFT_address,\\n    address trader\\n    ) external  {\\n    ReputationNFT(NFT_address).mint(msg.sender);\\n  }\\n  //Validator should be added for each borrower\\n  function addValidator(address validator_address) external  {\\n    require(validator_address != address(0), \\\"Zero address detected\\\");\\n    require(validators[validator_address] == false, \\\"Address already exists\\\");\\n\\n    validators[validator_address] = true; \\n    validators_array.push(validator_address);\\n}\\n\\n\\n\\n  function createZCBs(\\n    uint256 a,\\n    uint256 b\\n    ) internal returns(OwnedERC20[] memory) {\\n\\n    string memory name = string(abi.encodePacked(baseName, \\\"-\\\", Strings.toString(nonce)));\\n    string memory symbol = string(abi.encodePacked(baseSymbol, Strings.toString(nonce)));\\n    string memory s_name = string(abi.encodePacked(s_baseName, \\\"-\\\", Strings.toString(nonce)));\\n    string memory s_symbol = string(abi.encodePacked(s_baseSymbol, Strings.toString(nonce)));\\n    nonce++;\\n\\n    uint256 marketId = marketFactory.marketCount(); \\n    OwnedERC20 longzcb = linearBCFactory.newLongZCB(name, symbol, address(marketManager), address(vault), a,b); \\n    OwnedERC20 shortzcb = linearBCFactory.newShortZCB(s_name, s_symbol, address(marketManager), address(vault), address(longzcb), marketId); \\n\\n    OwnedERC20[] memory zcb_tokens = new OwnedERC20[](2);\\n    zcb_tokens[0] = longzcb;\\n    zcb_tokens[1] = shortzcb; \\n\\n    return zcb_tokens;\\n  }\\n\\n  /**\\n   @dev initiates market, called by frontend loan proposal or instrument form submit button.\\n   @param recipient is the \\n   @dev a and b must be 60.18 format\\n   */\\n\\n  function initiateMarket(\\n      address recipient,\\n      Vault.InstrumentData memory instrumentData // marketId should be set to zero, no way of knowing.\\n  ) external  {\\n\\n    (uint256 a, uint256 b) = getCurveParams(instrumentData.principal, instrumentData.expectedYield);\\n    uint256 marketId = marketFactory.marketCount(); \\n\\n    OwnedERC20[] memory zcb_tokens = createZCBs(a,b); \\n\\n    require(marketFactory.createZCBMarket(\\n        address(this), // controller is the settlement address\\n        instrumentData.description,\\n        zcb_tokens) == marketId, \\\"MarketID err\\\"); \\n\\n\\n    ad_to_id[recipient] = marketId; \\n    instrumentData.marketId = marketId;\\n\\n    vault.addProposal(\\n        instrumentData\\n    );\\n\\n    market_data[marketId] = MarketData(address(instrumentData.Instrument_address), recipient);\\n    // marketManager.setAssessmentPhase(marketId, true, true);  \\n    marketManager.setMarketPhase(marketId, true, true, 0, 1000 * (10**6));  // need to set min rep score here as well.e\\n    marketManager.add_short_zcb( marketId, address(zcb_tokens[1])); \\n  \\n    emit MarketInitiated(marketId, recipient);\\n}\\n\\n  \\n \\n  /**\\n  @notice main function called at maturity OR premature resolve of instrument(from early default)\\n  @dev triggered by resolve Loan \\n  @param atLoss: when actual returns lower than expected \\n  @param principal_loss: if total returned less than principal, principal-total returned, this is total loss\\n\\n  When market finishes at maturity, need to \\n  1. burn all vault tokens in bc \\n  2. mint all incoming redeeming vault tokens \\n  */\\nfunction resolveMarket(\\n    uint256 marketId,\\n    bool atLoss,\\n    uint256 extra_gain,\\n    uint256 principal_loss\\n) external  {\\n    marketManager.update_redemption_price(marketId, atLoss, extra_gain, principal_loss); \\n    marketManager.handle_maturity(marketId, atLoss, principal_loss); \\n    marketManager.deactivateMarket(marketId, atLoss);\\n    \\n    //Burn all vault tokens in BC\\n    address bc_ad = getZCB_ad( marketId); \\n    uint256 bc_vault_balance = vault.balanceOf(bc_ad); \\n    vault.controller_burn(bc_vault_balance,bc_ad); \\n\\n    uint256 winning_outcome = 0; //TODO  \\n    marketFactory.trustedResolveMarket(marketId, winning_outcome);\\n  }\\n\\n\\n  /// @notice called by the validator when market conditions are met\\n  function approveMarket(\\n      uint256 marketId\\n  ) external onlyValidator {\\n    if (!marketManager.marketCondition(marketId)) revert(\\\"Market Condition Not met\\\");    \\n    require(!marketManager.onlyReputable(marketId), \\\"Market Phase err\\\"); \\n    \\n    marketManager.approveMarket(marketId);\\n    marketManager.setUpperBound(marketId, 1000000*10**6); // need to get upper bound \\n    \\n    trustInstrument(marketId); \\n\\n    // Deposit to the instrument contract\\n    uint256 principal = vault.fetchInstrumentData(marketId).principal; \\n    //maybe this should be separated to prevent attacks \\n    \\n    vault.depositIntoInstrument(Instrument(market_data[marketId].instrument_address), principal );\\n    vault.setMaturityDate(Instrument(market_data[marketId].instrument_address));\\n    vault.onMarketApproval(marketId);\\n  }\\n  /*\\n  Market is denied by validator or automatically if conditions are not met \\n  */\\n  function denyMarket(\\n      uint256 marketId\\n  ) external  onlyValidator {\\n    marketManager.denyMarket(marketId);\\n      //TrustedMarketFactoryV3 marketFactory = TrustedMarketFactoryV3(marketInfo.marketFactoryAddress);\\n    \\n    uint256 winning_outcome = 0; //TODO  \\n    \\n    marketFactory.trustedResolveMarket(marketId, winning_outcome);\\n    \\n    vault.denyInstrument(marketId);\\n  }\\n \\n\\n\\n  function trustInstrument(uint256 marketId) private  {\\n    vault.trustInstrument(Instrument(market_data[marketId].instrument_address));\\n  }\\n\\n  function redeem_mint(uint256 amount, address to) external onlyManager{\\n    vault.controller_mint(amount,to); \\n  }\\n\\n  /* --------VIEW FUNCTIONS---------  */\\n  function getMarketId(address recipient) public view returns(uint256){\\n    return ad_to_id[recipient];\\n  }\\n\\n  function getZCB(uint256 marketId) public view returns (OwnedERC20){\\n    AbstractMarketFactoryV3.Market memory market = marketFactory.getZCBMarket(marketId);\\n    return OwnedERC20(market.shareTokens[0]);\\n  }\\n  function getZCB_ad(uint256 marketId) public view returns (address){\\n    AbstractMarketFactoryV3.Market memory market = marketFactory.getZCBMarket(marketId);\\n    return address(OwnedERC20(market.shareTokens[0]));\\n  }\\n  function getshortZCB_ad(uint256 marketId) public view returns(address){\\n    AbstractMarketFactoryV3.Market memory market = marketFactory.getZCBMarket(marketId);\\n    return address(OwnedERC20(market.shareTokens[1]));\\n  }\\n\\n  function canBeApproved(uint256 marketId) public view returns (bool) {\\n      //TODO\\n    return true;\\n  }\\n\\n  function isVerified(address addr) view public returns (bool) {\\n    return verified[addr];\\n  }\\n}\\n\\n\",\"keccak256\":\"0x6b776223843ae834c5a842d8a790210baab773406c3b2e5afafb04d2dd063f56\"},\"contracts/stablecoin/marketmanager.sol\":{\"content\":\"pragma solidity ^0.8.4;\\n\\nimport \\\"./owned.sol\\\";\\nimport \\\"../turbo/AMMFactory.sol\\\"; \\nimport \\\"./reputationtoken.sol\\\"; \\nimport {BondingCurve} from \\\"../bonds/bondingcurve.sol\\\";\\nimport {Controller} from \\\"./controller.sol\\\";\\nimport {OwnedERC20} from \\\"../turbo/OwnedShareToken.sol\\\";\\nimport \\\"./IMarketManager.sol\\\";\\nimport \\\"hardhat/console.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"../prb/PRBMathUD60x18.sol\\\";\\nimport {LinearShortZCB} from \\\"../bonds/LinearShortZCB.sol\\\"; \\n\\n\\ncontract MarketManager is Owned {\\n\\t/*Wrapper contract for bondingcurve markets, trades are restricted/funneled through here\\n\\t\\tTypes of restrictions are \\n\\t\\t1) Being verified \\n\\t\\t2) reputation to buy early \\n\\n\\t\\t4) Restriction to quantity \\n\\n\\tMisc. \\n\\t\\ta) To avoid securitization, enforce selling Fee  \\n\\t*/\\n\\tusing PRBMathUD60x18 for uint256;\\n\\n    uint256 private constant PRICE_PRECISION = 1e6; \\n\\n\\tReputationNFT rep;\\n  Controller controller;\\n\\n  \\tmapping(uint256=>uint256) private redemption_prices; //redemption price for each market, set when market resolves \\n  \\tmapping(uint256=>mapping(address=>uint256)) private assessment_collaterals;  //marketId-> trader->collateralIn\\n  \\tmapping(uint256=>mapping(address=>uint256)) private assessment_prices; \\n  \\tmapping(uint256=>mapping(address=>bool)) private assessment_trader; \\n\\tmapping(uint256=> MarketPhaseData) public restriction_data; // market ID => restriction data\\n\\tmapping(uint256=> uint256) collateral_pot; // marketID => total collateral recieved (? isn't this redundant bc bonding curves fundsperBonds)\\n\\tmapping(uint256=> CDP) private debt_pools; // marketID => debt info\\n\\n\\tstruct CDP{\\n\\t\\tmapping(address=>address) collateral_address; \\n\\t\\tmapping(address=>uint256) collateral_amount;\\n\\t\\tmapping(address=>uint256) borrowed_amount; \\n\\t\\tuint256 total_debt; \\n\\t\\tuint256 total_collateral; //only usdc \\n\\t}\\n\\n\\tstruct MarketPhaseData {\\n\\t\\tbool duringAssessment;\\n\\t\\tbool onlyReputable;\\n\\t\\tbool resolved;\\n\\t\\tuint256 min_rep_score;\\n\\t\\tbool alive;\\n\\t\\tbool atLoss;\\n\\t\\tuint256 base_budget;\\n\\t}\\n\\n\\tuint256 private INSURANCE_CONSTANT = 5 * 10**5; // 0.5 for DS decimal format.\\n\\tuint256 private REPUTATION_CONSTANT = 3 * 10**5;\\n\\t\\n    modifier onlyController(){\\n        require(address(controller) == msg.sender || msg.sender == owner || msg.sender == address(this), \\\"is not controller\\\"); \\n        _;\\n    }\\n\\n\\tconstructor(\\n\\t\\taddress _creator_address,\\n\\t\\taddress reputationNFTaddress,  \\n\\t\\taddress _controllerAddress\\n\\t) Owned(_creator_address){\\n\\t\\trep = ReputationNFT(reputationNFTaddress);\\n\\t\\tcontroller = Controller(_controllerAddress); \\n\\t}\\n\\n\\t/*----Phase Functions----*/\\n\\n\\t/*\\n\\tcalled on market initialization by controller\\n\\t*/\\n\\tfunction setMarketPhase(\\n\\t\\tuint256 marketId, \\n\\t\\tbool duringAssessment,\\n\\t\\tbool _onlyReputable,\\n\\t\\tuint256 min_rep_score,\\n\\t\\tuint256 base_budget\\n\\t) external  onlyController {\\n\\t\\tMarketPhaseData storage data = restriction_data[marketId]; \\n\\t\\tdata.onlyReputable = _onlyReputable; \\n\\t\\tdata.duringAssessment = duringAssessment;\\n\\t\\tdata.min_rep_score = min_rep_score;\\n\\t\\tdata.base_budget = base_budget;\\n\\t\\tdata.alive = true;\\n\\t}\\n\\n\\t/**\\n\\t called by this when onlyRep => false.\\n\\t */\\n\\tfunction setReputationPhase(\\n\\t\\tuint256 marketId,\\n\\t\\tbool _onlyReputable\\n\\t) internal {\\n\\t\\trequire(restriction_data[marketId].alive, \\\"market must be alive\\\");\\n\\t\\trestriction_data[marketId].onlyReputable = _onlyReputable;\\n\\t}\\n\\n\\t/**\\n\\t called by controller\\n\\t */\\n\\tfunction approveMarket(uint256 marketId) external onlyController {\\n\\t\\trequire(restriction_data[marketId].alive);\\n\\t\\trequire(restriction_data[marketId].duringAssessment);\\n\\n\\t\\trestriction_data[marketId].duringAssessment = false;\\t\\t\\n\\t}\\n\\n\\t/* \\n\\tCalled when market should end, a) when denied b) when maturity \\n\\t*/\\n\\tfunction deactivateMarket(uint256 marketId, bool atLoss) external  onlyController{\\n\\t\\trestriction_data[marketId].resolved = true; \\n\\t\\trestriction_data[marketId].atLoss = atLoss; \\n\\t\\trestriction_data[marketId].alive = false; \\n\\n\\t}\\n\\n\\t/*---View Functions---*/\\n\\n\\t/* \\n\\tReturns Minimal reputation score to participate in the onlyReputation phase\\n\\tTODO\\n\\t*/\\n\\tfunction getMinRepScore(uint256 marketId) internal view returns(uint256){\\n\\t\\treturn restriction_data[marketId].min_rep_score;\\n\\t}\\n\\n\\t/* Conditions */\\n \\t\\n\\t/**\\n\\t @dev verification of trader initializes reputation score at 0, to gain reputation need to participate in markets.\\n\\t */\\n\\tfunction isVerified(address trader) public view returns(bool){\\n\\t\\treturn (controller.isVerified(trader) || trader == owner);\\n\\t\\t//return (rep.balanceOf(trader) >= 1 || trader == owner); \\n\\t}\\n\\n\\n\\tfunction isReputable(address trader, uint256 marketId) public view returns(bool){\\n\\t\\treturn (restriction_data[marketId].min_rep_score <= rep.getReputationScore(trader) || trader == owner); \\n\\t}\\n\\n\\t/*\\n\\tReturns true if during risk assessment phase\\n\\t*/\\n\\tfunction duringMarketAssessment(\\n\\t\\tuint256 marketId) public view returns(bool){\\n\\t\\treturn restriction_data[marketId].duringAssessment; \\n\\t}\\n\\n\\t/*\\n\\tReturns true when market only allows reputable traders\\n\\t*/\\n\\tfunction onlyReputable(\\n\\t\\tuint256 marketId\\n\\t\\t) public view returns(bool){\\n\\t\\treturn restriction_data[marketId].onlyReputable; \\n\\n\\t}\\n\\n\\tfunction isMarketApproved(uint256 marketId) public view returns(bool){\\n\\t\\treturn(!restriction_data[marketId].duringAssessment && restriction_data[marketId].alive); \\n\\t\\t\\n\\t}\\n\\n\\t//TODO Need to find out if the given market has enough (liquidity-required liq)\\n\\tfunction exposureSet(address trader, address ammFactoryAddress, address marketId) internal view returns(bool){\\n\\t\\treturn true; \\n\\t}\\n\\n\\tfunction marketActive(uint256 marketId) public view returns(bool){\\n\\t\\treturn restriction_data[marketId].alive; \\n\\t}\\n\\n\\t/// @notice returns true if amount bought is greater than the insurance threshold\\n\\tfunction marketCondition(uint256 marketId) public view returns(bool){\\n\\t\\tuint256 principal = controller.vault().fetchInstrumentData(marketId).principal;\\n\\t\\tuint256 total_bought = BondingCurve(address(controller.getZCB(marketId))).getTotalCollateral();\\n\\t\\treturn (total_bought >= (principal * INSURANCE_CONSTANT)/PRICE_PRECISION); \\n\\t}\\n\\n\\n\\tfunction getDebtPosition(address trader, uint256 marketId) public view returns(uint256, uint256){\\n\\t\\tCDP storage cdp = debt_pools[marketId];\\n\\t\\treturn (cdp.collateral_amount[trader], cdp.borrowed_amount[trader]);\\n\\t}\\n\\n\\t/// @notice get trade budget = f(reputation)\\n\\t/// sqrt for now \\n\\tfunction getTraderBudget(uint256 marketId, address trader) public view returns(uint256){\\n\\t\\tuint256 repscore = rep.getReputationScore(trader);\\t\\n\\t\\treturn restriction_data[marketId].base_budget; // sqrt(repscore * 10**6), since w/ decimals.\\n\\t}\\n \\t\\n \\t/// @notice computes the price for ZCB one needs to short at to completely\\n \\t/// hedge for the case of maximal loss, function of principal and interest\\n\\tfunction getHedgePrice(uint256 marketId) public view returns(uint256){\\n\\t\\tuint256 principal = controller.vault().fetchInstrumentData(marketId).principal; \\n\\t\\tuint256 yield = controller.vault().fetchInstrumentData(marketId).expectedYield; \\n\\n\\t\\tuint256 den = (principal * (PRICE_PRECISION - INSURANCE_CONSTANT))/PRICE_PRECISION; \\n\\t\\treturn PRICE_PRECISION -  (yield*PRICE_PRECISION)/den;\\n\\n\\t}\\n\\n\\t/// @notice computes maximum amount of quantity that trader can short while being hedged\\n\\t/// such that when he loses his loss will be offset by his gains  \\n\\tfunction getHedgeQuantity(address trader, uint256 marketId) public view returns(uint256){\\n\\t\\tuint256 principal = controller.vault().fetchInstrumentData(marketId).principal; \\n\\t\\tuint256 holdings =  controller.vault().balanceOf(trader);\\n\\t\\tuint256 marketCap = controller.vault().totalSupply(); \\n\\t\\tuint num = (principal * (PRICE_PRECISION - INSURANCE_CONSTANT)/PRICE_PRECISION) * holdings; \\n\\t\\treturn num/marketCap; \\n\\t}\\t\\n\\n\\t\\n\\tfunction canBuy(\\n\\t\\taddress trader,\\n\\t\\tuint256 amount, //this is in DS with decimals.\\n\\t\\tuint256 marketId\\n\\t) public returns(bool, uint) {\\n\\t\\trequire(marketActive(marketId), \\\"Market Not Active\\\"); // this is not correct since marketDenied set to false by default.\\n\\t\\tbool _duringMarketAssessment = duringMarketAssessment(marketId);\\n\\t\\tbool _onlyReputable =  onlyReputable(marketId);\\n\\n\\t\\tif (_duringMarketAssessment){\\n\\t\\t\\tif (!isVerified(trader) || !(getTraderBudget(marketId, trader)>= amount)) return (false, 0); \\n\\t\\n\\t\\t}\\n\\n  \\t\\t//During the early risk assessment phase only reputable can buy \\n\\t\\tif (_onlyReputable){\\n\\t\\t\\trequire(_duringMarketAssessment, \\\"Market needs to be in assessment phase\\\"); \\n\\t\\t\\tif (!isReputable(trader, marketId)){ \\n\\t\\t\\t\\tconsole.log('notreputable'); \\n\\t\\t\\t\\treturn (false, 1); \\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t//If after assessment there is a set buy threshold, people can't buy above this threshold\\n\\t\\tif (!_duringMarketAssessment){\\n\\t\\t\\n\\t\\t\\tBondingCurve zcb = BondingCurve(address(controller.getZCB(marketId)));\\n\\t\\t\\tuint256 tokens_bought = zcb.calculatePurchaseReturn(amount);\\n\\t\\t\\tuint256 price_after_trade = zcb.calculateExpectedPrice(tokens_bought);\\n\\t\\t\\tuint256 price_upper_bound = zcb.getUpperBound();\\n\\t\\t\\trequire(price_upper_bound > 0, \\\"Restrictions need to be set\\\"); \\n\\t\\t\\tif (price_upper_bound > price_after_trade) return (false, 2); \\n\\t\\t}\\n\\n\\t\\treturn (true, 0); \\n\\t\\t// require(_duringMarketAssessment, \\\"Sells not allowed during assessments\\\");\\n\\t\\t// require(exposureset(trader, ammFactoryAddress, marketId), \\\"Not enough liquidity\\\");\\n\\n\\t}\\n\\n\\n\\t/// @notice amount is greater than \\n\\tfunction canSell(\\n\\t\\taddress trader,\\n\\t\\tuint256 amount, \\n\\t\\tuint256 marketId\\n\\t) internal view returns(bool) {\\n\\t\\trequire(marketActive(marketId), \\\"Market Not Active\\\"); \\n\\n\\t\\t// bool _duringMarketAssessment = duringMarketAssessment( marketId);\\n\\t\\t// if (_duringMarketAssessment){\\n\\t\\t// \\trequire(isVerified(trader), \\\"User Not Verified\\\");\\n\\t\\t// }\\n\\t\\treturn true; \\n\\t}\\n\\n\\t/**\\n\\t called by controller on approveMarket, preset upper bound for assessment phase is 1.\\n\\t */\\n\\tfunction setUpperBound(uint256 marketId, uint256 upper_bound) external onlyController {\\n\\t\\tBondingCurve zcb = BondingCurve(address(controller.getZCB(marketId)));\\n\\t\\tzcb.setUpperBound(upper_bound);\\n\\t}\\n\\t\\n\\n\\t/// @notice During assessment phase, need to log the trader's \\n\\t/// total collateral when he bought zcb. Trader can only redeem collateral in \\n\\t/// when market is not approved \\n\\t/// @param priceOut is the price of the zcb after the trader made his trade\\n\\tfunction log_assessment_trade(\\n\\t\\tuint256 marketId, \\n\\t\\taddress trader, \\n\\t\\tuint256 amountOut, \\n\\t\\tuint256 collateralIn,\\n\\t\\tuint256 priceOut)\\n\\t\\tinternal \\n\\t{\\t\\n\\t\\tassessment_trader[marketId][trader] = true; \\n\\t\\tassessment_collaterals[marketId][trader] = collateralIn;\\n\\t\\tassessment_prices[marketId][trader] = priceOut; \\n\\n\\t}\\n\\n\\t/* \\n\\tAfter market is denied, redeem every zcb trader has for his collateral \\n\\t*/\\n\\tfunction redeemPostAssessment(\\n\\t\\tuint256 marketId, \\n\\t\\taddress trader \\n\\t) public {\\n\\t\\trequire(restriction_data[marketId].resolved, \\\"Market Still During Assessment\\\");\\n\\t\\tuint256 collateral_amount = assessment_collaterals[marketId][trader]; \\n\\t\\tBondingCurve zcb = BondingCurve(address(controller.getZCB(marketId)));\\n\\t\\tzcb.redeemPostAssessment(trader, collateral_amount); \\n\\t}\\n\\n\\t/// @notice denies market from validator \\n\\tfunction denyMarket(\\n\\t\\tuint256 marketId\\n\\t) external  onlyController {\\n\\t\\trequire(marketActive(marketId), \\\"Market Not Active\\\"); \\n\\t\\trequire(restriction_data[marketId].duringAssessment, \\\"Not in assessment\\\"); \\n\\t\\tMarketPhaseData storage data = restriction_data[marketId]; \\n\\t\\tdata.resolved = true; \\n\\t\\tdata.duringAssessment = false;\\n\\t}\\n\\n\\n\\n\\tfunction buy(\\n        uint256 _marketId,\\n        uint256 _collateralIn\\n    ) external  returns (uint256){\\n\\t\\trequire(!restriction_data[_marketId].resolved, \\\"must not be resolved\\\");\\n\\t\\t(bool canbuy, uint256 error) = canBuy(msg.sender, _collateralIn, _marketId); \\n\\t\\trequire(canbuy,\\\"Trade Restricted\\\");\\n\\n\\n\\t\\tBondingCurve zcb = BondingCurve(address(controller.getZCB(_marketId))); // SOMEHOW GET ZCB\\n\\t\\tuint256 amountOut = zcb.trustedBuy(msg.sender, _collateralIn);\\n \\n \\t\\t//Need to log assessment trades for updating reputation scores or returning collateral\\n \\t\\t//when market denied \\n\\t\\tif (duringMarketAssessment(_marketId)){\\n\\t\\t\\tuint256 priceOut = zcb.calculateExpectedPrice(0); // 60.18 for some reason\\n\\t\\t\\tlog_assessment_trade(_marketId, msg.sender, amountOut, _collateralIn, priceOut);\\n\\n\\t\\t\\t//  keeps track of amount bought during reputation phase\\n\\t\\t\\t// and make transitions from onlyReputation true->false\\n\\t\\t\\tuint256 principal = controller.vault().fetchInstrumentData(_marketId).principal;\\n\\t\\t\\tuint256 total_bought = zcb.getTotalCollateral();\\n\\t\\t\\tconsole.log(\\\"total_bought\\\", total_bought);\\n\\n\\t\\t\\tif (onlyReputable(_marketId)){\\n\\n\\t\\t\\t\\tif (total_bought > (REPUTATION_CONSTANT * principal)/PRICE_PRECISION){\\n\\t\\t\\t\\t\\tsetReputationPhase(_marketId, false); \\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\treturn amountOut; \\n\\t}\\n\\n\\n\\tfunction sell(\\n        uint256 _marketId,\\n        uint256 _zcb_amount_in\\n    ) external  returns (uint256){\\n\\t\\trequire(!restriction_data[_marketId].resolved, \\\"must not be resolved\\\");\\n\\t\\trequire(canSell(msg.sender, \\n\\t\\t \\t_zcb_amount_in, \\n\\t\\t \\t_marketId),\\\"Trade Restricted\\\");\\n\\n\\t\\tBondingCurve zcb = BondingCurve(address(controller.getZCB(_marketId))); // SOMEHOW GET ZCB\\n\\t\\tuint256 amountOut = zcb.trustedSell(msg.sender, _zcb_amount_in);\\n\\n\\t\\treturn amountOut;\\n\\t}\\n\\n\\n\\n\\n\\n\\t///// Shorting logic  /////\\n\\tmapping(uint256=>mapping(address=>bool)) isShortZCB; //marketId-> address-> isshortZCB\\n\\tmapping(uint256=>address) shortZCBs; \\n\\tmapping(uint256=>mapping(address=>uint256) )assessment_shorts; \\n\\tfunction add_short_zcb(\\n\\t\\tuint256 marketId,\\n\\t\\taddress shortZCB_address\\n\\t\\t) external onlyController{\\n\\t\\tisShortZCB[marketId][shortZCB_address] = true;\\n\\t\\tshortZCBs[marketId] = shortZCB_address;\\n\\n\\n\\t}\\n\\n\\t/// @notice borrow for shorting from shortZCB, no collateral is posted here \\n\\t/// instead the collateral is stored in the shortZCB contract \\n\\tfunction borrow_for_shortZCB(\\n\\t\\tuint256 marketId, \\n\\t\\tuint256 requested_zcb \\n\\t\\t) external {\\n\\t\\trequire(isShortZCB[marketId][msg.sender], \\\"No\\\");\\n\\t\\tBondingCurve zcb = BondingCurve(address(controller.getZCB(marketId))); // SOMEHOW GET ZCB\\n\\n\\t\\tCDP storage cdp = debt_pools[marketId];\\n\\t\\tcdp.collateral_amount[msg.sender] += requested_zcb; //the collateral should be stored in the shortZCB\\n\\t\\tcdp.borrowed_amount[msg.sender] += requested_zcb;  \\n\\t\\tcdp.total_debt += requested_zcb; \\n\\t\\tcdp.total_collateral += requested_zcb; //only ds \\n\\t\\tcollateral_pot[marketId] += requested_zcb; //Total ds collateral \\n\\n\\t\\tzcb.trustedMint(msg.sender, requested_zcb); \\n\\n\\t}\\n\\n\\tfunction sellShort(\\n\\t\\tuint256 marketId, \\n\\t\\tuint256 collateralIn\\n\\n\\t\\t) external {\\n\\t\\t//TODO do can sell \\n\\t\\tLinearShortZCB(shortZCBs[marketId]).trustedShort(msg.sender, collateralIn); \\n\\t\\tif (duringMarketAssessment(marketId)){\\n\\t\\t\\tlog_assessment_shorts(marketId, msg.sender, collateralIn); \\n\\t\\t}\\n\\t}\\n\\n\\tfunction log_assessment_shorts(uint256 marketId, address trader, uint256 collateralIn) internal {\\n\\t\\tassessment_shorts[marketId][trader] += collateralIn; \\n\\t}\\n\\n\\t/// @notice called when market is denied \\n\\tfunction shortRedeemDeniedMarket(uint256 marketId, address trader) public {\\n\\t\\t// require(restriction_data[marketId].marketDenied, \\\"Market Still During Assessment\\\");\\n\\t\\tLinearShortZCB shortZCB = LinearShortZCB(shortZCBs[marketId]);\\n\\n\\t\\tuint256 trader_shorts_balance = shortZCB.balanceOf(trader); \\n\\t\\tshortZCB.trustedBurn( trader,  trader_shorts_balance);\\n\\t\\t \\n\\t\\tuint256 collateral_amount = assessment_shorts[marketId][trader]; \\n\\t\\tERC20 collateral = ERC20(shortZCB.getCollateral()); \\n\\t\\tcollateral.transferFrom(shortZCBs[marketId], trader,collateral_amount ); \\n\\n\\t}\\n\\n\\t// function redeemShort() external{\\n\\n\\t// }\\n\\n\\n\\n\\n\\n\\t/* \\n\\tFor now only allow collateral to be ds\\n\\t*/\\n\\tfunction borrow_with_collateral(\\n\\t\\tuint256 _marketId, \\n\\t\\tuint256 requested_zcb, \\n\\t\\taddress trader\\n\\t\\t) external {\\n\\t\\t//1.Use 100 ds as collateral to borrow 100zcb 1:1, only this for now \\n\\t\\t//2.use 0.1eth(170) as collateral to borrow 100zcb =>100/170 collateral ratio\\n\\t\\tBondingCurve zcb = BondingCurve(address(controller.getZCB(_marketId))); // SOMEHOW GET ZCB\\n\\t\\taddress collateral_address = zcb.getCollateral();\\n\\t\\tSafeERC20.safeTransferFrom(IERC20(collateral_address), trader, address(zcb), requested_zcb);\\n\\n\\t\\t// SafeERC20.safeTransferFrom(IERC20(collateral_address), trader, address(this), requested_zcb); \\n\\t\\tuint256 _collateralIn = requested_zcb; \\n\\n\\t\\tCDP storage cdp = debt_pools[_marketId];\\n\\t\\tcdp.collateral_amount[trader] += _collateralIn; \\n\\t\\tcdp.borrowed_amount[trader] += requested_zcb;  \\n\\t\\tcdp.total_debt += requested_zcb; \\n\\t\\tcdp.total_collateral += _collateralIn; //only ds \\n\\t\\tcollateral_pot[_marketId] += _collateralIn; //Total ds collateral \\n\\n\\t\\tzcb.trustedMint(trader, requested_zcb);\\n\\t}\\n\\n\\t/*\\n\\tTrader provides zcb and receives back collateral \\n\\t */\\n\\tfunction repay_for_collateral(\\n\\t\\tuint256 _marketId, \\n\\t\\tuint256 repaying_zcb, \\n\\t\\taddress trader\\n\\t) external {\\n\\t\\tBondingCurve zcb = BondingCurve(address(controller.getZCB(_marketId)));\\n\\t\\taddress collateral_address = zcb.getCollateral();\\n\\t\\tzcb.trustedBurn(trader, repaying_zcb);\\n\\n\\n\\t\\tuint256 _collateralOut = repaying_zcb; \\n\\n\\t\\tCDP storage cdp = debt_pools[_marketId];\\n\\t\\tcdp.collateral_amount[trader] -= _collateralOut;\\n\\t\\tcdp.borrowed_amount[trader] -= repaying_zcb;\\n\\t\\tcdp.total_debt -= repaying_zcb;\\n\\t\\tcdp.total_collateral -= _collateralOut;\\n\\t\\tcollateral_pot[_marketId] -= _collateralOut;\\n\\n\\t\\t// SafeERC20.safeTransfer(IERC20(collateral_address), trader, _collateralOut);\\n\\t\\t// zcb needs to approve transfer from itself to trader.\\n\\t\\tzcb.trustedApproveCollateralTransfer(trader, _collateralOut);\\n\\t\\tSafeERC20.safeTransferFrom(IERC20(collateral_address), address(zcb), trader, _collateralOut);\\n\\t}\\n\\n\\n\\n\\t/*Maturity Functions */\\n\\n\\n\\tfunction get_redemption_price(uint256 marketId) public view returns(uint256){\\n\\t\\treturn redemption_prices[marketId]; \\n\\t}\\n\\n\\t/**\\n\\t@dev Redemption price, as calculated at maturity,\\n\\tdepends on total_repayed/(principal + predetermined yield)\\n\\tIf total_repayed = 0, redemption price is 0\\n\\t@param atLoss: defines circumstances where expected returns are higher than actual\\n\\t@param principal_loss: principal - returned amount => non-negative always?\\n\\t@param extra_gain: any extra yield not factored during assessment. Is 0 yield is as expected\\n\\t */\\n\\tfunction update_redemption_price(\\n\\t\\tuint256 marketId,\\n\\t\\tbool atLoss, \\n\\t\\tuint256 extra_gain, \\n\\t\\tuint256 principal_loss\\n\\t) external  onlyController {\\t\\n\\n\\t\\tBondingCurve zcb = BondingCurve(address(controller.getZCB(marketId))); // SOMEHOW GET ZCB\\n\\t\\tuint256 total_bought_collateral = zcb.getTotalCollateral();\\n\\t\\tuint256 total_bought_bonds = zcb.getTotalZCB();\\n\\t\\tconsole.log(\\\"total_bought_bonds\\\", total_bought_bonds);\\n\\t\\tconsole.log(\\\"principal_loss\\\", principal_loss);\\n\\n\\t\\tif (atLoss){\\n\\t\\t\\tif (total_bought_collateral - principal_loss > 0){\\n\\t\\t\\t\\tredemption_prices[marketId] = PRICE_PRECISION - (principal_loss*PRICE_PRECISION/total_bought_bonds);\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\tredemption_prices[marketId] = 0; \\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse{\\n\\t\\t\\trequire(extra_gain >= 0 && principal_loss ==0,  \\\"loss err\\\"); \\n\\t\\t\\tuint256 num_shorts = debt_pools[marketId].total_debt; //For now assume that every zcb borrowed is used to short\\n\\t\\t\\tredemption_prices[marketId] = PRICE_PRECISION + (extra_gain*PRICE_PRECISION/(total_bought_bonds+num_shorts)); \\n\\t\\t}\\t\\n\\n\\t\\t\\tconsole.log('redemption_price', redemption_prices[marketId]); \\n\\t}\\n\\n\\n\\t/* \\n\\tHandles maturity. Includes default/no defaults\\n\\tCalled by controller after redemption price has been set \\n\\t\\n\\tif default: need to burn the underlying tokens used as collateral to buy the zcb as first loss\\n\\t*/\\n\\tfunction handle_maturity(\\n\\t\\tuint256 marketId, \\n\\t\\tbool atLoss, \\n\\t\\tuint256 principal_loss\\n\\t) external  onlyController {\\n\\n\\t\\tBondingCurve zcb =  BondingCurve(address(controller.getZCB(marketId)));\\n\\n\\t\\tuint256 redemption_price = get_redemption_price(marketId); \\n\\t\\trequire(redemption_price > 0, \\\"Need to set redemption price\\\"); // what if redemption price is set to zero?\\n\\t\\tuint256 total_bought_bonds = zcb.getTotalZCB();\\n\\t\\tuint256 total_bought_collateral = zcb.getTotalCollateral();\\n\\n\\t\\tif (atLoss){\\n\\n\\t\\t\\tuint256 burnamount = total_bought_collateral - ((redemption_price * total_bought_bonds)/PRICE_PRECISION);\\n\\t\\t\\tconsole.log('burnamounts', burnamount);\\n\\n\\t\\t\\tif(principal_loss >0){\\n\\t\\t\\t\\trequire(burnamount>0,\\\"burn amount err\\\"); \\n\\t\\t\\t\\tzcb.burnFirstLoss(burnamount);\\n\\n\\t\\t\\t}\\n\\t\\t\\n\\t\\t}\\n\\n\\t}\\n\\n\\t/* \\n\\t@notice trader will redeem entire balance of ZCB\\n\\tNeeds to be called at maturity, market needs to be resolved first(from controller)\\n\\t*/\\n\\tfunction redeem(\\n\\t\\tuint256 marketId,\\n\\t \\taddress receiver \\n\\t) public returns(uint256){\\n\\t\\trequire(!marketActive(marketId), \\\"Market Active\\\"); \\n\\t\\tBondingCurve zcb = BondingCurve(address(controller.getZCB(marketId)));\\n\\t\\tuint256 zcb_redeem_amount = zcb.balanceOf(msg.sender); \\n\\t\\tzcb.trustedBurn(msg.sender, zcb_redeem_amount); \\n\\n\\t\\tuint256 redemption_price = get_redemption_price(marketId); \\n\\t\\trequire(redemption_price > 0, \\\"Redeem price is 0\\\");\\n\\t\\tuint256 zcb_redeem_amount_prec = zcb_redeem_amount/(10**12); \\n\\t\\tuint256 collateral_redeem_amount = (redemption_price * zcb_redeem_amount_prec)/PRICE_PRECISION; \\n\\n\\t\\tcontroller.redeem_mint(collateral_redeem_amount, msg.sender); \\n\\n\\t\\treturn collateral_redeem_amount; \\n\\n\\t}\\n\\n\\n\\t/// @notice when market is resolved(maturity/early default), calculates score\\n\\t/// and update each assessment phase trader's reputation, called by individual traders\\n\\tfunction updateReputation(uint256 marketId) external  {\\n\\t\\trequire(restriction_data[marketId].resolved, \\\"Market not resolved\\\"); \\t\\n\\t\\trequire(assessment_trader[marketId][msg.sender], \\\"Not manager\\\"); \\n\\n\\t\\tbool atLoss = restriction_data[marketId].atLoss; \\n\\t\\tuint256 priceOut = assessment_prices[marketId][msg.sender]/(10**12); \\n\\t\\tuint256 collateralIn = assessment_collaterals[marketId][msg.sender]; \\n\\t\\tuint256 traderBudget = getTraderBudget(marketId, msg.sender);\\n\\t\\tuint256 num_bonds_bought = (collateralIn * priceOut)/PRICE_PRECISION;\\n\\t\\tconsole.log(\\\"collateralIn: \\\", collateralIn);\\n\\t\\tconsole.log(\\\"traderBudget: \\\", traderBudget);\\n\\t\\tconsole.log(\\\"num_bonds bought: \\\", num_bonds_bought); \\n\\t\\tconsole.log(\\\"Price Out: \\\", priceOut);\\n\\n\\t\\tuint256 scoreToAdd; \\n\\t\\t// if (!atLoss) scoreToAdd = (((num_bonds_bought*PRICE_PRECISION/traderBudget) * (PRICE_PRECISION - priceOut))/PRICE_PRECISION)*(num_bonds_bought)/PRICE_PRECISION;\\n\\t\\t// console.log('num_bonds_bought'); \\n\\t\\tif(!atLoss) scoreToAdd = num_bonds_bought; \\n\\t\\telse scoreToAdd = (num_bonds_bought/traderBudget) * priceOut * num_bonds_bought; \\n\\n\\t\\trep.addScore(msg.sender, scoreToAdd, !atLoss); \\n\\t}\\n\\n\\n\\tfunction max(uint256 a, uint256 b) internal pure returns (uint256) {\\n\\t    return a >= b ? a : b;\\n\\t}\\n\\n\\tfunction sqrt(uint y) internal pure returns (uint z) {\\n\\t    if (y > 3) {\\n\\t        z = y;\\n\\t        uint x = y / 2 + 1;\\n\\t        while (x < z) {\\n\\t            z = x;\\n\\t            x = (y / x + x) / 2;\\n\\t        }\\n\\t    } else if (y != 0) {\\n\\t        z = 1;\\n\\t    }\\n\\t}\\n\\n\\n\\n\\n\\n}\\n\\n\",\"keccak256\":\"0x11c6e0af77cb50efd32703a7981462ca839eebc1de8852ade8c26c5a4d114835\"},\"contracts/stablecoin/owned.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.4;\\n\\n// https://docs.synthetix.io/contracts/Owned\\ncontract Owned {\\n    address public owner;\\n    address public nominatedOwner;\\n\\n    constructor (address _owner) public {\\n        require(_owner != address(0), \\\"Owner address cannot be 0\\\");\\n        owner = _owner;\\n        emit OwnerChanged(address(0), _owner);\\n    }\\n\\n    function nominateNewOwner(address _owner) external onlyOwner {\\n        nominatedOwner = _owner;\\n        emit OwnerNominated(_owner);\\n    }\\n\\n    function acceptOwnership() external {\\n        require(msg.sender == nominatedOwner, \\\"You must be nominated before you can accept ownership\\\");\\n        emit OwnerChanged(owner, nominatedOwner);\\n        owner = nominatedOwner;\\n        nominatedOwner = address(0);\\n    }\\n\\n    modifier onlyOwner {\\n        require(msg.sender == owner, \\\"Only the contract owner may perform this action\\\");\\n        _;\\n    }\\n\\n    event OwnerNominated(address newOwner);\\n    event OwnerChanged(address oldOwner, address newOwner);\\n}\",\"keccak256\":\"0x36a2933ab9503c1e564c378880a9ef2a02f91f4089d7b842ee38ef9d070d50fe\",\"license\":\"GPL-2.0-or-later\"},\"contracts/stablecoin/reputationtoken.sol\":{\"content\":\"pragma solidity ^0.8.4; \\n//https://github.com/poap-xyz/poap-contracts/tree/master/contracts\\nimport {ERC721} from \\\"solmate/src/tokens/ERC721.sol\\\";\\nimport {Controller} from \\\"./controller.sol\\\";\\nimport {IReputationNFT} from \\\"./IReputationNFT.sol\\\";\\nimport {BondingCurve} from \\\"../bonds/bondingcurve.sol\\\";\\nimport \\\"hardhat/console.sol\\\";\\n\\n\\n\\ncontract ReputationNFT is IReputationNFT, ERC721 {\\n  mapping(uint256 => ReputationData) internal _reputation; // id to reputation\\n  mapping(address => uint256) internal _ownerToId;\\n  mapping(uint256 => TraderData[]) internal _marketData; // **MarketId to Market's data needed for calculating brier score.\\n\\n  uint256 private nonce = 1;\\n  Controller controller;\\n  uint256 SCALE = 1e18;\\n\\n\\n  struct ReputationData {\\n    uint256 n; // number of markets participated in => regular uint256\\n    uint256 score; // averaged reputation score => 60.18\\n  }\\n\\n  struct TraderData { // for each market\\n    address trader;\\n    uint256 tokensBought;\\n  }\\n\\n  modifier onlyController() {\\n    require(msg.sender == address(controller));\\n    _;\\n  }\\n\\n  constructor (\\n    address _controller\\n  ) ERC721(\\\"Debita Reputation Token\\\", \\\"DRT\\\") {\\n    console.log(\\\"here\\\");\\n    controller = Controller(_controller);\\n  }\\n\\n  function _baseURI() internal pure returns (string memory baseURI) {\\n    baseURI = \\\"\\\";\\n  }\\n\\n  function tokenURI(uint256 id) public view override returns (string memory) {\\n    require(_ownerOf[id] != address(0), \\\"Invalid Identifier\\\");\\n\\n    string memory baseURI = _baseURI();\\n    return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, id)) : \\\"\\\";\\n  }\\n\\n  function mint(address to) external {\\n    require(_ownerToId[to] == uint256(0), \\\"can only mint one reputation token\\\");\\n    super._mint(to, nonce);\\n    _ownerToId[to] = nonce;\\n    nonce++;\\n  }\\n\\n  function getReputationScore(address owner) view external returns (uint256){\\n    require(_ownerToId[owner] != uint256(0), \\\"No Id found\\\");\\n    return _reputation[_ownerToId[owner]].score;\\n  }\\n\\n\\n\\n  /**\\n   @notice calculates average of scores added.\\n   @param score: 60.18 format\\n   */\\n  function addScore(address to, uint256 score, bool atLoss) external  {\\n    require(_ownerToId[to] != uint256(0), \\\"No Id found\\\");\\n\\n    ReputationData storage data = _reputation[_ownerToId[to]];\\n    \\n    if (data.n == 0) {\\n      data.score = score;\\n    } else {\\n      //data.score = ((data.score / data.n) + score) / (data.n + 1);\\n      data.score = (data.score / data.n + score) / (data.n + 1);\\n    }\\n\\n    data.n++;\\n  }\\n\\n  /**\\n   @notice reset scores\\n   */\\n  function resetScore(address to) external {\\n    require(_ownerToId[to] != uint256(0), \\\"No Id found\\\");\\n    delete _reputation[_ownerToId[to]];\\n\\n  }\\n}\",\"keccak256\":\"0x2303f576166ec49e3b6170af1cc2eebe7106182b3b421f0e167c1d919c3cc590\"},\"contracts/turbo/AMMFactory.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"../balancer/BFactory.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\nimport \\\"./AbstractMarketFactoryV3.sol\\\";\\nimport \\\"../balancer/BNum.sol\\\";\\nimport \\\"../bonds/Ibondingcurve.sol\\\"; \\n\\ncontract AMMFactory is BNum {\\n    using SafeMath for uint256;\\n\\n    uint256 private constant MAX_UINT = 2**256 - 1;\\n    uint256 private constant MIN_INITIAL_LIQUIDITY = BONE * 100;\\n\\n    BFactory public bFactory;\\n    // MarketFactory => Market => BPool\\n    mapping(address => mapping(uint256 => BPool)) public pools;\\n    uint256 fee;\\n\\n    event PoolCreated(\\n        address pool,\\n        address indexed marketFactory,\\n        uint256 indexed marketId,\\n        address indexed creator,\\n        address lpTokenRecipient\\n    );\\n    event LiquidityChanged(\\n        address indexed marketFactory,\\n        uint256 indexed marketId,\\n        address indexed user,\\n        address recipient,\\n        // from the perspective of the user. e.g. collateral is negative when adding liquidity\\n        int256 collateral,\\n        int256 lpTokens,\\n        uint256[] sharesReturned\\n    );\\n    event SharesSwapped(\\n        address indexed marketFactory,\\n        uint256 indexed marketId,\\n        address indexed user,\\n        uint256 outcome,\\n        // from the perspective of the user. e.g. collateral is negative when buying\\n        int256 collateral,\\n        int256 shares,\\n        uint256 price\\n    );\\n\\n    constructor(BFactory _bFactory, uint256 _fee) {\\n        bFactory = _bFactory;\\n        fee = _fee;\\n    }\\n\\n    function createPool(\\n        AbstractMarketFactoryV3 _marketFactory,\\n        uint256 _marketId,\\n        uint256 _initialLiquidity,\\n        address _lpTokenRecipient\\n    ) public returns (uint256) {\\n        require(pools[address(_marketFactory)][_marketId] == BPool(address(0)), \\\"Pool already created\\\");\\n\\n        AbstractMarketFactoryV3.Market memory _market = _marketFactory.getMarket(_marketId);\\n\\n        uint256 _sets = _marketFactory.calcShares(_initialLiquidity);\\n\\n        // Comparing to sets because sets are normalized to 10e18.\\n        require(_sets >= MIN_INITIAL_LIQUIDITY, \\\"Initial liquidity must be at least 100 collateral.\\\");\\n\\n        //  Turn collateral into shares\\n        IERC20Full _collateral = _marketFactory.collateral();\\n        require(\\n            _collateral.allowance(msg.sender, address(this)) >= _initialLiquidity,\\n            \\\"insufficient collateral allowance for initial liquidity\\\"\\n        );\\n\\n        _collateral.transferFrom(msg.sender, address(this), _initialLiquidity);\\n        _collateral.approve(address(_marketFactory), MAX_UINT);\\n\\n        _marketFactory.mintShares(_marketId, _sets, address(this));\\n\\n        // Create pool\\n        BPool _pool = bFactory.newBPool();\\n\\n        // Add each outcome to the pool. Collateral is NOT added.\\n        for (uint256 i = 0; i < _market.shareTokens.length; i++) {\\n            OwnedERC20 _token = _market.shareTokens[i];\\n            _token.approve(address(_pool), MAX_UINT);\\n            _pool.bind(address(_token), _sets, _market.initialOdds[i]);\\n        }\\n\\n        // Set the swap fee.\\n        _pool.setSwapFee(fee);\\n\\n        // Finalize pool setup\\n        _pool.finalize();\\n\\n        pools[address(_marketFactory)][_marketId] = _pool;\\n\\n        // Pass along LP tokens for initial liquidity\\n        uint256 _lpTokenBalance = _pool.balanceOf(address(this)) - (BONE / 1000);\\n\\n        // Burn (BONE / 1000) lp tokens to prevent the bpool from locking up. When all liquidity is removed.\\n        _pool.transfer(address(0x0), (BONE / 1000));\\n        _pool.transfer(_lpTokenRecipient, _lpTokenBalance);\\n\\n        uint256[] memory _balances = new uint256[](_market.shareTokens.length);\\n        for (uint256 i = 0; i < _market.shareTokens.length; i++) {\\n            _balances[i] = 0;\\n        }\\n\\n        emit PoolCreated(address(_pool), address(_marketFactory), _marketId, msg.sender, _lpTokenRecipient);\\n        emit LiquidityChanged(\\n            address(_marketFactory),\\n            _marketId,\\n            msg.sender,\\n            _lpTokenRecipient,\\n            -int256(_initialLiquidity),\\n            int256(_lpTokenBalance),\\n            _balances\\n        );\\n\\n        return _lpTokenBalance;\\n    }\\n\\n    function addLiquidity(\\n        AbstractMarketFactoryV3 _marketFactory,\\n        uint256 _marketId,\\n        uint256 _collateralIn,\\n        uint256 _minLPTokensOut,\\n        address _lpTokenRecipient\\n    ) public returns (uint256 _poolAmountOut, uint256[] memory _balances) {\\n        BPool _pool = pools[address(_marketFactory)][_marketId];\\n        require(_pool != BPool(address(0)), \\\"Pool needs to be created\\\");\\n\\n        AbstractMarketFactoryV3.Market memory _market = _marketFactory.getMarket(_marketId);\\n\\n        //  Turn collateral into shares\\n        IERC20Full _collateral = _marketFactory.collateral();\\n        _collateral.transferFrom(msg.sender, address(this), _collateralIn);\\n        _collateral.approve(address(_marketFactory), MAX_UINT);\\n        uint256 _sets = _marketFactory.calcShares(_collateralIn);\\n        _marketFactory.mintShares(_marketId, _sets, address(this));\\n\\n        // Find poolAmountOut\\n        _poolAmountOut = MAX_UINT;\\n\\n        {\\n            uint256 _totalSupply = _pool.totalSupply();\\n            uint256[] memory _maxAmountsIn = new uint256[](_market.shareTokens.length);\\n            for (uint256 i = 0; i < _market.shareTokens.length; i++) {\\n                _maxAmountsIn[i] = _sets;\\n\\n                OwnedERC20 _token = _market.shareTokens[i];\\n                uint256 _bPoolTokenBalance = _pool.getBalance(address(_token));\\n\\n                // This is the result the following when solving for poolAmountOut:\\n                // uint256 ratio = bdiv(poolAmountOut, poolTotal);\\n                // uint256 tokenAmountIn = bmul(ratio, bal);\\n                uint256 _tokenPoolAmountOut =\\n                    (((((_sets * BONE) - (BONE / 2)) * _totalSupply) / _bPoolTokenBalance) - (_totalSupply / 2)) / BONE;\\n\\n                if (_tokenPoolAmountOut < _poolAmountOut) {\\n                    _poolAmountOut = _tokenPoolAmountOut;\\n                }\\n            }\\n            _pool.joinPool(_poolAmountOut, _maxAmountsIn);\\n        }\\n\\n        require(_poolAmountOut >= _minLPTokensOut, \\\"Would not have received enough LP tokens\\\");\\n\\n        _pool.transfer(_lpTokenRecipient, _poolAmountOut);\\n\\n        // Transfer the remaining shares back to _lpTokenRecipient.\\n        _balances = new uint256[](_market.shareTokens.length);\\n        for (uint256 i = 0; i < _market.shareTokens.length; i++) {\\n            OwnedERC20 _token = _market.shareTokens[i];\\n            _balances[i] = _token.balanceOf(address(this));\\n            if (_balances[i] > 0) {\\n                _token.transfer(_lpTokenRecipient, _balances[i]);\\n            }\\n        }\\n\\n        emit LiquidityChanged(\\n            address(_marketFactory),\\n            _marketId,\\n            msg.sender,\\n            _lpTokenRecipient,\\n            -int256(_collateralIn),\\n            int256(_poolAmountOut),\\n            _balances\\n        );\\n    }\\n\\n    function removeLiquidity(\\n        AbstractMarketFactoryV3 _marketFactory,\\n        uint256 _marketId,\\n        uint256 _lpTokensIn,\\n        uint256 _minCollateralOut,\\n        address _collateralRecipient\\n    ) public returns (uint256 _collateralOut, uint256[] memory _balances) {\\n        BPool _pool = pools[address(_marketFactory)][_marketId];\\n        require(_pool != BPool(address(0)), \\\"Pool needs to be created\\\");\\n\\n        AbstractMarketFactoryV3.Market memory _market = _marketFactory.getMarket(_marketId);\\n\\n        _pool.transferFrom(msg.sender, address(this), _lpTokensIn);\\n\\n        uint256[] memory exitPoolEstimate;\\n        {\\n            uint256[] memory minAmountsOut = new uint256[](_market.shareTokens.length);\\n            exitPoolEstimate = _pool.calcExitPool(_lpTokensIn, minAmountsOut);\\n            _pool.exitPool(_lpTokensIn, minAmountsOut);\\n        }\\n\\n        // Find the number of sets to sell.\\n        uint256 _setsToSell = MAX_UINT;\\n        for (uint256 i = 0; i < _market.shareTokens.length; i++) {\\n            uint256 _acquiredTokenBalance = exitPoolEstimate[i];\\n            if (_acquiredTokenBalance < _setsToSell) _setsToSell = _acquiredTokenBalance;\\n        }\\n\\n        // Must be a multiple of share factor.\\n        _setsToSell = (_setsToSell / _marketFactory.shareFactor()) * _marketFactory.shareFactor();\\n\\n        bool _resolved = _marketFactory.isMarketResolved(_marketId);\\n        if (_resolved) {\\n            _collateralOut = _marketFactory.claimWinnings(_marketId, _collateralRecipient);\\n        } else {\\n            _collateralOut = _marketFactory.burnShares(_marketId, _setsToSell, _collateralRecipient);\\n        }\\n        require(_collateralOut > _minCollateralOut, \\\"Amount of collateral returned too low.\\\");\\n\\n        // Transfer the remaining shares back to _collateralRecipient.\\n        _balances = new uint256[](_market.shareTokens.length);\\n        for (uint256 i = 0; i < _market.shareTokens.length; i++) {\\n            OwnedERC20 _token = _market.shareTokens[i];\\n            if (_resolved && _token == _market.winner) continue; // all winning shares claimed when market is resolved\\n            _balances[i] = exitPoolEstimate[i] - _setsToSell;\\n            if (_balances[i] > 0) {\\n                _token.transfer(_collateralRecipient, _balances[i]);\\n            }\\n        }\\n\\n        emit LiquidityChanged(\\n            address(_marketFactory),\\n            _marketId,\\n            msg.sender,\\n            _collateralRecipient,\\n            int256(_collateralOut),\\n            -int256(_lpTokensIn),\\n            _balances\\n        );\\n    }\\n\\n\\n    function buyZCB(\\n        AbstractMarketFactoryV3 _marketFactory, \\n        address from, \\n        address bondingcurve, \\n        uint256 _marketId, \\n        uint256 _collateralIn\\n        ) external returns(uint256){\\n\\n\\n        IERC20Full _collateral = _marketFactory.collateral();\\n        _collateral.transferFrom(from, address(this), _collateralIn);\\n        _collateral.approve(bondingcurve, _collateralIn); \\n\\n        return IBondingCurve(bondingcurve).buy(address(_marketFactory), from, _collateralIn, _marketId);\\n    }\\n\\n    function sellZCB(\\n        AbstractMarketFactoryV3 _marketFactory, \\n        address from, \\n        address bondingcurve, \\n        uint256 _marketId, \\n        uint256 _zcb_amountIn\\n        ) external returns(uint256){\\n\\n        uint256 fee_deducted_collateral_out = IBondingCurve(bondingcurve).sell(\\n            address(_marketFactory),\\n            from, \\n            _zcb_amountIn, \\n             _marketId); \\n\\n        IERC20Full _collateral = _marketFactory.collateral();\\n        _collateral.transfer(from, fee_deducted_collateral_out); \\n\\n        return fee_deducted_collateral_out; \\n    }\\n\\n\\n    function buy(\\n        AbstractMarketFactoryV3 _marketFactory,\\n        uint256 _marketId,\\n        uint256 _outcome,\\n        uint256 _collateralIn,\\n        uint256 _minTokensOut\\n    ) external returns (uint256) {\\n        BPool _pool = pools[address(_marketFactory)][_marketId];\\n        require(_pool != BPool(address(0)), \\\"Pool needs to be created\\\");\\n\\n        AbstractMarketFactoryV3.Market memory _market = _marketFactory.getMarket(_marketId);\\n        _marketFactory.logTrade(_marketId, _outcome, _collateralIn); \\n\\n        IERC20Full _collateral = _marketFactory.collateral();\\n        _collateral.transferFrom(msg.sender, address(this), _collateralIn);\\n        uint256 _sets = _marketFactory.calcShares(_collateralIn);\\n        _marketFactory.mintShares(_marketId, _sets, address(this));\\n\\n        uint256 _totalDesiredOutcome = _sets;\\n        {\\n            OwnedERC20 _desiredToken = _market.shareTokens[_outcome];\\n\\n            for (uint256 i = 0; i < _market.shareTokens.length; i++) {\\n                if (i == _outcome) continue;\\n                OwnedERC20 _token = _market.shareTokens[i];\\n                (uint256 _acquiredToken, ) =\\n                    _pool.swapExactAmountIn(address(_token), _sets, address(_desiredToken), 0, MAX_UINT);\\n                _totalDesiredOutcome += _acquiredToken;\\n            }\\n            require(_totalDesiredOutcome >= _minTokensOut, \\\"Slippage exceeded\\\");\\n\\n            _desiredToken.transfer(msg.sender, _totalDesiredOutcome);\\n        }\\n\\n        emit SharesSwapped(\\n            address(_marketFactory),\\n            _marketId,\\n            msg.sender,\\n            _outcome,\\n            -int256(_collateralIn),\\n            int256(_totalDesiredOutcome),\\n            bdiv(_sets, _totalDesiredOutcome)\\n        );\\n\\n        return _totalDesiredOutcome;\\n    }\\n\\n    function sellForCollateral(\\n        AbstractMarketFactoryV3 _marketFactory,\\n        uint256 _marketId,\\n        uint256 _outcome,\\n        uint256[] memory _shareTokensIn,\\n        uint256 _minSetsOut\\n    ) external returns (uint256) {\\n        BPool _pool = pools[address(_marketFactory)][_marketId];\\n        require(_pool != BPool(address(0)), \\\"Pool needs to be created\\\");\\n        AbstractMarketFactoryV3.Market memory _market = _marketFactory.getMarket(_marketId);\\n\\n        uint256 _setsOut = MAX_UINT;\\n        uint256 _totalUndesiredTokensIn = 0;\\n        for (uint256 i = 0; i < _market.shareTokens.length; i++) {\\n            _totalUndesiredTokensIn += _shareTokensIn[i];\\n        }\\n\\n        {\\n            _market.shareTokens[_outcome].transferFrom(msg.sender, address(this), _totalUndesiredTokensIn);\\n            _market.shareTokens[_outcome].approve(address(_pool), MAX_UINT);\\n\\n            for (uint256 i = 0; i < _market.shareTokens.length; i++) {\\n                if (i == _outcome) continue;\\n                OwnedERC20 _token = _market.shareTokens[i];\\n                (uint256 tokenAmountOut, ) =\\n                    _pool.swapExactAmountIn(\\n                        address(_market.shareTokens[_outcome]),\\n                        _shareTokensIn[i],\\n                        address(_token),\\n                        0,\\n                        MAX_UINT\\n                    );\\n\\n                //Ensure tokenAmountOut is a multiple of shareFactor.\\n                tokenAmountOut = (tokenAmountOut / _marketFactory.shareFactor()) * _marketFactory.shareFactor();\\n                if (tokenAmountOut < _setsOut) _setsOut = tokenAmountOut;\\n            }\\n\\n            require(_setsOut >= _minSetsOut, \\\"Minimum sets not available.\\\");\\n            _marketFactory.burnShares(_marketId, _setsOut, msg.sender);\\n        }\\n\\n        // Transfer undesired token balance back.\\n        for (uint256 i = 0; i < _market.shareTokens.length; i++) {\\n            OwnedERC20 _token = _market.shareTokens[i];\\n            uint256 _balance = _token.balanceOf(address(this));\\n            if (_balance > 0) {\\n                _token.transfer(msg.sender, _balance);\\n            }\\n        }\\n\\n        uint256 _collateralOut = _marketFactory.calcCost(_setsOut);\\n        emit SharesSwapped(\\n            address(_marketFactory),\\n            _marketId,\\n            msg.sender,\\n            _outcome,\\n            int256(_collateralOut),\\n            -int256(_totalUndesiredTokensIn),\\n            bdiv(_setsOut, _totalUndesiredTokensIn)\\n        );\\n\\n        return _collateralOut;\\n    }\\n\\n    // Returns an array of token values for the outcomes of the market, relative to the first outcome.\\n    // So the first outcome is 10**18 and all others are higher or lower.\\n    // Prices can be derived due to the fact that the total of all outcome shares equals one collateral, possibly with a scaling factor,\\n    function tokenRatios(AbstractMarketFactoryV3 _marketFactory, uint256 _marketId)\\n        external\\n        view\\n        returns (uint256[] memory)\\n    {\\n        BPool _pool = pools[address(_marketFactory)][_marketId];\\n        // Pool does not exist. Do not want to revert because multicall.\\n        if (_pool == BPool(address(0))) {\\n            return new uint256[](0);\\n        }\\n\\n        AbstractMarketFactoryV3.Market memory _market = _marketFactory.getMarket(_marketId);\\n        address _basisToken = address(_market.shareTokens[0]);\\n        uint256[] memory _ratios = new uint256[](_market.shareTokens.length);\\n        _ratios[0] = 10**18;\\n        for (uint256 i = 1; i < _market.shareTokens.length; i++) {\\n            uint256 _price = _pool.getSpotPrice(_basisToken, address(_market.shareTokens[i]));\\n            _ratios[i] = _price;\\n        }\\n        return _ratios;\\n    }\\n\\n    function getPoolBalances(AbstractMarketFactoryV3 _marketFactory, uint256 _marketId)\\n        external\\n        view\\n        returns (uint256[] memory)\\n    {\\n        BPool _pool = pools[address(_marketFactory)][_marketId];\\n        // Pool does not exist. Do not want to revert because multicall.\\n        if (_pool == BPool(address(0))) {\\n            return new uint256[](0);\\n        }\\n\\n        address[] memory _tokens = _pool.getCurrentTokens();\\n        uint256[] memory _balances = new uint256[](_tokens.length);\\n        for (uint256 i = 0; i < _tokens.length; i++) {\\n            _balances[i] = _pool.getBalance(_tokens[i]);\\n        }\\n        return _balances;\\n    }\\n\\n    function getPoolWeights(AbstractMarketFactoryV3 _marketFactory, uint256 _marketId)\\n        external\\n        view\\n        returns (uint256[] memory)\\n    {\\n        BPool _pool = pools[address(_marketFactory)][_marketId];\\n        // Pool does not exist. Do not want to revert because multicall.\\n        if (_pool == BPool(address(0))) {\\n            return new uint256[](0);\\n        }\\n\\n        address[] memory _tokens = _pool.getCurrentTokens();\\n        uint256[] memory _weights = new uint256[](_tokens.length);\\n        for (uint256 i = 0; i < _tokens.length; i++) {\\n            _weights[i] = _pool.getDenormalizedWeight(_tokens[i]);\\n        }\\n        return _weights;\\n    }\\n\\n    function getSwapFee(AbstractMarketFactoryV3 _marketFactory, uint256 _marketId) external view returns (uint256) {\\n        BPool _pool = pools[address(_marketFactory)][_marketId];\\n        return _pool.getSwapFee();\\n    }\\n\\n    function getPoolTokenBalance(\\n        AbstractMarketFactoryV3 _marketFactory,\\n        uint256 _marketId,\\n        address _user\\n    ) external view returns (uint256) {\\n        BPool _pool = pools[address(_marketFactory)][_marketId];\\n        return _pool.balanceOf(_user);\\n    }\\n\\n    function getPool(AbstractMarketFactoryV3 _marketFactory, uint256 _marketId) external view returns (BPool) {\\n        return pools[address(_marketFactory)][_marketId];\\n    }\\n}\\n\",\"keccak256\":\"0x1a997b0a568cb0ca711ae3b541f09269cc1b75b066aadce15324d6c423b9c309\",\"license\":\"MIT\"},\"contracts/turbo/AbstractMarketFactoryV3.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"../libraries/IERC20Full.sol\\\";\\nimport \\\"../balancer/BPool.sol\\\";\\nimport \\\"./TurboShareTokenFactory.sol\\\";\\nimport \\\"./FeePot.sol\\\";\\nimport \\\"../libraries/Rewardable.sol\\\";\\nimport { LinearBondingCurve } from \\\"../bonds/LinearBondingCurve.sol\\\";\\n\\nabstract contract AbstractMarketFactoryV3 is ZCBFactory, TurboShareTokenFactory, Ownable, Rewardable {\\n    using SafeMath for uint256;\\n\\n    event MarketCreated(uint256 id, string[] names, uint256[] initialOdds);\\n    event MarketResolved(uint256 id, address winner, uint256 winnerIndex, string winnerName);\\n    event MarketActivated(uint256 id);\\n\\n    event SharesMinted(uint256 id, uint256 amount, address receiver);\\n    event SharesBurned(uint256 id, uint256 amount, address receiver);\\n    event WinningsClaimed(\\n        uint256 id,\\n        address winningOutcome,\\n        uint256 winningIndex,\\n        string winningName,\\n        uint256 amount,\\n        uint256 settlementFee,\\n        uint256 payout,\\n        address indexed receiver\\n    );\\n\\n    IERC20Full public collateral;\\n    FeePot public feePot;\\n\\n    // fees are out of 1e18 and only apply to new markets\\n    uint256 public stakerFee;\\n    uint256 public settlementFee;\\n    uint256 public protocolFee;\\n\\n    address public protocol; // collects protocol fees\\n\\n    uint256 public accumulatedProtocolFee = 0;\\n    // settlement address => amount of collateral\\n    mapping(address => uint256) public accumulatedSettlementFees;\\n\\n    // How many shares equals one collateral.\\n    // Necessary to account for math errors from small numbers in balancer.\\n    // shares = collateral / shareFactor\\n    // collateral = shares * shareFactor\\n    uint256 public shareFactor;\\n\\n    struct Market {\\n        address settlementAddress;\\n        OwnedERC20[] shareTokens;\\n        OwnedERC20 winner;\\n        uint256 winnerIndex;\\n        uint256 settlementFee;\\n        uint256 protocolFee;\\n        uint256 stakerFee;\\n        uint256 creationTimestamp;\\n        uint256 resolutionTimestamp; // when winner is declared\\n        uint256[] initialOdds;\\n        bool active; // false if not ready to use or if resolved\\n    }\\n\\n    Market[] internal markets;\\n    // ZCBMarket[] internal zcbmarkets; \\n\\n    uint256 private constant MAX_UINT = 2**256 - 1;\\n\\n    mapping(uint256=> mapping(uint256=>uint256)) TradeDetails; //marketid -> (outcome->amount)\\n    mapping(uint256 => bool ) inAssessment; \\n    mapping(uint256=> uint256) buy_thresholds;\\n\\n\\n    constructor(\\n        address _owner,\\n        IERC20Full _collateral,\\n        uint256 _shareFactor,\\n        FeePot _feePot,\\n        uint256[3] memory _fees, // staker, settlement, protocol\\n        address _protocol\\n    ) {\\n        owner = _owner; // controls fees for new markets\\n        collateral = _collateral;\\n        shareFactor = _shareFactor;\\n        feePot = _feePot;\\n        stakerFee = _fees[0];\\n        settlementFee = _fees[1];\\n        protocolFee = _fees[2];\\n        protocol = _protocol;\\n\\n        _collateral.approve(address(_feePot), MAX_UINT);\\n\\n        // First market is always empty so that marketid zero means \\\"no market\\\"\\n        markets.push(makeEmptyMarket());\\n\\n        //FOR TESTING ONLY\\n        buy_thresholds[0] = MAX_UINT;\\n        buy_thresholds[1] = MAX_UINT; \\n        buy_thresholds[2] = MAX_UINT; \\n    }\\n        \\n\\n   // function quantityAvailable(uint256 marketId)\\n\\n    //Called by lendingpool when market is created i.e , and when loan is approved \\n    function handleAssessment(uint256 _marketId, bool startAssessing) \\n    external\\n    //onlyController\\n     {\\n        bool market_inAssessment = startAssessing? true : false; \\n        inAssessment[_marketId] = market_inAssessment; \\n    }\\n    function handleOnlyReputable(uint256 _marketId)\\n    external \\n    //onlyController\\n    {\\n\\n    }\\n    //Called by controller after assessment phase \\n    function set_buy_threshold(uint256 _marketId, uint256 threshold)\\n    external \\n    //onlyController\\n    {\\n        buy_thresholds[_marketId] = threshold;\\n    }\\n\\n    function get_buy_threshold(uint256 _marketId) external view returns(uint256){\\n        return buy_thresholds[_marketId]; \\n    }\\n    function isInAssessment(uint256 _marketId) external view returns(bool){\\n        return inAssessment[_marketId]; \\n    }\\n\\n    function onlyReputable(uint256 _marketId) external view returns(bool){\\n        return false;\\n    }\\n    function logTrade(uint256 _marketId, uint256 _outcome, uint256 _collateralIn) external {\\n        TradeDetails[_marketId][_outcome] = TradeDetails[_marketId][_outcome] + _collateralIn; \\n\\n    }\\n\\n    function getTradeDetails(uint256 _marketId, uint256 _outcome) external view returns(uint256){\\n        return TradeDetails[_marketId][_outcome]; \\n    }\\n\\n\\n\\n\\n    // Returns an empty struct if the market doesn't exist.\\n    // Can check market existence before calling this by comparing _id against markets.length.\\n    // Can check market existence of the return struct by checking that shareTokens[0] isn't the null address\\n    function getMarket(uint256 _id) public view returns (Market memory) {\\n        if (_id >= markets.length) {\\n            return makeEmptyMarket();\\n        } else {\\n            return markets[_id];\\n        }\\n    }\\n\\n    function marketCount() public view returns (uint256) {\\n        return markets.length; //+ zcbmarkets.length;\\n    }\\n\\n    // Returns factory-specific details about a market.\\n    // function getMarketDetails(uint256 _id) public view returns (MarketDetails memory);\\n\\n    function mintShares(\\n        uint256 _id,\\n        uint256 _shareToMint,\\n        address _receiver\\n    ) public {\\n        require(markets.length > _id);\\n        require(markets[_id].active);\\n\\n        uint256 _cost = calcCost(_shareToMint);\\n        collateral.transferFrom(msg.sender, address(this), _cost);\\n\\n        Market memory _market = markets[_id];\\n        for (uint256 _i = 0; _i < _market.shareTokens.length; _i++) {\\n            _market.shareTokens[_i].trustedMint(_receiver, _shareToMint);\\n        }\\n\\n        emit SharesMinted(_id, _shareToMint, _receiver);\\n    }\\n\\n    function burnShares(\\n        uint256 _id,\\n        uint256 _sharesToBurn,\\n        address _receiver\\n    ) public returns (uint256) {\\n        require(markets.length > _id);\\n        require(markets[_id].active);\\n\\n        Market memory _market = markets[_id];\\n        for (uint256 _i = 0; _i < _market.shareTokens.length; _i++) {\\n            // errors if sender doesn't have enough shares\\n            _market.shareTokens[_i].trustedBurn(msg.sender, _sharesToBurn);\\n        }\\n\\n        uint256 _payout = calcCost(_sharesToBurn);\\n        uint256 _protocolFee = _payout.mul(_market.protocolFee).div(10**18);\\n        uint256 _stakerFee = _payout.mul(_market.stakerFee).div(10**18);\\n        _payout = _payout.sub(_protocolFee).sub(_stakerFee);\\n\\n        accumulatedProtocolFee += _protocolFee;\\n        collateral.transfer(_receiver, _payout);\\n        feePot.depositFees(_stakerFee);\\n\\n        emit SharesBurned(_id, _sharesToBurn, msg.sender);\\n        return _payout;\\n    }\\n\\n    function claimWinnings(uint256 _id, address _receiver) public returns (uint256) {\\n        require(isMarketResolved(_id), \\\"market unresolved\\\");\\n\\n        Market memory _market = markets[_id];\\n        uint256 _winningShares = _market.winner.trustedBurnAll(msg.sender);\\n        _winningShares = (_winningShares / shareFactor) * shareFactor; // remove unusable dust\\n\\n        uint256 _payout = calcCost(_winningShares); // will fail if there are no winnings to claim\\n        uint256 _settlementFee = _payout.mul(_market.settlementFee).div(10**18);\\n        _payout = _payout.sub(_settlementFee);\\n\\n        accumulatedSettlementFees[_market.settlementAddress] += _settlementFee;\\n        collateral.transfer(_receiver, _payout);\\n\\n        uint256 _winningIndex = _market.winnerIndex;\\n        string memory _winningName = _market.winner.name();\\n\\n        emit WinningsClaimed(\\n            _id,\\n            address(_market.winner),\\n            _winningIndex,\\n            _winningName,\\n            _winningShares,\\n            _settlementFee,\\n            _payout,\\n            _receiver\\n        );\\n        return _payout;\\n    }\\n\\n    function claimManyWinnings(uint256[] memory _ids, address _receiver) public returns (uint256) {\\n        uint256 _totalWinnings = 0;\\n        for (uint256 i = 0; i < _ids.length; i++) {\\n            _totalWinnings = _totalWinnings.add(claimWinnings(_ids[i], _receiver));\\n        }\\n        return _totalWinnings;\\n    }\\n\\n    function claimSettlementFees(address _receiver) public returns (uint256) {\\n        uint256 _fees = accumulatedSettlementFees[msg.sender];\\n        if (_fees > 0) {\\n            accumulatedSettlementFees[msg.sender] = 0;\\n            collateral.transfer(_receiver, _fees);\\n        }\\n        return _fees;\\n    }\\n\\n    function claimProtocolFees() public returns (uint256) {\\n        require(msg.sender == protocol || msg.sender == address(this));\\n        uint256 _fees = accumulatedProtocolFee;\\n        if (_fees > 0) {\\n            accumulatedProtocolFee = 0;\\n            collateral.transfer(protocol, _fees);\\n        }\\n        return _fees;\\n    }\\n\\n    function setSettlementFee(uint256 _newFee) external onlyOwner {\\n        settlementFee = _newFee;\\n    }\\n\\n    function setStakerFee(uint256 _newFee) external onlyOwner {\\n        stakerFee = _newFee;\\n    }\\n\\n    function setProtocolFee(uint256 _newFee) external onlyOwner {\\n        protocolFee = _newFee;\\n    }\\n\\n    function setProtocol(address _newProtocol, bool _claimFirst) external onlyOwner {\\n        if (_claimFirst) {\\n            claimProtocolFees();\\n        }\\n        protocol = _newProtocol;\\n    }\\n\\n\\n    function startMarket(\\n        address _settlementAddress,\\n        string[] memory _names,\\n        uint256[] memory _initialOdds,\\n        bool _active\\n    ) internal returns (uint256 _marketId) {\\n        _marketId = markets.length;\\n        markets.push(\\n            Market(\\n                _settlementAddress,\\n                createShareTokens(_names, address(this)),\\n                OwnedERC20(address(0)),\\n                0,\\n                settlementFee,\\n                protocolFee,\\n                stakerFee,\\n                block.timestamp,\\n                0,\\n                _initialOdds,\\n                _active\\n            )\\n        );\\n        emit MarketCreated(_marketId, _names, _initialOdds);\\n        if (_active) {\\n            emit MarketActivated(_marketId);\\n        }\\n    }\\n       \\n    \\n    function activateMarket(uint256 _marketId) internal {\\n        markets[_marketId].active = true;\\n        emit MarketActivated(_marketId);\\n    }\\n\\n    function makeEmptyMarket() private pure returns (Market memory) {\\n        OwnedERC20[] memory _tokens = new OwnedERC20[](0);\\n        uint256[] memory _initialOdds = new uint256[](0);\\n        return Market(address(0), _tokens, OwnedERC20(address(0)), 0, 0, 0, 0, 0, 0, _initialOdds, false);\\n    }\\n\\n\\n    function endMarket(uint256 _marketId, uint256 _winningOutcome) internal {\\n        Market storage _market = markets[_marketId];\\n        OwnedERC20 _winner = _market.shareTokens[_winningOutcome];\\n\\n        _market.winner = _winner;\\n        _market.active = false;\\n        _market.winnerIndex = _winningOutcome;\\n        _market.resolutionTimestamp = block.timestamp;\\n        string memory _outcomeName = _winner.name();\\n        emit MarketResolved(_marketId, address(_winner), _winningOutcome, _outcomeName);\\n    }\\n\\n    function isMarketResolved(uint256 _id) public view returns (bool) {\\n        Market memory _market = markets[_id];\\n        return _market.winner != OwnedERC20(address(0));\\n    }\\n\\n    // shares => collateral\\n    // Shares must be both greater than (or equal to) and divisible by shareFactor.\\n    function calcCost(uint256 _shares) public view returns (uint256) {\\n        require(_shares >= shareFactor && _shares % shareFactor == 0);\\n        return _shares / shareFactor;\\n    }\\n\\n    // collateral => shares\\n    function calcShares(uint256 _collateralIn) public view returns (uint256) {\\n        return _collateralIn * shareFactor;\\n    }\\n\\n    function onTransferOwnership(address, address) internal override {}\\n\\n    /**\\n     @notice \\n     */\\n    function startZCBMarket(\\n        address _settlementAddress,\\n        uint256[] memory _initialOdds,\\n        bool _active,\\n        OwnedERC20[] memory _zcb\\n    ) internal returns (uint256 _marketId){\\n\\n        _marketId = markets.length;\\n        // OwnedERC20[] memory zcb = new OwnedERC20[](2);\\n        // zcb[0] = _zcb;\\n        markets.push(\\n            Market(\\n                _settlementAddress,\\n                _zcb,\\n                OwnedERC20(address(0)),\\n                0,\\n                settlementFee,\\n                protocolFee,\\n                stakerFee,\\n                block.timestamp,\\n                0,\\n                _initialOdds,\\n                _active\\n                )\\n            );\\n\\n        if (_active) {\\n            emit MarketActivated(_marketId);\\n        }\\n\\n    }\\n\\n    function getZCBMarket(uint256 _id) public view returns (Market memory) {\\n        if (_id >= markets.length) {\\n           revert(\\\"Market Not Activated\\\");\\n        } else {\\n            return markets[_id];\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xdfd0469868be1d9333baf53d7451c38fac437e433230c2f9a337c4581b5742f8\",\"license\":\"MIT\"},\"contracts/turbo/FeePot.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\nimport \\\"../libraries/IERC20Full.sol\\\";\\n\\ncontract FeePot is ERC20 {\\n    using SafeMath for uint256;\\n\\n    uint256 internal constant magnitude = 2**128;\\n\\n    IERC20Full public collateral;\\n    IERC20Full public reputationToken;\\n\\n    uint256 public magnifiedFeesPerShare;\\n\\n    mapping(address => uint256) public magnifiedFeesCorrections;\\n    mapping(address => uint256) public storedFees;\\n\\n    uint256 public feeReserve;\\n\\n    constructor(IERC20Full _collateral, IERC20Full _reputationToken)\\n        ERC20(\\n            string(abi.encodePacked(\\\"S_\\\", _reputationToken.symbol())),\\n            string(abi.encodePacked(\\\"S_\\\", _reputationToken.symbol()))\\n        )\\n    {\\n        collateral = _collateral;\\n        reputationToken = _reputationToken;\\n\\n        require(_collateral != IERC20Full(address(0)));\\n    }\\n\\n    function depositFees(uint256 _amount) public returns (bool) {\\n        collateral.transferFrom(msg.sender, address(this), _amount);\\n        uint256 _totalSupply = totalSupply(); // after collateral.transferFrom to prevent reentrancy causing stale totalSupply\\n        if (_totalSupply == 0) {\\n            feeReserve = feeReserve.add(_amount);\\n            return true;\\n        }\\n        if (feeReserve > 0) {\\n            _amount = _amount.add(feeReserve);\\n            feeReserve = 0;\\n        }\\n        magnifiedFeesPerShare = magnifiedFeesPerShare.add((_amount).mul(magnitude) / _totalSupply);\\n        return true;\\n    }\\n\\n    function withdrawableFeesOf(address _owner) public view returns (uint256) {\\n        return earnedFeesOf(_owner).add(storedFees[_owner]);\\n    }\\n\\n    function earnedFeesOf(address _owner) public view returns (uint256) {\\n        uint256 _ownerBalance = balanceOf(_owner);\\n        uint256 _magnifiedFees = magnifiedFeesPerShare.mul(_ownerBalance);\\n        return _magnifiedFees.sub(magnifiedFeesCorrections[_owner]) / magnitude;\\n    }\\n\\n    function _transfer(\\n        address _from,\\n        address _to,\\n        uint256 _amount\\n    ) internal override {\\n        storedFees[_from] = storedFees[_from].add(earnedFeesOf(_from));\\n        super._transfer(_from, _to, _amount);\\n\\n        magnifiedFeesCorrections[_from] = magnifiedFeesPerShare.mul(balanceOf(_from));\\n        magnifiedFeesCorrections[_to] = magnifiedFeesCorrections[_to].add(magnifiedFeesPerShare.mul(_amount));\\n    }\\n\\n    function stake(uint256 _amount) external returns (bool) {\\n        reputationToken.transferFrom(msg.sender, address(this), _amount);\\n        _mint(msg.sender, _amount);\\n        magnifiedFeesCorrections[msg.sender] = magnifiedFeesCorrections[msg.sender].add(\\n            magnifiedFeesPerShare.mul(_amount)\\n        );\\n        return true;\\n    }\\n\\n    function exit(uint256 _amount) external returns (bool) {\\n        redeemInternal(msg.sender);\\n        _burn(msg.sender, _amount);\\n        reputationToken.transfer(msg.sender, _amount);\\n        magnifiedFeesCorrections[msg.sender] = magnifiedFeesPerShare.mul(balanceOf(msg.sender));\\n        return true;\\n    }\\n\\n    function redeem() public returns (bool) {\\n        redeemInternal(msg.sender);\\n        magnifiedFeesCorrections[msg.sender] = magnifiedFeesPerShare.mul(balanceOf(msg.sender));\\n        return true;\\n    }\\n\\n    function redeemInternal(address _account) internal {\\n        uint256 _withdrawableFees = withdrawableFeesOf(_account);\\n        if (_withdrawableFees > 0) {\\n            storedFees[_account] = 0;\\n            collateral.transfer(_account, _withdrawableFees);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x35a2aa230007983b91a3bf432412cb3f3d497464e911e5c640a6d541f612f8a8\",\"license\":\"MIT\"},\"contracts/turbo/OwnedShareToken.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"../libraries/Ownable.sol\\\";\\n\\ncontract OwnedERC20 is ERC20, Ownable {\\n    constructor(\\n        string memory name_,\\n        string memory symbol_,\\n        address _owner\\n    ) ERC20(name_, symbol_) {\\n        owner = _owner;\\n    }\\n\\n    function trustedTransfer(\\n        address _from,\\n        address _to,\\n        uint256 _amount\\n    ) external onlyOwner {\\n        _transfer(_from, _to, _amount);\\n    }\\n\\n    function trustedMint(address _target, uint256 _amount) external virtual onlyOwner {\\n        _mint(_target, _amount);\\n    }\\n\\n    function trustedBurn(address _target, uint256 _amount) external virtual onlyOwner {\\n        _burn(_target, _amount);\\n    }\\n\\n    function trustedBurnAll(address _target) external onlyOwner returns (uint256) {\\n        uint256 _balance = balanceOf(_target);\\n        _burn(_target, _balance);\\n        return _balance;\\n    }\\n\\n    function onTransferOwnership(address, address) internal override {}\\n}\\n\",\"keccak256\":\"0xffd1670bd35f6feb4de1aa683a23c171031666e4356cff6f7c93df6d2aa5b78c\",\"license\":\"MIT\"},\"contracts/turbo/TrustedMarketFactoryV3.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"./AbstractMarketFactoryV3.sol\\\";\\nimport \\\"../libraries/CalculateLinesToBPoolOdds.sol\\\";\\nimport \\\"../libraries/Versioned.sol\\\";\\n\\ncontract TrustedMarketFactoryV3 is AbstractMarketFactoryV3, CalculateLinesToBPoolOdds, Versioned {\\n\\n    struct MarketDetails {\\n        string description;\\n    }\\n    MarketDetails[] internal marketDetails;\\n    // mapping(uint256=> mapping(uint256=>uint256)) TradeDetails; //marketid -> (outcome->amount)\\n\\n    modifier onlyOwnerManager() {\\n        require(msg.sender == owner || managers[msg.sender] , \\\"Only Validators can call this function\\\");\\n        _;\\n    }\\n\\n    mapping(address=>bool) managers; \\n\\n    constructor(\\n        address _owner,\\n        IERC20Full _collateral,\\n        uint256 _shareFactor,\\n        FeePot _feePot,\\n        uint256[3] memory _fees,\\n        address _protocol\\n    ) AbstractMarketFactoryV3(_owner, _collateral, _shareFactor, _feePot, _fees, _protocol) Versioned(\\\"v1.1.0\\\") {}\\n\\n    //TODO add managers \\n    function createMarket(\\n        address _creator,\\n        string calldata _description,\\n        string[] calldata _names,\\n        uint256[] calldata _odds\\n    ) public  returns (uint256) {\\n        marketDetails.push(MarketDetails(_description));\\n        return startMarket(_creator, _names, _odds, true);\\n    }\\n\\n    //TODO add managers \\n    function trustedResolveMarket(uint256 _id, uint256 _winningOutcome) public {\\n        endMarket(_id, _winningOutcome);\\n    }\\n\\n    function getMarketDetails(uint256 _id) public view returns (MarketDetails memory) {\\n        return marketDetails[_id];\\n    }\\n\\n    function getRewardEndTime(uint256 _marketId) public view override returns (uint256) {\\n        return 0;\\n    }\\n    \\n\\n    //ZCB markets\\n      function createZCBMarket(\\n        address _creator,\\n        string calldata _description,\\n        OwnedERC20[] memory zcb\\n    ) public  returns (uint256) {\\n        uint256[] memory odds = new uint256[](2); //TODO get rid of this \\n        odds[0] = 0;\\n        odds[1] = 0; \\n\\n        marketDetails.push(MarketDetails(_description));\\n        return startZCBMarket(_creator, odds, true, zcb);\\n    }\\n}\",\"keccak256\":\"0x23f7dcad36bf862dd1aa12379f56f24a136ac918a97636565a1c3efc86bb14db\",\"license\":\"MIT\"},\"contracts/turbo/TurboShareTokenFactory.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"./OwnedShareToken.sol\\\";\\n\\n\\n\\nabstract contract ZCBFactory {\\n    function createZCB(string memory _name, address _owner) internal returns(OwnedERC20[] memory){\\n        uint256 _numOutcomes = 1; \\n        OwnedERC20[] memory _tokens = new OwnedERC20[](_numOutcomes);\\n\\n        for (uint256 _i = 0; _i < _numOutcomes; _i++) {\\n            _tokens[_i] = new OwnedERC20(_name, _name, _owner);\\n        }\\n        return _tokens; \\n    }\\n}\\n\\n\\nabstract contract TurboShareTokenFactory {\\n    function createShareTokens(string[] memory _names, address _owner) internal returns (OwnedERC20[] memory) {\\n        uint256 _numOutcomes = _names.length;\\n        OwnedERC20[] memory _tokens = new OwnedERC20[](_numOutcomes);\\n\\n        for (uint256 _i = 0; _i < _numOutcomes; _i++) {\\n            _tokens[_i] = new OwnedERC20(_names[_i], _names[_i], _owner);\\n        }\\n        return _tokens;\\n    }\\n}\\n\\nabstract contract TurboShareTokenFactoryV1 {\\n    function createShareTokens(\\n        string[] memory _names,\\n        string[] memory _symbols,\\n        address _owner\\n    ) internal returns (OwnedERC20[] memory) {\\n        uint256 _numOutcomes = _names.length;\\n        OwnedERC20[] memory _tokens = new OwnedERC20[](_numOutcomes);\\n\\n        for (uint256 _i = 0; _i < _numOutcomes; _i++) {\\n            _tokens[_i] = new OwnedERC20(_names[_i], _symbols[_i], _owner);\\n        }\\n        return _tokens;\\n    }\\n}\\n\",\"keccak256\":\"0xa089ab77c0ac34afa00ff09eab3aa7da9ec009c2def9f44ad5ffb86150f53069\",\"license\":\"MIT\"},\"contracts/vaults/auth/Auth.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Provides a flexible and updatable auth pattern which is completely separate from application logic.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Auth.sol)\\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)\\nabstract contract Auth {\\n    event OwnerUpdated(address indexed user, address indexed newOwner);\\n\\n    event AuthorityUpdated(address indexed user, Authority indexed newAuthority);\\n\\n    address public owner;\\n\\n    Authority public authority;\\n    mapping(address=>bool) Authorized; \\n\\n    constructor(address _owner) {\\n        owner = _owner;\\n\\n        emit OwnerUpdated(msg.sender, _owner);\\n    }\\n\\n    modifier requiresAuth() virtual {\\n        require(isAuthorized(msg.sender, msg.sig), \\\"UNAUTHORIZED\\\");\\n\\n        _;\\n    }\\n\\n    function isAuthorized(address user, bytes4 functionSig) internal view virtual returns (bool) {\\n        //Authority auth = authority; // Memoizing authority saves us a warm SLOAD, around 100 gas.\\n\\n        // Checking if the caller is the owner only after calling the authority saves gas in most cases, but be\\n        // aware that this makes protected functions uncallable even to the owner if the authority is out of order.\\n        return(user == owner || Authorized[user]);\\n        //return (address(auth) != address(0) && auth.canCall(user, address(this), functionSig)) || user == owner;\\n    }\\n\\n    function setNewAuthority(address newAuthority) public {\\n        require(msg.sender == owner );\\n        Authorized[newAuthority] = true; \\n\\n    }\\n\\n    function setAuthority(Authority newAuthority) public virtual {\\n        // We check if the caller is the owner first because we want to ensure they can\\n        // always swap out the authority even if it's reverting or using up a lot of gas.\\n        require(msg.sender == owner || authority.canCall(msg.sender, address(this), msg.sig));\\n\\n        authority = newAuthority;\\n\\n        emit AuthorityUpdated(msg.sender, newAuthority);\\n    }\\n\\n    function setOwner(address newOwner) public virtual requiresAuth {\\n        owner = newOwner;\\n\\n        emit OwnerUpdated(msg.sender, newOwner);\\n    }\\n}\\n\\n/// @notice A generic interface for a contract which provides authorization data to an Auth instance.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Auth.sol)\\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)\\ninterface Authority {\\n    function canCall(\\n        address user,\\n        address target,\\n        bytes4 functionSig\\n    ) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x46c0e8d518396b50d7dc7f0050d716a5643afad9320b0cd27490fd8e00689dc7\",\"license\":\"AGPL-3.0-only\"},\"contracts/vaults/instrument.sol\":{\"content\":\"\\n// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.4;\\n\\nimport \\\"./vault.sol\\\";\\nimport {ERC20} from \\\"./tokens/ERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\nimport \\\"../prb/PRBMathUD60x18.sol\\\";\\n\\n\\n/// @notice Minimal interface for Vault compatible strategies.\\nabstract contract Instrument {\\n\\n    modifier onlyUtilizer() {\\n        require(msg.sender == Utilizer, \\\"!Utilizer\\\");\\n        _;\\n    }\\n\\n    modifier onlyAuthorized() {\\n        require(msg.sender == Utilizer || msg.sender == vault.owner(), \\\"!authorized\\\");\\n        _;\\n    }\\n\\n    modifier onlyVault() {\\n        require(msg.sender == address(vault), \\\"caller must be vault\\\");\\n        _;\\n    }\\n\\n    constructor (\\n        address _vault,\\n        address _Utilizer\\n    ) {\\n        vault = Vault(_vault);\\n        underlying = ERC20(vault.UNDERLYING());\\n        underlying.approve(_vault, MAX_UINT); // Give Vault unlimited access \\n        Utilizer = _Utilizer;\\n    }\\n\\n\\n    ERC20 public underlying;\\n    Vault public vault; \\n    uint256 private constant MAX_UINT = 2**256 - 1;\\n\\n    /// @notice address of user who submits the liquidity proposal \\n    address Utilizer; \\n\\n    /// @notice initializes a new Instrument\\n    /// DEPRECATED\\n    function _initialize(\\n        address _vault,\\n        address _Utilizer\\n    ) internal {\\n        vault = Vault(_vault);\\n        underlying = ERC20(vault.UNDERLYING());\\n        underlying.approve(_vault, MAX_UINT); // Give Vault unlimited access \\n        Utilizer = _Utilizer;\\n\\n    }\\n\\n    /**\\n     @notice hooks for approval logic that are specific to each instrument type, called by controller for approval/default logic\\n     */\\n    function onMarketApproval() virtual external {}\\n\\n    function setUtilizer(address _Utilizer) external onlyAuthorized {\\n        require(_Utilizer != address(0));\\n        Utilizer = _Utilizer;\\n    }\\n\\n\\n    /// @notice Withdraws a specific amount of underlying tokens from the Instrument.\\n    /// @param amount The amount of underlying tokens to withdraw.\\n    /// @return An error code, or 0 if the withdrawal was successful.\\n    function redeemUnderlying(uint256 amount) external onlyVault returns (bool){\\n        return underlying.transfer(address(vault), amount); \\n    }\\n\\n    /// @notice Returns a user's Instrument balance in underlying tokens.\\n    /// @param user The user to get the underlying balance of.\\n    /// @return The user's Instrument balance in underlying tokens.\\n    /// @dev May mutate the state of the Instrument by accruing interest.\\n    function balanceOfUnderlying(address user) external view returns (uint256){\\n        return underlying.balanceOf(user); \\n        }\\n}\\n\\n\\n\\n/// @notice Simple Instrument that provides USDC on stableswap 3pool \\n// contract Curve3pool_Instrument is Instrument{\\n\\n//     /// @notice invests amount into Instrument \\n//     function invest(uint256 amount ) external \\n//     //onlyGuardian \\n//     {   \\n//         require(this.balanceOfUnderlying(address(this)) >= amount);\\n//         _invest(amount);  \\n\\n//     }\\n\\n//     function _invest(uint256 _amount) internal {\\n\\n//     }\\n\\n\\n\\n// }\\n\\n\\n/// @notice Instrument that a) lends usdc fix rate at notional.finance and get zcb\\n/// b) use that zcb as collateral to borrow fiat from fiatdao, c) swap fiat dao to usdc\\n/// d) repeat\\n// contract LeveragedFixedRate_Instrument is Instrument{\\n\\n// }\\n\\n// /// @notice Instrument that lends to risky collateral in fuse pools\\n// contract RariLend_Instrument is Instrument{\\n\\n// }\\n\\n\\n\\n \\n/// @notice Contract for unsecured loans, each instance will be associated to a borrower+marketId\\n/// approved borrowers will interact with this contract to borrow, repay. \\n/// and vault will supply principal and harvest principal/interest \\ncontract CreditLine is Instrument {\\n    using PRBMathUD60x18 for uint256;\\n\\n    //  variables initiated at creation\\n    uint256  principal;\\n    uint256  interestAPR; \\n    uint256  faceValue; //total amount due, i.e principal+interest\\n    uint256  duration; \\n\\n    // Modify-able Variables during repayments, borrow\\n    uint256 totalOwed; \\n    uint256 principalOwed; \\n    uint256 interestOwed;\\n\\n    constructor(\\n        address vault,\\n        address borrower, \\n        uint256 _principal,\\n        uint256 _interestAPR, \\n        uint256 _duration,\\n        uint256 _faceValue\\n    ) public Instrument(vault, borrower){\\n        principal = _principal; \\n        interestAPR = _interestAPR; \\n        duration = _duration;   \\n        faceValue = _faceValue;\\n        interestOwed = faceValue - principal;\\n    }\\n\\n    /// @notice CreditLine contract is initiated at proposal \\n    /// @dev include any Instrument specific initialization logic  \\n    /// @param _borrower stored as Utilizer\\n    /// DEPRECATED\\n    function initialize(\\n        address _vault,\\n        address _borrower,         \\n        uint256 _principal,\\n        uint256 _interestAPR, \\n        uint256 _duration, \\n        uint256 _faceValue\\n    ) internal {\\n        _initialize(_vault, _borrower); \\n\\n        principal = _principal; \\n        interestAPR = _interestAPR; \\n        duration = _duration;   \\n        faceValue = _faceValue; \\n\\n        interestOwed = faceValue - principal; // getOwedInterest(_interestAPR, _duration); \\n    }\\n\\n    /// @notice use APR and duration to get total owed interest \\n    function getOwedInterest(uint256 APR, uint256 duration) internal pure returns(uint256 owed){\\n        return APR; \\n    }\\n\\n    /// @notice Allows a borrower to borrow on their creditline.\\n    function drawdown(uint256 amount) external onlyUtilizer{\\n        require(vault.isTrusted(this), \\\"Not approved\\\");\\n        require(underlying.balanceOf(address(this)) > amount, \\\"Exceeds Credit\\\");\\n        totalOwed += amount; \\n        principalOwed += amount; \\n        underlying.transfer(msg.sender, amount);\\n    }\\n\\n    /// @notice allows a borrower to repay their loan\\n    function repay(uint256 repay_principal, uint256 repay_interest) external onlyUtilizer{\\n        require(vault.isTrusted(this), \\\"Not approved\\\");\\n        require(repay_principal <= principalOwed, \\\"overpaid principal\\\");\\n        require(repay_interest <= interestOwed, \\\"overpaid interest\\\");\\n        underlying.transferFrom(msg.sender, address(this), repay_principal + repay_interest);\\n        handleRepay(repay_principal, repay_interest); \\n    }   \\n\\n    /// @notice updates balances after repayment\\n    /// need to remove min.\\n    function handleRepay(uint256 repay_principal, uint256 repay_interest) internal {\\n        totalOwed -= Math.min((repay_principal + repay_interest), totalOwed); \\n        principalOwed -= Math.min(repay_principal, principalOwed);\\n        interestOwed -= Math.min(repay_interest, interestOwed);\\n    }\\n}\",\"keccak256\":\"0x0eb32e273d450d6e2ddd61c6279b2697e858a27cc3d17d7f09c332beae4b53f4\",\"license\":\"AGPL-3.0-only\"},\"contracts/vaults/mixins/ERC4626.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"../tokens/ERC20.sol\\\";\\n// import {ERC20} from \\\"../../ERC20/ERC20.sol\\\";\\nimport \\\"hardhat/console.sol\\\";\\nimport {SafeTransferLib} from \\\"../utils/SafeTransferLib.sol\\\";\\nimport {FixedPointMathLib} from \\\"../utils/FixedPointMathLib.sol\\\";\\n\\n/// @notice Minimal ERC4626 tokenized Vault implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/mixins/ERC4626.sol)\\nabstract contract ERC4626 is ERC20 {\\n    using SafeTransferLib for ERC20;\\n    using FixedPointMathLib for uint256;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Deposit(address indexed caller, address indexed owner, uint256 assets, uint256 shares);\\n\\n    event Withdraw(\\n        address indexed caller,\\n        address indexed receiver,\\n        address indexed owner,\\n        uint256 assets,\\n        uint256 shares\\n    );\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               IMMUTABLES\\n    //////////////////////////////////////////////////////////////*/\\n\\n    ERC20 public immutable asset;\\n\\n    constructor(\\n        ERC20 _asset,\\n        string memory _name,\\n        string memory _symbol\\n    ) ERC20(_name, _symbol, _asset.decimals()) {\\n        asset = _asset;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        DEPOSIT/WITHDRAWAL LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function deposit(uint256 assets, address receiver) public virtual returns (uint256 shares) {\\n        // Check for rounding error since we round down in previewDeposit.\\n        require((shares = previewDeposit(assets)) != 0, \\\"ZERO_SHARES\\\");\\n\\n        // Need to transfer before minting or ERC777s could reenter.\\n        asset.safeTransferFrom(msg.sender, address(this), assets);\\n\\n        _mint(receiver, shares);\\n\\n        emit Deposit(msg.sender, receiver, assets, shares);\\n\\n        afterDeposit(assets, shares);\\n    }\\n\\n    function mint(uint256 shares, address receiver) public virtual returns (uint256 assets) {\\n        assets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\\n\\n        // Need to transfer before minting or ERC777s could reenter.\\n        asset.safeTransferFrom(msg.sender, address(this), assets);\\n   \\n        _mint(receiver, shares);\\n\\n        emit Deposit(msg.sender, receiver, assets, shares);\\n\\n        afterDeposit(assets, shares);\\n    }\\n\\n    function withdraw(\\n        uint256 assets,\\n        address receiver,\\n        address owner\\n    ) public virtual returns (uint256 shares) {\\n        shares = previewWithdraw(assets); // No need to check for rounding error, previewWithdraw rounds up.\\n\\n        if (msg.sender != owner) {\\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\\n\\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\\n        }\\n\\n        beforeWithdraw(assets, shares);\\n\\n        _burn(owner, shares);\\n\\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\\n\\n        asset.safeTransfer(receiver, assets);\\n    }\\n\\n    function redeem(\\n        uint256 shares,\\n        address receiver,\\n        address owner\\n    ) public virtual returns (uint256 assets) {\\n        if (msg.sender != owner) {\\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\\n\\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\\n        }\\n\\n        // Check for rounding error since we round down in previewRedeem.\\n        require((assets = previewRedeem(shares)) != 0, \\\"ZERO_ASSETS\\\");\\n\\n        beforeWithdraw(assets, shares);\\n\\n        _burn(owner, shares);\\n\\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\\n\\n        asset.safeTransfer(receiver, assets);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            ACCOUNTING LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function totalAssets() public view virtual returns (uint256);\\n\\n    function convertToShares(uint256 assets) public view virtual returns (uint256) {\\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\\n\\n        return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());\\n    }\\n\\n    function convertToAssets(uint256 shares) public view virtual returns (uint256) {\\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\\n\\n        return supply == 0 ? shares : shares.mulDivDown(totalAssets(), supply);\\n    }\\n\\n    function previewDeposit(uint256 assets) public view virtual returns (uint256) {\\n        return convertToShares(assets);\\n    }\\n\\n    function previewMint(uint256 shares) public view virtual returns (uint256) {\\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\\n\\n        return supply == 0 ? shares : shares.mulDivUp(totalAssets(), supply);\\n    }\\n\\n    function previewWithdraw(uint256 assets) public view virtual returns (uint256) {\\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\\n\\n        return supply == 0 ? assets : assets.mulDivUp(supply, totalAssets());\\n    }\\n\\n    function previewRedeem(uint256 shares) public view virtual returns (uint256) {\\n        return convertToAssets(shares);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                     DEPOSIT/WITHDRAWAL LIMIT LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function maxDeposit(address) public view virtual returns (uint256) {\\n        return type(uint256).max;\\n    }\\n\\n    function maxMint(address) public view virtual returns (uint256) {\\n        return type(uint256).max;\\n    }\\n\\n    function maxWithdraw(address owner) public view virtual returns (uint256) {\\n        return convertToAssets(balanceOf[owner]);\\n    }\\n\\n    function maxRedeem(address owner) public view virtual returns (uint256) {\\n        return balanceOf[owner];\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                          INTERNAL HOOKS LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function beforeWithdraw(uint256 assets, uint256 shares) internal virtual {}\\n\\n    function afterDeposit(uint256 assets, uint256 shares) internal virtual {}\\n}\\n\",\"keccak256\":\"0xe647a3196ee460c1f8f855c4c0982d2896ec8b3287367622716265ecfe5d4748\",\"license\":\"AGPL-3.0-only\"},\"contracts/vaults/tokens/ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            address recoveredAddress = ecrecover(\\n                keccak256(\\n                    abi.encodePacked(\\n                        \\\"\\\\x19\\\\x01\\\",\\n                        DOMAIN_SEPARATOR(),\\n                        keccak256(\\n                            abi.encode(\\n                                keccak256(\\n                                    \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n                                ),\\n                                owner,\\n                                spender,\\n                                value,\\n                                nonces[owner]++,\\n                                deadline\\n                            )\\n                        )\\n                    )\\n                ),\\n                v,\\n                r,\\n                s\\n            );\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\",\"keccak256\":\"0xcdfd8db76b2a3415620e4d18cc5545f3d50de792dbf2c3dd5adb40cbe6f94b10\",\"license\":\"AGPL-3.0-only\"},\"contracts/vaults/utils/FixedPointMathLib.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Arithmetic library with operations for fixed-point numbers.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\\nlibrary FixedPointMathLib {\\n    /*//////////////////////////////////////////////////////////////\\n                    SIMPLIFIED FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\\n\\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\\n    }\\n\\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\\n    }\\n\\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\\n    }\\n\\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                    LOW LEVEL FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function mulDivDown(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            // Store x * y in z for now.\\n            z := mul(x, y)\\n\\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\\n                revert(0, 0)\\n            }\\n\\n            // Divide z by the denominator.\\n            z := div(z, denominator)\\n        }\\n    }\\n\\n    function mulDivUp(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            // Store x * y in z for now.\\n            z := mul(x, y)\\n\\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\\n                revert(0, 0)\\n            }\\n\\n            // First, divide z - 1 by the denominator and add 1.\\n            // We allow z - 1 to underflow if z is 0, because we multiply the\\n            // end result by 0 if z is zero, ensuring we return 0 if z is zero.\\n            z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))\\n        }\\n    }\\n\\n    function rpow(\\n        uint256 x,\\n        uint256 n,\\n        uint256 scalar\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            switch x\\n            case 0 {\\n                switch n\\n                case 0 {\\n                    // 0 ** 0 = 1\\n                    z := scalar\\n                }\\n                default {\\n                    // 0 ** n = 0\\n                    z := 0\\n                }\\n            }\\n            default {\\n                switch mod(n, 2)\\n                case 0 {\\n                    // If n is even, store scalar in z for now.\\n                    z := scalar\\n                }\\n                default {\\n                    // If n is odd, store x in z for now.\\n                    z := x\\n                }\\n\\n                // Shifting right by 1 is like dividing by 2.\\n                let half := shr(1, scalar)\\n\\n                for {\\n                    // Shift n right by 1 before looping to halve it.\\n                    n := shr(1, n)\\n                } n {\\n                    // Shift n right by 1 each iteration to halve it.\\n                    n := shr(1, n)\\n                } {\\n                    // Revert immediately if x ** 2 would overflow.\\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\\n                    if shr(128, x) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Store x squared.\\n                    let xx := mul(x, x)\\n\\n                    // Round to the nearest number.\\n                    let xxRound := add(xx, half)\\n\\n                    // Revert if xx + half overflowed.\\n                    if lt(xxRound, xx) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Set x to scaled xxRound.\\n                    x := div(xxRound, scalar)\\n\\n                    // If n is even:\\n                    if mod(n, 2) {\\n                        // Compute z * x.\\n                        let zx := mul(z, x)\\n\\n                        // If z * x overflowed:\\n                        if iszero(eq(div(zx, x), z)) {\\n                            // Revert if x is non-zero.\\n                            if iszero(iszero(x)) {\\n                                revert(0, 0)\\n                            }\\n                        }\\n\\n                        // Round to the nearest number.\\n                        let zxRound := add(zx, half)\\n\\n                        // Revert if zx + half overflowed.\\n                        if lt(zxRound, zx) {\\n                            revert(0, 0)\\n                        }\\n\\n                        // Return properly scaled zxRound.\\n                        z := div(zxRound, scalar)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        GENERAL NUMBER UTILITIES\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\\n        assembly {\\n            // Start off with z at 1.\\n            z := 1\\n\\n            // Used below to help find a nearby power of 2.\\n            let y := x\\n\\n            // Find the lowest power of 2 that is at least sqrt(x).\\n            if iszero(lt(y, 0x100000000000000000000000000000000)) {\\n                y := shr(128, y) // Like dividing by 2 ** 128.\\n                z := shl(64, z) // Like multiplying by 2 ** 64.\\n            }\\n            if iszero(lt(y, 0x10000000000000000)) {\\n                y := shr(64, y) // Like dividing by 2 ** 64.\\n                z := shl(32, z) // Like multiplying by 2 ** 32.\\n            }\\n            if iszero(lt(y, 0x100000000)) {\\n                y := shr(32, y) // Like dividing by 2 ** 32.\\n                z := shl(16, z) // Like multiplying by 2 ** 16.\\n            }\\n            if iszero(lt(y, 0x10000)) {\\n                y := shr(16, y) // Like dividing by 2 ** 16.\\n                z := shl(8, z) // Like multiplying by 2 ** 8.\\n            }\\n            if iszero(lt(y, 0x100)) {\\n                y := shr(8, y) // Like dividing by 2 ** 8.\\n                z := shl(4, z) // Like multiplying by 2 ** 4.\\n            }\\n            if iszero(lt(y, 0x10)) {\\n                y := shr(4, y) // Like dividing by 2 ** 4.\\n                z := shl(2, z) // Like multiplying by 2 ** 2.\\n            }\\n            if iszero(lt(y, 0x8)) {\\n                // Equivalent to 2 ** z.\\n                z := shl(1, z)\\n            }\\n\\n            // Shifting right by 1 is like dividing by 2.\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n\\n            // Compute a rounded down version of z.\\n            let zRoundDown := div(x, z)\\n\\n            // If zRoundDown is smaller, use it.\\n            if lt(zRoundDown, z) {\\n                z := zRoundDown\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x9faabac0803e077fb8d8950f5e2fec1984d3e6cd6ad5fc144609b5c9de83d169\",\"license\":\"AGPL-3.0-only\"},\"contracts/vaults/utils/SafeCastLib.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Safe unsigned integer casting library that reverts on overflow.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeCastLib.sol)\\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeCast.sol)\\nlibrary SafeCastLib {\\n    function safeCastTo248(uint256 x) internal pure returns (uint248 y) {\\n        require(x < 1 << 248);\\n\\n        y = uint248(x);\\n    }\\n\\n    function safeCastTo224(uint256 x) internal pure returns (uint224 y) {\\n        require(x < 1 << 224);\\n\\n        y = uint224(x);\\n    }\\n\\n    function safeCastTo192(uint256 x) internal pure returns (uint192 y) {\\n        require(x < 1 << 192);\\n\\n        y = uint192(x);\\n    }\\n\\n    function safeCastTo160(uint256 x) internal pure returns (uint160 y) {\\n        require(x < 1 << 160);\\n\\n        y = uint160(x);\\n    }\\n\\n    function safeCastTo128(uint256 x) internal pure returns (uint128 y) {\\n        require(x < 1 << 128);\\n\\n        y = uint128(x);\\n    }\\n\\n    function safeCastTo96(uint256 x) internal pure returns (uint96 y) {\\n        require(x < 1 << 96);\\n\\n        y = uint96(x);\\n    }\\n\\n    function safeCastTo64(uint256 x) internal pure returns (uint64 y) {\\n        require(x < 1 << 64);\\n\\n        y = uint64(x);\\n    }\\n\\n    function safeCastTo32(uint256 x) internal pure returns (uint32 y) {\\n        require(x < 1 << 32);\\n\\n        y = uint32(x);\\n    }\\n\\n    function safeCastTo24(uint256 x) internal pure returns (uint24 y) {\\n        require(x < 1 << 24);\\n\\n        y = uint24(x);\\n    }\\n\\n    function safeCastTo8(uint256 x) internal pure returns (uint8 y) {\\n        require(x < 1 << 8);\\n\\n        y = uint8(x);\\n    }\\n}\\n\",\"keccak256\":\"0x636e0f18c1b287c9342e14660a914b37a927d9f64d6c29e27016784979ce8d59\",\"license\":\"AGPL-3.0-only\"},\"contracts/vaults/utils/SafeTransferLib.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"../tokens/ERC20.sol\\\";\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*//////////////////////////////////////////////////////////////\\n                             ETH OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        bool success;\\n\\n        assembly {\\n            // Transfer the ETH and store if it succeeded or not.\\n            success := call(gas(), to, amount, 0, 0, 0, 0)\\n        }\\n\\n        require(success, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            ERC20 OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferFrom(\\n        ERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), from) // Append the \\\"from\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FROM_FAILED\\\");\\n    }\\n\\n    function safeTransfer(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FAILED\\\");\\n    }\\n\\n    function safeApprove(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"APPROVE_FAILED\\\");\\n    }\\n}\\n\",\"keccak256\":\"0x333b56bef66ff71e3838910781df214acbeb6c2d6ace27a04ebb510f0e669300\",\"license\":\"AGPL-3.0-only\"},\"contracts/vaults/vault.sol\":{\"content\":\"pragma solidity ^0.8.4;\\n\\nimport {Auth} from \\\"./auth/Auth.sol\\\";\\nimport {ERC4626} from \\\"./mixins/ERC4626.sol\\\";\\n\\nimport {SafeCastLib} from \\\"./utils/SafeCastLib.sol\\\";\\nimport {SafeTransferLib} from \\\"./utils/SafeTransferLib.sol\\\";\\nimport {FixedPointMathLib} from \\\"./utils/FixedPointMathLib.sol\\\";\\n\\nimport {ERC20} from \\\"./tokens/ERC20.sol\\\";\\nimport {Instrument} from \\\"./instrument.sol\\\";\\nimport {Controller} from \\\"../stablecoin/controller.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\n\\n\\ncontract Vault is ERC4626, Auth{\\n\\tusing SafeCastLib for uint256; \\n    using SafeTransferLib for ERC20;\\n    using FixedPointMathLib for uint256;\\n\\n\\n    event InstrumentDeposit(address indexed user, Instrument indexed instrument, uint256 underlyingAmount);\\n    event InstrumentWithdrawal(address indexed user, Instrument indexed instrument, uint256 underlyingAmount);\\n    event InstrumentTrusted(address indexed user, Instrument indexed instrument);\\n    event InstrumentDistrusted(address indexed user, Instrument indexed instrument);\\n    event InstrumentHarvest(address indexed instrument, uint256 instrument_balance, uint256 mag, bool sign); //sign is direction of mag, + or -.\\n\\n    /*///////////////////////////////////////////////////////////////\\n                                 CONSTANTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal BASE_UNIT;\\n    uint256 totalInstrumentHoldings; //total holdings deposited into all Instruments collateral\\n    ERC20 public immutable UNDERLYING;\\n    Controller private controller;\\n\\n    mapping(Instrument => InstrumentData) public getInstrumentData;\\n    mapping(address => uint256) public  num_proposals;\\n    mapping(uint256=> Instrument) Instruments; //marketID-> Instrument\\n\\n    enum InstrumentType {\\n        CreditLine,\\n        Other\\n    }\\n\\n    /// @param trusted Whether the Instrument is trusted.\\n    /// @param balance The amount of underlying tokens held in the Instrument.\\n    struct InstrumentData {\\n        // Used to determine if the Vault will operate on a Instrument.\\n        bool trusted;\\n        // Balance of the contract denominated in Underlying, \\n        // used to determine profit and loss during harvests of the Instrument.  \\n        // represents the amount of debt the Instrument has incurred from this vault   \\n        uint248 balance; // in underlying\\n        uint256 faceValue; // in underlying\\n        uint256 marketId;\\n    \\tuint256 principal; //this is total available allowance in underlying\\n        uint256 expectedYield; // total interest paid over duration in underlying\\n        uint256 duration;\\n        string description;\\n        address Instrument_address;\\n        InstrumentType instrument_type;\\n        uint256 maturityDate;\\n    }\\n\\n    constructor(\\n        address _UNDERLYING,\\n        address _controller\\n    )\\n        ERC4626(\\n            ERC20(_UNDERLYING),\\n            string(abi.encodePacked(\\\"debita \\\", ERC20(_UNDERLYING).name(), \\\" Vault\\\")),\\n            string(abi.encodePacked(\\\"db\\\", ERC20(_UNDERLYING).symbol()))\\n        )  Auth(msg.sender)\\n\\n    {\\n        UNDERLYING = ERC20(_UNDERLYING);\\n        BASE_UNIT = 10**ERC20(_UNDERLYING).decimals();\\n        controller = Controller(_controller);\\n\\n        //totalSupply = type(uint256).max;\\n    }\\n    \\n    modifier onlyController(){\\n        require(address(controller) == msg.sender || msg.sender == owner ,  \\\"is not controller\\\"); \\n        _;\\n    }\\n\\n    /// @notice called by controller at maturity \\n    function controller_burn(uint256 amount, address bc_address) external onlyController {\\n        _burn(bc_address,amount); \\n    }\\n    /// @notice called by controller at maturity, since redeem amount > balance in bc\\n    function controller_mint(uint256 amount, address to) external onlyController {\\n        _mint(to , amount); \\n    }\\n\\n\\n\\n    /// @notice Harvest a trusted Instrument, records profit/loss \\n    function harvest(address instrument) public {\\n        require(getInstrumentData[Instrument(instrument)].trusted, \\\"UNTRUSTED_Instrument\\\");\\n        \\n        uint256 oldTotalInstrumentHoldings = totalInstrumentHoldings; \\n        \\n        uint256 balanceLastHarvest = getInstrumentData[Instrument(instrument)].balance;\\n        \\n        uint256 balanceThisHarvest = Instrument(instrument).balanceOfUnderlying(address(instrument));\\n        \\n        if (balanceLastHarvest == balanceThisHarvest) {\\n            return;\\n        }\\n        \\n        getInstrumentData[Instrument(instrument)].balance = balanceThisHarvest.safeCastTo248();\\n\\n        uint256 delta;\\n       \\n        bool net_positive = balanceThisHarvest >= balanceLastHarvest;\\n        \\n        delta = net_positive ? balanceThisHarvest - balanceLastHarvest : balanceLastHarvest - balanceThisHarvest;\\n\\n        totalInstrumentHoldings = net_positive ? oldTotalInstrumentHoldings + delta : oldTotalInstrumentHoldings - delta;\\n\\n        emit InstrumentHarvest(instrument, balanceThisHarvest, delta, net_positive);\\n    }\\n\\n    /// @notice Deposit a specific amount of float into a trusted Instrument.\\n   \\t/// Called when market is approved. \\n   \\t/// Also has the role of granting a credit line to a credit-based Instrument like uncol.loans \\n    function depositIntoInstrument(Instrument instrument, uint256 underlyingAmount) external onlyController{\\n    \\trequire(getInstrumentData[instrument].trusted, \\\"UNTRUSTED Instrument\\\");\\n    \\ttotalInstrumentHoldings += underlyingAmount; \\n\\n        getInstrumentData[instrument].balance += underlyingAmount.safeCastTo248();\\n\\n        UNDERLYING.transfer(address(instrument), underlyingAmount);\\n\\n        emit InstrumentDeposit(msg.sender, instrument, underlyingAmount);\\n    }\\n\\n    /// @notice Withdraw a specific amount of underlying tokens from a Instrument.\\n    function withdrawFromInstrument(Instrument instrument, uint256 underlyingAmount) external onlyController{\\n    \\trequire(getInstrumentData[instrument].trusted, \\\"UNTRUSTED Instrument\\\");\\n        \\n        getInstrumentData[instrument].balance -= underlyingAmount.safeCastTo248();\\n        \\n        totalInstrumentHoldings -= underlyingAmount;\\n        \\n        require(instrument.redeemUnderlying(underlyingAmount), \\\"REDEEM_FAILED\\\");\\n        \\n        emit InstrumentWithdrawal(msg.sender, instrument, underlyingAmount);\\n\\n    }\\n\\n\\n\\n    /// @notice Withdraws all underyling balance from the Instrument to the vault \\n    function withdrawAllFromInstrument(Instrument instrument) internal {\\n      uint248 total_Instrument_balance = instrument.balanceOfUnderlying(address(instrument)).safeCastTo248();\\n      \\n        uint248 current_balance =  getInstrumentData[instrument].balance;\\n      \\n        getInstrumentData[instrument].balance -= Math.min(total_Instrument_balance, current_balance).safeCastTo248();\\n      \\n        instrument.redeemUnderlying(total_Instrument_balance);\\n    }\\n    /// @notice Stores a Instrument as trusted when its approved\\n    function trustInstrument(Instrument instrument) external onlyController{\\n    \\tgetInstrumentData[instrument].trusted = true;\\n\\n    }\\n\\n    /// @notice Stores a Instrument as untrusted\\n    function distrustInstrument(Instrument instrument) external onlyController {\\n      getInstrumentData[instrument].trusted = false; \\n    }\\n\\n\\n    /// @notice returns true if Instrument is approved\\n    function isTrusted(Instrument instrument) public view returns(bool){\\n    \\treturn getInstrumentData[instrument].trusted; \\n    }\\n\\n    /// @notice Calculates the total amount of underlying tokens the Vault holds, excluding profit \\n    function totalAssets() public view override returns(uint256){\\n    \\treturn totalInstrumentHoldings + totalFloat();\\n    }\\n\\n   \\t\\n    function totalFloat() public view returns (uint256) {\\n        return UNDERLYING.balanceOf(address(this));\\n    }\\n\\n    function fetchInstrumentData(uint256 marketId) public view returns(InstrumentData memory){\\n        return getInstrumentData[Instruments[marketId]];\\n    }\\n    /**\\n     called on market denial + removal, maybe no chekcs?\\n     */\\n    function removeInstrument(uint256 marketId) internal {\\n        InstrumentData storage data = getInstrumentData[Instruments[marketId]];\\n        require(data.marketId > 0, \\\"instrument doesn't exist\\\");\\n        delete getInstrumentData[Instruments[marketId]];\\n        delete Instruments[marketId];\\n        // emit event here;\\n    }\\n\\n\\n    function onMarketApproval(uint256 marketId) external onlyController {\\n        Instruments[marketId].onMarketApproval();\\n    }\\n\\n    /// @notice add instrument proposal created by the Utilizer \\n    /// @dev Instrument instance should be created before this is called\\n    /// need to add authorization\\n    function addProposal(\\n        InstrumentData memory data\\n    ) external {\\n        require(data.principal > 0, \\\"principal must be greater than 0\\\");\\n        require(data.duration > 0, \\\"duration must be greater than 0\\\");\\n        require(data.faceValue > 0, \\\"faceValue must be greater than 0\\\");\\n        require(data.principal >= BASE_UNIT, \\\"Needs to be in decimal format\\\"); // should be collateral address, not DS. Can't be less than 1.0 X?\\n        require(data.marketId > 0, \\\"must be valid instrument\\\");\\n\\n        num_proposals[msg.sender] ++; \\n        getInstrumentData[Instrument(data.Instrument_address)] = (\\n        \\tInstrumentData(\\n        \\t\\tfalse, \\n                0, \\n                data.faceValue, \\n                data.marketId, \\n                data.principal, \\n                data.expectedYield, \\n                data.duration, \\n                data.description, \\n                data.Instrument_address,\\n                data.instrument_type,\\n                0\\n            )\\n        \\t); \\n\\n        Instruments[data.marketId] = Instrument(data.Instrument_address);\\n    }\\n\\n    /**\\n     @notice checks status of instrument\\n     returns true if resolution, false if not.\\n     */\\n    function checkInstrument(\\n        uint256 marketId\\n    ) external returns (bool) {\\n        InstrumentData storage data = getInstrumentData[Instruments[marketId]];\\n        \\n        require(data.marketId > 0 && data.trusted, \\\"instrument must be active\\\");\\n        require(data.maturityDate > 0, \\\"instrument hasn't been approved yet\\\" );\\n\\n        if (block.timestamp >= data.maturityDate) {\\n            resolveInstrument(Instruments[marketId]);\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    /**\\n     @notice called by controller on approveMarket.\\n     */\\n    function setMaturityDate(Instrument _instrument) external onlyController {\\n        getInstrumentData[_instrument].maturityDate = getInstrumentData[_instrument].duration + block.timestamp;\\n    }\\n\\n    /**\\n     @notice called on resolution => checkInstrument => called by anyone, withdraws all funds to vault, triggers resolveMarket for controller.\\n     @dev no checks, checks performed by checkInstrument()\\n     */\\n    function resolveInstrument(\\n        Instrument _instrument\\n    ) internal {\\n        harvest(address(_instrument));\\n\\n        InstrumentData storage data = getInstrumentData[_instrument];\\n\\n        bool atLoss = data.balance < data.faceValue;\\n\\n        uint256 total_loss = atLoss ? data.faceValue - data.balance : 0;\\n        uint256 extra_gain = !atLoss ? data.balance - data.faceValue : 0;\\n\\n        withdrawAllFromInstrument(_instrument);\\n        controller.resolveMarket(data.marketId, atLoss, extra_gain, total_loss);\\n        removeInstrument(data.marketId);\\n    }\\n\\n    /**\\n     called on market denial by controller.\\n     */\\n    function denyInstrument(uint256 marketId) external onlyController {\\n        InstrumentData storage data = getInstrumentData[Instruments[marketId]];\\n        \\n        require(marketId > 0 && data.Instrument_address != address(0), \\\"invalid instrument\\\");\\n\\n        require(!data.trusted, \\\"can't deny approved instrument\\\");\\n        \\n        removeInstrument(marketId);\\n    }\\n}\",\"keccak256\":\"0x1652abe6f9230bd082934c4970aa804d8b0e8459747b3028161ed8c707e65390\"},\"hardhat/console.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.4.22 <0.9.0;\\n\\nlibrary console {\\n\\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\\n\\n\\tfunction _sendLogPayload(bytes memory payload) private view {\\n\\t\\tuint256 payloadLength = payload.length;\\n\\t\\taddress consoleAddress = CONSOLE_ADDRESS;\\n\\t\\tassembly {\\n\\t\\t\\tlet payloadStart := add(payload, 32)\\n\\t\\t\\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\\n\\t\\t}\\n\\t}\\n\\n\\tfunction log() internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n\\t}\\n\\n\\tfunction logInt(int p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(int)\\\", p0));\\n\\t}\\n\\n\\tfunction logUint(uint p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n\\t}\\n\\n\\tfunction logString(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction logBool(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction logAddress(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes(bytes memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes1(bytes1 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes2(bytes2 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes3(bytes3 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes4(bytes4 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes5(bytes5 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes6(bytes6 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes7(bytes7 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes8(bytes8 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes9(bytes9 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes10(bytes10 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes11(bytes11 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes12(bytes12 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes13(bytes13 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes14(bytes14 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes15(bytes15 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes16(bytes16 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes17(bytes17 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes18(bytes18 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes19(bytes19 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes20(bytes20 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes21(bytes21 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes22(bytes22 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes23(bytes23 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes24(bytes24 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes25(bytes25 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes26(bytes26 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes27(bytes27 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes28(bytes28 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes29(bytes29 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes30(bytes30 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes31(bytes31 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes32(bytes32 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n\\t}\\n\\n\\tfunction log(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction log(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction log(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n}\\n\",\"keccak256\":\"0x72b6a1d297cd3b033d7c2e4a7e7864934bb767db6453623f1c3082c6534547f4\",\"license\":\"MIT\"},\"solmate/src/tokens/ERC721.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\\nabstract contract ERC721 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\\n\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                         METADATA STORAGE/LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    function tokenURI(uint256 id) public view virtual returns (string memory);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                      ERC721 BALANCE/OWNER STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(uint256 => address) internal _ownerOf;\\n\\n    mapping(address => uint256) internal _balanceOf;\\n\\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\\n        require((owner = _ownerOf[id]) != address(0), \\\"NOT_MINTED\\\");\\n    }\\n\\n    function balanceOf(address owner) public view virtual returns (uint256) {\\n        require(owner != address(0), \\\"ZERO_ADDRESS\\\");\\n\\n        return _balanceOf[owner];\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                         ERC721 APPROVAL STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(uint256 => address) public getApproved;\\n\\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(string memory _name, string memory _symbol) {\\n        name = _name;\\n        symbol = _symbol;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC721 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 id) public virtual {\\n        address owner = _ownerOf[id];\\n\\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \\\"NOT_AUTHORIZED\\\");\\n\\n        getApproved[id] = spender;\\n\\n        emit Approval(owner, spender, id);\\n    }\\n\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\n        isApprovedForAll[msg.sender][operator] = approved;\\n\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) public virtual {\\n        require(from == _ownerOf[id], \\\"WRONG_FROM\\\");\\n\\n        require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n\\n        require(\\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\\n            \\\"NOT_AUTHORIZED\\\"\\n        );\\n\\n        // Underflow of the sender's balance is impossible because we check for\\n        // ownership above and the recipient's balance can't realistically overflow.\\n        unchecked {\\n            _balanceOf[from]--;\\n\\n            _balanceOf[to]++;\\n        }\\n\\n        _ownerOf[id] = to;\\n\\n        delete getApproved[id];\\n\\n        emit Transfer(from, to, id);\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) public virtual {\\n        transferFrom(from, to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \\\"\\\") ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        bytes calldata data\\n    ) public virtual {\\n        transferFrom(from, to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC165 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\\n        return\\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 id) internal virtual {\\n        require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n\\n        require(_ownerOf[id] == address(0), \\\"ALREADY_MINTED\\\");\\n\\n        // Counter overflow is incredibly unrealistic.\\n        unchecked {\\n            _balanceOf[to]++;\\n        }\\n\\n        _ownerOf[id] = to;\\n\\n        emit Transfer(address(0), to, id);\\n    }\\n\\n    function _burn(uint256 id) internal virtual {\\n        address owner = _ownerOf[id];\\n\\n        require(owner != address(0), \\\"NOT_MINTED\\\");\\n\\n        // Ownership check above ensures no underflow.\\n        unchecked {\\n            _balanceOf[owner]--;\\n        }\\n\\n        delete _ownerOf[id];\\n\\n        delete getApproved[id];\\n\\n        emit Transfer(owner, address(0), id);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL SAFE MINT LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _safeMint(address to, uint256 id) internal virtual {\\n        _mint(to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \\\"\\\") ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function _safeMint(\\n        address to,\\n        uint256 id,\\n        bytes memory data\\n    ) internal virtual {\\n        _mint(to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n}\\n\\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\\nabstract contract ERC721TokenReceiver {\\n    function onERC721Received(\\n        address,\\n        address,\\n        uint256,\\n        bytes calldata\\n    ) external virtual returns (bytes4) {\\n        return ERC721TokenReceiver.onERC721Received.selector;\\n    }\\n}\\n\",\"keccak256\":\"0x04af19f16f00ba65ae168d6d10da5210dc18da6bcec6974dccf984ba388aa22d\",\"license\":\"AGPL-3.0-only\"},\"solmate/src/utils/FixedPointMathLib.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Arithmetic library with operations for fixed-point numbers.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\\nlibrary FixedPointMathLib {\\n    /*//////////////////////////////////////////////////////////////\\n                    SIMPLIFIED FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\\n\\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\\n    }\\n\\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\\n    }\\n\\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\\n    }\\n\\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                    LOW LEVEL FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function mulDivDown(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            // Store x * y in z for now.\\n            z := mul(x, y)\\n\\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\\n                revert(0, 0)\\n            }\\n\\n            // Divide z by the denominator.\\n            z := div(z, denominator)\\n        }\\n    }\\n\\n    function mulDivUp(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            // Store x * y in z for now.\\n            z := mul(x, y)\\n\\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\\n                revert(0, 0)\\n            }\\n\\n            // First, divide z - 1 by the denominator and add 1.\\n            // We allow z - 1 to underflow if z is 0, because we multiply the\\n            // end result by 0 if z is zero, ensuring we return 0 if z is zero.\\n            z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))\\n        }\\n    }\\n\\n    function rpow(\\n        uint256 x,\\n        uint256 n,\\n        uint256 scalar\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            switch x\\n            case 0 {\\n                switch n\\n                case 0 {\\n                    // 0 ** 0 = 1\\n                    z := scalar\\n                }\\n                default {\\n                    // 0 ** n = 0\\n                    z := 0\\n                }\\n            }\\n            default {\\n                switch mod(n, 2)\\n                case 0 {\\n                    // If n is even, store scalar in z for now.\\n                    z := scalar\\n                }\\n                default {\\n                    // If n is odd, store x in z for now.\\n                    z := x\\n                }\\n\\n                // Shifting right by 1 is like dividing by 2.\\n                let half := shr(1, scalar)\\n\\n                for {\\n                    // Shift n right by 1 before looping to halve it.\\n                    n := shr(1, n)\\n                } n {\\n                    // Shift n right by 1 each iteration to halve it.\\n                    n := shr(1, n)\\n                } {\\n                    // Revert immediately if x ** 2 would overflow.\\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\\n                    if shr(128, x) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Store x squared.\\n                    let xx := mul(x, x)\\n\\n                    // Round to the nearest number.\\n                    let xxRound := add(xx, half)\\n\\n                    // Revert if xx + half overflowed.\\n                    if lt(xxRound, xx) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Set x to scaled xxRound.\\n                    x := div(xxRound, scalar)\\n\\n                    // If n is even:\\n                    if mod(n, 2) {\\n                        // Compute z * x.\\n                        let zx := mul(z, x)\\n\\n                        // If z * x overflowed:\\n                        if iszero(eq(div(zx, x), z)) {\\n                            // Revert if x is non-zero.\\n                            if iszero(iszero(x)) {\\n                                revert(0, 0)\\n                            }\\n                        }\\n\\n                        // Round to the nearest number.\\n                        let zxRound := add(zx, half)\\n\\n                        // Revert if zx + half overflowed.\\n                        if lt(zxRound, zx) {\\n                            revert(0, 0)\\n                        }\\n\\n                        // Return properly scaled zxRound.\\n                        z := div(zxRound, scalar)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        GENERAL NUMBER UTILITIES\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\\n        assembly {\\n            // Start off with z at 1.\\n            z := 1\\n\\n            // Used below to help find a nearby power of 2.\\n            let y := x\\n\\n            // Find the lowest power of 2 that is at least sqrt(x).\\n            if iszero(lt(y, 0x100000000000000000000000000000000)) {\\n                y := shr(128, y) // Like dividing by 2 ** 128.\\n                z := shl(64, z) // Like multiplying by 2 ** 64.\\n            }\\n            if iszero(lt(y, 0x10000000000000000)) {\\n                y := shr(64, y) // Like dividing by 2 ** 64.\\n                z := shl(32, z) // Like multiplying by 2 ** 32.\\n            }\\n            if iszero(lt(y, 0x100000000)) {\\n                y := shr(32, y) // Like dividing by 2 ** 32.\\n                z := shl(16, z) // Like multiplying by 2 ** 16.\\n            }\\n            if iszero(lt(y, 0x10000)) {\\n                y := shr(16, y) // Like dividing by 2 ** 16.\\n                z := shl(8, z) // Like multiplying by 2 ** 8.\\n            }\\n            if iszero(lt(y, 0x100)) {\\n                y := shr(8, y) // Like dividing by 2 ** 8.\\n                z := shl(4, z) // Like multiplying by 2 ** 4.\\n            }\\n            if iszero(lt(y, 0x10)) {\\n                y := shr(4, y) // Like dividing by 2 ** 4.\\n                z := shl(2, z) // Like multiplying by 2 ** 2.\\n            }\\n            if iszero(lt(y, 0x8)) {\\n                // Equivalent to 2 ** z.\\n                z := shl(1, z)\\n            }\\n\\n            // Shifting right by 1 is like dividing by 2.\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n\\n            // Compute a rounded down version of z.\\n            let zRoundDown := div(x, z)\\n\\n            // If zRoundDown is smaller, use it.\\n            if lt(zRoundDown, z) {\\n                z := zRoundDown\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x9faabac0803e077fb8d8950f5e2fec1984d3e6cd6ad5fc144609b5c9de83d169\",\"license\":\"AGPL-3.0-only\"}},\"version\":1}",
  "bytecode": "0x60806040526001600955670de0b6b3a7640000600b553480156200002257600080fd5b50604051620014e1380380620014e183398101604081905262000045916200022b565b604080518082018252601781527f4465626974612052657075746174696f6e20546f6b656e00000000000000000060208083019182528351808501909452600384526211149560ea1b908401528151919291620000a59160009162000185565b508051620000bb90600190602084019062000185565b505050620000f0604051806040016040528060048152602001636865726560e01b8152506200011660201b62000c651760201c565b600a80546001600160a01b0319166001600160a01b0392909216919091179055620002ee565b62000161816040516024016200012d91906200025b565b60408051601f198184030181529190526020810180516001600160e01b0390811663104c13eb60e21b179091526200016416565b50565b80516a636f6e736f6c652e6c6f67602083016000808483855afa5050505050565b8280546200019390620002b1565b90600052602060002090601f016020900481019282620001b7576000855562000202565b82601f10620001d257805160ff191683800117855562000202565b8280016001018555821562000202579182015b8281111562000202578251825591602001919060010190620001e5565b506200021092915062000214565b5090565b5b8082111562000210576000815560010162000215565b6000602082840312156200023d578081fd5b81516001600160a01b038116811462000254578182fd5b9392505050565b6000602080835283518082850152825b8181101562000289578581018301518582016040015282016200026b565b818111156200029b5783604083870101525b50601f01601f1916929092016040019392505050565b600181811c90821680620002c657607f821691505b60208210811415620002e857634e487b7160e01b600052602260045260246000fd5b50919050565b6111e380620002fe6000396000f3fe608060405234801561001057600080fd5b506004361061010b5760003560e01c80636352211e116100a257806395d89b411161007157806395d89b4114610249578063a22cb46514610251578063b88d4fde14610264578063c87b56dd14610277578063e985e9c51461028a57600080fd5b80636352211e146101ef5780636a6278421461020257806370a082311461021557806375a67d5c1461023657600080fd5b80630b19c264116100de5780630b19c264146101a357806323b872dd146101b657806333620eb8146101c957806342842e0e146101dc57600080fd5b806301ffc9a71461011057806306fdde0314610138578063081812fc1461014d578063095ea7b31461018e575b600080fd5b61012361011e366004610fa8565b6102b8565b60405190151581526020015b60405180910390f35b61014061030a565b60405161012f919061106b565b61017661015b366004610fe0565b6004602052600090815260409020546001600160a01b031681565b6040516001600160a01b03909116815260200161012f565b6101a161019c366004610f44565b610398565b005b6101a16101b1366004610f6d565b61047f565b6101a16101c4366004610e4a565b61053d565b6101a16101d7366004610dfe565b610704565b6101a16101ea366004610e4a565b610766565b6101766101fd366004610fe0565b61086d565b6101a1610210366004610dfe565b6108c4565b610228610223366004610dfe565b610974565b60405190815260200161012f565b610228610244366004610dfe565b6109d7565b610140610a38565b6101a161025f366004610f1b565b610a45565b6101a1610272366004610e85565b610ab1565b610140610285366004610fe0565b610ba8565b610123610298366004610e18565b600560209081526000928352604080842090915290825290205460ff1681565b60006301ffc9a760e01b6001600160e01b0319831614806102e957506380ac58cd60e01b6001600160e01b03198316145b806103045750635b5e139f60e01b6001600160e01b03198316145b92915050565b600080546103179061112b565b80601f01602080910402602001604051908101604052809291908181526020018280546103439061112b565b80156103905780601f1061036557610100808354040283529160200191610390565b820191906000526020600020905b81548152906001019060200180831161037357829003601f168201915b505050505081565b6000818152600260205260409020546001600160a01b0316338114806103e157506001600160a01b038116600090815260056020908152604080832033845290915290205460ff165b6104235760405162461bcd60e51b815260206004820152600e60248201526d1393d517d055551213d49256915160921b60448201526064015b60405180910390fd5b60008281526004602052604080822080546001600160a01b0319166001600160a01b0387811691821790925591518593918516917f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b92591a4505050565b6001600160a01b0383166000908152600760205260409020546104b45760405162461bcd60e51b815260040161041a9061109e565b6001600160a01b03831660009081526007602090815260408083205483526006909152902080546104eb5760018101839055610524565b80546104f89060016110c3565b81546001830154859161050a916110db565b61051491906110c3565b61051e91906110db565b60018201555b805481600061053283611166565b919050555050505050565b6000818152600260205260409020546001600160a01b038481169116146105935760405162461bcd60e51b815260206004820152600a60248201526957524f4e475f46524f4d60b01b604482015260640161041a565b6001600160a01b0382166105dd5760405162461bcd60e51b81526020600482015260116024820152701253959053125117d49150d25412515395607a1b604482015260640161041a565b336001600160a01b038416148061061757506001600160a01b038316600090815260056020908152604080832033845290915290205460ff165b8061063857506000818152600460205260409020546001600160a01b031633145b6106755760405162461bcd60e51b815260206004820152600e60248201526d1393d517d055551213d49256915160921b604482015260640161041a565b6001600160a01b0380841660008181526003602090815260408083208054600019019055938616808352848320805460010190558583526002825284832080546001600160a01b03199081168317909155600490925284832080549092169091559251849392917fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef91a4505050565b6001600160a01b0381166000908152600760205260409020546107395760405162461bcd60e51b815260040161041a9061109e565b6001600160a01b031660009081526007602090815260408083205483526006909152812081815560010155565b61077183838361053d565b6001600160a01b0382163b15806108295750604051630a85bd0160e11b8082523360048301526001600160a01b03858116602484015260448301849052608060648401526000608484015290919084169063150b7a029060a401602060405180830381600087803b1580156107e557600080fd5b505af11580156107f9573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061081d9190610fc4565b6001600160e01b031916145b6108685760405162461bcd60e51b815260206004820152601060248201526f155394d0519157d49150d2541251539560821b604482015260640161041a565b505050565b6000818152600260205260409020546001600160a01b0316806108bf5760405162461bcd60e51b815260206004820152600a6024820152691393d517d3525395115160b21b604482015260640161041a565b919050565b6001600160a01b038116600090815260076020526040902054156109355760405162461bcd60e51b815260206004820152602260248201527f63616e206f6e6c79206d696e74206f6e652072657075746174696f6e20746f6b60448201526132b760f11b606482015260840161041a565b61094181600954610cab565b600980546001600160a01b038316600090815260076020526040812082905590919061096c83611166565b919050555050565b60006001600160a01b0382166109bb5760405162461bcd60e51b815260206004820152600c60248201526b5a45524f5f4144445245535360a01b604482015260640161041a565b506001600160a01b031660009081526003602052604090205490565b6001600160a01b038116600090815260076020526040812054610a0c5760405162461bcd60e51b815260040161041a9061109e565b506001600160a01b03166000908152600760209081526040808320548352600690915290206001015490565b600180546103179061112b565b3360008181526005602090815260408083206001600160a01b03871680855290835292819020805460ff191686151590811790915590519081529192917f17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31910160405180910390a35050565b610abc85858561053d565b6001600160a01b0384163b1580610b625750604051630a85bd0160e11b808252906001600160a01b0386169063150b7a0290610b049033908a9089908990899060040161101a565b602060405180830381600087803b158015610b1e57600080fd5b505af1158015610b32573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b569190610fc4565b6001600160e01b031916145b610ba15760405162461bcd60e51b815260206004820152601060248201526f155394d0519157d49150d2541251539560821b604482015260640161041a565b5050505050565b6000818152600260205260409020546060906001600160a01b0316610c045760405162461bcd60e51b815260206004820152601260248201527124b73b30b634b21024b232b73a34b334b2b960711b604482015260640161041a565b6000610c1b60408051602081019091526000815290565b90506000815111610c3b5760405180602001604052806000815250610c5e565b8083604051602001610c4e929190610ff8565b6040516020818303038152906040525b9392505050565b610ca881604051602401610c79919061106b565b60408051601f198184030181529190526020810180516001600160e01b031663104c13eb60e21b179052610db6565b50565b6001600160a01b038216610cf55760405162461bcd60e51b81526020600482015260116024820152701253959053125117d49150d25412515395607a1b604482015260640161041a565b6000818152600260205260409020546001600160a01b031615610d4b5760405162461bcd60e51b815260206004820152600e60248201526d1053149150511657d3525395115160921b604482015260640161041a565b6001600160a01b038216600081815260036020908152604080832080546001019055848352600290915280822080546001600160a01b0319168417905551839291907fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef908290a45050565b80516a636f6e736f6c652e6c6f67602083016000808483855afa5050505050565b80356001600160a01b03811681146108bf57600080fd5b803580151581146108bf57600080fd5b600060208284031215610e0f578081fd5b610c5e82610dd7565b60008060408385031215610e2a578081fd5b610e3383610dd7565b9150610e4160208401610dd7565b90509250929050565b600080600060608486031215610e5e578081fd5b610e6784610dd7565b9250610e7560208501610dd7565b9150604084013590509250925092565b600080600080600060808688031215610e9c578081fd5b610ea586610dd7565b9450610eb360208701610dd7565b935060408601359250606086013567ffffffffffffffff80821115610ed6578283fd5b818801915088601f830112610ee9578283fd5b813581811115610ef7578384fd5b896020828501011115610f08578384fd5b9699959850939650602001949392505050565b60008060408385031215610f2d578182fd5b610f3683610dd7565b9150610e4160208401610dee565b60008060408385031215610f56578182fd5b610f5f83610dd7565b946020939093013593505050565b600080600060608486031215610f81578283fd5b610f8a84610dd7565b925060208401359150610f9f60408501610dee565b90509250925092565b600060208284031215610fb9578081fd5b8135610c5e81611197565b600060208284031215610fd5578081fd5b8151610c5e81611197565b600060208284031215610ff1578081fd5b5035919050565b6000835161100a8184602088016110fb565b9190910191825250602001919050565b6001600160a01b038681168252851660208201526040810184905260806060820181905281018290526000828460a084013781830160a090810191909152601f909201601f19160101949350505050565b602081526000825180602084015261108a8160408501602087016110fb565b601f01601f19169190910160400192915050565b6020808252600b908201526a139bc8125908199bdd5b9960aa1b604082015260600190565b600082198211156110d6576110d6611181565b500190565b6000826110f657634e487b7160e01b81526012600452602481fd5b500490565b60005b838110156111165781810151838201526020016110fe565b83811115611125576000848401525b50505050565b600181811c9082168061113f57607f821691505b6020821081141561116057634e487b7160e01b600052602260045260246000fd5b50919050565b600060001982141561117a5761117a611181565b5060010190565b634e487b7160e01b600052601160045260246000fd5b6001600160e01b031981168114610ca857600080fdfea2646970667358221220de5fa13db36cef375fb5a5aa7926698e3565a93e869122ea24eb2416ddf40db664736f6c63430008040033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061010b5760003560e01c80636352211e116100a257806395d89b411161007157806395d89b4114610249578063a22cb46514610251578063b88d4fde14610264578063c87b56dd14610277578063e985e9c51461028a57600080fd5b80636352211e146101ef5780636a6278421461020257806370a082311461021557806375a67d5c1461023657600080fd5b80630b19c264116100de5780630b19c264146101a357806323b872dd146101b657806333620eb8146101c957806342842e0e146101dc57600080fd5b806301ffc9a71461011057806306fdde0314610138578063081812fc1461014d578063095ea7b31461018e575b600080fd5b61012361011e366004610fa8565b6102b8565b60405190151581526020015b60405180910390f35b61014061030a565b60405161012f919061106b565b61017661015b366004610fe0565b6004602052600090815260409020546001600160a01b031681565b6040516001600160a01b03909116815260200161012f565b6101a161019c366004610f44565b610398565b005b6101a16101b1366004610f6d565b61047f565b6101a16101c4366004610e4a565b61053d565b6101a16101d7366004610dfe565b610704565b6101a16101ea366004610e4a565b610766565b6101766101fd366004610fe0565b61086d565b6101a1610210366004610dfe565b6108c4565b610228610223366004610dfe565b610974565b60405190815260200161012f565b610228610244366004610dfe565b6109d7565b610140610a38565b6101a161025f366004610f1b565b610a45565b6101a1610272366004610e85565b610ab1565b610140610285366004610fe0565b610ba8565b610123610298366004610e18565b600560209081526000928352604080842090915290825290205460ff1681565b60006301ffc9a760e01b6001600160e01b0319831614806102e957506380ac58cd60e01b6001600160e01b03198316145b806103045750635b5e139f60e01b6001600160e01b03198316145b92915050565b600080546103179061112b565b80601f01602080910402602001604051908101604052809291908181526020018280546103439061112b565b80156103905780601f1061036557610100808354040283529160200191610390565b820191906000526020600020905b81548152906001019060200180831161037357829003601f168201915b505050505081565b6000818152600260205260409020546001600160a01b0316338114806103e157506001600160a01b038116600090815260056020908152604080832033845290915290205460ff165b6104235760405162461bcd60e51b815260206004820152600e60248201526d1393d517d055551213d49256915160921b60448201526064015b60405180910390fd5b60008281526004602052604080822080546001600160a01b0319166001600160a01b0387811691821790925591518593918516917f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b92591a4505050565b6001600160a01b0383166000908152600760205260409020546104b45760405162461bcd60e51b815260040161041a9061109e565b6001600160a01b03831660009081526007602090815260408083205483526006909152902080546104eb5760018101839055610524565b80546104f89060016110c3565b81546001830154859161050a916110db565b61051491906110c3565b61051e91906110db565b60018201555b805481600061053283611166565b919050555050505050565b6000818152600260205260409020546001600160a01b038481169116146105935760405162461bcd60e51b815260206004820152600a60248201526957524f4e475f46524f4d60b01b604482015260640161041a565b6001600160a01b0382166105dd5760405162461bcd60e51b81526020600482015260116024820152701253959053125117d49150d25412515395607a1b604482015260640161041a565b336001600160a01b038416148061061757506001600160a01b038316600090815260056020908152604080832033845290915290205460ff165b8061063857506000818152600460205260409020546001600160a01b031633145b6106755760405162461bcd60e51b815260206004820152600e60248201526d1393d517d055551213d49256915160921b604482015260640161041a565b6001600160a01b0380841660008181526003602090815260408083208054600019019055938616808352848320805460010190558583526002825284832080546001600160a01b03199081168317909155600490925284832080549092169091559251849392917fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef91a4505050565b6001600160a01b0381166000908152600760205260409020546107395760405162461bcd60e51b815260040161041a9061109e565b6001600160a01b031660009081526007602090815260408083205483526006909152812081815560010155565b61077183838361053d565b6001600160a01b0382163b15806108295750604051630a85bd0160e11b8082523360048301526001600160a01b03858116602484015260448301849052608060648401526000608484015290919084169063150b7a029060a401602060405180830381600087803b1580156107e557600080fd5b505af11580156107f9573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061081d9190610fc4565b6001600160e01b031916145b6108685760405162461bcd60e51b815260206004820152601060248201526f155394d0519157d49150d2541251539560821b604482015260640161041a565b505050565b6000818152600260205260409020546001600160a01b0316806108bf5760405162461bcd60e51b815260206004820152600a6024820152691393d517d3525395115160b21b604482015260640161041a565b919050565b6001600160a01b038116600090815260076020526040902054156109355760405162461bcd60e51b815260206004820152602260248201527f63616e206f6e6c79206d696e74206f6e652072657075746174696f6e20746f6b60448201526132b760f11b606482015260840161041a565b61094181600954610cab565b600980546001600160a01b038316600090815260076020526040812082905590919061096c83611166565b919050555050565b60006001600160a01b0382166109bb5760405162461bcd60e51b815260206004820152600c60248201526b5a45524f5f4144445245535360a01b604482015260640161041a565b506001600160a01b031660009081526003602052604090205490565b6001600160a01b038116600090815260076020526040812054610a0c5760405162461bcd60e51b815260040161041a9061109e565b506001600160a01b03166000908152600760209081526040808320548352600690915290206001015490565b600180546103179061112b565b3360008181526005602090815260408083206001600160a01b03871680855290835292819020805460ff191686151590811790915590519081529192917f17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31910160405180910390a35050565b610abc85858561053d565b6001600160a01b0384163b1580610b625750604051630a85bd0160e11b808252906001600160a01b0386169063150b7a0290610b049033908a9089908990899060040161101a565b602060405180830381600087803b158015610b1e57600080fd5b505af1158015610b32573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b569190610fc4565b6001600160e01b031916145b610ba15760405162461bcd60e51b815260206004820152601060248201526f155394d0519157d49150d2541251539560821b604482015260640161041a565b5050505050565b6000818152600260205260409020546060906001600160a01b0316610c045760405162461bcd60e51b815260206004820152601260248201527124b73b30b634b21024b232b73a34b334b2b960711b604482015260640161041a565b6000610c1b60408051602081019091526000815290565b90506000815111610c3b5760405180602001604052806000815250610c5e565b8083604051602001610c4e929190610ff8565b6040516020818303038152906040525b9392505050565b610ca881604051602401610c79919061106b565b60408051601f198184030181529190526020810180516001600160e01b031663104c13eb60e21b179052610db6565b50565b6001600160a01b038216610cf55760405162461bcd60e51b81526020600482015260116024820152701253959053125117d49150d25412515395607a1b604482015260640161041a565b6000818152600260205260409020546001600160a01b031615610d4b5760405162461bcd60e51b815260206004820152600e60248201526d1053149150511657d3525395115160921b604482015260640161041a565b6001600160a01b038216600081815260036020908152604080832080546001019055848352600290915280822080546001600160a01b0319168417905551839291907fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef908290a45050565b80516a636f6e736f6c652e6c6f67602083016000808483855afa5050505050565b80356001600160a01b03811681146108bf57600080fd5b803580151581146108bf57600080fd5b600060208284031215610e0f578081fd5b610c5e82610dd7565b60008060408385031215610e2a578081fd5b610e3383610dd7565b9150610e4160208401610dd7565b90509250929050565b600080600060608486031215610e5e578081fd5b610e6784610dd7565b9250610e7560208501610dd7565b9150604084013590509250925092565b600080600080600060808688031215610e9c578081fd5b610ea586610dd7565b9450610eb360208701610dd7565b935060408601359250606086013567ffffffffffffffff80821115610ed6578283fd5b818801915088601f830112610ee9578283fd5b813581811115610ef7578384fd5b896020828501011115610f08578384fd5b9699959850939650602001949392505050565b60008060408385031215610f2d578182fd5b610f3683610dd7565b9150610e4160208401610dee565b60008060408385031215610f56578182fd5b610f5f83610dd7565b946020939093013593505050565b600080600060608486031215610f81578283fd5b610f8a84610dd7565b925060208401359150610f9f60408501610dee565b90509250925092565b600060208284031215610fb9578081fd5b8135610c5e81611197565b600060208284031215610fd5578081fd5b8151610c5e81611197565b600060208284031215610ff1578081fd5b5035919050565b6000835161100a8184602088016110fb565b9190910191825250602001919050565b6001600160a01b038681168252851660208201526040810184905260806060820181905281018290526000828460a084013781830160a090810191909152601f909201601f19160101949350505050565b602081526000825180602084015261108a8160408501602087016110fb565b601f01601f19169190910160400192915050565b6020808252600b908201526a139bc8125908199bdd5b9960aa1b604082015260600190565b600082198211156110d6576110d6611181565b500190565b6000826110f657634e487b7160e01b81526012600452602481fd5b500490565b60005b838110156111165781810151838201526020016110fe565b83811115611125576000848401525b50505050565b600181811c9082168061113f57607f821691505b6020821081141561116057634e487b7160e01b600052602260045260246000fd5b50919050565b600060001982141561117a5761117a611181565b5060010190565b634e487b7160e01b600052601160045260246000fd5b6001600160e01b031981168114610ca857600080fdfea2646970667358221220de5fa13db36cef375fb5a5aa7926698e3565a93e869122ea24eb2416ddf40db664736f6c63430008040033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "addScore(address,uint256,bool)": {
        "params": {
          "score": ": 60.18 format"
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "addScore(address,uint256,bool)": {
        "notice": "calculates average of scores added."
      },
      "resetScore(address)": {
        "notice": "reset scores"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 65695,
        "contract": "contracts/stablecoin/reputationtoken.sol:ReputationNFT",
        "label": "name",
        "offset": 0,
        "slot": "0",
        "type": "t_string_storage"
      },
      {
        "astId": 65697,
        "contract": "contracts/stablecoin/reputationtoken.sol:ReputationNFT",
        "label": "symbol",
        "offset": 0,
        "slot": "1",
        "type": "t_string_storage"
      },
      {
        "astId": 65708,
        "contract": "contracts/stablecoin/reputationtoken.sol:ReputationNFT",
        "label": "_ownerOf",
        "offset": 0,
        "slot": "2",
        "type": "t_mapping(t_uint256,t_address)"
      },
      {
        "astId": 65712,
        "contract": "contracts/stablecoin/reputationtoken.sol:ReputationNFT",
        "label": "_balanceOf",
        "offset": 0,
        "slot": "3",
        "type": "t_mapping(t_address,t_uint256)"
      },
      {
        "astId": 65761,
        "contract": "contracts/stablecoin/reputationtoken.sol:ReputationNFT",
        "label": "getApproved",
        "offset": 0,
        "slot": "4",
        "type": "t_mapping(t_uint256,t_address)"
      },
      {
        "astId": 65767,
        "contract": "contracts/stablecoin/reputationtoken.sol:ReputationNFT",
        "label": "isApprovedForAll",
        "offset": 0,
        "slot": "5",
        "type": "t_mapping(t_address,t_mapping(t_address,t_bool))"
      },
      {
        "astId": 29123,
        "contract": "contracts/stablecoin/reputationtoken.sol:ReputationNFT",
        "label": "_reputation",
        "offset": 0,
        "slot": "6",
        "type": "t_mapping(t_uint256,t_struct(ReputationData)29147_storage)"
      },
      {
        "astId": 29127,
        "contract": "contracts/stablecoin/reputationtoken.sol:ReputationNFT",
        "label": "_ownerToId",
        "offset": 0,
        "slot": "7",
        "type": "t_mapping(t_address,t_uint256)"
      },
      {
        "astId": 29133,
        "contract": "contracts/stablecoin/reputationtoken.sol:ReputationNFT",
        "label": "_marketData",
        "offset": 0,
        "slot": "8",
        "type": "t_mapping(t_uint256,t_array(t_struct(TraderData)29152_storage)dyn_storage)"
      },
      {
        "astId": 29136,
        "contract": "contracts/stablecoin/reputationtoken.sol:ReputationNFT",
        "label": "nonce",
        "offset": 0,
        "slot": "9",
        "type": "t_uint256"
      },
      {
        "astId": 29139,
        "contract": "contracts/stablecoin/reputationtoken.sol:ReputationNFT",
        "label": "controller",
        "offset": 0,
        "slot": "10",
        "type": "t_contract(Controller)23736"
      },
      {
        "astId": 29142,
        "contract": "contracts/stablecoin/reputationtoken.sol:ReputationNFT",
        "label": "SCALE",
        "offset": 0,
        "slot": "11",
        "type": "t_uint256"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_array(t_struct(TraderData)29152_storage)dyn_storage": {
        "base": "t_struct(TraderData)29152_storage",
        "encoding": "dynamic_array",
        "label": "struct ReputationNFT.TraderData[]",
        "numberOfBytes": "32"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_contract(Controller)23736": {
        "encoding": "inplace",
        "label": "contract Controller",
        "numberOfBytes": "20"
      },
      "t_mapping(t_address,t_bool)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      },
      "t_mapping(t_address,t_mapping(t_address,t_bool))": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => mapping(address => bool))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_address,t_bool)"
      },
      "t_mapping(t_address,t_uint256)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_mapping(t_uint256,t_address)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => address)",
        "numberOfBytes": "32",
        "value": "t_address"
      },
      "t_mapping(t_uint256,t_array(t_struct(TraderData)29152_storage)dyn_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => struct ReputationNFT.TraderData[])",
        "numberOfBytes": "32",
        "value": "t_array(t_struct(TraderData)29152_storage)dyn_storage"
      },
      "t_mapping(t_uint256,t_struct(ReputationData)29147_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => struct ReputationNFT.ReputationData)",
        "numberOfBytes": "32",
        "value": "t_struct(ReputationData)29147_storage"
      },
      "t_string_storage": {
        "encoding": "bytes",
        "label": "string",
        "numberOfBytes": "32"
      },
      "t_struct(ReputationData)29147_storage": {
        "encoding": "inplace",
        "label": "struct ReputationNFT.ReputationData",
        "members": [
          {
            "astId": 29144,
            "contract": "contracts/stablecoin/reputationtoken.sol:ReputationNFT",
            "label": "n",
            "offset": 0,
            "slot": "0",
            "type": "t_uint256"
          },
          {
            "astId": 29146,
            "contract": "contracts/stablecoin/reputationtoken.sol:ReputationNFT",
            "label": "score",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_struct(TraderData)29152_storage": {
        "encoding": "inplace",
        "label": "struct ReputationNFT.TraderData",
        "members": [
          {
            "astId": 29149,
            "contract": "contracts/stablecoin/reputationtoken.sol:ReputationNFT",
            "label": "trader",
            "offset": 0,
            "slot": "0",
            "type": "t_address"
          },
          {
            "astId": 29151,
            "contract": "contracts/stablecoin/reputationtoken.sol:ReputationNFT",
            "label": "tokensBought",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}